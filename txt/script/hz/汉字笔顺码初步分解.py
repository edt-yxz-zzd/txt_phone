#__all__:goto
#TODO:goto
r'''[[[
e script/hz/汉字笔顺码初步分解.py
script.hz.汉字笔顺码初步分解

手动收集数据囗集中区:goto
手动收集数据囗代码区:goto
漫游:goto


view ../../python3_src/seed/pkg_tools/load_as_module.py
from seed.pkg_tools.load_as_module import load_as_module, reload_module_or_package
m = load_as_module('m', 'script/hz/汉字笔顺码初步分解.py')
reload_module_or_package('m')
m.main1('../笔顺码分解/29685-ex.txt')
from importlib.util import spec_from_file_location
spec = spec_from_file_location('m', 'script/hz/汉字笔顺码初步分解.py')


view ../../python3_src/nn_ns/CJK/CJK_data/raw/125成字部件_44部首.txt
view ../../python3_src/nn_ns/CJK/CJK_data/raw/unicode_cjk_部件_笔画.py

view ../../python3_src/nn_ns/CJK/CJK_data/raw/我的所有折笔归类囗对应的字母数字.txt
view ../../python3_src/nn_ns/CJK/CJK_data/raw/汉字笔顺表\[20200913]/stroke-seq_MB-master\[汉字笔顺表]\[20200827]/单字_笔顺码_29685个.txt
衲	452342534	550
from nn_ns.CJK.CJK_data.raw.汉字笔顺 import 汉字到笔顺码

view ../../python3_src/nn_ns/CJK/CJK_struct/cjk_decomp_0_4_0/cjk-decomp-0.4.0.txt
view ../../python3_src/nn_ns/CJK/CJK_struct/cjk_decomp_0_4_0/format.txt
10008:a(禾,血)
⺀:rd(㇔)
㑢:a(佉,卩)
view ../../python3_src/nn_ns/CJK/CJK_struct/cjk_decomp_0_4_0/read_cjk_decomp.py
from nn_ns.CJK.CJK_struct.cjk_decomp_0_4_0.read_cjk_decomp import default_iter_read_cjk_decomp
    '-> Iter (hanzi|int, (case, [(hanzi|int)]))'


view ../../python3_src/nn_ns/CJK/CJK_struct/cjk_decomp_0_4_0/cjk-decomp-0.4.0-原版.txt
view ../../python3_src/nn_ns/CJK/CJK_data/raw/汉字笔顺表\[20200913]/stroke-seq_MB-master\[汉字笔顺表]\[20200827]/单字_笔顺码_29685个-原版.txt






py -m nn_ns.app.debug_cmd   script.hz.汉字笔顺码初步分解
py -m nn_ns.app.doctest_cmd script.hz.汉字笔顺码初步分解:f -v
from script.hz.汉字笔顺码初步分解 import f




view ../笔顺码分解/29685-ex5.txt
    +笔顺码相同的部首再聚类
    +启用囗局部部件替换
view ../笔顺码分解/29685-ex4.txt
    +笔顺码相同的部首再聚类
view ../笔顺码分解/29685-ex3.txt
    -笔顺码相同的部首再聚类
view ../笔顺码分解/29685-ex2.txt
    冻结-用于 diff ex2 ex3
view ../笔顺码分解/29685-ex.txt
    编辑-收集信息



[[[[[[[[[[收集信息:
view ../笔顺码分解/29685-ex4.txt
    ex4文件 不断被覆盖
        所以不能记录信息
信息记录在这里

漫游:搜索:
    /#######
    /#####
    /\(yet\|bad\)\d
    /^yet#
        因为bad13全都看过


[[部件替换:see:局部部件替换囗
看:
^bad#
13个:
𦀗:554444-1213234;a,糸,赤,
𦀗-糸-糹
𨀤:2512121-111234;a,足,耒,
𨀤-足-⻊
䬴:34451154-11234;a,食,末,
䬴-食-飠
䨮:14524444-11121112511;d,雨,彗,
䨮-雨-[头用雨]-14524444
㹑:3121-111251113454;a,牛,贰,
㹑-牛-牜
䍪:431113-11234;a,羊,末,
䍪-羊-⺶
辏:1521-111341134;a,车,37121,
辏-车-[左用车]-1521
垔:125221-121;d,西,土,
垔-西-覀
栾:412234-1234;d,亦,木,
栾-亦-[头囗鸾]-412234
美:431121-134;d,羊,大,
美-羊-⺷
䴨:41352211515-1332511234;a,鹿,原,
䴨-鹿-[左用鹿]-41352211515
鼖:12122-1212514311254;d,卉,鼓,
鼖-卉-[头囗桒]-12122
書:511121-2511;d,聿,日,
書-聿-[断尾聿]-511121


]]


[[
跳过 第一超区 看:
^yet#
yet



=====
𨘀:_454-1121132511134;sbl,⻎,頊,
ok#<<==sbl

䬻:34451154-111534;a,37004,㦮,
37004=飠

𥦌:44534-1121132;d,65737,弄,
䆢:44534-1215134;d,65737,抉,
65737=穴

䎯:111234-12212511134;a,37009,37060,
37009=耒

衎:332_112-112;w,行,干,
ok#<<==w

瑩:4334433445-11214;d,37027,玉,
37027=𤇾

褭:41_3534-1211254444;w,衣,馬,
ok#<<==w

䮸:3211343451145-1211254444;d,37153,⺆,馬,
d,37153,⺆=𦥯

𪂂:12251112-32511154444;a,97020,鳥,
97020=龺

爰:3443-11354;d,⺤,38336,
⺤.笔顺码=3443

聿:511-112;d/m,⺺,37024,
整区不拆

京:41251-234;d,37045,小,
整区多拆

脁:3541-341534;a,⺼,兆,
⺼.笔顺码=3541

冃:25-11;st,⺆,二,
整区不拆

㸤:4143113_4143112-3215;w,辡,片,
ok#<<==w

瑴:121451_3554-1121;str,37047,王,
整区多拆
?或 右上包围
?见下面:觳:_3554-1214513535112;str,37127,37810,

鞗:322354-122125112;a,39752,37779,
條:322354-1234;a,39752,条,
倏:322354-1344;a,39752,37582,
整区多拆
?或 左上包围

㶂:441441-12212512134;a,97147,黄,
97147=?横组氵氵

黉:44345-12212512134;d,37044,黄,
37044=?头囗觉

檿:13251125111344-1234;stl,37069,木,
37069=厭

堂:24345251-121;d,37062,土,
整区多拆
?头囗尝
    xxx 37062=?头囗堂

棃:31234353-1234;d,37063,木,
37063=?头囗黎

墼:1251112523554-121;d,𣪠,土,
𣪠=?头囗擊

驘:4152513511_354-1211254444;st,𣎆,馬,
𣎆=?上包围囗赢

斄:11234313413-12343434;d,37087,𠩬,
釐:11234313413-2511211;d,37087,厘,
整区多拆
?或 类似『广』

㮟:1234_1234-13251;w,林,石,
ok#<<==w

廑:4131221-2511121;stl,28722,37304,
整区多拆
?或 类似『虍』

㢽:515_515-122111;w,弜,耳,
ok#<<==w

卓:2125-1112;d,⺊,早,
整区不拆

賾:1225125-11212511134;a,𦣞,責,
𦣞=?左囗颐

韰:2135454-211121111;d,𣦼,韭,
𣦼=?头囗餐

亭:4125145-12;d,37106,丁,
37106=纵三组亠口冖
？反正『高』竖-非『丶』

㫌:415331-12121;stl,62307,正,
整区多拆
62307=左上囗旅

剆:451154-22;a,37105,刂,
37105=?左囗郎

壼:12145-12155121;d,37151,亞,
37151=纵组士冖

㻎:1_34-11211121;w,大,玨,
ok#<<==w
？其中『夷』交叉

上:21-1;d/t,⺊,㇐,
整区不拆

璺:321125125151145-11214;d,37147,玉,
37147=?纵组囗头囗興冖
37147=?头囗璺

鷂:3443311252-32511154444;a,37021,鳥,
37021=䍃

棨:45133134-1234;d,𢼄,木,
𢼄=?横组户攵

梟:3251115-1234;str,37157,木,
37157=?断足鳥

考:1213-15;stl,⺹,丂,
ok#<<==stl

末:1_234-1;w,木,㇐,
ok#<<==w

坚:2254-121;d,37144,土,
37144=?头囗坚

觳:_3554-1214513535112;str,37127,37810,
整区多拆#TODO:整区多拆 使 yet变ok
?或 右上包围
?见上面:瑴:121451_3554-1121;str,37047,王,

単:443-251112;d,⺍,37277,
⺍.笔顺码=443
?其中:鴬:443-4532511154444;d,⺍,37328,
?    分错区:头囗觉

丮:5-112;str,㇠,37024,
ok#<<==str

=====整理一下囗漫游一:
[[

?鴬:443-4532511154444;d,⺍,37328,
?    分错区:头囗觉

䮸:3211343451145-1211254444;d,37153,⺆,馬,
重拆:d,37153,⺆=𦥯
算了，改为:整区多拆

[[[手动原样通过:手动原样通过囗区首字囗字集
yet->pass
^[衎褭㸤㮟㢽㻎末]
    移除:𨘀考丮
允许的结构类型:[adsb]
有误:发现:s*与w*不同
w* not in [adsb] ==>> 手动通过
s* in [adsb] ==>> 部件 缺 笔顺码

衎:332_112-112;w,行,干,
ok#<<==w
褭:41_3534-1211254444;w,衣,馬,
ok#<<==w
㸤:4143113_4143112-3215;w,辡,片,
ok#<<==w
㮟:1234_1234-13251;w,林,石,
ok#<<==w
㢽:515_515-122111;w,弜,耳,
ok#<<==w
㻎:1_34-11211121;w,大,玨,
ok#<<==w  ？其中『夷』交叉
末:1_234-1;w,木,㇐,
ok#<<==w


以下改为:笔顺码补丁
𨘀:_454-1121132511134;sbl,⻎,頊,
⻎.笔顺码=454
ok#<<==sbl
考:1213-15;stl,⺹,丂,
⺹.笔顺码=1213
ok#<<==stl
丮:5-112;str,㇠,37024,
㇠.笔顺码=5
ok#<<==str

]]手动原样通过:手动原样通过囗区首字囗字集]


[[[笔顺码补丁:全局替换:全局部件替换囗
爰:3443-11354;d,⺤,38336,
⺤.笔顺码=3443
脁:3541-341534;a,⺼,兆,
⺼.笔顺码=3541
単:443-251112;d,⺍,37277,
⺍.笔顺码=443
𨘀:_454-1121132511134;sbl,⻎,頊,
⻎.笔顺码=454
考:1213-15;stl,⺹,丂,
⺹.笔顺码=1213
丮:5-112;str,㇠,37024,
㇠.笔顺码=5

]]笔顺码补丁:全局替换:全局部件替换囗]

[[[部件替换表+笔顺码补丁:全局替换:全局部件替换囗
[效果:
    ^[𪂂䎐瑩䝁]
    打补丁:瑩.37027=𤇾 -> 瑩+䝁 两区合并，不再『多拆』
        移除『䝁』自 整区多拆囗原首字到部首倒装笔顺码
    打补丁:𪂂.97020=龺 -> 𪂂+䎐 两区合并，不再『可延长』
        移除『䎐』自 否决囗囗双缀还可能延长囗字集
]

䬻:34451154-111534;a,37004,㦮,
37004=飠

𥦌:44534-1121132;d,65737,弄,
䆢:44534-1215134;d,65737,抉,
65737=穴

䎯:111234-12212511134;a,37009,37060,
37009=耒

瑩:4334433445-11214;d,37027,玉,
37027=𤇾

𪂂:12251112-32511154444;a,97020,鳥,
97020=龺

檿:13251125111344-1234;stl,37069,木,
37069=厭

鷂:3443311252-32511154444;a,37021,鳥,
37021=䍃

黉:44345-12212512134;d,37044,黄,
37044=[头囗觉]

㶂:441441-12212512134;a,97147,黄,
97147=[横组氵氵]

棃:31234353-1234;d,37063,木,
37063=[头囗黎]

墼:1251112523554-121;d,𣪠,土,
𣪠=[头囗擊]

驘:4152513511_354-1211254444;st,𣎆,馬,
𣎆=[上包围囗赢]

賾:1225125-11212511134;a,𦣞,責,
𦣞=[左囗颐]

韰:2135454-211121111;d,𣦼,韭,
𣦼=[头囗餐]

剆:451154-22;a,37105,刂,
37105=[左囗郎]

壼:12145-12155121;d,37151,亞,
37151=[纵组士冖]

棨:45133134-1234;d,𢼄,木,
𢼄=[横组户攵]

梟:3251115-1234;str,37157,木,
37157=[断足鳥]

坚:2254-121;d,37144,土,
37144=[头囗坚]

璺:321125125151145-11214;d,37147,玉,
37147=[纵组囗头囗興冖]
37147=[头囗璺]

亭:4125145-12;d,37106,丁,
37106=[纵三组亠口冖]
？反正『高』竖-非『丶』

]]部件替换表+笔顺码补丁:全局替换:全局部件替换囗]



[[[整区不拆:整区不拆囗原首字囗字集
/聿冃卓上

聿:511-112;d/m,⺺,37024,
整区不拆
冃:25-11;st,⺆,二,
整区不拆
卓:2125-1112;d,⺊,早,
整区不拆
上:21-1;d/t,⺊,㇐,
整区不拆
]]整区不拆:整区不拆囗原首字囗字集]

[[[整区多拆:整区多拆囗原首字到部首倒装笔顺码
^[鷂觳䝁顆螚京瑴鞗堂斄廑㫌]


京:41251-234;d,37045,小,
整区多拆

瑴:121451_3554-1121;str,37047,王,
整区多拆
?或 右上包围
?见下面:觳:_3554-1214513535112;str,37127,37810,

鞗:322354-122125112;a,39752,37779,
條:322354-1234;a,39752,条,
倏:322354-1344;a,39752,37582,
整区多拆
?或 左上包围

堂:24345251-121;d,37062,土,
整区多拆
?头囗尝
    xxx 37062=?头囗堂

斄:11234313413-12343434;d,37087,𠩬,
釐:11234313413-2511211;d,37087,厘,
整区多拆
?或 类似『广』

廑:4131221-2511121;stl,28722,37304,
整区多拆
?或 类似『虍』

㫌:415331-12121;stl,62307,正,
整区多拆
?xxx 62307=左上囗旅


觳:_3554-1214513535112;str,37127,37810,
整区多拆#TODO:整区多拆 使 yet变ok
?或 右上包围
?见上面:瑴:121451_3554-1121;str,37047,王,

]]整区多拆:整区多拆囗原首字到部首倒装笔顺码]


]]#整理一下囗漫游一



=====
]]

]]]]]]]]]]







####################

e ../笔顺码分解/29685-ex.txt
view script/hz/汉字笔顺码初步分解.py
编辑中:不再更改:py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @main1 :../笔顺码分解/29685-ex.txt
view ../笔顺码分解/29685-ex.txt
#####
here:goto
here

DONE::
    len_LCP作为切分的尝试
        或者:共同后缀:比如:辶
    每一个归类块:表明数量
    䢛:_454-2534251;sbl,辶,19452,
    巨:1_5-51;sl,匚,99721,
    栽:121_534-1234;str,𢦏,木,



冻结:用作比较:py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @main1 :../笔顺码分解/29685-ex2.txt
view ../笔顺码分解/29685-ex2.txt


不太行:
干:1-12;d/t,㇐,十,
    ==>>qhzs4skip_ts添加『干』
    see:/29685-ex3.txt
厃:35-13;d,⺈,厂,
詹:35-13344111251;d,⺈,38049,
尔:35-234;d,⺈,小,
負:35-2511134;d,⺈,貝,
    ==>>qhzs4skip_ts添加『厃』
手:3-112;d/t,㇒,扌,
    ==>>qhzs4skip_ts添加『手』
三:1-11;d,㇐,二,
亚:1-22431;d,㇐,业,
画:1-2512152;d,㇐,37679,
    ==>>qhzs4skip_ts添加『三』

py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @main1 :../笔顺码分解/29685-ex3.txt +force
view ../笔顺码分解/29685-ex3.txt
diff ../笔顺码分解/29685-ex2.txt ../笔顺码分解/29685-ex3.txt
    检查:qhzs4skip_ts中的区域未被拆
        比如:检查:没有拆成:『干:1-12;d/t,㇐,十,』

/29685-ex3.txt:
    部首初分:
        已检查到『手:3-112;d/t,㇒,扌,』
        ##『亗:252-11;d,山,二,』『䬴:34451154-11234;a,食,末,』『干:1-12;d/t,㇐,十,』


脸型:
㞱𡵅岚峁㞩㞵崒岦峷岜
㫔暃旵

韭昂:底部

不一致:
飦:34451154-112;a,飠,干,
䬴:34451154-11234;a,食,末
䬻:34451154-111534;a,37004,㦮,

踌:2512121-1113124;a,⻊,寿,
𨀤:2512121-111234;a,足,耒,

䍪:431113-11234;a,羊,末,
羢:431113-113534;a,⺶,戎,
    ==>> 笔顺码相同的部首再聚类
    see:def key2(...)
    see:/29685-ex4.txt
詹:35-13344111251;d,⺈,38049,
矦:351331134;stl,厃,矢,


py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @main1 :../笔顺码分解/29685-ex4.txt +笔顺码相同的部首再聚类 +force
view ../笔顺码分解/29685-ex4.txt

鴬:443-4532511154444;d,⺍,37328,
    分错区:头囗觉

py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @main1 :../笔顺码分解/29685-ex5.txt +笔顺码相同的部首再聚类 +启用囗局部部件替换 +force
diff ../笔顺码分解/29685-ex4.txt ../笔顺码分解/29685-ex5.txt

view ../笔顺码分解/29685-ex5.txt
  !!以初步拆分许多
  !!只剩一些零碎:
    共375超区
    共3035区
    共29782字或不成字部首
    其中未完成初步拆分:只有2超区
      bug区:共1超区 1区 48字
      yet区:共1超区 2583区 4048字
#375#3035#29782#
#bug1#ok444#pass7#yet2583#
#######
#1#48#
#bug1#
...
#######
#2583#4048#
#yet2583#
...



py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @main1 :../笔顺码分解/29685-ex6.txt +笔顺码相同的部首再聚类 +启用囗局部部件替换 --启用共同双缀当作部首笔顺码的最小区规模=4 +force
view ../笔顺码分解/29685-ex6.txt
㔭:15251112134;a,匕,是,
匘:35555325341;a,匕,37119,
    笔顺码有误
TODO:a,d,...,最后部件当部首，一字两部首:例:益盍
TODO:排序<笔顺码>+排序<逆序(笔顺码)> -每个汉字部件-找出 共同双缀 最长 的 前几个 汉字部件
    view ../../python3_src/nn_ns/CJK/CJK_data/raw/汉字笔顺表\[20200913]/stroke-seq_MB-master\[汉字笔顺表]\[20200827]/单字_笔顺码_29685个.txt
TODO:推导出:数字部件.笔顺码
    def 推导囗汉字部件囗笔顺码囗():
py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @推导囗汉字部件囗笔顺码囗 :../笔顺码分解/29685-deduce.txt +force
py -m nn_ns.app.adhoc_argparser__main__call8module   script.hz.汉字笔顺码初步分解   @推导囗汉字部件囗笔顺码囗 :../笔顺码分解/29685-deduce.txt +force > ../../../tmp/out4py/script.hz.汉字笔顺码初步分解-推导囗汉字部件囗笔顺码囗-find_longest_bifix.on_err.txt
view ../笔顺码分解/29685-deduce.txt
view  ../../../tmp/out4py/script.hz.汉字笔顺码初步分解-推导囗汉字部件囗笔顺码囗-find_longest_bifix.on_err.txt


e hz/汉字拆分囗大部件囗小规模尝试.txt
    现在或可尝试之



#######
[[[[[[{([
手动收集数据囗集中区:here

[[-deduce.txt
@推导囗汉字部件囗笔顺码囗 :../笔顺码分解/29685-deduce.txt

新增:
    部件笔顺码更正表囗单个囗源
    部件拆分更正表囗单个囗源

䧐:2541251521->5241251521

𦱳:d,艹,62697->d,䒑,62697
䤋:a,酉,或->a,酋,或
𥦬:d,65737,八->d,65737,62017
⺳:d,冖,八->d,冖,儿

下面-出故障:部件替换表囗全局囗源:
    䆢:44534-1215134;d,65737,抉,
    65737=穴
65737:d(宀,儿)
    bug:替换 65737->穴 于 bk2f_bks.key 时，覆盖了 原先的 bk2f_bks[穴]
        see:部件替换表囗全局囗源/部件替换表囗全局囗/部件替换表囗全局囗数据/囗打补丁囗拆分表囗

𥥖	4453412251	510
𥥖:d(65737,古)
𥥸:d(65737,余)
𥧄:d(65737,45797)
𥧔:d(65737,氣)
    看起來像是[宀儿]而非(穴)
䆫:d(65737,怱)
    看起來像是(穴)而非[宀儿]
[𥥖𥥸𥧄𥧔窗𥦬]
窗vs𥦬
窗	445343253541	550
𥦬	4453434253541	510
    多了一点
窗:d(穴,囱)
𥦬:d(65737,八)->d(65737,62017)
    部件错！
62017:s(囗,夂)
𠧧:d(卜,62017)
穴:d(宀,八)
⺳vs⺳
㓁:d(冖,八)
⺳:d(冖,八)->d(冖,儿)
    部件错！
    see:部件拆分更正表囗单个囗源


('d', '-', '玉')
121145323:㺸
4121111121112:㻗
㺸	323541121	520
㺸:323541121->3235411214

_on_err4find_longest_bifix.yqkey__bad_pairs__xx__triples4on_err ==>>
    view  ../../../tmp/out4py/script.hz.汉字笔顺码初步分解-推导囗汉字部件囗笔顺码囗-find_longest_bifix.on_err.txt
    [[[
=====
('a', '-', '刀')
-----
3551:切
435431424343213:䵑
切:a,七,刀
䵑:a,黍,刀
切:1553
䵑:312343424134534

䵑:a,黍,刀->a,黍,刃
=====
('a', '-', '尤')
-----
4531444455:紌
5314321125225:㞊
紌:a,糹,尤
㞊:a,祟,尤
紌:5544441354
㞊:5225211234135

㞊:a,祟,尤->a,祟,尢
=====
('d', '-', '王')
-----
121143134431421:𤨣
412114311152221:𦻒
𤨣:d,47771,王
𦻒:d,莫,王
𤨣:124134431341121
𦻒:122251113411214

𦻒:d,莫,王->d,莫,玉
=====
('a', '-', '由')
-----
121525445445115123:鼬
4512152:廸
鼬:a,鼠,由
廸:a,廴,由
鼬:321511544544525121
廸:2512154
=====
('a', '-', '白')
-----
1152351113:铂
4511523:廹
铂:a,钅,白
廹:a,廴,白
铂:3111532511
廹:3251154
=====
('d', '+', '二')
-----
114544:忈
41354153:㫄
忈:d,二,心
㫄:d,二,92492
忈:114544
㫄:41354153

㫄:d,二,92492->d,亠,92492
=====
('a', '-', '有')
-----
1152315125152:𨚼
454115231:迶
𨚼:a,邑,有
迶:a,辶,有
𨚼:2515215132511
迶:132511454

迶:a,辶,有->sbl,辶,有
=====
('a', '-', '隶')
-----
3414211513414:䇐
43142115121:埭
䇐:a,立,隶
埭:a,土,隶
䇐:4143151124143
埭:12151124134

䇐:4143151124143->4143151124134
=====
('a', '-', '西')
-----
1535215113:毢
45153521:廼
毢:a,毛,西
廼:a,廴,西
毢:3115125351
廼:12535154
=====
('a', '+', '分')
-----
125422:𠚼
3453132511134:頒
𠚼:a,分,刂
頒:a,分,頁
𠚼:125422
頒:3453132511134

𠚼:a,分,刂->c_null
=====
('w', '=', '㇑')

相邻两个:双缀 总有一个 非空，但 整体双缀空:
243:⺌
513:尸
52:卩
52:阝
522:屮
？
=====
('a', '+', '每')
-----
3155414554234:䋣
415541441542511:𣫺
䋣:a,每,糸
𣫺:a,每,育
䋣:3155414554234
𣫺:415541441542511

𣫺:415541441542511->315541441542511
=====
('a', '-', '褱')
-----
345343142122521415231:䃶
4353431421225214121:壞
䃶:a,石,褱
壞:a,土,褱
䃶:132514125221241343543
壞:1214125221241343534

䃶:132514125221241343543->132514125221241343534
=====
('a', '-', '幸')
-----
21134121444455:緈
454211134121353:㺚
緈:a,糹,幸
㺚:a,犭,幸
緈:55444412143112
㺚:353121431112454

達	121431112454	550
㺚:a,犭,幸->a,犭,達
=====
('a', '-', '广')
-----
14314:疒
3141152:旷
疒:a,亠,广
旷:a,日,广
疒:41341
旷:2511413

疒:a,亠,广->c_null
xxx笔顺码还是错:疒:a,亠,广->sr,广,冫
=====
('a', '-', '朗')
-----
11534511544334:𤎜
2545115444441215253:䱶
𤎜:a,火,朗
䱶:a,魚,朗
𤎜:43344511543511
䱶:3525121444445115452

䱶:a,魚,朗->a,魚,郎
=====
('a', '-', '入')
-----
4344441215253:魞
543:兦
魞:a,魚,入
兦:a,㇗,入
魞:3525121444434
兦:345

兦:a,㇗,入->sbl,㇗,入
可能有毛病:
/㇗!
stl,㇗!61447:stl(㇗,90011)
stl,虍!𧆝:stl(虍,61447)
    唯一
a/t,㇠!⻜:a/t(㇠,90011)
sbl,㇠!飞:sbl(㇠,90011)
refh,冫!90011:refh(冫)
sbl,㇗!62321:sbl(㇗,90011)

w,㇗!59381:w(㇗,八)
w,㇗!63796:w(㇗,㇐)
d,㇗!62255:d(㇗,丅)
sbr,㇘!59479:sbr(㇘,61994)
=====
('d', '+', '馬')
-----
1211254444413534:䮍
32511154444252:㠀
䮍:d,馬,衣
㠀:d,馬,山
䮍:1211254444413534
㠀:32511154444252

㠀:d,馬,山->d,鳥,山
=====
('d/t', '-', '⺆')
-----
435421521:[头囗囊]
52552:冎
[头囗囊]:d/t,65522,⺆
冎:d/t,38465,⺆
[头囗囊]:125124534
冎:25525

[头囗囊]:d/t,65522,⺆->d/t,65522,冖
47005=[头囗囊]
47005:d/t,65522,⺆->d/t,65522,冖
冎:d/t,38465,⺆->d/t,38465,冂
=====
('a', '+', '匕')
-----
15251112134:㔭
35555325341:匘
㔭:a,匕,是
匘:a,匕,37119
㔭:15251112134
匘:35555325341

*:a,匕,...->a,[左用匕],...
比:ra,匕->a,[左用匕],匕
匘:35555325341->15555325341
=====
('a', '-', '奂')
-----
43152534334:焕
5315253252:㡈
焕:a,火,奂
㡈:a,巾,奂
焕:43343525134
㡈:2523525135

两个错:
43152534334:焕
5315253252:㡈
531525343213:䅋

㡈:a,巾,奂->a,巾,免
䅋:a,禾,奂->a,禾,免
=====
('d', '+', 99697)
-----
1121124143125111515111:䶬
313112515:𢏗
䶬:d,99697,龍
𢏗:d,99697,弓
䶬:1121124143125111515111
𢏗:313112515

？干vs撇化千
=====
('d', '-', '丹')
-----
14533334511121:𩬅
4153221:䒟
𩬅:d,髟,丹
䒟:d,艹,丹
𩬅:12111543333541
䒟:1223514

丹	3541	550
䒟:1223514->1223541
=====
('w', '=', '⺆')
-----
2535:𦉪
3511:月
𦉪:w,⺆,儿
月:w,⺆,二
𦉪:2535
月:3511

𦉫 𠔿 𦉪
𦉪:w,⺆,儿->st,[无钩冂],儿
𠔿:st,⺆,人->st,[无钩冂],人
𦉫:st,⺆,10001->st,[无钩冂],10001
=====
('w', '=', '㇚')
-----
121:扌
234:小
扌:w,㇚,二
小:w,㇚,八
扌:121
小:234

扌:w,㇚,二->c_null
=====
('a', '-', '夘')
-----
254534321:栁
554531521114:䛄
栁:a,木,夘
䛄:a,言,夘
栁:123435452
䛄:411125135455

㼝:35455-1554;d,夘,瓦,
㼝-夘-夗

䛄:a,言,夘->a,言,夗
㼝:d,夘,瓦->d,夗,瓦
=====
('d', '+', '卝')
-----
122132511212151534354:蘷
2121112:𦍋
蘷:d,卝,夒
𦍋:d,卝,扌
蘷:122132511212151534354
𦍋:2121112

122121354:羐
122132511212151534354:蘷
2121112:𦍋

羐	122121354	550
羐:122121354->2121121354
蘷:d,卝,夒->d,艹,夒
=====
('a', '-', '巛')
-----
45555:廵
555251453432134:𥻘
廵:a,廴,巛
𥻘:a,粦,巛
廵:55554
𥻘:431234354152555
=====
('d', '+', '坐')
-----
1234341252511:嗇
3434121354:夎
嗇:d,坐,回
夎:d,坐,夂
嗇:1234341252511
夎:3434121354

嗇:d,坐,回->d,[出头巫],回
=====
('a', '+', '廴')
-----
12535154:廼
2512154:廸
廼:a,廴,西
廸:a,廴,由
廼:12535154
廸:2512154
-----
252211154:廽
3251154:廹
廽:a,廴,囬
廹:a,廴,白
廽:252211154
廹:3251154
-----
3251154:廹
55554:廵
廹:a,廴,白
廵:a,廴,巛
廹:3251154
廵:55554

#op错:a->sbl
12535154:廼
2512154:廸
252211154:廽
3251154:廹
55554:廵

廵:a,廴,巛->sbl,廴,巛
廸:a,廴,由->sbl,廴,由
廹:a,廴,白->sbl,廴,白
廼:a,廴,西->sbl,廴,西
廽:a,廴,囬->sbl,廴,囬
=====
('a', '-', '囬')
-----
1112252412152:蜖
451112252:廽
蜖:a,虫,囬
廽:a,廴,囬
蜖:2512142522111
廽:252211154
=====
('d', '+', '旣')
-----
32511351535121:墍
5115415351234:槩
墍:d,旣,土
槩:d,旣,木
墍:32511351535121
槩:5115415351234

槩:d,旣,木->d,既,木
=====
('d/t', '-', '丷')
-----
211134:羊
343:乊
羊:d/t,37145,丷
乊:d/t,㇒,丷
羊:431112
乊:343

羊:d/t,37145,丷->d/t,丷,37145
=====
('a', '+', '義')
-----
341121312153452:䣡
431121312153432511154444:䴊
䣡:a,義,阝
䴊:a,義,鳥
䣡:341121312153452
䴊:431121312153432511154444

䣡:341121312153452->431121312153452
=====
('d', '-', '𠚤')
-----
353413413:䇖
453252:㞮
䇖:d,⺮,𠚤
㞮:d,山,𠚤
䇖:314314353
㞮:252354

？都不是同一部件
=====
    ]]]
    [[[
已处理:
䵑:a,黍,刀->a,黍,刃
㞊:a,祟,尤->a,祟,尢
𦻒:d,莫,王->d,莫,玉
㫄:d,二,92492->d,亠,92492
迶:a,辶,有->sbl,辶,有
㺚:a,犭,幸->a,犭,達
䱶:a,魚,朗->a,魚,郎
兦:a,㇗,入->sbl,㇗,入
㠀:d,馬,山->d,鳥,山
[头囗囊]:d/t,65522,⺆->d/t,65522,冖
冎:d/t,38465,⺆->d/t,38465,冂
比:ra,匕->a,[左用匕],匕
㡈:a,巾,奂->a,巾,免
䅋:a,禾,奂->a,禾,免
𦉪:w,⺆,儿->st,[无钩冂],儿
𠔿:st,⺆,人->st,[无钩冂],人
𦉫:st,⺆,10001->st,[无钩冂],10001
䛄:a,言,夘->a,言,夗
㼝:d,夘,瓦->d,夗,瓦
蘷:d,卝,夒->d,艹,夒
嗇:d,坐,回->d,[出头巫],回
廵:a,廴,巛->sbl,廴,巛
廸:a,廴,由->sbl,廴,由
廹:a,廴,白->sbl,廴,白
廼:a,廴,西->sbl,廴,西
廽:a,廴,囬->sbl,廴,囬
槩:d,旣,木->d,既,木
羊:d/t,37145,丷->d/t,丷,37145
𠚼:a,分,刂->c_null
疒:a,亠,广->c_null
扌:w,㇚,二->c_null
    部件拆分更正表囗单个囗源
*:a,匕,...->a,[左用匕],...
    手动直接修改文件
    %s/:a(匕/:a([左用匕]
        # ))

䇐:4143151124143->4143151124134
𣫺:415541441542511->315541441542511
䃶:132514125221241343543->132514125221241343534
匘:35555325341->15555325341
䒟:1223514->1223541
羐:122121354->2121121354
䣡:341121312153452->431121312153452
    部件笔顺码更正表囗单个囗源

待处理:
243:⺌
stl,㇗!61447:stl(㇗,90011)
𢏗:313112515
䇖:d,⺮,𠚤

    ]]]
    [[[再运行一次，只剩:
=====
('w', '=', '㇑')
243:⺌
513:尸
52:卩
52:阝
522:屮
⺌:w,㇑,丷
尸:w,㇑,99721
卩:w,㇑,㇆
阝:w,㇑,㇌
屮:w,㇑,凵
⺌:243
尸:513
卩:52
阝:52
屮:522

尸:w,㇑,99721->c_null
卩:w,㇑,㇆->c_null
阝:w,㇑,㇌->c_null
屮:w,㇑,凵->c_null
=====
('d', '+', 99697)
-----
1121124143125111515111:䶬
313112515:𢏗
䶬:d,99697,龍
𢏗:d,99697,弓
䶬:1121124143125111515111
𢏗:313112515

幵郉栞
麉	11211241352211535	550
䶬	1121124143125111515111	520

𢏗	313112515	510
圱	313121	550

幵	113112	550
栞	1131121234	550
𠛬	11311222	510
郉	11311252	550

ra,干!99697:ra(干)
a,于!幵:a(于,干)
d,幵!栞:d(幵,木)
a,幵!郉:a(幵,阝)
a,女!姸:a(女,幵)
a,言!詽:a(言,幵)
a,豕!豣:a(豕,幵)
a,金!銒:a(金,幵)
d,⺮!筓:d(⺮,幵)

a,65415!61237:a(65415,99697)
a,96824!𢆬:a(96824,99697)
a,99697!𠛬:a(99697,刂)
a,99697!𩒖:a(99697,頁)
a,衤!𧙧:a(衤,99697)
a,骨!𩩄:a(骨,99697)
d,37142!𢁌:d(37142,99697,35189)

d,99697!14081:d(99697,心)
d,99697!19848:d(99697,木)
d,99697!䶬:d(99697,龍)
d,99697!麉:d(99697,鹿)
d,99697!𢆛:d(99697,并)
d,99697!𢆞:d(99697,束)
d,99697!𢏗:d(99697,弓)
d,99697!𥅝:d(99697,目)
d,99697!𧵭:d(99697,貝)
d,99697!𨴚:d(99697,門)


d,上!𢆒:d(上,99697)
d,止!𣥭:d(止,99697)
d,比!𣬊:d(比,99697)
d,目!𥅳:d(目,99697)
d,羽!𦐧:d(羽,99697)
d,龍!𪚜:d(龍,99697)

stl,尸!16378:stl(尸,99697)
w,99697!𢏘:w(99697,弓)
w,99697!𪚟:w(99697,龍)
wt,中!33238:wt(中,99697)

幵:113112

幵:a,于,干->a,[左用干],干
xxx 99697:ra,干->a,[左用干],干
幵:113112
𠛬:11311222
𠛬:113112-22;a,99697,刂,
99697=幵

麉:11211241352211535->11311241352211535
䶬:1121124143125111515111->1131124143125111515111
𢏗:313112515->113112515
=====
('d/t', '-', '冖')
-----
435421521:[头囗囊]
54342:龸
[头囗囊]:d/t,65522,冖
龸:d/t,⺌,冖
[头囗囊]:125124534
龸:24345

[头囗囊]:125124534->1251245
=====
('d', '-', '𠚤')
-----
353413413:䇖
453252:㞮
䇖:d,⺮,𠚤
㞮:d,山,𠚤
䇖:314314353
㞮:252354

麁	3541352211535	550
𧥧	3544111251	510
灸	3544334	550
邜	35452	550
夘	35452	549


wb,𠂊!𠚤:wb(𠂊,㇔)
a,37267!26247:a(37267,𠚤)
a,54847!47413:a(54847,𠚤)
a,土!𡉍:a(土,𠚤)
a,巾!𢁞:a(巾,𠚤)
a,扌!𢩶:a(扌,𠚤)
a,牛!24514:a(牛,𠚤)
a,犭!𤜩:a(犭,𠚤)
a,禾!𥝢:a(禾,𠚤)
a,釆!25104:a(釆,𠚤)
a,𠚤!24586:a(𠚤,斤)
d,⺮!䇖:d(⺮,𠚤)
d,山!㞮:d(山,𠚤)
d,𠚤!13221:d(𠚤,木)
d,𠚤!43625:d(𠚤,㇐)
d,𠚤!𠤓:d(𠚤,⺆,匕)
d,𠚤!𠶰:d(𠚤,周)
d,𠚤!𡖴:d(𠚤,⺆,出,兀)
d,𠚤!𡖸:d(𠚤,⺆,㇒,出,35189)
d,𠚤!𡵁:d(𠚤,山)
d/t,㇐!20234:d/t(㇐,𠚤)
sbl,24845!𫀺:sbl(24845,𠚤)
sbl,風!𩖝:sbl(風,𠚤)
w,10001!47527:w(10001,𠚤)


d,37063!黎:d(37063,37271)
d,卄!菞:d(卄,37063)
a,禾!37063:a(禾,99972)
lock,99972!匁:lock(99972,㇏)
str,勹!99972:str(勹,㇒)


䇖:d,⺮,𠚤->d,⺮,99972
=====
    ]]]
    [[[
尸:w,㇑,99721->c_null
卩:w,㇑,㇆->c_null
阝:w,㇑,㇌->c_null
屮:w,㇑,凵->c_null
䇖:d,⺮,𠚤->d,⺮,99972
[头囗囊]:125124534->1251245
麉:11211241352211535->11311241352211535
䶬:1121124143125111515111->1131124143125111515111
𢏗:313112515->113112515
    部件笔顺码更正表囗单个囗源

𠛬:113112-22;a,99697,刂,
99697=幵
    部件替换表囗全局囗源

    ]]]
    [[[再次运行，_show____yqkey__bad_pairs__xx__triples4on_err()不再出错
出错在之后:
    def _try_deduce_from_src_bk(src_bk, _updated_src_bks, /):
        ... ...
        assert lcs, (src_bk, yqkey, js_4arg, bifix_info)
            #必然有:倒装:共同后缀
            #
            #('用', ('st', '=', '⺆'), '35_', (2, 0, '35', '', '35-'))
            #('𦉫', ('st', '=', '[无钩冂]'), '25_', (2, 0, '25', '', '25-'))
            #('㣺', ('wt', '=', '㇑'), '442_', (3, 0, '442', '', '442-'))
        ... ...
    『用』『𦉫』: 是前面出错，被忽略，方至此
        『用』发现是错于check_and_mk_prefix_js:
    def check_and_mk_prefix_js(src_bk, js4src_bk, dst_bks_, /):
        ... ...
        i = 0
        for dst_bk_ in dst_bks_:
            ... ...
            js_ = bk2js[dst_bk_]
            j = i+len(js_)
            assert js_ == js4src_bk[i:j], (src_bk, js_, js4src_bk[i:j], (i,j), js4src_bk)
                #('用', '25', '35', (0, 2), '35112')
                #   『⺆』本无 笔顺码，可见之前 推导出错
                #   提前 设定为 35
            ... ...
        ... ...
        『𦉫』发现是错于check_and_mk_suffix_js:
    def check_and_mk_suffix_js(src_bk, js4src_bk, _dst_bks, /):
        ... ...
        for _dst_bk in _dst_bks:
            ... ...
            assert _js == js4src_bk[i:j], (src_bk, _js, js4src_bk[i:j], (i,j), js4src_bk)
                #('𦉫', '32', '22', (2, 4), '2522')
                #   𦉫:st([无钩冂],10001)
                #       <<== _add_bk_js ('丌', 10001, '32')
            ... ...
        ... ...

看看谁提供了错误的『⺆』笔顺码
    见:_add_bk_js():print所有推导源部件
    ########
    def _add_bk_js(src_bk, dst_bk, js, _updated_src_bks, /):
        print('_add_bk_js', (src_bk, dst_bk, js))
        _add_bk_js_(dst_bk, js, _updated_src_bks)

_add_bk_js ('囗', '⺆', '25')
嘴~口vs囗~国围
口:mc(囗)
囗:d/t(⺆,㇐)
囗:d/t,⺆,㇐->c_null
#删后，又有:
_add_bk_js ('㸑', '⺆', '45')
㸑:d(99846,⺆,焚)
手动直接修改文件:
    ---弃置:
    *:d,99846,⺆,...->d,99846,冖,...
    %s/:d(99846,⺆/:d(99846,冖
        # ))
    ---弃置:
    *:d,99846,⺆,...->d,[头囗㸑],...
    [头囗㸑]:d,99846,冖
    %s/:d(99846,⺆/:d([头囗㸑]
        # ))
    [头囗㸑]:d(99846,冖)
    ---现任:
    发现已有:
        37147:d(99846,冖)
        37147=[头囗璺]
    *:d,99846,⺆,...->d,[头囗璺],...
    %s/:d(99846,⺆/:d(37147
        # ))

#⺆/⺼-似乎是 unicode-cjk部首区字符，而非 cjk汉字
直接搜『⺆』，发现错误-或-可能有误: [
冏:a(⺆,㕣)
⺆:a/t(㇑,㇆)
曱:d/m(⺆,干)
甲:d/o(⺆,37024)
见:d/o(⺆,儿)
贝:d/o(⺆,人)
禹:d/o(䖝,⺆)
𠕂:d/o(三,⺆)
内:d/o(人,⺆)
肉:d/o(仌,⺆)
37671:d/o(从,⺆)
內:d/o(入,⺆)
17013:d/o(凵,⺆)
丑:d/o(刀,二)
禸:d/o(厶,⺆)
51389:d/s(⺆,亞)
51101:d/s(业,⺆)
24504:d/s(彑,⺆)
冎:d/t(38465,⺆)
44702:d/t(52248,⺆)
46166:d/t(54168,⺆)
59423:d/t(61952,⺆)
47005:d/t(65522,⺆)
70063:d/t(97658,⺆)
59934:d/t(⺆,日)
60054:d/t(⺆,㇆)
99732:d/t(⺆,99932)
囗:d/t(⺆,㇐)
𠀃:d/t(⺆,㇐)
𢃹:d/t(⺆,48791)
37737:d/t(⺌,⺆)
龸:d/t(⺌,冖)
47044:d/t(亠,55103,⺆)
63227:d/t(十,⺆)
53407:d/t(卜,⺆)
25919:d/t(甘,⺆)
24595:d/t(百,⺆)
22301:d/t(𠔿,⺆)
䍏:lock(59349,⺆)
20134:lock(⺆,26827)
    许多...
42523:lock(㇓,⺆)
24410:lock(丄,⺆)
51585:lock(人,⺆)
26653:lock(兀,⺆)
37645:lock(凵,⺆)
51441:lock(山,⺆)
49584:lock(川,⺆)
49196:lock(幺,⺆)
48740:lock(王,⺆)
26942:lock(玨,⺆)
冂:me(⺆)
𠕄:mo(⺆)
冖:msp(⺆)
24198:r3st(⺆)
凵:refv(⺆)
𠔽:rst(⺆)
40919:s(⺆,仌)
52868:s(⺆,90213)
54210:s(⺆,凵)
62621:s(⺆,㕣)
36137:s/t(⺆,卄)
33986:st(21628,⺆)
20325:st(⺆,𠅇)
21628:st(⺆,儿)
    许多...
⺼:st(⺆,亠)
用:st(⺆,37024)
    许多...
41320:st/t(⺆,井)
24273:stl(⺆,𦍍)
47421:stl(⺆,又)
    许多...
冇:stl(𠂇,⺆)
63582:str(㇆,⺆)
22528:w(⺆,卄)
    许多...
𪩲:w(才,⺆)
朿:w(木,⺆)
99700:wb(大,⺆)
99878:wt(⺆,㇔)
99885:wt(⺆,土)
央:wt(大,⺆)
50619:wt(尢,⺆)
    ]


==>>
⺆:a/t,㇑,㇆->c_null
冏:a,⺆,㕣->st,[无钩冂],㕣
曱:d/m,⺆,干->c_null
甲:d/o,⺆,37024->c_null
见:d/o,⺆,儿->d//st,[无钩冂],[见之儿]
贝:d/o,⺆,人->d//st,[无钩冂],人

『d/o』当作『c_null』
    def is_ok4try_deduce__op(op, /):
        return ... and not op == 'd/o'



怀疑:d(...,⺆,...)当为d(...,冖,...)
    ---弃置:
    %s/:d(\([^)]*,\)\?⺆\([,)]\)/:d(\1[冖自纵组⺆]\2
        # )
        共319行
    ---现任:
    发现许多 d(⺆,...)，可能不是『冖』
        冤 vs 40086:d(⺆,兔)
    ==>>区分 首部件与否
    %s/:d(⺆,/:d([头用⺆],
        # ))
        共48行
    %s/:d(\([^)]*\),⺆\([,)]\)/:d(\1,[冖自纵组⺆]\2
        # )
        共271行
    %s/(\([^)]*\),⺆\([,)]\)/(\1,[无钩冂自偏旁⺆]\2
        # )
        共43行
    %s/(⺆\([,)]\)/([无钩冂自部首⺆]\1
        # )
        共162行

『用』:
⺆:null->35
[无钩冂自部首⺆]:null->25
[无钩冂自偏旁⺆]:null->25
[冖自纵组⺆]:null->45
[头用⺆]:null->35
    部件笔顺码更正表囗单个囗源
⺆:a/t,㇑,㇆->c_null
囗:d/t,⺆,㇐->c_null
曱:d/m,⺆,干->c_null
甲:d/o,⺆,37024->c_null
见:d/o,⺆,儿->d//st,[无钩冂],[见之儿]
贝:d/o,⺆,人->d//st,[无钩冂],人
⺼:st,⺆,亠->st,⺆,冫
冏:a,⺆,㕣->st,[无钩冂],㕣
    ⺆->[无钩冂自部首⺆]
    部件拆分更正表囗单个囗源


『𦉫』:
d,37197!养:d(37197,10001)
d,二!亓:d(二,10001)
d,亠!亣:d(亠,10001)
d,人!介:d(人,10001)
    ==>> 10001=[底囗介] #笔顺码=32
    部件替换表囗全局囗源
𦉫:st,[无钩冂],10001->st,[无钩冂],[双竖]
    部件拆分更正表囗单个囗源


『㣺』
㣺:wt(㇑,99754)
忄:wt(㇑,八)
99743:ra(㇏)
99754:a(㇒,99743)
忄	442	550
㣺	4424	520
    ??? 难道不该是『4442』???
    左点+点+点
小	234	550
㳟	12213424134	520
恭	1221342444	550
    [底囗恭]:2444???
㤗	111342444	520
忝	11342444	550
叅	545454342444	550
慕	12225111342444	550
㝳	12444	520
㓒	4115342444	520
隳	52131212511342444	550
䧙	52252342444	520
㛋	531342444	520
---
    㳤	4414132444	520



㣺:4424->4442
㣺:wt,㇑,99754->c_null
忄:wt,㇑,八->c_null
    部件拆分更正表囗单个囗源

鹵:d(⺊,37793)
37793:s(囗,𠂭)
𠂭:w(乂,37036)
37792:w(37036,白)
氺:w(㇚,37036)
軣:d(車,37036)
w,了!37450:w(了,37036)
w,人!38033:w(人,37036)
    ==>> 37036=[脊四点]

[脊四点]
[雨四点]
[煮四点]
[鹵四点]
𠂭:w,乂,37036->w,乂,[鹵四点]
氺	24134	550
    先中间后两边
脊	4134342511	550
    先两边后中间


TODO:
    ---
    『尚/卤/病/魔/鹿』怎么拆？先拆大框、先拆小框、先拆上下？
        view others/数学/编程/永恒代码/操作符.txt
        view others/数学/编程/永恒代码/操作符.例.汉字部件拆分格式.txt
    ---
    e ../../python3_src/nn_ns/CJK/CJK_struct/cjk_decomp_0_4_0/cjk-decomp-0.4.0.txt
        删除 排序时 使用的 行头:『.*!』
        保存 patch...
    ---
    于推导前提前检验 拆分后 双缀 笔顺码 匹配与否
    ---
    _add_bk_js__ex
        inputs4_add_bk_js__ex

[[
查看哪些汉字无法显示
view script/hz/查看哪些汉字无法显示.py
    ...没用...不知 系统字体 及其路径
cjk.chars
    seed.data_funcs
view ../../python3_src/nn_ns/CJK/CJK_data/raw/汉字相关字符范围.py

grep seed.data_funcs.rngs  -r . -l
from seed.data_funcs.rngs import make_Ranges, sorted_ints_to_iter_nontouch_ranges, detect_iter_ranges, StackStyleSimpleIntSet, StackStyleSimpleIntMapping, TouchRangeBasedIntMapping
]]

    ]]]

]]

===[-ex6.txt:
# --启用共同双缀当作部首笔顺码的最小区规模=4

匘:35555325341;a,匕,37119,
    笔顺码有误:35 vs 15
    㔭:15251112134;a,匕,是,

整区多拆:
n今:3445;d,亽,㇇,
y㖍:441225135;d,斗,叱,
y昚:134432511;d,𡗜,日,


===
部首变形导致笔顺码改变or双缀初拆有误or笔顺码有误or部件拆分有误:数量: 14
雟:52-3324111212534251;d,屮,43236,
    分错区:左囗艸#撇化屮#左上用屮#撇化
邫:111-32515215;a,丰,邑,
邦:111-352;a,丰,阝,
    两字:分错区:左囗邦#撇化丰

笔划错or部首错:
𪇵:4131221-1251213432511154444;a,廣,鳥,
𤒼:4131221-1251213443344334;a,廣,炎,
鄺:4131221-251213452;a,廣,阝,
𠢹:4131221-251213453;a,廣,力,


copy to:部件替换囗整区囗源+已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集:
䄣:4524-121252212511134;a,示,賣,
䄣-示-礻
㼝:35455-1554;d,夘,瓦,
㼝-夘-夗
䴻:31234353_4-1234343435;d,䄪,麥,
䴻-䄪-[头囗黎]-31234353
頖:43113-132511134;a,半,頁,
頖-半-[撇化半]-43113#[左囗判]
圱:313-121;a,千,土,
圱-千-[撇化千]-313#[左囗圱]

整区多拆:
顬:14524444132522_4-13251113;a,需,頁,
㼬:12143112_4-155;a,幸,瓦,
𤦂:12511534_4-1121;d,或,玉,
頽:3123435_4-13251113;a,秃,頁,
胥:5213425-11;d,疋,月,
預:5452_4-13251113;a,予,頁,
䴻:31234353_4-1234343435;d,䄪,麥,



===
共同双缀当作部首笔顺码:双缀还可能延长:数量: 24

>否决囗囗双缀还可能延长囗字集
    xxx += 頂㪁博鵕䫕剃㶇劀䄣耐鵮䫢䨄杀弆㼝呑貣㲍𤔅噐
        21=24-3
    += 㪁博剃㶇劀䄣耐䫢弆㼝貣㲍 邒皴鶙燄韽㣻乔爬嘂#移出:頂鵕䫕鵮䨄杀呑𤔅噐#因为 这里 要的是 候选错区字，而非 区首字
        12=21-9=24-3-9
    += 䝴浆䒿
>部件替换表囗全局囗源
䒿:12245-2511;d,37165,月,
37165=[纵组艹冖]
桨:412354-1234;d,37194,木,
37194=[头囗桨]
㯻:1251245_34-135333412;d,47005,豕,木,
47005=[头囗囊]

x-(('d', [47005, '豕', '木'], '125124513533341234', '㯻'), [('d', [47005, '貝'], '12512452511134', '䝴')])
---
橐:1251245132511234;d,65522,38062,
囊:1251245251251112213534;d,65522,38373,
    重拆:[头囗囊]=65522+冖
    放到？整区多拆？整区多拆囗例外字集囗并未多拆囗用作重拆
叓:1251254;d,65522,又,
    分错区<<==因为改为：[头囗囊]
---
㯻:1251245_34-135333412;d,47005,豕,木,
㰆:1251245_34-2111211112;d,47005,棐,
䝴:1251245_34-25111;d,47005,貝,
㯱:1251245_34-31125212;d,47005,缶,木,
TODO:[区规模==4]的yet确认
]

===
鴬:443-4532511154444;d,⺍,37328,
    分错区:头囗觉

===以下:
copy from:
    view ../笔顺码分解/29685-ex.txt

bug:
𦱳:431-55455452;d,艹,62697,
䧐:2541251521;a,阝,享,
䤋:43125351112511534;a,酉,或,
用:35112;st,⺆,37024,
𠚼:125422;a,分,刂,
𣫺:415541441542511;a,每,育,
㠀:32511154444252;d,馬,山,
𦥯:3211343451145;d,37153,冖,
  lcp==len


𣚺:1123413553455414;a,木,92642,
敘:34112343134;a,金,⺙,
𦢊:3541251112213424134;a,月,暴,
鰴:3322521352512144443134;a,魚,37944,
䍧:3112431112;a,牛,羊,
䴞:2125344444154154132411121;a,齒,翟,
䴜:21253444441325113554;a,齒,鬼,
䑘:321511431113121;a,白,差,
麒:4135221151512211134;stl,鹿,其,
麟:41352211515431234354152;stl,鹿,粦,
𣊁:121415331342511;d,敖,日,
候:3225131134;a,39752,37260,
攸:3223134;a,39752,⺙,
  删去『候』，lcp==len

䲝:352512113455;a,魚,仓,
䲤:352512114411253511;a,魚,酒,


言:4111251;d,亠,37244,
豸:3443533;d,⺤,犭,

着:4311-1325111;d,羊,目,
羌:4311-135;d,羊,㇟,
羞:4311-135211;d,羊,丑,
  笔划 错
  字型布局 也错


#######
[[[
xxx部首变形导致笔顺码改变or双缀初拆有误or笔顺码有误or部件拆分有误:数量: 23
x-[('14524444-11121112511', 'd', ['雨', '彗'], '1452444411121112511', '䨮'), ('14524444-112', 'd', ['雨', '于'], '14524444112', '𩁹')]
雨:竖->点
x-[('2512121-111234', 'a', ['足', '耒'], '2512121111234', '𨀤'), ('2512121-111253134', 'a', ['足', '契'], '2512121111253134', '𨂰')]
足:人->21:提化
足:2512134;d,口,龰,
𨀤:2512121-111234;a,足,耒,
x-[('3121-111251113454', 'a', ['牛', '贰'], '3121111251113454', '㹑'), ('3121-112', 'a', ['牛', '干'], '3121112', '㸩')]
牛:3112|3121:提化
x-[('1521-111341134', 'a', ['车', 37121], '1521111341134', '辏'), ('1521-112', 'a', ['车', '干'], '1521112', '轩')]
车1512|1521:提化
x-[('34451154-11234', 'a', ['食', '末'], '3445115411234', '䬴'), ('34451154-1135', 'a', ['食', '元'], '344511541135', '䬧')]
食:作部首时缺笔
食:344511534;d,亽,艮,
䬴:34451154-11234;a,食,末,
x-[('431113-11234', 'a', ['羊', '末'], '43111311234', '䍪'), ('431113-12511234', 'a', ['羊', '東'], '43111312511234', '䍶')]
羊:竖->撇
羊:431112;d/t,37145,丷,
䍪:431113-11234;a,羊,末,
x-[('412234-1234', 'd', ['亦', '木'], '4122341234', '栾'), ('412234-251214', 'd', ['亦', '虫'], '412234251214', '蛮')]
亦:撇->竖
x-[('431121-134', 'd', ['羊', '大'], '431121134', '美'), ('431121-25221', 'd', ['羊', '皿'], '43112125221', '盖')]
羊:431112|431121:断尾
羊:431112;d/t,37145,丷,
美:431121-134;d,羊,大,
x-[('41352211515-1332511234', 'a', ['鹿', '原'], '413522115151332511234', '䴨'), ('41352211515-1554', 'a', ['鹿', '瓦'], '413522115151554', '㼾')]
鹿:比:提化
鹿:41352211535;stl,65510,比,
䴨:41352211515-1332511234;a,鹿,原,
x-[('12122-1212514311254', 'd', ['卉', '鼓'], '121221212514311254', '鼖'), ('12122-1234', 'd', ['卉', '木'], '121221234', '桒')]
卉:撇->竖
x-[('554444-1213234', 'a', ['糸', '赤'], '5544441213234', '𦀗'), ('554444-13252', 'a', ['糸', '布'], '55444413252', '𥿠')]
糸:竖->点
糸:554234;d,幺,小,
𦀗:554444-1213234;a,糸,赤,
x-[('511121-2511', 'd', ['聿', '日'], '5111212511', '書'), ('511121-25111', 'd', ['聿', '旦'], '51112125111', '晝')]
聿:511112|511121断尾
聿:511112;d/m,⺺,37024,
書:511121-2511;d,聿,日,
x-[('125221-121', 'd', ['西', '土'], '125221121', '垔'), ('125221-14334', 'd', ['西', '灭'], '12522114334', '㶾')]
西:丨丨->儿
西:125351;d/o,兀,囗,
垔:125221-121;d,西,土,
x-[('1-234', 'd/m', ['十', '小'], '1234', '朩'), ('1-252', 'd/m', ['十', '巾'], '1252', '巿')]

known:䨮𨀤㹑辏䬴䍪栾美䴨鼖𦀗書垔
  已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集
#######

留:3545325121;d,卯,田,
貿:354532511134;d,卯,貝,
贸:354532534;d,卯,贝,
  分错区#该区:卯
壴:121251431;d,十,豆,
  ???壴:12-1251431;d,十,豆,
  错区？好像也说得过去！

整区不拆
  朩:1-234;d/m,十,小,
    丈:1-34;d/m,十,乂,
    屯:1-525;d/m,十,𡳾,
整区多拆
  䃕:4334433445_1-1325;d,𤇾,石,
    原首字:䝁
  顆:25111234_4-13251113;a,果,頁,
    原首字:顆
  螚:5425113535_4-25121;d,能,虫,
    原首字:螚
]]]
#######
[[[
xxx共同双缀当作部首笔顺码:双缀还可能延长:数量: 29

亪:4132344;d,亦,乁,
弈:413234132;d,亦,卄,
奕:413234134;d,亦,大,
帟:413234252;d,亦,巾,
  分错区#该区:
      ^413
      ^411

䴫:413522115351452444434454;a,鹿,零,
䴣:4135221153534312;a,鹿,乎,
  笔划 错
  41352211535
  41352211515
㒯:241351221122112;a,光,華,
  缺笔
  24135
  243135
㪜:2521325112154;a,耑,⺙,
  笔划 错
  2521325112154
  2521325222154
䋷:545233154554234;d,46156,糸,
  笔划 错
  䋷:54523-3154-554234;d,46156,糸,
  -3154-
  -3134-

來:12343434;w,木,从,
  來:1_34-23434;w,木,从,
  末:1_34-12;w,木,㇐,
  束:1_34-2512;w,木,口,
  ->來:12_34-3434;w,木,从,
  ->末:1_234-1;w,木,㇐,
  ->束:1_234-251;w,木,口,
衋:511112132511132511325221;d,聿,38255,
  ?衋:5111-12132511132511325221;d,聿,38255,
    ?vs書:5111-212511;d,聿,日,
㼺:41351122511554;a,害,瓦,
㔓:31253;a,千,力,
  㔓:31-253;a,千,力,
  圱:31-3121;a,千,土,

𣇸:121212342511;d,卉,32100,
  ?十十vs艹
䣋:3443123452;a,釆,阝,
  ?爫木vs丿米

整区多拆:
  鷂:34433112523-2511154444;a,37021,鳥,
    原首字:鷂
    拆多1笔
    34433112523-
    3443311252-
  觳:121_3554-4513535112;str,37127,37810,
    ..殸:121_3554-5213;str,37127,𠃜,
    原首字:觳
    121_3554-
    _3554-

ok:鴌㤁佱佥侴鶑㷀羸嬴彂㡫巸丫忒末䎐瓯廵瞿辱朿㶳
  否决囗囗双缀还可能延长囗字集

]]]
#######


])}]]]]]]
#######

#]]]'''
__all__ = r'''
'''.split()#'''
__all__

def _():
  if 0:
    from seed.tiny import echo, print_err, mk_fprint, mk_assert_eq_f, expectError
    from seed.func_tools.fmapT.fmapT__tiny import dot, fmapT__dict, fmapT__list, fmapT__iter

from seed.helper.get4may import nmay2tmay #nmay2tmay__Nothing, , get4nmay__Nothing, get4nmay, fget4nmay__Nothing, fget4nmay, fgetP4nmay__Nothing_, fgetP4nmay_, fget4nmay__human, fget4nmay__Nothing__human, xget4nmay_, xget4nmay__human
from seed.tiny import check_type_is, fst, snd, at
from seed.helper.stable_repr import stable_repr
from seed.tiny_.dict__add_fmap_filter import fmap4dict_value, dict_add__eq, dict_add__is, group4dict_value #, filter4dict_value
from seed.mapping_tools.dict_op import inv__k2v_to_v2ks, inv__k2vs_to_v2ks, inv__k2v_to_v2k # inv__k2vs_to_v2k
from seed.mapping_tools.dict_op import set_symmetric_partition__immutable, partition_by_keyss__immutable, subset_keys__immutable, subtract_keys__immutable #, mapping_zipped_symmetric_partition__immutable
from seed.seq_tools.lcp_of import len_lcp_of__lsls, len_lcs_of__lsls, lcp_of__lsls, lcs_of__lsls
from seed.tiny import mk_fprint, fst, echo
from collections import Counter
from itertools import groupby
from heapq import heappush, heappop

d = Counter('122333aaa')
d.elements()
d.most_common()
d.total()
'elements', 'fromkeys', 'most_common', 'subtract', 'total'
'''
>>> d = Counter('122333aaa')
>>> d
Counter({'3': 3, 'a': 3, '2': 2, '1': 1})
>>> d.elements()
<itertools.chain object at 0x71ea95a0e0>
>>> [*d.elements()]
['1', '2', '2', '3', '3', '3', 'a', 'a', 'a']
>>> d.most_common()
[('3', 3), ('a', 3), ('2', 2), ('1', 1)]
>>> d.total()
9

'''#'''

def load():
    #see:load_with_patch()
    from nn_ns.CJK.CJK_data.raw.汉字笔顺 import 汉字到笔顺码
    from nn_ns.CJK.CJK_struct.cjk_decomp_0_4_0.read_cjk_decomp import default_iter_read_cjk_decomp
    #from nn_ns.CJK.CJK_struct.cjk_decomp_0_4_0.read_cjk_decomp import load_default, diff__bk2f_bks_, patch__bk2f_bks_
    hz2js = hz2istrokes = 汉字到笔顺码
    bk2f_bks = bk2cased_bks = dict(default_iter_read_cjk_decomp())

    cks = hz2js.keys() & bk2f_bks.keys()
    assert len(cks) == 29670
    lks = hz2js.keys() - bk2f_bks.keys()
    rks = bk2f_bks.keys() - hz2js.keys()
    assert len(lks) == 89
    assert len(rks) == 55568
    rks__hz = {x for x in rks if type(x) is str}
    rks__bk = {x for x in rks if type(x) is int}
    assert len(rks__hz) == 45081
    assert all(len(hz)==1 for hz in rks__hz)
    assert len(rks__bk) == 10487
    return hz2js, bk2f_bks
#end-def load():


bugs____ = r'''
𦱳:431-55455452;d,艹,62697,
䧐:2541251521;a,阝,享,
䤋:43125351112511534;a,酉,或,
用:35112;st,⺆,37024,
𠚼:125422;a,分,刂,
𣫺:415541441542511;a,每,育,
㠀:32511154444252;d,馬,山,
𦥯:3211343451145;d,37153,冖,
𣚺:1123413553455414;a,木,92642,
敘:34112343134;a,金,⺙,
𦢊:3541251112213424134;a,月,暴,
鰴:3322521352512144443134;a,魚,37944,
䍧:3112431112;a,牛,羊,
䴞:2125344444154154132411121;a,齒,翟,
䴜:21253444441325113554;a,齒,鬼,
䑘:321511431113121;a,白,差,
麒:4135221151512211134;stl,鹿,其,
麟:41352211515431234354152;stl,鹿,粦,
𣊁:121415331342511;d,敖,日,
候:3225131134;a,39752,37260,
攸:3223134;a,39752,⺙,
䲝:352512113455;a,魚,仓,
䲤:352512114411253511;a,魚,酒,
言:4111251;d,亠,37244,
豸:3443-533;d,⺤,犭,
着:4311-1325111;d,羊,目,
羌:4311-135;d,羊,㇟,
羞:4311-135211;d,羊,丑,
亪:4132344;d,亦,乁,
弈:413234132;d,亦,卄,
奕:413234134;d,亦,大,
帟:413234252;d,亦,巾,
䴫:413522115351452444434454;a,鹿,零,
䴣:4135221153534312;a,鹿,乎,
㒯:241351221122112;a,光,華,
㪜:2521325112154;a,耑,⺙,
䋷:545233154554234;d,46156,糸,
來:12343434;w,木,从,
衋:511112132511132511325221;d,聿,38255,
㼺:41351122511554;a,害,瓦,
㔓:31253;a,千,力,
𣇸:121212342511;d,卉,32100,
䣋:3443123452;a,釆,阝,
留:3545325121;d,卯,田,
貿:354532511134;d,卯,貝,
贸:354532534;d,卯,贝,
壴:121251431;d,十,豆,
鴬:443-4532511154444;d,⺍,37328,
匘:35555325341;a,匕,37119,
雟:52-3324111212534251;d,屮,43236,
邫:111-32515215;a,丰,邑,
邦:111-352;a,丰,阝,
𪇵:4131221-1251213432511154444;a,廣,鳥,
𤒼:4131221-1251213443344334;a,廣,炎,
鄺:4131221-251213452;a,廣,阝,
𠢹:4131221-251213453;a,廣,力,
叓:1251254;d,65522,又,
'''#'''
bugs__ = ''.join(map(fst, bugs____.split()))
bug_hz_set = set(bugs__) - {*':125422\n'}
r'''
手动收集数据囗代码区:here
=====
bug_hz_set
    bugs__
        bugs____
整区多拆囗原首字到部首倒装笔顺码
    #整区多拆#多拆了笔划
否决囗囗双缀还可能延长囗字集
整区不拆囗原首字囗字集
    =qhzs4skip_ts
    #整区不拆
已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集
部件替换
全局部件替换囗
手动原样通过囗区首字囗字集
笔顺码补丁
部件替换表


TODO:保证数据全被用到
    assert used_bug_hz_set == bug_hz_set
    assert 整区多拆囗已使用囗字集 == 整区多拆囗原首字到部首倒装笔顺码.keys()
    assert 否决双缀延长囗已使用囗字集 == {*否决囗囗双缀还可能延长囗字集}
    assert skip.used_qhzs == {*整区不拆囗原首字囗字集}
    assert {*known_bads} == {*已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集}
    assert {*map(fst, 部件替换囗整区囗数据)} == {*已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集}
        ts = 区首字到区[区首字]
    assert case2num_qhzs['pass'] == len(手动原样通过囗区首字囗字集)
'''#'''



class 整区多拆囗原首字到部首倒装笔顺码:
  r'''
TODO:添加右侧拆分是否有误,若y则nm8bk2js__patch_1替换+检查<<==手动固化
    整区多拆:但原来的拆分也可能是错的
        要将yet改为fix，还需看右侧拆分
            y n
            yes no
允许的结构类型:[adsb]
整区多拆:
y鷂:34433112523-2511154444;a,37021,鳥,
    3443311252-
n觳:121_3554-4513535112;str,37127,37810,
    ..殸:121_3554-5213;str,37127,𠃜,
    121_3554-
    _3554-
    str->包围-上-右，即『右上两侧包围』
        但我只考虑字型布局，是左右结构，所以错，即标识『n』

䝁:4334433445-1251431;d,𤇾,豆,
y䃕:4334433445_1-1325;d,𤇾,石,
    原首字:䝁
    4334433445_1-
    4334433445-
    ##打以下补丁之后，本区融合，不再『多拆』
    瑩:4334433445-11214;d,37027,玉,
    37027=𤇾
y顆:25111234_4-13251113;a,果,頁,
    25111234-
y螚:5425113535_4-25121;d,能,虫,
    5425113535_-
n京:41251-234;d,37045,小,
    41-
n瑴:121451_3554-1121;str,37047,王,
    _3554-

鞗:322354-122125112;a,39752,37779,
y條:322354-1234;a,39752,条,
倏:322354-1344;a,39752,37582,
    322-

n堂:24345251-121;d,37062,土,
    24345-
斄:11234313413-12343434;d,37087,𠩬,
y釐:11234313413-2511211;d,37087,厘,
    112343134-
n廑:4131221-2511121;stl,28722,37304,
    413-
n㫌:415331-12121;stl,62307,正,
    4153-

n䮸:3211343451145-1211254444;d,37153,⺆,馬,
重拆:d,37153,⺆=𦥯
    3211343451145-


n今:3445;d,亽,㇇,
重拆:d,人,?
    34-

y㖍:441225135;d,斗,叱,
    4412-

y昚:134432511;d,𡗜,日,
    13443-
    眘:1344325111;d,𡗜,目,


y顬:14524444132522_4-13251113;a,需,頁,
    14524444132522-
y㼬:12143112_4-155;a,幸,瓦,
    12143112-
y𤦂:12511534_4-1121;d,或,玉,
    12511534-
y頽:3123435_4-13251113;a,秃,頁,
    3123435-
y胥:5213425-11;d,疋,月,
    52134-
y預:5452_4-13251113;a,予,頁,
    5452-
䴻:31234353_4-1234343435;d,䄪,麥,
y䴻:31234353_4-1234343435;d,[头囗黎],麥,
    31234353-
y橐:1251245132511234;d,65522,38062,
    1251245-



,='-'
'''#'''
  if 1:
    #   qhz :: 区首字 char 汉字
    yn_qhz2js_ex = (dict
(y鷂='3443311252-=37021=䍃'
,n觳='_3554-!sr,殳,?'
#,y䝁='4334433445-'#𤇾<<==打补丁:瑩.37027=𤇾 -> 瑩+䝁 两区合并，不再『多拆』
,y顆='25111234-'#果
,y螚='5425113535-'#能
,n京='41-!d,亠,?'
,n瑴='_3554-!sr,殳,?'
,y鞗='322-=39752=[横组亻丨]'
,n堂='24345-!d,[头囗尝],?'
,y斄='112343134-=37087=[横组未攵]'
,n廑='413-!stl,广,?'
,n㫌='4153-!a,方,?'
,n䮸='3211343451145-!d,𦥯,?'
#,n今='344-!d,亽,?'
,n今='34-!d,人,?'
,y㖍='4412-'#斗
,y昚='13443-'#大+丷
,y顬='14524444132522-'#需
,y㼬='12143112-'#幸
,y𤦂='12511534-'#或
,y頽='3123435-'#秃#提化
,y胥='52134-'#疋
,y預='5452-'#予
,y䴻='31234353-'#[头囗黎]
#,y橐='1251245-!d,[头囗囊],?'
))
  #class 整区多拆囗原首字到部首倒装笔顺码
  整区多拆囗例外字集囗并未多拆囗用作重拆 = '' # = '橐'
    # = '橐'#没用？至少在[--启用共同双缀当作部首笔顺码的最小区规模==2]之前无用，会被直接跳过skip()
  def _(yn_qhz2js_ex, 例外字集囗仅用于重拆, /):
    def yn2bool(yn,/):
        assert len(yn)==1
        assert yn in 'yn'
        return yn == 'y'
    #   qhz :: 区首字 char 汉字
    qhz2yn_js_ex = {qhz:(yn2bool(yn), js_ex) for (yn,qhz), js_ex in yn_qhz2js_ex.items()}
    assert len(qhz2yn_js_ex) == len(yn_qhz2js_ex)
    for qhz, (yn, js_ex) in qhz2yn_js_ex.items():
        assert len(qhz)==1
        assert type(yn) is bool
        assert js_ex
    qhz2yn_js_ = {}
    qhz2f_bks__patch = {}
    nm8bk2js__patch_2 = {}
    _uint8bk2nm8bk__patch = {}
    for qhz, (yn, js_ex) in qhz2yn_js_ex.items():
        assert yn is (not '!' in js_ex) or qhz in 例外字集囗仅用于重拆
        if '!' in js_ex:
            assert not yn or qhz in 例外字集囗仅用于重拆
            [js_, new_f_bks] = js_ex.split('!')
        else:
            assert yn
            [js_, *eq_ex] = js_ex.split('=')
        assert js_.endswith('-')
        assert not '=' in js_
        assert not '!' in js_
        if not yn:
            assert new_f_bks
            [f, *bks] = new_f_bks.split(',')
            assert bks
            nm8bk = bks[0]
            qhz2f_bks__patch[qhz] = (f, bks)
            assert nm8bk
            has_nm8bk = True

        elif yn and eq_ex:
            assert yn
            [bk, nm8bk] = eq_ex
            assert bk
            uint8bk = int(bk)
            dict_add__eq(_uint8bk2nm8bk__patch, uint8bk, nm8bk)
            assert nm8bk
            has_nm8bk = True
        else:
            ...#no nm8bk
            has_nm8bk = False

        qhz2yn_js_[qhz] = (yn,js_)
        if has_nm8bk:
            js = js_.replace('-', '')
            js = js.replace('_', '')
            dict_add__eq(nm8bk2js__patch_2, nm8bk, js)
            del nm8bk, js
    _uint8bk2nm8bk__patch
    bk2nm8bk__patch_2 = _uint8bk2nm8bk__patch
    ######################
    qhz2yn_js_
    qhz2f_bks__patch
    nm8bk2js__patch_2
        #vs nm8bk2js__patch_1
    return (qhz2yn_js_, qhz2f_bks__patch, nm8bk2js__patch_2, bk2nm8bk__patch_2)
  if 1:
    (qhz2yn_js_, qhz2f_bks__patch, nm8bk2js__patch_2, bk2nm8bk__patch_2) = _alls = _(yn_qhz2js_ex, 整区多拆囗例外字集囗并未多拆囗用作重拆)
整区多拆囗原首字到部首倒装笔顺码


if 1:
    #xxx共同双缀当作部首笔顺码:双缀还可能延长:数量: 29
    否决囗囗双缀还可能延长囗字集 = '鴌㤁佱佥侴鶑㷀羸嬴彂㡫巸丫忒末䎐瓯廵瞿辱朿㶳'
    否决囗囗双缀还可能延长囗字集 = ('鴌㤁佱佥侴鶑㷀羸嬴彂㡫巸丫忒末瓯廵瞿辱朿㶳'
        #bad_ts
        #移除『䎐』#龺<<==打补丁:𪂂.97020=龺 -> 𪂂+䎐 两区合并，不再『可延长』
    #'頂㪁博鵕䫕剃㶇劀䄣耐鵮䫢䨄杀弆㼝呑貣㲍𤔅噐'
    '㪁博剃㶇劀䄣耐䫢弆㼝貣㲍' '邒皴鶙燄韽㣻乔爬嘂'#移出:頂鵕䫕鵮䨄杀呑𤔅噐#因为 这里 要的是 候选错区字，而非 区首字
    '䝴浆䒿'
    )

if 0:
    #旧:排序以(f, ss, js, hz)
    #qhzs4skip_ts = '干？戈羐尸氺'
    pass
else:
    #新:排序以(f, ss[:1], js, ss, hz)
    qhzs4skip_ts =   '干㦮羐⺌扌厃手三朩聿冃卓上'
    #不同排序==>>区首字不同
整区不拆囗原首字囗字集 = qhzs4skip_ts
    #skip()
    #整区不拆

已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集 = '䨮𨀤㹑辏䬴䍪栾美䴨鼖𦀗書垔' '䄣㼝䴻頖圱'


#13+5个:
部件替换囗整区囗源 = '''
𦀗:554444-1213234;a,糸,赤,
𦀗-糸-糹
𨀤:2512121-111234;a,足,耒,
𨀤-足-⻊
䬴:34451154-11234;a,食,末,
䬴-食-飠
䨮:14524444-11121112511;d,雨,彗,
䨮-雨-[头用雨]-14524444
㹑:3121-111251113454;a,牛,贰,
㹑-牛-牜
䍪:431113-11234;a,羊,末,
䍪-羊-⺶
辏:1521-111341134;a,车,37121,
辏-车-[左用车]-1521
垔:125221-121;d,西,土,
垔-西-覀
栾:412234-1234;d,亦,木,
栾-亦-[头囗鸾]-412234
美:431121-134;d,羊,大,
美-羊-⺷
䴨:41352211515-1332511234;a,鹿,原,
䴨-鹿-[左用鹿]-41352211515
鼖:12122-1212514311254;d,卉,鼓,
鼖-卉-[头囗桒]-12122
書:511121-2511;d,聿,日,
書-聿-[断尾聿]-511121
䄣:4524-121252212511134;a,示,賣,
䄣-示-礻
㼝:35455-1554;d,夘,瓦,
㼝-夘-夗
䴻:31234353_4-1234343435;d,䄪,麥,
䴻-䄪-[头囗黎]-31234353
頖:43113-132511134;a,半,頁,
頖-半-[撇化半]-43113
圱:313-121;a,千,土,
圱-千-[撇化千]-313
'''#'''
#部件替换
def check_bk(bk, /):
    if type(bk) is int:
        uint8bk = bk
        assert uint8bk >= 0
    else:
        nm8bk = bk
        check_nm8bk(nm8bk)
def check_nm8bk(nm8bk, /):
    部件名 = nm8bk
    check_type_is(str, 部件名)
    assert 部件名
    部件名不成字 = not len(部件名) == 1
    assert 部件名不成字 is (部件名[0]=='[') is (部件名[-1]==']') is not (len(部件名)==1), 部件名
def 部件替换囗整区囗预备囗():
    ls2 = [*filter(bool, 部件替换囗整区囗源.split())]
    assert len(ls2)==len(已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集)*2
    ls = ls2[1::2]
    assert len(ls)==len(已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集)
    assert {*map(fst, ls)} == {*已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集}
    部件替换囗整区囗数据 = []
    for s in ls:
        xs = s.split('-')
        assert 3 <= len(xs) <= 4
        [区首字,旧部首,新部首
        ,*tmay_js4bk] = xs
        assert 区首字
        assert 旧部首
        assert 新部首
        assert not 旧部首 == 新部首
        check_bk(旧部首)
        check_nm8bk(新部首)
        新部首不成字 = not len(新部首) == 1
        assert 新部首不成字 is bool(tmay_js4bk)

        部件替换囗整区囗数据.append((*xs,))

    assert {*map(fst, 部件替换囗整区囗数据)} == {*已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集}
    return 部件替换囗整区囗数据
部件替换囗整区囗数据 = 部件替换囗整区囗预备囗()
assert len(部件替换囗整区囗数据) == 13+5
def 局部部件替换囗(hz2js, tss, 区首字到区, /):
    if 1:
        #为何要tss? 防止ts就地变成ws
        del tss

    nm8bk2js__patch_1 = {}
        # vs nm8bk2js__patch_2
    for [区首字,旧部首,新部首
        ,*tmay_js4bk] in 部件替换囗整区囗数据:
        ts = 区首字到区[区首字]
            #KeyError#所有数据全被用到
        assert not 旧部首 == 新部首

        (f, bks, js, qhz) = ts[0]
        #   qhz :: 区首字 char 汉字
        assert qhz == 区首字
        assert bks[0] == 旧部首
        smay_js4bk = hz2js.get(新部首)
        新部首不成字 = not smay_js4bk
        #del smay_js4bk
        assert 新部首不成字 is bool(tmay_js4bk) or (not 新部首不成字 and len(新部首)>1), 新部首
            #or.rhs <<== [头囗黎]，已写入hz2js
        for (_f, bks, js, hz) in ts:
            assert bks[0] == 旧部首
            assert f == _f

        if 新部首不成字 or len(新部首)>1:
            [js4bk] = tmay_js4bk
            dict_add__eq(nm8bk2js__patch_1, 新部首, js4bk)
            #hz2js[新部首] = js4bk
                #登记笔顺码
                #启用囗局部部件替换 要求 hz2js可变
            if smay_js4bk:
                assert js4bk == smay_js4bk, (js4bk, smay_js4bk, ts[0])
        else:
            [] = tmay_js4bk
        for (f, bks, js, hz) in ts:
            assert bks[0] == 旧部首
            bks[0] = 新部首
                #部件替换
                #bk2f_bks 也被修改
            assert bks[0] == 新部首
            assert not bks[0] == 旧部首

    return nm8bk2js__patch_1

def 囗打补丁囗(hz2js, _nm8bk2js__patch, /):
    for nm8bk, js in _nm8bk2js__patch.items():
        dict_add__eq(hz2js, nm8bk, js)
def 全局部件替换囗(hz2js, bk2f_bks, /):
    (_qhz2yn_js_, _qhz2f_bks__patch, nm8bk2js__patch_2, bk2nm8bk__patch_2) = 整区多拆囗原首字到部首倒装笔顺码._alls

    nm8bk2js__patch_2
    bk2nm8bk__patch_2
    assert {*bk2nm8bk__patch_2.values()} <= nm8bk2js__patch_2.keys()

    bk2nm8bk__patch_3 = 部件替换表囗全局囗数据
    nm8bk2js__patch_3 = 笔顺码补丁囗全局囗数据
    nm8bk2js__patch_2 = 整区多拆囗原首字到部首倒装笔顺码.nm8bk2js__patch_2

    #see:囗打补丁囗(hz2js, nm8bk2js__patch_1)
    囗打补丁囗(hz2js, nm8bk2js__patch_2)
    囗打补丁囗(hz2js, nm8bk2js__patch_3)

    囗打补丁囗拆分表囗(bk2f_bks, bk2nm8bk__patch_3)
    囗打补丁囗拆分表囗(bk2f_bks, bk2nm8bk__patch_2)

def 囗打补丁囗拆分表囗(bk2f_bks, _bk2nm8bk__patch, /):
    for k_, _k in _bk2nm8bk__patch.items():
        if k_ in bk2f_bks:
            if 0:
                #bug:when (_k in bk2f_bks)
                #   65737->穴
                bk2f_bks[_k] = bk2f_bks.pop(k_)
            else:
                #dict_add__eq(bk2f_bks, _k, bk2f_bks.pop(k_))
                #   大都存在
                bk2f_bks.setdefault(_k, bk2f_bks.pop(k_))
    for _, (f,bks) in bk2f_bks.items():
        for i,bk in enumerate([*bks]):
            if bk in _bk2nm8bk__patch:
                bks[i] = _bk2nm8bk__patch[bk]

手动原样通过囗区首字囗字集 = '衎褭㸤㮟㢽㻎末'



部件替换表囗全局囗源 = r'''
䬻:34451154-111534;a,37004,㦮,
37004=飠

𥦌:44534-1121132;d,65737,弄,#䆢:44534-1215134;d,65737,抉,
65737=穴

䎯:111234-12212511134;a,37009,37060,
37009=耒

瑩:4334433445-11214;d,37027,玉,
37027=𤇾

𪂂:12251112-32511154444;a,97020,鳥,
97020=龺

檿:13251125111344-1234;stl,37069,木,
37069=厭

鷂:3443311252-32511154444;a,37021,鳥,
37021=䍃

黉:44345-12212512134;d,37044,黄,
37044=[头囗觉]

㶂:441441-12212512134;a,97147,黄,
97147=[横组氵氵]

棃:31234353-1234;d,37063,木,
37063=[头囗黎]

墼:1251112523554-121;d,𣪠,土,
𣪠=[头囗擊]

驘:4152513511_354-1211254444;st,𣎆,馬,
𣎆=[上包围囗赢]

賾:1225125-11212511134;a,𦣞,責,
𦣞=[左囗颐]

韰:2135454-211121111;d,𣦼,韭,
𣦼=[头囗餐]

剆:451154-22;a,37105,刂,
37105=[左囗郎]

壼:12145-12155121;d,37151,亞,
37151=[纵组士冖]

棨:45133134-1234;d,𢼄,木,
𢼄=[横组户攵]

梟:3251115-1234;str,37157,木,
37157=[断足鳥]

坚:2254-121;d,37144,土,
37144=[头囗坚]

璺:321125125151145-11214;d,37147,玉,#37147=[纵组囗头囗興冖]
37147=[头囗璺]

亭:4125145-12;d,37106,丁,#反正『高』竖-非『丶』
37106=[纵三组亠口冖]




䒿:12245-2511;d,37165,月,
37165=[纵组艹冖]

桨:412354-1234;d,37194,木,
37194=[头囗桨]

㯻:1251245-13533341234;d,47005,豕,木,#:1251245_34-135333412;d,47005,豕,木,
47005=[头囗囊]

𠛬:113112-22;a,99697,刂,
99697=幵

介:_32-34;d,人,10001,#:34-32;d,人,10001,
10001=[底囗介]

'''#'''
r'''
手动直接修改文件
    %s/:a(匕/:a([左用匕]
        # ))
    %s/:d(99846,⺆/:d(37147
        # ))
    %s/:d(⺆,/:d([头用⺆],
        # ))
        共48行
    %s/:d(\([^)]*\),⺆\([,)]\)/:d(\1,[冖自纵组⺆]\2
        # )
        共271行
因为『⺆:a/t(㇑,㇆)』:
    %s/(\([^)]*\),⺆\([,)]\)/(\1,[无钩冂自偏旁⺆]\2
        # )
        共43行
    %s/(⺆\([,)]\)/([无钩冂自部首⺆]\1
        # )
        共162行


'''#'''
def 部件替换表囗全局囗():
    ls2 = 部件替换表囗全局囗源.split()
    ls_ = ls2[0::2]
    _ls = ls2[1::2]
    assert len(ls2)==len(ls_)*2, (ls2, len(ls2))
    assert len(ls2)==len(_ls)*2

    bk2nm8bk = {}
    #nm8bk2js = {}
    nm8bk2js = 囗笔顺码补丁囗预备囗()
    for s_, _s in zip(ls_, _ls):
        i = s_.index(':')
        j = s_.index('-')
        js4bk = s_[i+1:j]
        js4bk = js4bk.replace('-', '')
        js4bk = js4bk.replace('_', '')
        assert js4bk.isdigit()
        int(js4bk)

        bk, nm8bk = _s.split('=')
        check_nm8bk(nm8bk)
        assert bk
        assert (bk[0] <= '9') or len(bk) == 1
        if not (bk[0] <= '9'):
            hz = bk
            assert len(hz) == 1
            bk = hz
        else:
            uint8bk = int(bk)
            bk = uint8bk
        bk # hz or uint8bk
        check_bk(bk)
        dict_add__eq(bk2nm8bk, bk, nm8bk)
        dict_add__eq(nm8bk2js, nm8bk, js4bk)
    nm8bk2js__patch_3 = nm8bk2js
    bk2nm8bk__patch_3 = bk2nm8bk
    return bk2nm8bk, nm8bk2js__patch_3

笔顺码补丁囗源 = r'''
爰:3443-11354;d,⺤,38336,
⺤.笔顺码=3443
脁:3541-341534;a,⺼,兆,
⺼.笔顺码=3541
単:443-251112;d,⺍,37277,
⺍.笔顺码=443
𨘀:_454-1121132511134;sbl,⻎,頊,
⻎.笔顺码=454
考:1213-15;stl,⺹,丂,
⺹.笔顺码=1213
丮:5-112;str,㇠,37024,
㇠.笔顺码=5
'''#'''
#笔顺码补丁:
def 囗笔顺码补丁囗预备囗():
    ls2 = 笔顺码补丁囗源.split()
    ls = ls2[1::2]
    assert len(ls2)==len(ls)*2
    hz2js__patch = nm8bk2js__patch_3_1 = dict(s.split('.笔顺码=') for s in ls)
    assert all(sz==1 for sz in map(len, hz2js__patch))
        #单字
    return nm8bk2js__patch_3_1

#部件替换表
部件替换表囗全局囗数据, 笔顺码补丁囗全局囗数据 = 部件替换表囗全局囗()


部件笔顺码更正表囗单个囗源 = r'''
䧐:2541251521->5241251521
㺸:323541121->3235411214
䇐:4143151124143->4143151124134
𣫺:415541441542511->315541441542511
䃶:132514125221241343543->132514125221241343534
匘:35555325341->15555325341
䒟:1223514->1223541
羐:122121354->2121121354
䣡:341121312153452->431121312153452
[头囗囊]:null->1251245
麉:11211241352211535->11311241352211535
䶬:1121124143125111515111->1131124143125111515111
𢏗:313112515->113112515
⺆:null->35
[无钩冂自部首⺆]:null->25
[无钩冂自偏旁⺆]:null->25
[冖自纵组⺆]:null->45
[头用⺆]:null->35
㣺:4424->4442
'''#'''
r'''
#[头囗囊]:125124534->1251245
'''#'''

部件拆分更正表囗单个囗源 = r'''
𦱳:d,艹,62697->d,䒑,62697
䤋:a,酉,或->a,酋,或
𥦬:d,65737,八->d,65737,62017
⺳:d,冖,八->d,冖,儿
䵑:a,黍,刀->a,黍,刃
㞊:a,祟,尤->a,祟,尢
𦻒:d,莫,王->d,莫,玉
㫄:d,二,92492->d,亠,92492
迶:a,辶,有->sbl,辶,有
㺚:a,犭,幸->a,犭,達
䱶:a,魚,朗->a,魚,郎
兦:a,㇗,入->sbl,㇗,入
㠀:d,馬,山->d,鳥,山
比:ra,匕->a,[左用匕],匕
㡈:a,巾,奂->a,巾,免
䅋:a,禾,奂->a,禾,免
䛄:a,言,夘->a,言,夗
㼝:d,夘,瓦->d,夗,瓦
蘷:d,卝,夒->d,艹,夒
嗇:d,坐,回->d,[出头巫],回
廵:a,廴,巛->sbl,廴,巛
廸:a,廴,由->sbl,廴,由
廹:a,廴,白->sbl,廴,白
廼:a,廴,西->sbl,廴,西
廽:a,廴,囬->sbl,廴,囬
槩:d,旣,木->d,既,木
羊:d/t,37145,丷->d/t,丷,37145

𠚼:a,分,刂->c_null
疒:a,亠,广->c_null
扌:w,㇚,二->c_null

尸:w,㇑,99721->c_null
卩:w,㇑,㇆->c_null
阝:w,㇑,㇌->c_null
屮:w,㇑,凵->c_null
䇖:d,⺮,𠚤->d,⺮,99972

⺆:a/t,㇑,㇆->c_null
囗:d/t,[无钩冂自部首⺆],㇐->c_null
曱:d/m,[无钩冂自部首⺆],干->c_null
甲:d/o,[无钩冂自部首⺆],37024->c_null
见:d/o,[无钩冂自部首⺆],儿->d//st,[无钩冂],[见之儿]
贝:d/o,[无钩冂自部首⺆],人->d//st,[无钩冂],人
⺼:st,[无钩冂自部首⺆],亠->st,[无钩冂自部首⺆],冫
冏:a,[无钩冂自部首⺆],㕣->st,[无钩冂],㕣

冎:d/t,38465,[无钩冂自偏旁⺆]->d/t,38465,冂
𦉪:w,[无钩冂自部首⺆],儿->st,[无钩冂],儿
𠔿:st,[无钩冂自部首⺆],人->st,[无钩冂],人
47005:d/t,65522,[无钩冂自偏旁⺆]->d/t,65522,冖
𦉫:st,[无钩冂自部首⺆],10001->st,[无钩冂],10001
㣺:wt,㇑,99754->c_null
忄:wt,㇑,八->c_null
'''#'''
部件拆分更正表囗单个囗源
r'''
#[头囗囊] ~~ 47005:d/t,65522,⺆->d/t,65522,冖

⺆:a/t,㇑,㇆->c_null
囗:d/t,⺆,㇐->c_null
曱:d/m,⺆,干->c_null
甲:d/o,⺆,37024->c_null
见:d/o,⺆,儿->d//st,[无钩冂],[见之儿]
贝:d/o,⺆,人->d//st,[无钩冂],人
⺼:st,⺆,亠->st,⺆,冫
冏:a,⺆,㕣->st,[无钩冂],㕣
    ⺆->[无钩冂自部首⺆]

冎:d/t,38465,⺆->d/t,38465,冂
𦉪:w,⺆,儿->st,[无钩冂],儿
𠔿:st,⺆,人->st,[无钩冂],人
47005:d/t,65522,⺆->d/t,65522,冖
𦉫:st,⺆,10001->st,[无钩冂],10001


冎:d/t,38465,[无钩冂自偏旁⺆]->d/t,38465,冂
𦉪:w,[无钩冂自部首⺆],儿->st,[无钩冂],儿
𠔿:st,[无钩冂自部首⺆],人->st,[无钩冂],人
47005:d/t,65522,[无钩冂自偏旁⺆]->d/t,65522,冖
𦉫:st,[无钩冂自部首⺆],10001->st,[无钩冂],10001
    没必要改？

𦉫:st,[无钩冂],10001->st,[无钩冂],[双竖]
𦉫:st,[无钩冂],[底囗介]->st,[无钩冂],[双竖]
𦉫:st,⺆,10001->st,[无钩冂],[双竖]

'''#'''
r'''
太麻烦，直接改 数据文件，原版 另存为:.*-原版.txt
    view ../../python3_src/nn_ns/CJK/CJK_struct/cjk_decomp_0_4_0/cjk-decomp-0.4.0-原版.txt
    view ../../python3_src/nn_ns/CJK/CJK_data/raw/汉字笔顺表\[20200913]/stroke-seq_MB-master\[汉字笔顺表]\[20200827]/单字_笔顺码_29685个-原版.txt

e others/app/gvim/sort_lines.txt
:%s/\([^:]*\):\([^(]*\)(\([^,)]*\)/\2,\3!\0
用:35112;st,⺆,37024,
=====
25515:囘
35112:用

=====
2511:冃
25121:田
251251:同
2521:円
2522:𦉫
25251:冋
2534:冈
2534:𠔿
253434:网
25431:𦉰
25431252:岡
25431415:罔
25515:囘
冃同円冋冈网𦉰岡罔囘
𦉫𠔿
35112:用
3541:⺼
('st', '=', '⺆')
'''#'''
def bk5str(s, /):
    assert s
    if s[0].isdigit():
        assert s.isdigit()
        bk = int(s)
    else:
        bk = s
    check_bk(bk)
    return bk
def f_bks5str(s, /):
    [f, *bks] = s.split(',')
    bks = [*map(bk5str, bks)]
    return f, bks
def 囗部件笔顺码更正表囗单个囗预备囗():
    ls = 部件笔顺码更正表囗单个囗源.split()
    bk2old_new_js = {}
    bk__old_new_js__pairs = []
    for s in ls:
        s_,_s = s.split(':')
        bk = bk5str(s_)
        may_old_js,new_js = _s.split('->')
        if may_old_js == 'null':
            may_old_js = None
        assert may_old_js is None or may_old_js.isdigit()
        assert new_js.isdigit()
        dict_add__eq(bk2old_new_js, bk, (may_old_js, new_js))
        bk__old_new_js__pairs.append((bk, (may_old_js, new_js)))
    return bk__old_new_js__pairs #bk2old_new_js
部件笔顺码更正表囗单个囗数据 = 囗部件笔顺码更正表囗单个囗预备囗()

def 囗部件拆分更正表囗单个囗预备囗():
    ls = 部件拆分更正表囗单个囗源.split()
    bk2old_new_f_bks = {}
    bk__old_new_f_bks__pairs = []
    for s in ls:
        s_,_s = s.split(':')
        bk = bk5str(s_)
        old,new = _s.split('->')
        old_f_bks = f_bks5str(old)
        may_new_f_bks = f_bks5str(new)
            #may_new_f_bks = None if new=='c_null' else f_bks5str(new)
            # 不再删除，c_null 相当于 特殊的 c.*()
        dict_add__eq(bk2old_new_f_bks, bk, (old_f_bks, may_new_f_bks))
        bk__old_new_f_bks__pairs.append((bk, (old_f_bks, may_new_f_bks)))
    return bk__old_new_f_bks__pairs #bk2old_new_f_bks
部件拆分更正表囗单个囗数据 = 囗部件拆分更正表囗单个囗预备囗()
def 部件拆分更正囗(bug_hz_set, bk2f_bks, /):
    #bk2old_new_f_bks = 部件拆分更正表囗单个囗数据
    #for (bk, (old_f_bks, new_f_bks)) in bk2old_new_f_bks.items():
    bk__old_new_f_bks__pairs = 部件拆分更正表囗单个囗数据
    for (bk, (old_f_bks, may_new_f_bks)) in bk__old_new_f_bks__pairs:
        assert bk2f_bks[bk] in (old_f_bks, may_new_f_bks), (bk, bk2f_bks[bk], old_f_bks, may_new_f_bks)
        if may_new_f_bks is None:
            del bk2f_bks[bk]
        else:
            bk2f_bks[bk] = may_new_f_bks
            bug_hz_set.discard(bk)
def 部件笔顺码更正囗(bug_hz_set, bk2js, /):
    bk__old_new_js__pairs = 部件笔顺码更正表囗单个囗数据
    for (bk, (may_old_js, new_js)) in bk__old_new_js__pairs:
        assert bk2js.get(bk) in (may_old_js, new_js)
        bk2js[bk] = new_js
        bug_hz_set.discard(bk)




def load_with_patch():
    [hz2js#汉字到笔顺码
    ,bk2f_bks#部件到字型零件
    ] = load()
    if 1:
    #if 启用囗局部部件替换:
        hz2js = dict(hz2js)
            #<<==登记笔顺码
    bk2js = hz2js
    del hz2js
    部件拆分更正囗(bug_hz_set, bk2f_bks)
    部件笔顺码更正囗(bug_hz_set, bk2js)
    全局部件替换囗(bk2js, bk2f_bks)
    return bk2js, bk2f_bks


def main1(opath, /, *
    ,force=False
    ,笔顺码相同的部首再聚类=False
    ,启用囗局部部件替换=False
    ######################
    ,启用共同双缀当作部首笔顺码的最小区规模=5
    ,双缀延长正错比例=4
    ,双缀延长错字上限=5
    ):
    kws = dict(locals())
    del kws['opath']
    del kws['force']
    [hz2js#汉字到笔顺码
    ,bk2f_bks#部件到字型零件
    ] = load_with_patch()
    if 0:
        [hz2js#汉字到笔顺码
        ,bk2f_bks#部件到字型零件
        ] = load()
        if 1:
        #if 启用囗局部部件替换:
            hz2js = dict(hz2js)
                #<<==登记笔顺码
        全局部件替换囗(hz2js, bk2f_bks)

    #[[[
    #]]]
    #[[[
    #以hz2js为准，因为它比较少字
    #   糅合配对(hz2js/汉字到笔顺码,bk2f_bks/部件到字型零件)


    ls = []
        #[(f, bks, js, hz)]
        #   f :: smay str 字型布局
        #   bks :: 可空[(hz|uint)] 部件零件
        #   js :: str 笔顺码
        #   hz :: char 汉字
    used_bug_hz_set = {*[]}
    ls4bug = []
    for hz, js in hz2js.items():
        m = bk2f_bks.get(hz)
        if m is None:
            m = ('', [])
        f,bks = m
        x = (f, bks, js, hz)
        if hz in bug_hz_set:
            used_bug_hz_set.add(hz)
            ls4bug.append(x)
        else:
            ls.append(x)
    assert used_bug_hz_set == bug_hz_set, set_symmetric_partition__immutable(used_bug_hz_set, bug_hz_set)
    del bk2f_bks


    #]]]
    #[[[
    #确认没有意外字符
    #   确认格式化用字符未出现
    #
    fs = set()
    xs = ':;,'
    for _ls in [ls, ls4bug]:
        for (f, bks, js, hz) in ls:
            fs.add(f)
    for f in fs:
        assert not any(x in f for x in xs), repr(f)
    del fs, xs

    #]]]
    #[[[
    # 排序:部首一致的字聚集
    #   将部首一致的字聚合成区groupby
    # 再排序:大区靠前
    #
    #bk :: int | hz # cannot sort
    def key1(x, /):
        (f, bks, js, hz) = x
        ss = [*map(str, bks)]
        return (f, ss[:1], js, ss, hz)
        return (f, ss, js, hz)
    ls.sort(key=key1)
    ls4bug.sort(key=key1)
    it = iter(ls); del ls

    if 0:
        ts = []
        tss = [ts]
        (f_, bks_, js_, hz_) = '', [], '', '\0'
        for (f, bks, js, hz) in it:
            if not (f_, bks_[:1]) == (f, bks[:1]):
                ts = []
                tss.append(ts)
            ts.append((f, bks, js, hz))

            (f_, bks_, js_, hz_) = (f, bks, js, hz)
    else:
        def 区名囗(x, /):
            (f, bks, js, hz) = x
            return f, bks[:1]
        tss = [[*it] for _, it in groupby(it, 区名囗)]
    pass
    #tss.sort(key=len, reverse=True)

    区首字到区 = {}
    for ts in tss:
        (f, bks, js, qhz) = ts[0]
        #   qhz :: 区首字 char 汉字
        区首字到区[qhz] = ts


    if 1:
        nm8bk2js__patch_3 = 笔顺码补丁囗全局囗数据
        nm8bk2js__patch_2 = 整区多拆囗原首字到部首倒装笔顺码.nm8bk2js__patch_2
    if 启用囗局部部件替换:
        nm8bk2js__patch_1 = 局部部件替换囗(hz2js, tss, 区首字到区)
            #vs nm8bk2js__patch_2
        囗打补丁囗(hz2js, nm8bk2js__patch_1)

    tss.sort(key=len, reverse=True)
    tss, 区首字到区, ls4bug
    #]]]
    #[[[
    # +跳过小区:共同双缀~=~部首笔顺码，但:小区无用
    #+跳过qhzs4skip_ts#手动收集的信息
    #+跳过无零件拆出
    #
    #skip用于:共同双缀当作部首笔顺码
    #_skip用于:尽最大努力自动化验证成字真子部件笔顺码
    #
    def skip(ts, /):
        sz = len(ts)
        return _skip(sz, ts[0])
    def _skip(sz, t0, /):
        return bool(_skip_ex(sz, t0))
    def _skip_ex(sz, t0, /):
        #   qhz :: 区首字 char 汉字
        (f, bks, js, qhz) = t0
        if not bks:
            return 3#True
        if qhz in 整区不拆囗原首字囗字集:#qhzs4skip_ts
            skip.used_qhzs.add(qhz)
            return 2#True
        return sz < max(2, 启用共同双缀当作部首笔顺码的最小区规模)
        return sz < max(5, 启用共同双缀当作部首笔顺码的最小区规模)
    skip.used_qhzs = set()
    #]]]
    #[[[
    #共同双缀当作部首笔顺码
    #   格式: xyz --> xyz|x-yz|_z-xy|x_z-y
    #区内排序，盖因:(_z-xy|x_z-y)缺少z在后面，导致次序改变
    #
    n4skip = 0
    bad_tss = []
    整区多拆囗已使用囗字集 = set()
    否决双缀延长囗已使用囗字集 = set()
    for ts in tss:
        (f, bks, js, qhz) = ts[0]
        #   qhz :: 区首字 char 汉字
        sz = len(ts)
        if skip(ts):
            g = echo
            a_b_ = ''
            n4skip += 1
        elif qhz in 整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_:
          if 1:
            整区多拆囗已使用囗字集.add(qhz)
          def _(yn,/):
            assert not yn
            (qhz2yn_js_, qhz2f_bks__patch, nm8bk2js__patch_2, bk2nm8bk__patch_2) = 整区多拆囗原首字到部首倒装笔顺码._alls
            qhz2f_bks__patch
            yn,js_ = qhz2yn_js_[qhz]
            assert not yn
            (f, bks) = qhz2f_bks__patch[qhz]
            ts[:] = [(f,[*bks,f'!#{f_}',*bks_],js,hz) for f_,bks_,js,hz in ts]
            return ts[0]
          if 1:
            yn,a_b_ = 整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_[qhz]
            #see:全局部件替换囗 prepare for [yn==True]
            if not yn:
                (f, bks, _js, _qhz) = _(yn)
                    #刷新qhz信息
                assert js==_js
                assert qhz==_qhz
            assert a_b_#否则:整区不拆囗原首字囗字集
            assert a_b_[-1] == '-'
            a_b = a_b_[:-1]
            assert a_b
            assert not a_b[-1] == '_'
            if '_' in a_b:
                lcp, lcs = a_b.split('_')
            else:
                lcp = a_b
                lcs = ''
            a = len(lcp)
            b = len(lcs)

            def g(js,/):
                assert a+b < len(js)
                assert js.startswith(lcp)
                assert js.endswith(lcs)
                mid = js[a:len(js)-b]
                assert mid
                js_ = a_b_+mid
                return js_


        else:
            #共同双缀=共同前缀+共同后缀
            #街:行圭
            #栽:𢦏木
            #裹:衣果
            #近:辶斤
            jss = [js for (f, bks, js, hz) in ts]
            lcp = lcp_of__lsls(999, jss)
            lcs = lcs_of__lsls(999, jss)
            a = len(lcp)
            b = len(lcs)
            if b:
                a_b_ = f'{lcp}_{lcs}-'
            else:
                a_b_ = f'{lcp}-'
            assert a or b, (a,b,(lcp,lcs),js, ts[:5])
                #bug:𦱳:431-55455452;d,艹,62697,
                #   错:不是草字头
            def h(i,/):
                try:
                    d = Counter(js[i] for js in jss)
                except IndexError:
                    print('笔画数最小者 当为 len(lcp) or len(lcs)', ts[:20])
                        #今:3445;d,亽,㇇,
                        #令:34454;d,亽,龴,
                        #... 人 vs 亽 vs 亽㇇
                    raise
                items = d.most_common()
                assert sz == d.total()
                单笔顺码囗最多,n0 = items[0]
                assert  n0 < sz
                num_diff = sz-n0
                #原:if num_diff < sz//5 and num_diff <= 2:
                #当前:if not (num_diff <= sz//4 and num_diff <= 5):
                if not (num_diff <= sz//双缀延长正错比例 and num_diff <= 双缀延长错字上限):
                    return
                bad_ts = [(f, bks, js, hz) for (f, bks, js, hz) in ts if not js[i]==单笔顺码囗最多]
                assert len(bad_ts) == num_diff > 0
                used_qhzs = [hz for (f, bks, js, hz) in bad_ts if hz in 否决囗囗双缀还可能延长囗字集]
                否决双缀延长囗已使用囗字集.update(used_qhzs)
                bad_ts = [(f, bks, js, hz) for (f, bks, js, hz) in bad_ts if not hz in used_qhzs]
                if not bad_ts:
                    return
                #rint(bad_ts)
                bad_tss.append((ts[0], bad_ts))
            if a:
                h(a)
            if b:
                h(-1-b)

            def g(js,/):
                assert a+b < len(js), (a,b,(lcp,lcs),js, ts[:5])
                mid = js[a:len(js)-b]
                assert mid
                js_ = a_b_+mid
                return js_
        ts[:] = [(g(js), f, bks, js, hz) for (f, bks, js, hz) in ts]
        #js_ = g(js)
        if '_' in a_b_:
            ts.sort(key=fst)
            #之前:
            #咸:131251534;st,戊,𠮛,
            #戌:131534;st,戊,㇐,
            #之后:
            #戌:13_534-1;st,戊,㇐,
            #咸:13_534-1251;st,戊,𠮛,
    tss, 区首字到区, ls4bug
    wss = tss; del tss, ts
    n4skip
    n4not_skip = len(wss) - n4skip
    if not (n4skip and n4not_skip):
        print('共同双缀当作部首笔顺码:异常:', n4skip, n4not_skip)
    if bad_tss:
        print('共同双缀当作部首笔顺码:双缀还可能延长:数量:', len(bad_tss))

    assert {*整区多拆囗原首字到部首倒装笔顺码.整区多拆囗例外字集囗并未多拆囗用作重拆} & 整区多拆囗已使用囗字集 == {*[]}
    assert {*整区多拆囗原首字到部首倒装笔顺码.整区多拆囗例外字集囗并未多拆囗用作重拆} | 整区多拆囗已使用囗字集 == 整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_.keys(), set_symmetric_partition__immutable({*整区多拆囗原首字到部首倒装笔顺码.整区多拆囗例外字集囗并未多拆囗用作重拆} | 整区多拆囗已使用囗字集, 整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_.keys())
    assert 否决双缀延长囗已使用囗字集 == {*否决囗囗双缀还可能延长囗字集}, set_symmetric_partition__immutable(否决双缀延长囗已使用囗字集, {*否决囗囗双缀还可能延长囗字集})
    assert skip.used_qhzs == {*整区不拆囗原首字囗字集}


    ws4bug = [(echo(js), f, bks, js, hz) for (f, bks, js, hz) in ls4bug]
    del ls4bug
    wss, 区首字到区, ws4bug
    #]]]
    #[[[
    #起先用于:『kw:笔顺码相同的部首再聚类』
    #也用于:验证成字真子部件笔顺码
    def key2(ws, /):
        (js_, f, bks, js, qhz) = ws[0]
        i = js_.find('-')
        s0 = s = js_[:i+1] # <<== [i==-1]
        s = s.replace('_', '')
        s = s.replace('-', '')
        return (-len(s), s, s0)
            # s :: smay 部首笔顺码
            # s0 :: smay 部首笔顺码 含'_-'
    #]]]
    #[[[
    #尽最大努力自动化验证成字真子部件笔顺码
    #   打上标签:移出集中延后处理bug、已确认ok、出错bad、无能为力yet、手动原样通过pass、手动固化/整区多拆fix
    #       出错:=部首变形导致笔顺码改变or双缀初拆有误or笔顺码有误or部件拆分有误

    qhz2case = {} #{区首字:case}
    n4skip = 0
    n4skip_f = 0
    n4f = 0
    n4f0 = 0
    n4bk = 0
    n4s = 0
    n4no_hz8bk = 0
    n4checked = 0
    bads = []
    known_bads = []
        #已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集

    if 1:
        ws = ws4bug
        (js_, f, bks, js, qhz) = ws[0]
        qhz2case[qhz] = 'bug'
        n4bug = 1
    for ws in wss:
        (js_, f, bks, js, qhz) = ws[0]
        #   qhz :: 区首字 char 汉字
        qhz2case[qhz] = 'yet'
        if 1 and _skip(len(ws), ws[0][1:]):
            #bug:if skip([ws[0][1:]]):
            n4skip += 1
            if not f:
                n4f += 1
            else:
                n4skip_f += 1
            continue
        if 0 and qhz in 整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_:
            yn,_ = 整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_[qhz]
            if not yn:
                #手动固化/整区多拆
                qhz2case[qhz] = 'fix'
                n4checked += 1
                continue
            else:
                #打补丁nm8bk2js__patch_1+自动检查ok-bad,而非fix
                pass
            pass
        if not f:
            n4f += 1
            continue
        if not f[0] in 'adsb':
            if qhz in 手动原样通过囗区首字囗字集:
                bk = bks[0]
                nm8bk = bk
                js4bk = hz2js.get(nm8bk)
                (_, s, _) = key2(ws)
                assert s == js4bk, ws[0]
                qhz2case[qhz] = 'pass'
                n4checked += 1
                continue
            n4f0 += 1
            continue
        bk = bks[0]
        if not type(bk) is str:
            n4bk += 1
            continue
        if 0 and not 启用囗局部部件替换:
            #0 <<== 全局部件替换囗
            [hz8bk] = bk
            nm8bk = hz8bk
        else:
            nm8bk = bk
                #可能不是char
        assert nm8bk == bk
        js4bk = hz2js.get(nm8bk)
        #js4bk是成字部件笔顺码
        if js4bk is None:
            n4no_hz8bk += 1
            continue
        (_, s, _) = key2(ws)
        if not s:
            #无拆分
            n4s += 1
            #上面:if not f[0] in 'adsb':
            #   ==>> 必拆分
            continue
        #s是真子自动拆出部件笔顺码
        n4checked += 1
        if not js4bk == s:
            #验证成字真子部件笔顺码
            sample = ws[:2]
            #rint(sample)
            if qhz in 已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集:
                known_bads.append((qhz, js4bk, s))
            else:
                bads.append(sample)
            qhz2case[qhz] = 'bad'
        else:
            qhz2case[qhz] = 'ok'
    assert len(wss) == n4skip_f + n4f + n4f0 + n4bk + n4no_hz8bk + n4s + n4checked
    assert len(wss)+n4bug == len(qhz2case)

    if not (n4f==1 and n4s==0 and n4checked):
        print('验证成字真子部件笔顺码:异常:', n4skip, n4f, n4f0, n4bk, n4no_hz8bk, n4s, n4checked)
    if bads:
        print('部首变形导致笔顺码改变or双缀初拆有误or笔顺码有误or部件拆分有误:数量:', len(bads))


    case2num_qhzs = {**Counter(qhz2case.values())}
    #rint('case total', case2num_qhzs)
    assert case2num_qhzs['pass'] == len(手动原样通过囗区首字囗字集)
    #assert case2num_qhzs['fix'] == len(整区多拆囗原首字到部首倒装笔顺码.qhz2yn_js_)
    assert 'fix' not in case2num_qhzs

    if 启用囗局部部件替换:
        #没有 局部部件替换囗()抛出KeyError ==>> 全用到
        assert not known_bads, known_bads
    else:
        assert {*known_bads} == {*已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集}
    #]]]
    #[[[
    #kw:+笔顺码相同的部首再聚类
    #   比如:部首区『土/工』归属于同一个 超区
    #   盖因:不一致:
    #       #飦:34451154-112;a,飠,干,
    #       #䬴:34451154-11234;a,食,末
    #       #䬻:34451154-111534;a,37004,㦮,

    wss, qhz2case, ws4bug

    if 笔顺码相同的部首再聚类:
        wss.sort(key=key2)
        wsss = [[*it_tss] for _, it_tss in groupby(wss, key=key2)]
        wsss.sort(key=lambda wss:sum(map(len, wss)), reverse=True)
    else:
        wsss = [wss]
    del wss
    wsss
    wsss.insert(0, [ws4bug])
    del ws4bug

    qhz2case__ls = partition_by_keyss__immutable(qhz2case, ((ws[0][-1] for ws in wss) for wss in wsss))

    wsss, qhz2case, qhz2case__ls

    #]]]
    #[[[
    #找出 倒装笔顺码囗相应部件 ['_' in js]->(op,fst_bk)
    wqkey2bifix_hzs = {}
    for wss in wsss:
        for ws in wss:
            (js_, f, bks, js, qhz) = ws[0]
            if '_' in js_:
                a_b = js_.split('-')
                smay_lcp, lcs = a_b.split('_')
                assert bks, ws[:3]
                assert len(ws)>=2, ws[:3]
                hz1 = ws[1][-1]
                fst_bk = bks[0]
                wqkey = (f, fst_bk)
                bifix = smay_lcp, lcs
                wqkey2bifix_hzs[wqkey] = (bifix, [qhz, hz1])
    wqkey2bifix_hzs
    #]]]
    #[[[
    #输出
    #   格式:
    #   #   超区| #######
    #   #       | #{超区的规模囗高}#{超区的规模囗低}#
    #   #   区  | {case}#####
    #   #       | #{区的规模}
    #   #       | {汉字}:{初拆倒装笔顺码};{字型布局},
    #   #       | {汉字}:{初拆倒装笔顺码};{字型布局},{零件},
    #   #       | {汉字}:{初拆倒装笔顺码};{字型布局},{零件},{零件},
    #   #       | {汉字}:{初拆倒装笔顺码};{字型布局},{零件},{零件},...,
    #
    def _mk3(qhz2case, /):
        case2qhzs = inv__k2v_to_v2ks(qhz2case)
            #{case:{区首字}}
        case2num_qhzs = fmap4dict_value(len, case2qhzs)
            #{case:区数量}
        cases = sorted(case2qhzs)
        return (case2qhzs, case2num_qhzs, cases)
    def _mk2s(qhz2case, /):
        (case2qhzs, case2num_qhzs, cases) = _mk3(qhz2case)
        s = '#'.join(f'{c}{case2num_qhzs[c]}' for c in cases)
        return cases, s

    wsss, qhz2case, qhz2case__ls
    _2s = _mk2s(qhz2case)
    _2s__ls = [*map(_mk2s, qhz2case__ls)]
    assert len(wsss) == len(qhz2case__ls)
    assert len(wsss) == len(_2s__ls)
    cases, _ = _2s
    wsss, qhz2case, cases, _2s, _2s__ls


    hhhhh = '#'*5
    hh = '#'*2
    hhhhhhh = '#'*7
    omode = 'wt' if force else 'xt'
    with open(opath, omode, encoding='u8') as fout:
        fprint = mk_fprint(fout)
        ########################
        fprint(f'#{__name__}:参数:', stable_repr(kws))
        ########################
        fprint('#', ' '.join(cases))
        ########################
        fprint(hhhhhhh)
        fprint(f'#延后处理囗字集:', 排序字集囗(bug_hz_set))
        ########################
        if 已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集:
            fprint(hhhhhhh)
            fprint('#已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集:', 排序字集囗(已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集))
            if not 启用囗局部部件替换:
                err_qhzs = {*已知囗成字真子部件笔顺码囗有毛病囗区首字囗字集}^{*known_bads}
                if err_qhzs:
                    fprint('已知:异常:', err_qhzs)
        ########################
        if 启用囗局部部件替换:
            fprint(hhhhhhh)
            fprint(f'#局部部件替换囗笔顺码补丁:', stable_repr(nm8bk2js__patch_1))
            fprint(f'#局部部件替换囗区首字囗字集:', 排序字集囗(map(fst, 部件替换囗整区囗数据)))
            #see:局部部件替换囗+启用囗局部部件替换
        ########################
        fprint(hhhhhhh)
        (_qhz2yn_js_, _qhz2f_bks__patch, nm8bk2js__patch_2, bk2nm8bk__patch_2) = 整区多拆囗原首字到部首倒装笔顺码._alls
        fprint(f'#整区多拆囗全局囗笔顺码补丁:', stable_repr(nm8bk2js__patch_2))
        fprint(f'#整区多拆囗全局囗部件替换表:', stable_repr(bk2nm8bk__patch_2))
        fprint(f'#整区多拆囗区首字囗字集:', 排序字集囗(_qhz2yn_js_))
            #see:全局部件替换囗 prepare for [yn==True]
        ########################
        fprint(hhhhhhh)
        fprint(f'#整区不拆囗原首字囗字集:', 排序字集囗(整区不拆囗原首字囗字集))
        ########################
        fprint(hhhhhhh)
        fprint('#手动原样通过囗区首字囗字集:', 排序字集囗(手动原样通过囗区首字囗字集))
        ########################
        fprint(hhhhhhh)
        assert nm8bk2js__patch_3 is 笔顺码补丁囗全局囗数据
        fprint(f'#笔顺码补丁:', stable_repr(nm8bk2js__patch_3))
        fprint(f'#部件替换表:', stable_repr(部件替换表囗全局囗数据))
        ########################
        if bad_tss:
            fprint(hhhhhhh)
            fprint('xxx共同双缀当作部首笔顺码:双缀还可能延长:数量:', len(bad_tss))
            for bad_ts in bad_tss:
                fprint(f'x-{bad_ts!r}')
        ########################
        if bads:
            fprint(hhhhhhh)
            fprint('xxx部首变形导致笔顺码改变or双缀初拆有误or笔顺码有误or部件拆分有误:数量:', len(bads))
            for bad in bads:
                fprint(f'x-{bad!r}')
        ########################
        fprint(hhhhhhh)
        fprint(f'#倒装笔顺码囗相应部件:{len(wqkey2bifix_hzs)}:', stable_repr(wqkey2bifix_hzs))
        ######################
        ######################
        ######################
        ######################
        wsss, qhz2case, _2s, _2s__ls
        def show2(_2s, /):
            _, s = _2s
            fprint(f'#{s}#')
        num__wss = len(wsss)
        num__ws = sum(map(len, wsss))
        num__w = sum(sum(map(len, wss)) for wss in wsss)
        fprint(hhhhhhh)
        fprint(f'#{num__wss}#{num__ws}#{num__w}#')
        show2(_2s)
        ######################
        ######################
        #fprint(hhhhh)
        assert len(wsss) == len(_2s__ls)
        for wss, _2s_ in zip(wsss, _2s__ls):
            fprint(hhhhhhh)
            num__ws = len(wss)
            num__w = sum(map(len, wss))
            fprint(f'#{num__ws}#{num__w}#')
            show2(_2s_)
            #fprint(hh, end='')
            for ws in wss:
                (js_, f, bks, js, qhz) = ws[0]
                fprint(qhz2case[qhz], end='')
                fprint(hhhhh)
                sz = num__w = len(ws)
                fprint(f'#{num__w}#')
                for (js_, f, bks, js, hz) in ws:
                    args = ','.join(map(str, bks))
                    t = ',' if args else ''
                    s = f'{hz}:{js_};{f},{args}{t}'
                    fprint(s)
            #fprint(hhhhh)
        fprint(hhhhhhh)
    #]]]
#end-def main1(opath, /, *...)

def 排序字集囗(hzs, /):
    hzs = set(hzs)
    hzs = sorted(hzs)
    return ''.join(hzs)

#def check_bk(bk, /):
#def lt__bk(lhs_bk, rhs_bk, /):
def key4bk4sort(bk, /):
    return (type(bk) is int, bk)
def sorted__bk(bks, /):
    return sorted(bks, key=key4bk4sort)
def 排序部件囗(bks, /):
    bks = set(bks)
    bks = sorted__bk(bks)
    return ','.join(map(str, bks))
def _op2priority_case(op, /, *
    ,f1_ls = 'adswbrmc'
    ,op_ls = 'lock,built'.split(',')
    ):
    f1 = op[0]
    for i, op_ in enumerate(op_ls, len(f1_ls)):
        if op.startswith(op_):
            #op_priority_case = (i, op_)
            op_case = op_
            op_priority = i
            break
    else:
            assert f1 in f1_ls, (f1, f1_ls)
            i = f1_ls.index(f1)
            #op_priority_case = (i, f1)
            op_case = f1
            op_priority = i
    op_priority_case = (op_priority, op_case)
    return op_priority_case
#def key4qkey4sort(qkey, /):
#def key4xqkey4sort(xqkey, /):
def key4yqkey4sort(yqkey, /):
    #推导优先a,d,s,...
    #xst = fst | lst = first | last
    #xqkey = (op, op_tag/{+-=}, may_xst_dst_bk)
    #xqkey = hqkey | tqkey
    #   h-head,t-tail,q-区
    #yqkey = hqkey | tqkey
    #   xqkey vs yqkey
    #   xqkey 强调静多态，容器内部只含hqkey或只含tqkey
    #       容器<xqkey> === (容器<hqkey>|容器<tqkey>)
    #   yqkey 强调动多态，容器内部hqkey,tqkey混杂
    #       容器<yqkey> === 容器<(hqkey|tqkey)>
    #
    (op, op_tag, may_xst_dst_bk) = yqkey
    op_priority_case = _op2priority_case(op)
    tmay_xst_dst_bk = nmay2tmay(may_xst_dst_bk)
    tmay_key4xst_dst_bk = [*map(key4bk4sort, tmay_xst_dst_bk)]
    return (op_priority_case, op, op_tag, tmay_key4xst_dst_bk)
r'''
#def sorted__xqkey(xqkeys, /):
#def sorted__yqkey(yqkeys, /):
    #return sorted(yqkeys, key=key4yqkey4sort)
def sorted__yqkey_via_qsz(yqkey2bk2f_bks__overlap, /):
    return sorted(yqkey2bk2f_bks__overlap, key=lambda yqkey:(-len(yqkey2bk2f_bks__overlap[yqkey]), key4yqkey4sort(yqkey)))
'''#'''
def hqkey5f_bks(f_bks, /):
    # a,d 考虑 首部件作部首
    hqkey = xqkey5f_bks_(False, f_bks)
    return hqkey
def tqkey5f_bks__ad_using_last_bk(f_bks, /):
    # a,d 考虑 尾部件作部首
    tqkey = xqkey5f_bks_(True, f_bks)
    return tqkey
tqkey5f_bks = tqkey5f_bks__ad_using_last_bk
def xqkey5f_bks_(using_last_bk, f_bks, /):
    f1_ls = 'ad'
    xqkey = xqkey5f_bks__selected_using_last_bk(f_bks, using_last_bk, f1_ls)
    return xqkey
def xqkey5f_bks__selected_using_last_bk(f_bks, using_last_bk, f1_ls, /):
    op, dst_bks = f_bks
    f1 = op[0]
    if using_last_bk and f1 in f1_ls:
        tmay_lst_dst_bk = dst_bks[-1:]
        tmay_xst_dst_bk = tmay_lst_dst_bk
    else:
        tmay_fst_dst_bk = dst_bks[:1]
        tmay_xst_dst_bk = tmay_fst_dst_bk
    tmay_xst_dst_bk
    if not f1 in f1_ls:
        op_tag = '='
    else:
        assert tmay_xst_dst_bk
        op_tag = '-' if using_last_bk else '+'
    op_tag
    if tmay_xst_dst_bk:
        [xst_dst_bk] = tmay_xst_dst_bk
        assert xst_dst_bk is not None
        assert xst_dst_bk
        may_xst_dst_bk = xst_dst_bk
    else:
        [] = tmay_xst_dst_bk
        may_xst_dst_bk = None
    assert nmay2tmay(may_xst_dst_bk) == tuple(tmay_xst_dst_bk)
    xqkey = (op, op_tag, may_xst_dst_bk)
    return xqkey

#def mk_key4bk4sort_via_qkey(bk2f_bks, /):
#def mk_key4bk4sort_via_xqkey(using_last_bk, bk2f_bks, /):
#def mk_key4bk4sort_via_yqkey(bk2ht, bk2f_bks, /):
def _mk_key4bk4sort_via_yqkey(bk2yqkey, yqkey2bk2f_bks__overlap, /):
    #def key4bk4sort_via_xqkey(bk, /):
    def key4bk4sort_via_yqkey(bk, /):
        #using_last_bk = bk2ht[bk]
        #f_bks = op, dst_bks = bk2f_bks[bk]
        #yqkey = xqkey5f_bks_(using_last_bk, f_bks)
        yqkey = bk2yqkey[bk]
        k0 = -len(yqkey2bk2f_bks__overlap[yqkey])
        k1 = key4yqkey4sort(yqkey)
        k2 = key4bk4sort(bk)
        return k0, k1, k2
    return key4bk4sort_via_yqkey
#def mk_key4bk4sort_via_yqkey(bk2yqkey, yqkey2bk2f_bks__overlap, /):
def mk_key4bk4sort_via_yqkey_ex(bk2yqkey, yqkey2bk2f_bks__overlap, /):
    def mk_k0_k1_(yqkey, /):
        k0 = -len(yqkey2bk2f_bks__overlap[yqkey])
        k1 = key4yqkey4sort(yqkey)
        return k0, k1
    yqkey2k0k1 = {yqkey:mk_k0_k1_(yqkey) for yqkey in yqkey2bk2f_bks__overlap}
    bk2k0k1k2 = {bk:(*yqkey2k0k1[yqkey], key4bk4sort(bk)) for bk, yqkey in bk2yqkey.items()}
    yqkeys__sorted_via_qsz_yqkey = sorted(yqkey2k0k1, key=yqkey2k0k1.get)
    bks__sorted_via_qsz_yqkey = sorted(bk2k0k1k2, key=bk2k0k1k2.get)
    yqkey2sorted_idx = {yqkey:i for i, yqkey in enumerate(yqkeys__sorted_via_qsz_yqkey)}
    bk2sorted_idx = {yqkey:i for i, yqkey in enumerate(bks__sorted_via_qsz_yqkey)}
    def key4bk4sort_via_yqkey(bk, /):
        return bk2sorted_idx[bk]
    return (key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (yqkeys__sorted_via_qsz_yqkey, bks__sorted_via_qsz_yqkey), (yqkey2k0k1, bk2k0k1k2))
#def sorted__bk_via_qkey_(bk2f_bks, bks, /):
#def sorted__bk_via_qkey__(using_last_bk, bk2f_bks, bks, /):
#def sorted__bk_via_qsz_yqkey__(bk2yqkey, yqkey2bk2f_bks__overlap, bks, /):
def sorted__bk_via_qsz_yqkey_ex__(bk2yqkey, yqkey2bk2f_bks__overlap, bks, /):
    _ex = mk_key4bk4sort_via_yqkey_ex(bk2yqkey, yqkey2bk2f_bks__overlap)
    key4bk4sort_via_yqkey = _ex[0]
    bks__sorted_via_qsz_yqkey = sorted(bks, key=key4bk4sort_via_yqkey)
    return bks__sorted_via_qsz_yqkey, _ex

def str_info5bk_(bk2f_bks, bk, /):
    op, dst_bks = bk2f_bks[bk]
    return str_info5bk__(op, dst_bks, bk)
def str_info5bk__(op, dst_bks, bk, /):
    fmt = '{bk}:{op},{dst_bks}'
    fmt = '{bk}:{f_bks__str}'
    f_bks__str = ','.join(map(str, [op, *dst_bks]))
    return fmt.format(**locals())
def show_infos4bks(fprint, bk2f_bks, bks, /):
    for bk in bks:
        line = str_info5bk_(bk2f_bks, bk)
        fprint(line)
def show_jss4bks(fprint, bk2js, bks, /):
    for bk in bks:
        js = bk2js[bk]
        print(f'{bk}:{js}')
#TODO:推导出:数字部件.笔顺码
def 推导囗汉字部件囗笔顺码囗(opath, /, *, force=False):
    r'''

    hz = 汉字 :: char
    js = 笔顺码
    bk = 部件 =:
        | uint  #部件数字代号
        | hz    #汉字字符
        | 部件人工名 :: str # '[nm]'
    check_bk(bk)

    q = 区
    qbk = 区首部件 #qhz = 区首字
    op = 字型布局 #字型结构连词
    '''#'''

    [bk2js#部件到笔顺码
    ,bk2f_bks#部件到字型零件
    ] = load_with_patch()
    # src->dst === parent->child
    src_bk2dst_bks = fmap4dict_value(snd, bk2f_bks)
    dst_bk2src_bks = inv__k2vs_to_v2ks(src_bk2dst_bks)
    old_known_js_bks = {*bk2js}

    def is_bk_known_js(bk, /):
        return bk in bk2js
    def dst_bks2num_unknown_js_dst_bks_(dst_bks, /):
        return sum(not is_bk_known_js(bk) for bk in dst_bks)
        return sum(not is_bk_known_js(bk) for bk in set(dst_bks))
    src_bk2num_unknown_js_dst_bks = fmap4dict_value(dst_bks2num_unknown_js_dst_bks_, src_bk2dst_bks)

    inputs4_add_bk_js__ex = []
    def _add_bk_js__ex(ex_info4_add_bk_js, dst_bk, js, _updated_src_bks, /):
        js4src_bk, err_msg = ex_info4_add_bk_js
        (src_bk, op, dst_bks, i, dst_bk) = err_msg
        bk__may_js__pairs = [*bks2pairs_with_may_js_(bk2js, dst_bks)]
        inputs4_add_bk_js__ex.append(((src_bk, dst_bk, js), ((src_bk, js4src_bk), i, bk__may_js__pairs)))
        ###
        _add_bk_js(src_bk, dst_bk, js, _updated_src_bks)
    def _add_bk_js(src_bk, dst_bk, js, _updated_src_bks, /):
        print('_add_bk_js', (src_bk, dst_bk, js))
        _add_bk_js_(dst_bk, js, _updated_src_bks)

    def _add_bk_js_(bk, js, _updated_src_bks, /):
        check_bk(bk)
        assert js
        m = bk2js.get(bk)
        if m:
            assert js == bk2js[bk], (bk, js)
            raise logic-err
        else:
            assert not is_bk_known_js(bk), bk
            dict_add__is(bk2js, bk, js)
            _on_add_new_bk_js(bk, js, _updated_src_bks)
    def _on_add_new_bk_js(bk, js, _updated_src_bks, /):
        #update:src_bk2num_unknown_js_dst_bks
        assert is_bk_known_js(bk)
        dst_bk = bk
        src_bks = dst_bk2src_bks[dst_bk]
        for src_bk in src_bks:
            #bug:src_bk2num_unknown_js_dst_bks[src_bk] -= 1
            n = src_bk2dst_bks[src_bk].count(dst_bk)
            assert n >= 1 # ==>> update
            src_bk2num_unknown_js_dst_bks[src_bk] -= n
            num_unknown_js_dst_bks = src_bk2num_unknown_js_dst_bks[src_bk]
            assert num_unknown_js_dst_bks >= 0
        #is_ok4try_deduce()==>>:
        _update__updated_src_bks(_updated_src_bks, src_bks)
            #(1 == src_bk2num_unknown_js_dst_bks[src_bk])
        _update__updated_src_bks(_updated_src_bks, [dst_bk])
            #(src_bk in bk2js) # dst_bk 用作src_bk
            # bug_fixed <<== [not_any__is_ok4try_deduce]
    #end-def _on_add_new_bk_js(bk, js, _updated_src_bks, /):

    #heapq
    def _update__updated_src_bks(_updated_src_bks, src_bks, /):
        #_updated_src_bks |= src_bks
        #_updated_src_bks += sorted__bk(src_bks)
        for src_bk in src_bks:
            _push__updated_src_bks(_updated_src_bks, src_bk)
    def _push__updated_src_bks(_updated_src_bks, src_bk, /):
        k = key4bk4sort_via_yqkey(src_bk)
        heappush(_updated_src_bks, (k, src_bk))
    def _pop__updated_src_bks(_updated_src_bks, /):
        (_k, src_bk) = heappop(_updated_src_bks)
        return src_bk
    def _mk_new__updated_src_bks():
        _updated_src_bks = []
        return _updated_src_bks
    def try_deduce_from_src_bk(src_bk, /):
        #_updated_src_bks = set()
        #_updated_src_bks = {src_bk}
        #_updated_src_bks = [src_bk]
        _updated_src_bks = _mk_new__updated_src_bks()
        _update__updated_src_bks(_updated_src_bks, [src_bk])
        while _updated_src_bks:
            #src_bk = _updated_src_bks.pop()
            src_bk = _pop__updated_src_bks(_updated_src_bks)
            _try_deduce_from_src_bk(src_bk, _updated_src_bks)
        return
    #_ok_op_prefix_ls = 'a d s w ba bd'.split()
    def is_ok4try_deduce__op(op, /):
        #adswbrmc,lock,built
        f1 = op[0]
        return (f1 in 'adsw' or (f1=='b' and op[1] in 'ad')) and not op == 'd/o'

    def is_ok4try_deduce(src_bk, /):
        return ((src_bk in bk2js) and (1 == src_bk2num_unknown_js_dst_bks[src_bk]) and (src_bk not in _try_deduce_from_src_bk.err_src_bks) and is_ok4try_deduce__op(fst(bk2f_bks[src_bk])))

    def _head4try_deduce(src_bk, /):
        assert is_ok4try_deduce(src_bk)
        js4src_bk = bk2js[src_bk]
        op, dst_bks = bk2f_bks[src_bk]
            #dst_bks = src_bk2dst_bks[src_bk]
        tfs = [*map(is_bk_known_js, dst_bks)]
        assert tfs.count(False) == 1, ((src_bk, op, dst_bks), tfs)
        i = tfs.index(False)
        dst_bk = dst_bks[i]
        err_msg = (src_bk, op, dst_bks, i, dst_bk)
        return js4src_bk, err_msg
    def _try_deduce_from_src_bk(src_bk, _updated_src_bks, /):
        if 0:
            TODO-启用囗加法推导
        #DONE:a,d 考虑 尾部件作部首:using yqkey instead xqkey 两者之间选择较大区
        #DONE:推导优先a,d,s,...: .using heapq as _updated_src_bks op_priority_case
        #   sorted__yqkey_via_qsz.key4yqkey4sort._op2priority_case
        if not is_ok4try_deduce(src_bk): return
        js4src_bk, err_msg = ex_info4_add_bk_js = _head4try_deduce(src_bk)
        (_src_bk, op, dst_bks, i, dst_bk) = err_msg
            #唯一部件 未知 笔顺码
        f1 = op[0]
        assert f1 in 'adsw' or (f1=='b' and op[1] in 'ad')
        assert is_bk_known_js(src_bk)
        done = False
        if f1 in 'ads':
            #see:囗检验囗笔顺码囗
            try:
                js_ = check_and_mk_prefix_js(src_bk, js4src_bk, dst_bks[:i])
                _js = check_and_mk_suffix_js(src_bk, js4src_bk, dst_bks[i+1:])
                assert js4src_bk.startswith(js_), err_msg
                assert js4src_bk.endswith(_js), err_msg
                assert len(js4src_bk) > len(js_) + len(_js), err_msg
                _js_ = js4src_bk[len(js_):len(js4src_bk) - len(_js)]
                assert js4src_bk == js_ + _js_ + _js, err_msg
                done = True
            except AssertionError:
                assert not done
                if f1 in 'ad':
                    if src_bk not in _try_deduce_from_src_bk.err_src_bks:
                        _try_deduce_from_src_bk.err_src_bks.add(src_bk)
                        #print(err_msg)
                        #fprint(mk_err_msg_ex4try_deduce(src_bk))
                    return
                else:
                    assert f1 == 's'
                    assert not done
                    r'''
                    if op=='st':
                        lcs = ???
                        if not lcs:
                            raise
                    '''#'''
                    if type(src_bk) is str and src_bk in '用𦉫㣺':
                        raise
            else:
                assert done
                _add_bk_js__ex(ex_info4_add_bk_js, dst_bk, _js_, _updated_src_bks)
                return
            assert not done
            assert f1 == 's'
        #end-if f1 in 'ads':
        assert not done
        assert f1 not in 'ad'
        assert f1 in 'sw' or (f1=='b' and op[1] in 'ad')
        assert len(dst_bks) == 2
        部首, 偏旁 = dst_bks
        #see:倒装笔顺码囗相应部件
        yqkey = bk2yqkey[src_bk]
        yqkeys__without_bifix_info
        yqkey_set__without_bifix_info
            #区中 已知 笔顺码 数量 == 1
        if yqkey in yqkey_set__without_bifix_info:
            return
        assert yqkey in yqkey2js_4arg, (src_bk, yqkey)
            #('匕', ('sbl', '=', '㇟'))
            #   匕:sbl(㇟,㇒)
            #   yqkey区 只有『匕』有 笔顺码 ==>> 没有 js_4arg
        js_4arg = yqkey2js_4arg[yqkey]
        bifix_info = yqkey2bifix_info[yqkey]
        (sz_lcp, sz_lcs, lcp, lcs, lcp_lcs_) = bifix_info
        #assert lcs, (src_bk, yqkey, js_4arg, bifix_info)
        assert lcs, (src_bk, yqkey, js_4arg, bifix_info, dst_bks)
            #必然有:倒装:共同后缀
            #
            #('用', ('st', '=', '⺆'), '35_', (2, 0, '35', '', '35-'))
            #   用:st(⺆,37024)
            #('𦉫', ('st', '=', '[无钩冂]'), '25_', (2, 0, '25', '', '25-'))
            #('㣺', ('wt', '=', '㇑'), '442_', (3, 0, '442', '', '442-'))
            #   㣺:wt(㇑,99754)
            #   忄:wt(㇑,八)
            #   99743:ra(㇏)
            #   99754:a(㇒,99743)
        if i==0:
            #部首-笔顺码-待求
            js1 = bk2js[偏旁]
            if not js4src_bk == lcp+js1+lcs:
                return
            js0 = lcp+lcs
            _js_ = js0
        elif i==1:
            #偏旁-笔顺码-待求
            js0 = bk2js[部首]
            if not js0 == lcp+lcs:
                return
            js1 = js4src_bk[sz_lcp:len(js4src_bk)-sz_lcs]
            assert js4src_bk == lcp+js1+lcs
            _js_ = js1
        else:
            raise 000
        _add_bk_js__ex(ex_info4_add_bk_js, dst_bk, _js_, _updated_src_bks)
        return
    _try_deduce_from_src_bk.err_src_bks = set()
    #end-def _try_deduce_from_src_bk(src_bk, _updated_src_bks, /):
    #end-def try_deduce_from_src_bk(src_bk, /):
    def mk_err_msg_ex4try_deduce(src_bk, /):
        js4src_bk, err_msg = _head4try_deduce(src_bk)
        (_src_bk, op, dst_bks, i, dst_bk) = err_msg
        may_js__ls = [*map(bk2js.get, dst_bks)]
        err_msg_ex = (src_bk, op, dst_bks, i, dst_bk, may_js__ls, js4src_bk)
        return err_msg_ex
    def check_and_mk_prefix_js(src_bk, js4src_bk, dst_bks_, /):
        i = 0
        for dst_bk_ in dst_bks_:
            js_ = bk2js[dst_bk_]
            j = i+len(js_)
            assert js_ == js4src_bk[i:j], (src_bk, js_, js4src_bk[i:j], (i,j), js4src_bk)
                #('用', '25', '35', (0, 2), '35112')
                #   『⺆』本无 笔顺码，可见之前 推导出错
                #   提前 设定为 35
            i = j
        return js4src_bk[:i]
    def check_and_mk_suffix_js(src_bk, js4src_bk, _dst_bks, /):
        j = len(js4src_bk)
        for _dst_bk in _dst_bks:
            _js = bk2js[_dst_bk]
            i = j-len(_js)
            assert i >= 0
            assert _js == js4src_bk[i:j], (src_bk, _js, js4src_bk[i:j], (i,j), js4src_bk)
                #('𦉫', '32', '22', (2, 4), '2522')
                #   𦉫:st([无钩冂],10001)
                #       <<== _add_bk_js ('丌', 10001, '32')
            j = i
        return js4src_bk[j:]
    def 囗遍历尝试囗触发式推导囗():
        src_bks = sorted__bk(src_bk2num_unknown_js_dst_bks)
        for src_bk in src_bks:
            try_deduce_from_src_bk(src_bk)
        _src_bk2num_unknown_js_dst_bks = fmap4dict_value(dst_bks2num_unknown_js_dst_bks_, src_bk2dst_bks)
        assert src_bk2num_unknown_js_dst_bks == _src_bk2num_unknown_js_dst_bks
        assert not any(map(is_ok4try_deduce, src_bk2dst_bks)), 排序部件囗(filter(is_ok4try_deduce, src_bk2dst_bks))
            # ⻭,𠗆,𡝤,𦰌,10931,26393,26683,37401,37413,37499,37576,37625,37662,37692,37748,37765,37835,37976,37978,38001,38034,38212,40843
                #==>> _on_add_new_bk_js().{bug_fixed <<== [not_any__is_ok4try_deduce]}
        new_known_js_bks = {*bk2js}
        new_known_js_bks -= old_known_js_bks
        patch4bk2js__deduced = subset_keys__immutable(bk2js, new_known_js_bks)
        return patch4bk2js__deduced
    #end-def 囗遍历尝试囗触发式推导囗():
    def find_known_js_bifix_idc_ex(src_bk, /):
        op, dst_bks = bk2f_bks[src_bk]
        #tfs = [*map(is_bk_known_js, dst_bks)]
        #s = ''.join(str(int(tf)) for tf in tfs)
        may_js__ls = [*map(bk2js.get, dst_bks)]
        s = ''.join(str(int(may_js is not None)) for may_js in may_js__ls)
        if not '0' in s:
            i = 0
            j = len(s)
        else:
            i = s.index('0')
            j = 1+s.rindex('0')
        dst_bks_ = dst_bks[:i]
        _dst_bks = dst_bks[j:]
        js__ls_ = may_js__ls[:i]
        _js__ls = may_js__ls[j:]
        assert all(js__ls_)
        assert all(_js__ls)
        js4src_bk = bk2js[src_bk]
        known_js_bifix_idc_ex = ((i, j), (op, dst_bks), (s, may_js__ls), (src_bk, js4src_bk), (dst_bks_, _dst_bks), (js__ls_, _js__ls))
        return known_js_bifix_idc_ex
    def is_ok4known_js_bifix_idc_ex(known_js_bifix_idc_ex, /, *
        ,f1_ls = 'c,m,w,s,a,d,r'.split(',')
        ,op_ls = 'ba,ba/o,bd,bd/m,bd/t,lock,built'.split(',')
        ,op_ls2 = 'ba,ba/o,bd,bd/m,bd/t,sbl,str'.split(',')
        ):
        #see:_show_op_count
        #see:_op2priority_case
        op_priority_case = _op2priority_case(op)
        (op_priority, op_case) = op_priority_case
        if op_case not in 'ad':
            return False
        ((i, j), (op, dst_bks), (s, may_js__ls), (src_bk, js4src_bk), (dst_bks_, _dst_bks), (js__ls_, _js__ls)) = known_js_bifix_idc_ex
        f1 = op[0]
        assert op in op_ls or f1 in f1_ls
        spec = None
        if op in op_ls2:
            spec = True
        elif op in op_ls:
            return False
        elif f1 in 'cmr':
            return False
        elif f1 == 'w':
            spec = True
        elif f1 == 's':
            return False
        elif f1 in 'ad':
            spec = False
        else:
            assert f1 in f1_ls
            assert 0, f1
        assert spec is not None
        if spec:
            ...
        return _is_bifix_jss(js4src_bk, js__ls_, _js__ls)
    def _is_bifix_jss(js4src_bk, js__ls_, _js__ls, /):
        js_ = ''.join(js__ls_)
        _js = ''.join(_js__ls)
        return len(js4src_bk) >= len(js_) + len(_js) and js4src_bk.startswith(js_) and js4src_bk.endswith(_js)
    def 囗检验囗笔顺码囗():
        bad_src_bk_exs = []
        unknown_js_src_bks = []
        for src_bk in src_bks__sorted_via_qsz_yqkey:
            #if not src_bk in bk2js:
            if not is_bk_known_js(src_bk):
                unknown_js_src_bks.append(src_bk)
                continue
            known_js_bifix_idc_ex = find_known_js_bifix_idc_ex(src_bk)
            if not is_ok4known_js_bifix_idc_ex(known_js_bifix_idc_ex):
                bad_src_bk_exs.append((src_bk, known_js_bifix_idc_ex))
        unknown_decomp_bk2js = subtract_keys__immutable(bk2js, bk2f_bks)
        return (bad_src_bk_exs, unknown_js_src_bks, unknown_decomp_bk2js)

    def _show_unknown_js_src_bks(fprint, unknown_js_src_bks, bk2f_bks, dst_bk2src_bks, /):
        'bk:op,dst_bks,:src_bks, #每无笔顺码部件一行:拆分+所在大部件'
        fmt = '{bk}:{f_bks__str},:{src_bks__str},'
        fprint(f'# {fmt}')
        for bk in unknown_js_src_bks:
            src_bks = dst_bk2src_bks.get(bk, [])
            src_bks__str = ','.join(map(str, src_bks))
            f_bks = op, dst_bks = bk2f_bks[bk]
            f_bks__str = ','.join(map(str, [op, *dst_bks]))
            fprint(fmt.format(**locals()))
    #end-def _show_unknown_js_src_bks(fprint, unknown_js_src_bks, bk2f_bks, dst_bk2src_bks, /):
    def _show_qinfo(fprint, bk2f_bks, /):
        'qbk:op:op_tag:may_xst_dst_bk:bk_ls#每区一行:所有部件拆分'
        fmt = '{qbk}:{op}:{op_tag}:{may_xst_dst_bk}:{bk_ls__prtn__str},'
        fprint(f'# {fmt}')
        if 0:
            (hqkey2bk2f_bks, tqkey2bk2f_bks
            ,bk2ht, bk2yqkey
            ,yqkey_set, yqkey2bk2f_bks__overlap
            ,src_bks__sorted_via_qsz_yqkey
            ,(key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (yqkey2k0k1, bk2k0k1k2))
            ,yqkeys__sorted_via_qsz_yqkey
            ,yqkey2sorted_bks__overlap
            ,yqkey2sorted_bks__partition
            ,yqkey2qbk, qbk2yqkey
            ) = mk_qgroup_(bk2f_bks)
        yqkey_ls = yqkeys__sorted_via_qsz_yqkey
        yqkey2bk_ls__prtn = yqkey2sorted_bks__partition
            #yqkey2bk_ls__overlap = yqkey2sorted_bks__overlap
        fprint(f'{len(yqkey_ls)} qkeys <<== {len(bk2f_bks)} bks')
        for yqkey in yqkey_ls:
            qbk = yqkey2qbk[yqkey]
            (op, op_tag, may_xst_dst_bk) = yqkey
            bk_ls__prtn = yqkey2bk_ls__prtn[yqkey]
            bk_ls__prtn__str = ','.join(map(str, bk_ls__prtn))
            fprint(fmt.format(**locals()))
    #end-def _show_qinfo(fprint, bk2f_bks, /):

    def _show_op_count(fprint, /):
        #用于:is_ok4known_js_bifix_idc_ex()
        op_set = {*map(fst, bk2f_bks.values())}
        fprint(len(op_set))
        fprint(stable_repr(op_set))
        op2total = {**Counter(map(fst, bk2f_bks.values()))}
        fprint(stable_repr(op2total))
    if 0:
        #提前 自 下面:
        _show_op_count(print)
        raise 0

    mk_qgroup_
    (hqkey2bk2f_bks, tqkey2bk2f_bks
    ,bk2ht, bk2yqkey
    ,yqkey_set, yqkey2bk2f_bks__overlap
    ,src_bks__sorted_via_qsz_yqkey
    ,(key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (yqkey2k0k1, bk2k0k1k2))
    ,yqkeys__sorted_via_qsz_yqkey
    ,yqkey2sorted_bks__overlap
    ,yqkey2sorted_bks__partition
    ,yqkey2qbk, qbk2yqkey
    ) = mk_qgroup_(bk2f_bks)

    (yqkeys__without_bifix_info
    ,yqkey2bifix_info
    ,yqkeys__without_js_4arg
    ,yqkey2js_4arg
    ,yqkey__bad_pairs__xx__triples4on_err
    ) = find_longest_bifix(yqkeys__sorted_via_qsz_yqkey, yqkey2sorted_bks__overlap, bk2js)
    yqkey_set__without_bifix_info = {*yqkeys__without_bifix_info}
    print('len(yqkeys__without_bifix_info)', len(yqkeys__without_bifix_info))
    def _show____yqkey__bad_pairs__xx__triples4on_err():
        for yqkey, bad_pairs, _xx in yqkey__bad_pairs__xx__triples4on_err:
            print('=====')
            print(yqkey)
            if bad_pairs:
              if 1:
                assert not _xx
              for ((xjs_,bk_), (xjs,bk)) in bad_pairs:
                print('-----')
                print(f'{xjs_}:{bk_}')
                print(f'{xjs}:{bk}')
                show_infos4bks(print, bk2f_bks, [bk_,bk])
                show_jss4bks(print, bk2js, [bk_,bk])
            else:
                assert _xx
                xjs_bk_pairs = _xx
                for xjs, bk in xjs_bk_pairs:
                    print(f'{xjs}:{bk}')
                bks = [*map(snd, xjs_bk_pairs)]
                show_infos4bks(print, bk2f_bks, bks)
                show_jss4bks(print, bk2js, bks)
    if yqkey__bad_pairs__xx__triples4on_err:
        _show____yqkey__bad_pairs__xx__triples4on_err()
        raise 000
    if 1:
        #于推导前提前检验
        (bad_src_bk_exs, unknown_js_src_bks, unknown_decomp_bk2js) = 囗检验囗笔顺码囗()
        if bad_src_bk_exs:
            print(bad_src_bk_exs)
            return

    patch4bk2js__deduced = 囗遍历尝试囗触发式推导囗()
        #_try_deduce_from_src_bk not-using fprint
    inputs4_add_bk_js__ex
    print('inputs4_add_bk_js__ex', inputs4_add_bk_js__ex)
    _try_deduce_from_src_bk.err_src_bks
        #过气无用 <<== is_ok4try_deduce 状态改变
        #改用:bad_src_bk_exs:
    (bad_src_bk_exs, unknown_js_src_bks, unknown_decomp_bk2js) = 囗检验囗笔顺码囗()

    hhhhhhh = '#'*7
    hhhhhhhhhhhhhh = '#'*14
    omode = 'wt' if force else 'xt'
    with open(opath, omode, encoding='u8') as fout:
        fprint = mk_fprint(fout)
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, '所有op')
        _show_op_count(fprint)
            #108
            #{'a', 'a/m', 'a/s', 'a/t', 'ba', 'ba/o', 'bd', 'bd/m', 'bd/t', 'built', 'c', 'cbl/o', 'ctl/t', 'ctlbr/t', 'd', 'd/m', 'd/o', 'd/s', 'd/t', 'lock', 'mb', 'mc', 'me', 'ml', 'mo', 'mo0', 'mo2', 'mo4', 'mo5', 'mr', 'msp', 'mt', 'mtl', 'r/a', 'r3a', 'r3d', 'r3d/m', 'r3gw', 'r3st', 'r3stl', 'r3str', 'r3tr', 'r4a', 'r4d', 'r4dia', 'r4ref/t', 'r4sq', 'r5p', 'r5x', 'ra', 'ra/m', 'rd', 'rd/m', 'rd/s', 'rd/t', 'refh', 'refr', 'refv', 'rot', 'rrefd', 'rrefl', 'rrefl/m', 'rrefr', 'rrefr/m', 'rrefr/o', 'rrefr/t', 'rrotd', 'rrotr', 'rrotu', 'rs', 'rsb', 'rsbr', 'rsq', 'rst', 'rstl', 's', 's/t', 'sb', 'sbl', 'sbl/m', 'sbl/o', 'sbr', 'sl', 'sl/m', 'sl/s', 'sr', 'st', 'st/t', 'stl', 'stl/m', 'stl/s', 'str', 'str/o', 'w', 'w/o', 'w/t', 'wa', 'wb', 'wbl', 'wbr', 'wd', 'wl', 'wl/t', 'wr', 'wt', 'wt/t', 'wtl', 'wtr'}
            #{'a': 50263, 'a/m': 56, 'a/s': 3, 'a/t': 18, 'ba': 3, 'ba/o': 1, 'bd': 1, 'bd/m': 1, 'bd/t': 3, 'built': 31, 'c': 35, 'cbl/o': 1, 'ctl/t': 1, 'ctlbr/t': 1, 'd': 22661, 'd/m': 332, 'd/o': 31, 'd/s': 67, 'd/t': 392, 'lock': 223, 'mb': 2, 'mc': 1, 'me': 116, 'ml': 10, 'mo': 11, 'mo0': 1, 'mo2': 1, 'mo4': 1, 'mo5': 2, 'mr': 1, 'msp': 105, 'mt': 14, 'mtl': 4, 'r/a': 1, 'r3a': 45, 'r3d': 10, 'r3d/m': 2, 'r3gw': 11, 'r3st': 1, 'r3stl': 1, 'r3str': 1, 'r3tr': 143, 'r4a': 3, 'r4d': 1, 'r4dia': 3, 'r4ref/t': 1, 'r4sq': 51, 'r5p': 1, 'r5x': 3, 'ra': 394, 'ra/m': 5, 'rd': 155, 'rd/m': 15, 'rd/s': 2, 'rd/t': 1, 'refh': 26, 'refr': 1, 'refv': 4, 'rot': 2, 'rrefd': 1, 'rrefl': 27, 'rrefl/m': 2, 'rrefr': 17, 'rrefr/m': 2, 'rrefr/o': 1, 'rrefr/t': 2, 'rrotd': 1, 'rrotr': 1, 'rrotu': 3, 'rs': 1, 'rsb': 1, 'rsbr': 1, 'rsq': 1, 'rst': 2, 'rstl': 3, 's': 313, 's/t': 4, 'sb': 126, 'sbl': 2851, 'sbl/m': 1, 'sbl/o': 4, 'sbr': 35, 'sl': 217, 'sl/m': 2, 'sl/s': 6, 'sr': 3, 'st': 941, 'st/t': 1, 'stl': 3269, 'stl/m': 1, 'stl/s': 2, 'str': 572, 'str/o': 1, 'w': 1107, 'w/o': 2, 'w/t': 2, 'wa': 3, 'wb': 88, 'wbl': 11, 'wbr': 25, 'wd': 3, 'wl': 15, 'wl/t': 1, 'wr': 17, 'wt': 191, 'wt/t': 1, 'wtl': 41, 'wtr': 33}
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, '部分op<<==bad_src_bk_exs')
        op_set5bad = {fst(bk2f_bks[bk]) for bk,_ in bad_src_bk_exs}
        fprint(len(op_set5bad))
        fprint(stable_repr(op_set5bad))
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, '部分op<<==_try_deduce_from_src_bk.err_src_bks')
        op_set5err = {fst(bk2f_bks[bk]) for bk in _try_deduce_from_src_bk.err_src_bks}
        fprint(len(op_set5err))
        fprint(stable_repr(op_set5err))
            # {'a', 'a/m', 'a/t', 'built', 'd', 'd/m', 'd/o', 'd/t', 'lock', 's', 'sb', 'sbl', 'sl', 'sl/m', 'sl/s', 'st', 'stl', 'str', 'w', 'wbl', 'wbr', 'wl', 'wr', 'wt', 'wtl', 'wtr'}
        if 0 and len(_try_deduce_from_src_bk.err_src_bks):
            fprint(len(_try_deduce_from_src_bk.err_src_bks))
            print(len(_try_deduce_from_src_bk.err_src_bks))
        ########################
        (bad_src_bk_exs, unknown_js_src_bks, unknown_decomp_bk2js)
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, 'bad_src_bk_exs')
        fprint(len(bad_src_bk_exs))
        for bad_src_bk_ex in bad_src_bk_exs:
            fprint(bad_src_bk_ex)
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, 'unknown_js_src_bks#笔顺码-尚缺 #bk:op,dst_bks,:src_bks, #每无笔顺码部件一行:拆分+所在大部件')
        fprint(len(unknown_js_src_bks))
        _show_unknown_js_src_bks(fprint, unknown_js_src_bks, bk2f_bks, dst_bk2src_bks)
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, 'unknown_decomp_bk2js')
        fprint(len(unknown_decomp_bk2js))
        def _():
            #src_bks__sorted_via_qsz_yqkey
            def flip(kv, /):
                k,v = kv
                return v,k
            ps = sorted(unknown_decomp_bk2js.items(), key=flip)
            for bk,js in ps:
                fprint(bk, js)
        _()
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, 'patch4bk2js__deduced')
        fprint(len(patch4bk2js__deduced))
        def _():
            for bk in sorted__bk(patch4bk2js__deduced):
                fprint(bk, patch4bk2js__deduced[bk])
        _()
        ########################
        fprint(hhhhhhhhhhhhhh)
        fprint(hhhhhhh, '区信息 #qbk:op:op_tag:may_fst_dst_bk:bk_ls#每区一行:所有部件拆分')
        _show_qinfo(fprint, bk2f_bks)
        ########################
        fprint(hhhhhhhhhhhhhh)
    return#patch4bk2js__deduced
    #(lonly_dict, zipped_common_dict, ronly_dict) = mapping_zipped_symmetric_partition__immutable(bk2js, bk2f_bks)

#end-def 推导囗汉字部件囗笔顺码囗():
def mk_qgroup_(bk2f_bks, /):
    hqkey2bk2f_bks = group4dict_value(hqkey5f_bks, bk2f_bks)

    tqkey2bk2f_bks = group4dict_value(tqkey5f_bks, bk2f_bks)

    bk2ht = {bk:len(hqkey2bk2f_bks[hqkey5f_bks(f_bks)]) > len(tqkey2bk2f_bks[tqkey5f_bks(f_bks)]) for bk,f_bks in bk2f_bks.items()}
        # {bk:using_last_bk/bool}
        # False - h/head/fst
        # True - t/tail/lst

    bk2yqkey = {bk:(hqkey5f_bks if bk2ht[bk] is False else tqkey5f_bks)(f_bks) for bk,f_bks in bk2f_bks.items()}

    yqkey_set = {*bk2yqkey.values()}

    yqkey2bk2f_bks__overlap = {yqkey:(hqkey2bk2f_bks if yqkey in hqkey2bk2f_bks else tqkey2bk2f_bks)[yqkey] for yqkey in yqkey_set}
        #yqkey2bk2f_bks__overlap is not partition by bk

    hqkey2bk2f_bks, tqkey2bk2f_bks
    bk2ht, bk2yqkey
    yqkey_set, yqkey2bk2f_bks__overlap

    #src_bks__sorted_via_qsz_yqkey, _ex = sorted__bk_via_qsz_yqkey_ex__(bk2yqkey, yqkey2bk2f_bks__overlap, bk2f_bks)
    _ex = mk_key4bk4sort_via_yqkey_ex(bk2yqkey, yqkey2bk2f_bks__overlap)
    (key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (_yqkeys__sorted_via_qsz_yqkey, _bks__sorted_via_qsz_yqkey), (yqkey2k0k1, bk2k0k1k2)) = _ex
    #assert src_bks__sorted_via_qsz_yqkey == _bks__sorted_via_qsz_yqkey
    src_bks__sorted_via_qsz_yqkey = _bks__sorted_via_qsz_yqkey

    (key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (yqkey2k0k1, bk2k0k1k2))

    #yqkeys__sorted_via_qsz_yqkey = sorted__yqkey_via_qsz(yqkey2bk2f_bks__overlap)
    #assert yqkeys__sorted_via_qsz_yqkey == _yqkeys__sorted_via_qsz_yqkey
    yqkeys__sorted_via_qsz_yqkey = _yqkeys__sorted_via_qsz_yqkey

    yqkey2sorted_bks__overlap = fmap4dict_value(sorted__bk, yqkey2bk2f_bks__overlap)
    yqkey2sorted_bks__partition = {yqkey:[bk for bk in bks if bk2yqkey[bk]==yqkey] for yqkey, bks in yqkey2sorted_bks__overlap.items()}
    yqkey2qbk = fmap4dict_value(fst, yqkey2sorted_bks__partition)
    qbk2yqkey = inv__k2v_to_v2k(yqkey2qbk)

    src_bks__sorted_via_qsz_yqkey
    (key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (yqkey2k0k1, bk2k0k1k2))
    yqkeys__sorted_via_qsz_yqkey
    yqkey2sorted_bks__overlap
    yqkey2sorted_bks__partition
    yqkey2qbk, qbk2yqkey

    return (
    (hqkey2bk2f_bks, tqkey2bk2f_bks
    ,bk2ht, bk2yqkey
    ,yqkey_set, yqkey2bk2f_bks__overlap
    ,src_bks__sorted_via_qsz_yqkey
    ,(key4bk4sort_via_yqkey, (yqkey2sorted_idx, bk2sorted_idx), (yqkey2k0k1, bk2k0k1k2))
    ,yqkeys__sorted_via_qsz_yqkey
    ,yqkey2sorted_bks__overlap
    ,yqkey2sorted_bks__partition
    ,yqkey2qbk, qbk2yqkey
    ))
#end-def mk_qgroup_(bk2f_bks, /):

def _on_err4find_longest_bifix(yqkey, bks__overlap, bk_js_pairs, yqkeys__without_js_4arg, yqkey__bad_pairs__xx__triples4on_err, /):
    #see:find_longest_bifix().on_err
    yqkeys__without_js_4arg.append(yqkey)
    (op, op_tag, may_xst_dst_bk) = yqkey
    bad_pairs = []
    if op_tag == '-':
        def key_(js, /):
            return js[::-1]
    else:
        key_ = echo
    tmp = [(key_(js), bk) for bk,js in bk_js_pairs]
    xjs_bk_pairs = sorted(tmp, key=fst)
    for xjs, bk in xjs_bk_pairs:
        print(f'{xjs}:{bk}')
    xjs_, bk_ = xjs_bk_pairs[0]
    for xjs, bk in xjs_bk_pairs:
        sz_lcp = len_lcp_of__lsls([xjs_, xjs])
        #xjs已反转，lcp可能是lcs
        bad = False
        if sz_lcp:
            pass
        elif op_tag=='=':
            sz_lcs = len_lcs_of__lsls([xjs_, xjs])
            bad = not sz_lcs
        else:
            bad = True

        if bad:
            print('=====')
            print(f'{xjs_}:{bk_}')
            print(f'{xjs}:{bk}')
            print()
            bad_pairs.append(((xjs_,bk_), (xjs,bk)))
        xjs_, bk_ = xjs, bk
    print(yqkey)
    print('=====')
    if not bad_pairs:
        #相邻两个:双缀 总有一个 非空，但 整体双缀空:
        yqkey__bad_pairs__xx__triples4on_err.append((yqkey, [], xjs_bk_pairs))
    else:
        yqkey__bad_pairs__xx__triples4on_err.append((yqkey, bad_pairs, []))
    return yqkey
    #return (yqkey, bks__overlap)
    r'''
    =====
    1225545:䒛
    43155455452:𦱳

    ('d', '+', '艹')
    =====
    𦱳:431-55455452;d,艹,62697,
    𦱳:d,艹,62697->d,䒑,62697
    𦱳 兹 慈 孳
    首:431-325111;d,䒑,自,
    兼:431-5112234;d,䒑,37471,
    兹:431-554554;d,䒑,𢆶,
see:
    部件笔顺码更正表囗单个囗源
    部件拆分更正表囗单个囗源
    '''#'''
#end-def _on_err4find_longest_bifix(yqkey, bks__overlap, bk_js_pairs, /):
def bks2pairs_with_may_js_(bk2js, bks, /):
    '{bk:js} -> [bk] -> Iter (bk, may_js)'
    for bk in bks:
        may_js = bk2js.get(bk)
        assert may_js is None or may_js
        yield (bk, may_js)
def find_longest_bifix(yqkeys__sorted_via_qsz_yqkey, yqkey2sorted_bks__overlap, bk2js, /):
    #, yqkey2sorted_bks__partition
    _on_err = _on_err4find_longest_bifix
    on_err = lambda:_on_err(yqkey, bks__overlap, bk_js_pairs, yqkeys__without_js_4arg, yqkey__bad_pairs__xx__triples4on_err)
    yqkey__bad_pairs__xx__triples4on_err = []
    ########
    yqkeys__without_bifix_info = []
    yqkey2bifix_info = {}
    yqkeys__without_js_4arg = []
    yqkey2js_4arg = {}
    for yqkey in yqkeys__sorted_via_qsz_yqkey:
        bks__overlap = yqkey2sorted_bks__overlap[yqkey]
        bk_js_pairs = [(bk,may_js) for bk, may_js in bks2pairs_with_may_js_(bk2js, bks__overlap) if may_js is not None]
        jss = [*map(snd, bk_js_pairs)]
        assert all(jss)

        if not len(jss) >= 2:
            yqkeys__without_bifix_info.append(yqkey)
            continue

        bifix_info = (sz_lcp, sz_lcs, lcp, lcs, lcp_lcs_) = jss2bifix_info(jss)
        yqkey2bifix_info[yqkey] = bifix_info

        (op, op_tag, may_xst_dst_bk) = yqkey
        #see:xqkey5f_bks_.xqkey5f_bks__selected_using_last_bk.using_last_bk
        if 0 and not (lcp or lcs):
                yqkeys__without_js_4arg.append(yqkey)
                continue

        elif op_tag == '+':
            #assert lcp, on_err()
            if not lcp:
                on_err()
                yqkeys__without_js_4arg.append(yqkey)
                continue
            js_4argH = f'{lcp}_'
            js_4arg = js_4argH
        elif op_tag == '-':
            #assert lcs, on_err()
            if not lcs:
                on_err()
                continue
            js_4argT = f'_{lcs}'
            js_4arg = js_4argT
        elif op_tag == '=':
            f1 = op[0]
            if f1 in 'rmc' or op in ('lock', 'built'):
                continue
            #assert (lcp or lcs), on_err()
            if not (lcp or lcs):
                on_err()
                continue
            #js_4arg = lcp_lcs_
            js_4argHT = f'{lcp}_{lcs}'
            js_4arg = js_4argHT
        else:
            raise 000
        js_4arg
        yqkey2js_4arg[yqkey] = js_4arg

        #bks__partition = yqkey2sorted_bks__partition[yqkey]
    return (
    (yqkeys__without_bifix_info
    ,yqkey2bifix_info
    ,yqkeys__without_js_4arg
    ,yqkey2js_4arg
    ,yqkey__bad_pairs__xx__triples4on_err
    ))
#end-def find_longest_bifix(yqkeys__sorted_via_qsz_yqkey, yqkey2sorted_bks__overlap, bk2js, /):

def jss2bifix_info(jss, /):
    #共同双缀=共同前缀+共同后缀
    #街:行圭
    #栽:𢦏木
    #裹:衣果
    #近:辶斤
    if not len(jss) >= 2:raise TypeError
    lcp = lcp_of__lsls(None, jss)
    lcs = lcs_of__lsls(None, jss)
    sz_lcp = len(lcp)
    sz_lcs = len(lcs)
    #err:assert sz_lcp or sz_lcs, (sz_lcp,sz_lcs,lcp,lcs)
    #   (0, 0, '', '')
    if sz_lcs:
        lcp_lcs_ = f'{lcp}_{lcs}-'
    else:
        lcp_lcs_ = f'{lcp}-'
    return (sz_lcp, sz_lcs, lcp, lcs, lcp_lcs_)




if __name__ == "__main__":
    pass



