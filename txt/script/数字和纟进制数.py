#__all__:goto
r'''[[[
e script/数字和纟进制数.py

script.数字和纟进制数
py -m nn_ns.app.debug_cmd   script.数字和纟进制数 -x # -off_defs
py -m nn_ns.app.doctest_cmd script.数字和纟进制数:__doc__ -ht # -ff -df

max min
median中位数
[[
]]

[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟进制数扌  =2 ='count()'
0:0
1:1
2:1
3:2
4:1
5:2
6:2
7:3
8:1
9:2
10:2
11:3
12:2
13:3
14:3
15:4
16:1
17:2
18:2
19:3
20:2
21:3
22:3
23:4
24:2
25:3
26:3
27:4
28:3
29:4
30:4
31:5
32:1
33:2
34:2
35:3
36:2
37:3
38:3
39:4
40:2
41:3
42:3
43:4
44:3
45:4
46:4
47:5
48:2
49:3
50:3
51:4
52:3
53:4
54:4
55:5
56:3
57:4
58:4
59:5
60:4
61:5
62:5
63:6
64:1
65:2
66:2
67:3
68:2
69:3
70:3
71:4
72:2
73:3
74:3
75:4
76:3
77:4
78:4
79:5
80:2
81:3
82:3
83:4
84:3
85:4
86:4
87:5
88:3
89:4
90:4
91:5
92:4
93:5
94:5
95:6
96:2
97:3
98:3
99:4
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3,5,7,10,11]' ='count()'
0:(0, 0, 0, 0, 0, 0)
1:(1, 1, 1, 1, 1, 1)
2:(1, 2, 2, 2, 2, 2)
3:(2, 1, 3, 3, 3, 3)
4:(1, 2, 4, 4, 4, 4)
5:(2, 3, 1, 5, 5, 5)
6:(2, 2, 2, 6, 6, 6)
7:(3, 3, 3, 1, 7, 7)
8:(1, 4, 4, 2, 8, 8)
9:(2, 1, 5, 3, 9, 9)
10:(2, 2, 2, 4, 1, 10)
11:(3, 3, 3, 5, 2, 1)
12:(2, 2, 4, 6, 3, 2)
13:(3, 3, 5, 7, 4, 3)
14:(3, 4, 6, 2, 5, 4)
15:(4, 3, 3, 3, 6, 5)
16:(1, 4, 4, 4, 7, 6)
17:(2, 5, 5, 5, 8, 7)
18:(2, 2, 6, 6, 9, 8)
19:(3, 3, 7, 7, 10, 9)
20:(2, 4, 4, 8, 2, 10)
21:(3, 3, 5, 3, 3, 11)
22:(3, 4, 6, 4, 4, 2)
23:(4, 5, 7, 5, 5, 3)
24:(2, 4, 8, 6, 6, 4)
25:(3, 5, 1, 7, 7, 5)
26:(3, 6, 2, 8, 8, 6)
27:(4, 1, 3, 9, 9, 7)
28:(3, 2, 4, 4, 10, 8)
29:(4, 3, 5, 5, 11, 9)
30:(4, 2, 2, 6, 3, 10)
31:(5, 3, 3, 7, 4, 11)
32:(1, 4, 4, 8, 5, 12)
33:(2, 3, 5, 9, 6, 3)
34:(2, 4, 6, 10, 7, 4)
35:(3, 5, 3, 5, 8, 5)
36:(2, 2, 4, 6, 9, 6)
37:(3, 3, 5, 7, 10, 7)
38:(3, 4, 6, 8, 11, 8)
39:(4, 3, 7, 9, 12, 9)
40:(2, 4, 4, 10, 4, 10)
41:(3, 5, 5, 11, 5, 11)
42:(3, 4, 6, 6, 6, 12)
43:(4, 5, 7, 7, 7, 13)
44:(3, 6, 8, 8, 8, 4)
45:(4, 3, 5, 9, 9, 5)
46:(4, 4, 6, 10, 10, 6)
47:(5, 5, 7, 11, 11, 7)
48:(2, 4, 8, 12, 12, 8)
49:(3, 5, 9, 1, 13, 9)
50:(3, 6, 2, 2, 5, 10)
51:(4, 5, 3, 3, 6, 11)
52:(3, 6, 4, 4, 7, 12)
53:(4, 7, 5, 5, 8, 13)
54:(4, 2, 6, 6, 9, 14)
55:(5, 3, 3, 7, 10, 5)
56:(3, 4, 4, 2, 11, 6)
57:(4, 3, 5, 3, 12, 7)
58:(4, 4, 6, 4, 13, 8)
59:(5, 5, 7, 5, 14, 9)
60:(4, 4, 4, 6, 6, 10)
61:(5, 5, 5, 7, 7, 11)
62:(5, 6, 6, 8, 8, 12)
63:(6, 3, 7, 3, 9, 13)
64:(1, 4, 8, 4, 10, 14)
65:(2, 5, 5, 5, 11, 15)
66:(2, 4, 6, 6, 12, 6)
67:(3, 5, 7, 7, 13, 7)
68:(2, 6, 8, 8, 14, 8)
69:(3, 5, 9, 9, 15, 9)
70:(3, 6, 6, 4, 7, 10)
71:(4, 7, 7, 5, 8, 11)
72:(2, 4, 8, 6, 9, 12)
73:(3, 5, 9, 7, 10, 13)
74:(3, 6, 10, 8, 11, 14)
75:(4, 5, 3, 9, 12, 15)
76:(3, 6, 4, 10, 13, 16)
77:(4, 7, 5, 5, 14, 7)
78:(4, 6, 6, 6, 15, 8)
79:(5, 7, 7, 7, 16, 9)
80:(2, 8, 4, 8, 8, 10)
81:(3, 1, 5, 9, 9, 11)
82:(3, 2, 6, 10, 10, 12)
83:(4, 3, 7, 11, 11, 13)
84:(3, 2, 8, 6, 12, 14)
85:(4, 3, 5, 7, 13, 15)
86:(4, 4, 6, 8, 14, 16)
87:(5, 3, 7, 9, 15, 17)
88:(3, 4, 8, 10, 16, 8)
89:(4, 5, 9, 11, 17, 9)
90:(4, 2, 6, 12, 9, 10)
91:(5, 3, 7, 7, 10, 11)
92:(4, 4, 8, 8, 11, 12)
93:(5, 3, 9, 9, 12, 13)
94:(5, 4, 10, 10, 13, 14)
95:(6, 5, 7, 11, 14, 15)
96:(2, 4, 8, 12, 15, 16)
97:(3, 5, 9, 13, 16, 17)
98:(3, 6, 10, 2, 17, 18)
99:(4, 3, 11, 3, 18, 9)
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3,5,7,10,11]' ='count()' +median_only
0:0
1:1
2:2
3:3
4:4
5:5
6:6
7:3
8:4
9:5
10:2
11:3
12:3
13:4
14:4
15:4
16:4
17:5
18:6
19:7
20:4
21:3
22:4
23:5
24:6
25:5
26:6
27:7
28:4
29:5
30:4
31:5
32:5
33:5
34:6
35:5
36:6
37:7
38:8
39:9
40:4
41:5
42:6
43:7
44:8
45:5
46:6
47:7
48:8
49:9
50:5
51:5
52:6
53:7
54:6
55:5
56:4
57:5
58:6
59:7
60:6
61:7
62:8
63:7
64:8
65:5
66:6
67:7
68:8
69:9
70:6
71:7
72:8
73:9
74:10
75:9
76:10
77:7
78:6
79:7
80:8
81:9
82:10
83:11
84:8
85:7
86:8
87:9
88:8
89:9
90:9
91:7
92:8
93:9
94:10
95:11
96:12
97:13
98:10
99:9
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3,5,7,10,11]' ='count()' +median_only +to_div_radix
0:0
1:0
2:0
3:0
4:0
5:0
6:0
7:0
8:0
9:0
10:0
11:0
12:0
13:1
14:1
15:0
16:0
17:1
18:0
19:1
20:1
21:1
22:1
23:1
24:1
25:1
26:1
27:0
28:0
29:1
30:0
31:1
32:1
33:1
34:1
35:0
36:0
37:1
38:1
39:1
40:1
41:1
42:1
43:1
44:1
45:1
46:1
47:1
48:1
49:1
50:0
51:1
52:1
53:1
54:1
55:1
56:1
57:1
58:1
59:1
60:0
61:1
62:1
63:1
64:1
65:1
66:1
67:1
68:1
69:1
70:1
71:1
72:1
73:1
74:1
75:1
76:1
77:1
78:1
79:1
80:1
81:1
82:1
83:1
84:1
85:1
86:1
87:1
88:1
89:1
90:1
91:1
92:1
93:1
94:1
95:1
96:1
97:1
98:1
99:1
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3,5,7,10,11]' ='count()' -median_only +to_div_radix
0:(0, 0, 0, 0, 0, 0)
1:(0, 0, 0, 0, 0, 0)
2:(0, 0, 0, 0, 0, 0)
3:(1, 0, 0, 0, 0, 0)
4:(0, 0, 0, 0, 0, 0)
5:(1, 1, 0, 0, 0, 0)
6:(1, 0, 0, 0, 0, 0)
7:(1, 1, 0, 0, 0, 0)
8:(0, 1, 0, 0, 0, 0)
9:(1, 0, 1, 0, 0, 0)
10:(1, 0, 0, 0, 0, 0)
11:(1, 1, 0, 0, 0, 0)
12:(1, 0, 0, 0, 0, 0)
13:(1, 1, 1, 1, 0, 0)
14:(1, 1, 1, 0, 0, 0)
15:(2, 1, 0, 0, 0, 0)
16:(0, 1, 0, 0, 0, 0)
17:(1, 1, 1, 0, 0, 0)
18:(1, 0, 1, 0, 0, 0)
19:(1, 1, 1, 1, 1, 0)
20:(1, 1, 0, 1, 0, 0)
21:(1, 1, 1, 0, 0, 1)
22:(1, 1, 1, 0, 0, 0)
23:(2, 1, 1, 0, 0, 0)
24:(1, 1, 1, 0, 0, 0)
25:(1, 1, 0, 1, 0, 0)
26:(1, 2, 0, 1, 0, 0)
27:(2, 0, 0, 1, 0, 0)
28:(1, 0, 0, 0, 1, 0)
29:(2, 1, 1, 0, 1, 0)
30:(2, 0, 0, 0, 0, 0)
31:(2, 1, 0, 1, 0, 1)
32:(0, 1, 0, 1, 0, 1)
33:(1, 1, 1, 1, 0, 0)
34:(1, 1, 1, 1, 0, 0)
35:(1, 1, 0, 0, 0, 0)
36:(1, 0, 0, 0, 0, 0)
37:(1, 1, 1, 1, 1, 0)
38:(1, 1, 1, 1, 1, 0)
39:(2, 1, 1, 1, 1, 0)
40:(1, 1, 0, 1, 0, 0)
41:(1, 1, 1, 1, 0, 1)
42:(1, 1, 1, 0, 0, 1)
43:(2, 1, 1, 1, 0, 1)
44:(1, 2, 1, 1, 0, 0)
45:(2, 1, 1, 1, 0, 0)
46:(2, 1, 1, 1, 1, 0)
47:(2, 1, 1, 1, 1, 0)
48:(1, 1, 1, 1, 1, 0)
49:(1, 1, 1, 0, 1, 0)
50:(1, 2, 0, 0, 0, 0)
51:(2, 1, 0, 0, 0, 1)
52:(1, 2, 0, 0, 0, 1)
53:(2, 2, 1, 0, 0, 1)
54:(2, 0, 1, 0, 0, 1)
55:(2, 1, 0, 1, 1, 0)
56:(1, 1, 0, 0, 1, 0)
57:(2, 1, 1, 0, 1, 0)
58:(2, 1, 1, 0, 1, 0)
59:(2, 1, 1, 0, 1, 0)
60:(2, 1, 0, 0, 0, 0)
61:(2, 1, 1, 1, 0, 1)
62:(2, 2, 1, 1, 0, 1)
63:(3, 1, 1, 0, 0, 1)
64:(0, 1, 1, 0, 1, 1)
65:(1, 1, 1, 0, 1, 1)
66:(1, 1, 1, 0, 1, 0)
67:(1, 1, 1, 1, 1, 0)
68:(1, 2, 1, 1, 1, 0)
69:(1, 1, 1, 1, 1, 0)
70:(1, 2, 1, 0, 0, 0)
71:(2, 2, 1, 0, 0, 1)
72:(1, 1, 1, 0, 0, 1)
73:(1, 1, 1, 1, 1, 1)
74:(1, 2, 2, 1, 1, 1)
75:(2, 1, 0, 1, 1, 1)
76:(1, 2, 0, 1, 1, 1)
77:(2, 2, 1, 0, 1, 0)
78:(2, 2, 1, 0, 1, 0)
79:(2, 2, 1, 1, 1, 0)
80:(1, 2, 0, 1, 0, 0)
81:(1, 0, 1, 1, 0, 1)
82:(1, 0, 1, 1, 1, 1)
83:(2, 1, 1, 1, 1, 1)
84:(1, 0, 1, 0, 1, 1)
85:(2, 1, 1, 1, 1, 1)
86:(2, 1, 1, 1, 1, 1)
87:(2, 1, 1, 1, 1, 1)
88:(1, 1, 1, 1, 1, 0)
89:(2, 1, 1, 1, 1, 0)
90:(2, 0, 1, 1, 0, 0)
91:(2, 1, 1, 1, 1, 1)
92:(2, 1, 1, 1, 1, 1)
93:(2, 1, 1, 1, 1, 1)
94:(2, 1, 2, 1, 1, 1)
95:(3, 1, 1, 1, 1, 1)
96:(1, 1, 1, 1, 1, 1)
97:(1, 1, 1, 1, 1, 1)
98:(1, 2, 2, 0, 1, 1)
99:(2, 1, 2, 0, 1, 0)
vs:
99:(4, 3, 11, 3, 18, 9)
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3,5,7,10,11]' ='count()' -median_only +bit_only
0:(0, 0, 0, 0, 0, 0)
1:(0, 0, 0, 0, 0, 0)
2:(0, 1, 0, 0, 0, 0)
3:(1, 0, 1, 0, 0, 0)
4:(0, 0, 1, 1, 0, 0)
5:(0, 1, 0, 1, 0, 0)
6:(1, 0, 0, 1, 1, 1)
7:(1, 1, 0, 0, 1, 1)
8:(0, 1, 0, 0, 1, 1)
9:(0, 0, 1, 0, 1, 1)
10:(0, 0, 0, 0, 0, 1)
11:(1, 0, 0, 0, 0, 0)
12:(0, 0, 0, 0, 0, 0)
13:(1, 0, 1, 1, 0, 0)
14:(1, 1, 1, 0, 0, 0)
15:(1, 0, 0, 0, 0, 0)
16:(0, 1, 0, 0, 0, 0)
17:(0, 1, 1, 0, 0, 0)
18:(0, 0, 1, 0, 0, 0)
19:(0, 0, 1, 1, 1, 0)
20:(0, 1, 0, 1, 0, 0)
21:(0, 0, 1, 0, 0, 1)
22:(0, 1, 1, 0, 0, 0)
23:(1, 1, 1, 0, 0, 0)
24:(0, 1, 1, 0, 0, 0)
25:(1, 1, 0, 1, 0, 0)
26:(1, 1, 0, 1, 0, 0)
27:(1, 0, 0, 1, 0, 0)
28:(1, 0, 0, 0, 1, 0)
29:(1, 0, 0, 0, 1, 0)
30:(1, 0, 0, 0, 0, 0)
31:(1, 0, 0, 1, 0, 1)
32:(0, 0, 0, 1, 0, 1)
33:(0, 0, 0, 1, 0, 0)
34:(0, 0, 0, 1, 0, 0)
35:(0, 1, 0, 0, 0, 0)
36:(0, 0, 0, 0, 0, 0)
37:(0, 0, 0, 1, 1, 0)
38:(0, 0, 0, 1, 1, 0)
39:(1, 0, 1, 1, 1, 0)
40:(0, 0, 0, 1, 0, 0)
41:(0, 1, 0, 1, 0, 1)
42:(0, 0, 0, 0, 0, 1)
43:(1, 1, 1, 1, 0, 1)
44:(0, 1, 1, 1, 0, 0)
45:(1, 0, 0, 1, 0, 0)
46:(1, 0, 0, 1, 1, 0)
47:(1, 1, 1, 1, 1, 0)
48:(0, 0, 1, 1, 1, 0)
49:(0, 1, 1, 0, 1, 0)
50:(0, 1, 0, 0, 0, 0)
51:(1, 1, 0, 0, 0, 1)
52:(0, 1, 0, 0, 0, 1)
53:(1, 1, 0, 0, 0, 1)
54:(1, 0, 0, 0, 0, 1)
55:(1, 0, 0, 0, 1, 0)
56:(0, 0, 0, 0, 1, 0)
57:(1, 0, 0, 0, 1, 0)
58:(1, 0, 0, 0, 1, 0)
59:(1, 1, 1, 0, 1, 0)
60:(1, 0, 0, 0, 0, 0)
61:(1, 1, 0, 0, 0, 1)
62:(1, 1, 0, 0, 0, 1)
63:(1, 0, 1, 0, 0, 1)
64:(0, 0, 1, 0, 1, 1)
65:(0, 1, 0, 0, 1, 1)
66:(0, 0, 0, 0, 1, 0)
67:(0, 1, 1, 0, 1, 0)
68:(0, 1, 1, 0, 1, 0)
69:(0, 1, 1, 0, 1, 0)
70:(0, 1, 0, 0, 0, 0)
71:(0, 1, 1, 0, 0, 1)
72:(0, 0, 1, 0, 0, 1)
73:(0, 1, 1, 0, 1, 1)
74:(0, 1, 1, 0, 1, 1)
75:(0, 1, 0, 0, 1, 1)
76:(0, 1, 0, 1, 1, 1)
77:(0, 1, 0, 0, 1, 0)
78:(0, 1, 0, 0, 1, 0)
79:(1, 1, 1, 0, 1, 0)
80:(0, 1, 0, 0, 0, 0)
81:(0, 0, 0, 0, 0, 1)
82:(0, 0, 0, 1, 1, 1)
83:(0, 0, 1, 1, 1, 1)
84:(0, 0, 1, 0, 1, 1)
85:(0, 0, 0, 0, 1, 1)
86:(0, 0, 0, 0, 1, 1)
87:(1, 0, 1, 0, 1, 1)
88:(0, 0, 1, 1, 1, 0)
89:(0, 0, 1, 1, 1, 0)
90:(0, 0, 0, 1, 0, 0)
91:(1, 0, 1, 0, 1, 1)
92:(0, 0, 1, 0, 1, 1)
93:(1, 0, 1, 0, 1, 1)
94:(1, 0, 1, 1, 1, 1)
95:(1, 0, 1, 1, 1, 1)
96:(0, 0, 1, 1, 1, 1)
97:(0, 0, 1, 1, 1, 1)
98:(0, 1, 1, 0, 1, 1)
99:(1, 0, 1, 0, 1, 0)
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3,5,7,10,11]' ='count()' -median_only +bit_only +bit5mod_two
    奇进数 周期为 01
0:(0, 0, 0, 0, 0, 0)
1:(1, 1, 1, 1, 1, 1)
2:(1, 0, 0, 0, 0, 0)
3:(0, 1, 1, 1, 1, 1)
4:(1, 0, 0, 0, 0, 0)
5:(0, 1, 1, 1, 1, 1)
6:(0, 0, 0, 0, 0, 0)
7:(1, 1, 1, 1, 1, 1)
8:(1, 0, 0, 0, 0, 0)
9:(0, 1, 1, 1, 1, 1)
10:(0, 0, 0, 0, 1, 0)
11:(1, 1, 1, 1, 0, 1)
12:(0, 0, 0, 0, 1, 0)
13:(1, 1, 1, 1, 0, 1)
14:(1, 0, 0, 0, 1, 0)
15:(0, 1, 1, 1, 0, 1)
16:(1, 0, 0, 0, 1, 0)
17:(0, 1, 1, 1, 0, 1)
18:(0, 0, 0, 0, 1, 0)
19:(1, 1, 1, 1, 0, 1)
20:(0, 0, 0, 0, 0, 0)
21:(1, 1, 1, 1, 1, 1)
22:(1, 0, 0, 0, 0, 0)
23:(0, 1, 1, 1, 1, 1)
24:(0, 0, 0, 0, 0, 0)
25:(1, 1, 1, 1, 1, 1)
26:(1, 0, 0, 0, 0, 0)
27:(0, 1, 1, 1, 1, 1)
28:(1, 0, 0, 0, 0, 0)
29:(0, 1, 1, 1, 1, 1)
30:(0, 0, 0, 0, 1, 0)
31:(1, 1, 1, 1, 0, 1)
32:(1, 0, 0, 0, 1, 0)
33:(0, 1, 1, 1, 0, 1)
34:(0, 0, 0, 0, 1, 0)
35:(1, 1, 1, 1, 0, 1)
36:(0, 0, 0, 0, 1, 0)
37:(1, 1, 1, 1, 0, 1)
38:(1, 0, 0, 0, 1, 0)
39:(0, 1, 1, 1, 0, 1)
40:(0, 0, 0, 0, 0, 0)
41:(1, 1, 1, 1, 1, 1)
42:(1, 0, 0, 0, 0, 0)
43:(0, 1, 1, 1, 1, 1)
44:(1, 0, 0, 0, 0, 0)
45:(0, 1, 1, 1, 1, 1)
46:(0, 0, 0, 0, 0, 0)
47:(1, 1, 1, 1, 1, 1)
48:(0, 0, 0, 0, 0, 0)
49:(1, 1, 1, 1, 1, 1)
50:(1, 0, 0, 0, 1, 0)
51:(0, 1, 1, 1, 0, 1)
52:(1, 0, 0, 0, 1, 0)
53:(0, 1, 1, 1, 0, 1)
54:(0, 0, 0, 0, 1, 0)
55:(1, 1, 1, 1, 0, 1)
56:(1, 0, 0, 0, 1, 0)
57:(0, 1, 1, 1, 0, 1)
58:(0, 0, 0, 0, 1, 0)
59:(1, 1, 1, 1, 0, 1)
60:(0, 0, 0, 0, 0, 0)
61:(1, 1, 1, 1, 1, 1)
62:(1, 0, 0, 0, 0, 0)
63:(0, 1, 1, 1, 1, 1)
64:(1, 0, 0, 0, 0, 0)
65:(0, 1, 1, 1, 1, 1)
66:(0, 0, 0, 0, 0, 0)
67:(1, 1, 1, 1, 1, 1)
68:(0, 0, 0, 0, 0, 0)
69:(1, 1, 1, 1, 1, 1)
70:(1, 0, 0, 0, 1, 0)
71:(0, 1, 1, 1, 0, 1)
72:(0, 0, 0, 0, 1, 0)
73:(1, 1, 1, 1, 0, 1)
74:(1, 0, 0, 0, 1, 0)
75:(0, 1, 1, 1, 0, 1)
76:(1, 0, 0, 0, 1, 0)
77:(0, 1, 1, 1, 0, 1)
78:(0, 0, 0, 0, 1, 0)
79:(1, 1, 1, 1, 0, 1)
80:(0, 0, 0, 0, 0, 0)
81:(1, 1, 1, 1, 1, 1)
82:(1, 0, 0, 0, 0, 0)
83:(0, 1, 1, 1, 1, 1)
84:(1, 0, 0, 0, 0, 0)
85:(0, 1, 1, 1, 1, 1)
86:(0, 0, 0, 0, 0, 0)
87:(1, 1, 1, 1, 1, 1)
88:(1, 0, 0, 0, 0, 0)
89:(0, 1, 1, 1, 1, 1)
90:(0, 0, 0, 0, 1, 0)
91:(1, 1, 1, 1, 0, 1)
92:(0, 0, 0, 0, 1, 0)
93:(1, 1, 1, 1, 0, 1)
94:(1, 0, 0, 0, 1, 0)
95:(0, 1, 1, 1, 0, 1)
96:(0, 0, 0, 0, 1, 0)
97:(1, 1, 1, 1, 0, 1)
98:(1, 0, 0, 0, 1, 0)
99:(0, 1, 1, 1, 0, 1)
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   ,100:枚举冫数字和纟多种进制数扌  ='[2,3]' ='count()' +max_only +to_mod_radix --offset=1
0:-1
1:0
2:1
3:0
4:1
5:-1
6:1
7:0
8:0
9:0
10:1
11:0
12:1
13:0
14:0
15:-1
16:0
17:1
18:1
19:0
20:0
21:0
22:0
23:1
24:0
25:1
26:0
27:0
28:1
29:-1
30:1
31:0
32:0
33:-1
34:0
35:1
36:1
37:0
38:0
39:-1
40:0
41:1
42:0
43:1
44:0
45:-1
46:0
47:1
48:0
49:1
50:0
51:1
52:0
53:0
54:1
55:0
56:0
57:-1
58:0
59:1
60:0
61:1
62:0
63:-1
64:0
65:1
66:0
67:1
68:-1
69:1
70:0
71:0
72:0
73:1
74:0
75:1
76:0
77:0
78:-1
79:0
80:1
81:0
82:1
83:-1
84:1
85:-1
86:0
87:0
88:0
89:1
90:1
91:0
92:0
93:0
94:0
95:1
96:0
97:1
98:0
99:-1
]]
[[
py_adhoc_call { -lineno }  script.数字和纟进制数   @list.300:枚举冫数字和纟多种进制数扌  ='[3]' ='count()' +max_only +to_div_radix
[0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 3, 2, 3, 3, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2, 2, 1, 1, 1]
]]
[[
>>> ''.join(map(str, 枚举冫数字和纟多种进制数扌([2], range(300), max_only=True, to_mod_radix=True)))
'011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001011010010110011010011001011001101001011010011001011001101001100101101001011001101001011010011001011010010110011010011001011001101001011010011001011010010110011010010110100110010110011010011001'
>>> ''.join(map(str, 枚举冫数字和纟多种进制数扌([3], range(300), max_only=True, to_mod_radix=True)))
'012120201120201012201012120120201012201012120012120201201012120012120201120201012120201012201012120012120201201012120012120201120201012012120201120201012201012120201012120012120201120201012012120201120201012201012120120201012201012120012120201120201012201012120012120201201012120012120201120201012012'
>>> ''.join(map(str, 枚举冫数字和纟多种进制数扌([5], range(300), max_only=True, to_mod_radix=True)))
'012341234023401340124012312340234013401240123012342340134012401230123412340340124012301234123402340140123012341234023401340121234023401340124012301234234013401240123012341234034012401230123412340234014012301234123402340134012012341234023401340124012323401340124012301234123403401240123012341234023401'
>>> ''.join(map(str, 枚举冫数字和纟多种进制数扌([7], range(300), max_only=True, to_mod_radix=True)))
'012345612345602345601345601245601235601234601234512345602345601345601245601235601234601234501234562345601345601245601235601234601234501234561234560345601245601235601234601234501234561234560234560145601235601234601234501234561234560234560134560125601234601234501234561234560234560134560124560123601234'
>>> ''.join(map('{:X}'.format, 枚举冫数字和纟多种进制数扌([11], range(300), max_only=True, to_mod_radix=True)))
'0123456789A123456789A023456789A013456789A012456789A012356789A012346789A012345789A012345689A012345679A012345678A0123456789123456789A023456789A013456789A012456789A012356789A012346789A012345789A012345689A012345679A012345678A01234567890123456789A23456789A013456789A012456789A012356789A012346789A012345789'
>>> ''.join(map('{:X}'.format, 枚举冫数字和纟多种进制数扌([13], range(300), max_only=True, to_mod_radix=True)))
'0123456789ABC123456789ABC023456789ABC013456789ABC012456789ABC012356789ABC012346789ABC012345789ABC012345689ABC012345679ABC012345678ABC0123456789BC0123456789AC0123456789AB123456789ABC023456789ABC013456789ABC012456789ABC012356789ABC012346789ABC012345789ABC012345689ABC012345679ABC012345678ABC0123456789B'
>>> s09 = ''.join(map(chr, range(ord('0'), 1+ord('9'))))
>>> sAZ = ''.join(map(chr, range(ord('A'), 1+ord('Z'))))
>>> tbl = s09 + sAZ
>>> ''.join(map(tbl.__getitem__, 枚举冫数字和纟多种进制数扌([17], range(300), max_only=True, to_mod_radix=True)))
'0123456789ABCDEFG123456789ABCDEFG023456789ABCDEFG013456789ABCDEFG012456789ABCDEFG012356789ABCDEFG012346789ABCDEFG012345789ABCDEFG012345689ABCDEFG012345679ABCDEFG012345678ABCDEFG0123456789BCDEFG0123456789ACDEFG0123456789ABDEFG0123456789ABCEFG0123456789ABCDFG0123456789ABCDEG0123456789ABCDEF123456789AB'

]]



]]]'''#'''
__all__ = r'''
求冫数字和纟进制数扌
枚举冫数字和纟进制数扌
枚举冫数字和纟多种进制数扌
'''.split()#'''
__all__
___begin_mark_of_excluded_global_names__0___ = ...
from itertools import islice
from seed.tiny_.check import check_type_is, check_int_ge

from seed.int_tools.digits.uint25radix_repr import uint2radix_repr_# uint5radix_repr_

___end_mark_of_excluded_global_names__0___ = ...

def 求冫数字和纟进制数扌(radix, u, /, *, with_num_digits=False):
    check_type_is(bool, with_num_digits)
    check_int_ge(2, radix)
    check_int_ge(0, u)
    #if radix > 36:raise NotImplementedError(radix)
    #int(u, base=radix)
    #r = sum(uint2radix_repr_(radix, u, is_big_endian=False))
    it = uint2radix_repr_(radix, u, is_big_endian=False)
    if with_num_digits:
        ds = [*it]
        777; it = iter(ds)
        sz = len(ds)
    n = sum(it)
    if radix == 2:
        assert n == u.bit_count()
        if with_num_digits:
            assert sz == u.bit_length()
    return n if not with_num_digits else (sz, n)

def 枚举冫数字和纟进制数扌(radix, us, /):
    f = 求冫数字和纟进制数扌
    for u in us:
        yield f(radix, u)
def 枚举冫数字和纟多种进制数扌(radixes, us, /, *, max_only=False, median_only=False, to_mod_radix=False, to_div_radix=False, bit_only=False, bit5mod_two=False, offset=0):
    #, may_sep4join8str=None
    check_type_is(bool, max_only)
    check_type_is(bool, median_only)
    check_type_is(bool, to_mod_radix)
    check_type_is(bool, to_div_radix)
    check_type_is(bool, bit_only)
    check_type_is(bool, bit5mod_two)
    check_type_is(int, offset)
    if max_only and median_only:raise 000
    if bit_only + to_div_radix + to_mod_radix >= 2:raise 000
    #if not may_sep4join8str is None: check_type_is(str, may_sep4join8str)

    with_num_digits = bit_only and not bit5mod_two
    def g(u, it, /):
        for radix, (sz, digit_sum) in zip(radixes, it):
            b = 0 if sz == 0 else _calc_bit_(u, radix, sz, digit_sum)
            yield b
    radixes = tuple(radixes)
    for radix in radixes:
        check_int_ge(2, radix)
    if median_only:
        assert len(radixes)
        j = len(radixes)//2
    f = 求冫数字和纟进制数扌
    for u in us:
        it = (f(radix, u, with_num_digits=with_num_digits) for radix in radixes)
        if bit_only:
            it = g(u, it) if not bit5mod_two else (n&1 for n in it)
        elif to_div_radix:
            it = (n//radix for radix, n in zip(radixes, it))
        elif to_mod_radix:
            it = (n%radix for radix, n in zip(radixes, it))
        if median_only:
            out = n = sorted(it)[j]
        elif max_only:
            out = n = max(it)
        else:
            out = ls = tuple(it)
        out
        if offset:
            if type(out) is int:
                out = n -offset
            else:
                out = tuple(n -offset for n in ls)
            out
        out

        yield out
def _calc_bit_(u, radix, sz, digit_sum, /):
    assert sz > 0
        # head_digit exists
    # mean/average:sum[radix/2, (radix-1)/2...]
    double_mean = (radix*sz-sz+1) if sz else 0
        # [radix==2][sz==3]:
        #   [double_mean == 4]
        #   [digit_sum <- {1,2,3}]
        #   1 => 0b100
        #   2 => 0b101,0b110
        #   3 => 0b111
    #b = int(double_mean < 2*digit_sum)
    d = 2*digit_sum -double_mean
    if d == 0:
        #R = radix**sz
        #assert 0 <= u < R
        v = u//radix**max(0,sz-2)
        head_digit, snd_digit = divmod(v, radix)
        assert 0 <= head_digit < radix
        assert (sz == 1) is (head_digit==0)
        if head_digit == 0:
            head_digit, snd_digit = snd_digit, 0
        assert 0 < head_digit < radix
        # [head_digit <- [1..<radix]]
        half = radix//2
        d = head_digit -half
        if radix&1 == 1:
            # [odd radix]
            # [radix/2 == ?.5 =!= head_digit]
            pass
        elif not d == 0:
            # [even radix]
            # [radix/2 =!= head_digit]
            pass
        else:
            # [even radix]
            # [radix/2 == head_digit]
            if sz == 1:
                d = 0
            else:
                d = snd_digit+1 -half
            d
        d
    d
    b = int(0 < d)
    if 0b0000:print(u, radix, (sz, digit_sum), double_mean, b)
    return b


__all__
from script.数字和纟进制数 import 求冫数字和纟进制数扌,枚举冫数字和纟进制数扌
from script.数字和纟进制数 import *
