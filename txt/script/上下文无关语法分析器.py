
r"""
上下文无关语法分析器
类似 Haskell.parsec 的识别器


可选 a
	= ()
	| (a,)
列表 a
	= ()
	| (a, 列表 a)

地址 = 列表 自然数
	#多个层次的地址
	#非严格单调递增
	地址 != ()
虚拟地址
	= 地址
	| (自然数,)

缓存起始地址
缓存末尾地址
	当前缓存量 = 缓存末尾地址-缓存起始地址
虚拟终止地址
	相应识别器的“终止”限制
当前地址



大阳符
	.起始地址
	.末尾地址
	.阳符名
	.低层值

阳符扩展
	= 阳符名
	| 内建特殊阳符名 #@@none@@ @@any@@ 显式集合 函数式集合

阴符表达式
	= 高层值函数* 基本阴符表达式
基本阴符表达式
	= 阴符名
	| 内建识别器
	| 内建识别器构造器(...)
	| 用户自定义识别器
	| 用户自定义识别器构造器(...)

语法 :: dict<阴符名,阴符表达式>

失败栈 = 列表 (阴符表达式,状态,起始地址,可选 末尾地址)


输入缓存器
	当前地址
识别器
	枚举状态
		识别器 状态
			与 地址/输入消耗量 等 输入相关数据 无关
	枚举地址名
处理器


锁死缓存起始地址的类型
	形式锁死类型
		半锁死
		实际锁死类型
			锁死
			可解锁 #“是我”消息
			无锁
子实际锁死类型 = 父实际锁死类型 * 父对子形式锁死类型
a=父实际锁死类型
b=父对子形式锁死类型
c=子实际锁死类型

________________________________________
|\\   \\    |
| \\ c \\ b | 锁死   半锁死 可解锁 无锁
|  \\   \\  |
| a =====\\ |
|-----------+
| 锁死        锁死   锁死   锁死   锁死
| 可解锁      锁死   锁死   可解锁 无锁
| 无锁        锁死   无锁   无锁   无锁
|
|





识别器的 关联数据
	实际锁死类型
	可选虚拟终止地址 from 可选虚拟终止地址名
	可选前置指令序列结果
	====识别中途结果
	状态
	可选中途高层值
	命名地址存储器
	动态变量空间
识别器 状态 的 查询
	可选 非终止状态的相关数据
		形式锁死类型
		前置指令序列
			#若无 子识别器，则在 步进 前执行，并产生 额外输入
		后置指令序列
			#若有 子识别器，则在 处理子识别结果 前执行，并产生 额外输入 #联合 前置指令序列 的结果
			#为何不把结果存在 高层值？
			#  避免含义不明，且高层值是可选的
			#  倒是可以添加一个 动态变量空间 用以 保存变量
		可选 子识别器及相关数据 #缺省：大阳符 步进
			子识别器
			是否需要高层值
			可选虚拟终止地址名

识别最终结果
识别中途结果
	状态
	可选中途高层值
	命名地址存储器
	动态变量空间
地址存取动作
	保存当前地址 地址名
	删除地址 地址名
	回退当前地址 地址名
指令
	地址存取动作
	缩减缓存 可选地址名 #缺省：当前地址
	求解锁 #含 缩减缓存
	是我 #含 求解锁，此后失败 只能是 是我失败
	比较地址 变量名 [(地址名,地址名)]
		sign sum(b-a for a,b in pairs)
		用于比较两地址的先后，或 两消耗量的大小
		计算结果作为 处理子识别结果 的 额外输入


识别器 与 处理器 之间的信息传递
	识别器 <----> 处理器
	-->
		状态
			#父对子形式锁死类型
			#指令
		可选中途高层值
	<--
		消耗量

====内建
优先识别器 [识别器表达式] (可选 非我失败原因)
优先识别器 xs m
	assert xs
	保存当前地址
	for x in xs[:-1]:
		试 可解锁:x
			成功|是我失败
				返回
			非我失败
				回退当前地址
				继续
	x := xs[-1]
	试 无锁:x
		if 非我失败 and m:
			更改原因
		返回

显式解锁串行识别器 [识别器表达式] (可选 识别器表达式) [识别器表达式]
显式解锁串行识别器 [识别器表达式] 自然数{0..2*数组长}
显式解锁串行识别器 xs m ys
	for x in xs:
		试 半锁死:x
			成功
				继续
			失败
				返回 非我失败
	if m:
		[z] := m
		试 可解锁:z
			失败
				返回
			成功
				pass
	else:
		求解锁
	for y in ys:
		试 无锁:y
			成功
				继续
			失败
				返回 是我失败
	返回 成功
消耗解锁串行识别器 [识别器表达式]
消耗解锁串行识别器 xs
	求解锁
	for x in xs:
		试 无锁:x
			成功
				继续
			失败
				if 消耗量==0:
					返回 非我失败
				else:
					返回 是我失败
	返回 成功
常量识别器 [阳符扩展] 自然数{0..数组长}
常量识别器 xs i
	for x in xs[:i]:
		试 半锁死:x
			成功
				继续
			失败
				返回 非我失败
	求解锁
	for x in xs[i:]:
		试 无锁:x
			成功
				继续
			失败
				返回 是我失败


前向识别器 识别器表达式 成功变
前向识别器 x t
	保存当前地址
	试 锁死:x
		回退当前地址
		成功
			返回 ?t
		失败
			返回 !t


非我失败识别器 非我失败原因
	返回 非我失败
是我失败识别器 是我失败原因
	返回 是我失败


失败保护识别器 识别器表达式
	试 可解锁:x
		成功
			返回
		失败
			返回 非我失败

限长成功识别器 最小长度 (可选 最大长度)
限长成功识别器 n m=oo
	x := @@any@@
	for _ in [0..n-1]:
		试 半锁死:x
			成功
				继续
			失败
				EOF
				返回 非我失败
	求解锁
	for _ in [n..m-1]:
		试 无锁:x
			成功
				继续
			失败
				EOF
				返回 成功
	返回 成功

前缀识别器 识别器表达式 [识别器表达式] 是否要求完全匹配 是否逆转后续成败
前缀识别器 x ys b t
	保存当前地址 0
	试 锁死:x
		成功
			保存当前地址 1
			if b:
				d := 消耗量
		失败
			返回
	for c,y in zip([锁死...,无锁],ys):
		回退当前地址 0
		试 c:y{虚拟终止地址=1}
			成功
				if b:
					保存当前地址 2
					dd := 消耗量
					if dd != d:
						改为 是我失败
			失败
				pass

			?t 更改 成败
			成功
				继续
			失败
				返回 是我失败
	回退当前地址 1
	返回 成功






====过时
地址栈动作
	入栈当前地址
	出栈地址
	回退当前地址
		====
		出栈地址*n
			n
		出栈地址*n 入栈当前地址
			-n
		出栈地址*n 回退当前地址 出栈地址*m
			n,m
		出栈地址*n 回退当前地址 出栈地址*m 入栈当前地址
			n,-m

#"""



from abc import ABC, abstractmethod

def 地址小于等于(lhs, rhs):
	return lhs[0] <= rhs[0]
def 地址相等(lhs, rhs):
	return lhs[0] == rhs[0]


锁死 = '锁死'
可解锁 = '可解锁'
无锁 = '无锁'
半锁死 = '半锁死'
全部实际锁死类型 = {锁死, 可解锁, 无锁}
全部形式锁死类型 = {半锁死, *全部实际锁死类型}
def 求子实际锁死类型(*, 父实际锁死类型, 父对子形式锁死类型
		)->'子实际锁死类型':
	assert 父实际锁死类型 in 全部实际锁死类型
	assert 父对子形式锁死类型 in 全部形式锁死类型
	if 父实际锁死类型==锁死 or 父对子形式锁死类型==锁死:
		子实际锁死类型 = 锁死
	elif 父实际锁死类型==无锁:
		子实际锁死类型 = 无锁
	elif 父实际锁死类型==可解锁:
		if 父对子形式锁死类型==半锁死:
			子实际锁死类型 = 锁死
		else:
			子实际锁死类型 = 父对子形式锁死类型
	else:
		raise logic-error
	assert 子实际锁死类型 in 全部实际锁死类型
	return 子实际锁死类型



class 处理器接口(ABC):
	@classmethod
	@abstractmethod
	def 组建(cls, *, 识别器, 输入缓存器
			)->'处理器':
		pass
	@abstractmethod
	def 识别(self
			)-> '("成功", 高层值) | ("失败", 失败原因, 失败栈)':
		pass



class 识别器接口(ABC):
	@abstractmethod
	def __repr__(self):
		pass
	@abstractmethod
	def 启动(self, *, 是否需要高层值
			)->'识别中途结果':
		pass
	@abstractmethod
	def 取可选非终止状态的相关数据(self, *, 状态
			)->'可选 非终止状态的相关数据':
		pass
	@abstractmethod
	def 步进(self, *, 状态, 可选中途高层值, 大阳符, 前置指令序列结果
			)->'识别中途结果':
		pass
	@abstractmethod
	def 处理子识别结果(self, *, 状态, 可选中途高层值, 子识别最终结果, 前置指令序列结果, 后置指令序列结果
			)->'识别中途结果':
		pass
	@abstractmethod
	def 处理终止地址(self, *, 状态, 可选中途高层值, 前置指令序列结果
			)->'识别最终结果':
		pass

class 输入缓存器(ABC):
	@abstractmethod
	def 读取不多于(self, n)->'[大阳符]':
		pass


class 处理器(处理器接口):
	def __init__(self, *, 识别器, 输入缓存器
			):
		self.识别器 = 识别器
		self.输入缓存器 = 输入缓存器
	@classmethod
	def 组建(cls, *, 识别器, 输入缓存器
			)->'处理器':
		return cls(识别器=识别器, 输入缓存器=输入缓存器)
	def _push(self, ls, *, 识别器, 实际锁死类型, 是否需要高层值, 可选虚拟终止地址):
		识别中途结果 = 识别器.启动(是否需要高层值=是否需要高层值)
		状态 = 识别中途结果.状态
		可选中途高层值 = 识别中途结果.可选中途高层值
		关联数据 = ???
		ls.append((识别器, 关联数据))
	def 识别(self
			)-> '("成功", 高层值) | ("失败", 失败原因, 失败栈)':
		ls = []
			# [(识别器,关联数据)]

		输入缓存器 = self.输入缓存器
		识别器 = self.识别器
		self._push(ls, 识别器=识别器, 实际锁死类型=无锁, 是否需要高层值=True, 可选虚拟终止地址=())
		从子子识别器返回 = False
			#almost bool(关联数据.可选前置指令序列结果)
			#  除了 call 步进() 时
		while ls:
			(识别器, 关联数据) = ls[-1]
			状态 = 关联数据.状态
			可选中途高层值 = 关联数据.可选中途高层值
			可选虚拟终止地址 = 关联数据.可选虚拟终止地址
			可选非终止状态的相关数据 = 识别器.取可选非终止状态的相关数据(状态)
			if not 可选非终止状态的相关数据:
				...
				pop
				子识别最终结果 = ???
				从子子识别器返回 = True
				continue
			[非终止状态的相关数据] = 可选非终止状态的相关数据
			可选子识别器及相关数据 = 非终止状态的相关数据.可选子识别器及相关数据
			if 从子子识别器返回:
				从子子识别器返回 = False
				[xxx] = 关联数据.可选前置指令序列结果
				关联数据.可选前置指令序列结果 = ()
				后置指令序列 = 非终止状态的相关数据.后置指令序列
				yyy = self._exec_post(ls, 后置指令序列=后置指令序列)
				识别器.处理子识别结果(状态=???, 可选中途高层值=???, 子识别最终结果=???, 前置指令序列结果=xxx, 后置指令序列结果=yyy)
				continue

			#=====正常进程
			前置指令序列 = 非终止状态的相关数据.前置指令序列
			xxx = self._exec_pre(ls, 前置指令序列=前置指令序列)
			if not 可选子识别器及相关数据:
				if 可选虚拟终止地址:
					[虚拟终止地址] = 可选虚拟终止地址
					assert 地址小于等于(输入缓存器.当前地址, 虚拟终止地址)
					_01 = not 地址相等(输入缓存器.当前地址, 虚拟终止地址)
				else:
					_01 = 1
				可选大阳符 = 输入缓存器.读取不多于(_01)
				if not 可选大阳符:
					识别最终结果 = 识别器.处理终止地址(状态=状态, 可选中途高层值=可选中途高层值, 前置指令序列结果=xxx)
					???
				else:
					[大阳符] = 可选大阳符
					识别中途结果 = 识别器.步进(状态=状态, 可选中途高层值=可选中途高层值, 大阳符=大阳符, 前置指令序列结果=xxx)
					???
			else:
				关联数据.可选前置指令序列结果 = (xxx,)
				[子识别器及相关数据] = 可选子识别器及相关数据
				(子识别器,子是否需要高层值, 可选虚拟终止地址名) = 子识别器及相关数据
				子形式锁死类型 = 非终止状态的相关数据.形式锁死类型
				子实际锁死类型 = 求子实际锁死类型(父实际锁死类型=关联数据.实际锁死类型, 父对子形式锁死类型=子形式锁死类型)
				可选虚拟终止地址 = 关联数据.命名地址存储器[可选虚拟终止地址名]
				self._push(ls, 识别器=子识别器, 实际锁死类型=子实际锁死类型, 是否需要高层值=可选中途高层值 and 子是否需要高层值, 可选虚拟终止地址=可选虚拟终止地址)
				???





