#__all__:goto
r'''[[[
round_robin_schedule
[[固化并迁移:
迁移至:
cp ./script/循环对抗赛配对方案.py ../../python3_src/seed/algo/round_robin_schedule.py
view ../../python3_src/seed/algo/round_robin_schedule.py
固化:
mv ./script/循环对抗赛配对方案.py ./script/循环对抗赛配对方案20240313.py
view ./script/循环对抗赛配对方案20240313.py
]]

e ./script/循环对抗赛配对方案.py
[:所有算法版本名]:goto
[:命令行冫输出到文件]:goto
[:二轮定理:循环赛配对方案中任意两轮赛事交错成环丶环长为偶数丶环长大于等于四]:goto
[:循环对抗赛配对方案尾二版算法大纲暨证明]:goto
    #递归
    #这是 首个 完整的递归算法冫循环赛配对方案
        #『首个』的前提是:不考虑:蛮力最小化版
    #尾二版
[:循环对抗赛配对方案平分版算法大纲暨证明]:goto
    #递归
    #这是 第二个 完整的递归算法冫循环赛配对方案
    #平分版
[:循环对抗赛配对方案位移辻对称版算法大纲暨证明]:goto
    #非递归#直接构造
    #这是 首个 完整的非递归算法冫循环赛配对方案
    #非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版

script.循环对抗赛配对方案
py -m nn_ns.app.debug_cmd   script.循环对抗赛配对方案 -x
py -m nn_ns.app.doctest_cmd script.循环对抗赛配对方案:__doc__
###py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=3
py_adhoc_call   script.循环对抗赛配对方案   ,构建冫循环对抗赛配对方案冖冖规则化冖冖尾二扌  --队伍数半数=3
py_adhoc_call   script.循环对抗赛配对方案   ,枚举冫循环对抗赛配对方案冖冖规则化扌 +欤扁平化冫配对方案 +欤输出冫队伍数总数 --版本名:尾二版  --鬽队伍数半数纟最大许可=3
py_adhoc_call   script.循环对抗赛配对方案   ,枚举冫循环对抗赛配对方案冖冖规则化扌 +欤扁平化冫配对方案 +欤输出冫队伍数总数 --版本名:平分版  --鬽队伍数半数纟最大许可=9
py_adhoc_call   script.循环对抗赛配对方案   ,枚举冫循环对抗赛配对方案冖冖规则化扌 +欤扁平化冫配对方案 +欤输出冫队伍数总数 +欤不输出冫奇数的队伍数半数 --版本名:非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版  --鬽队伍数半数纟最大许可=9
#失败#py_adhoc_call   script.循环对抗赛配对方案   ,枚举冫循环对抗赛配对方案冖冖规则化扌 +欤扁平化冫配对方案 +欤输出冫队伍数总数 --版本名:非递归冫交错位移日字绕圈版  --鬽队伍数半数纟最大许可=9

[[
循环赛
round robin
===
循环赛
现代汉语词典
xúnhuánsài
体育运动竞赛方式之一，参加者相互轮流比赛，按全部比赛中得分多少决定名次。
21世纪英汉汉英双向词典
1.a round match; a round robin
===
round robin
21世纪英汉汉英双向词典
<<可数名词>>
1 (为隐蔽署名者之次序而) 署名排列成圆形的请愿书 (等)
2 ((美)) (网球、西洋棋等的) 循环赛
在线英汉－汉英词典
循环赛；一系列；联名声明书
===
]]
[[
===
对抗赛
现代汉语词典
duìkàngsài
两个或几个技术水平相近单位之间组织的单项体育运动比赛。
21世纪英汉汉英双向词典
1.a championship contest
===
championship
21世纪英汉汉英双向词典
champion.ship
<<名词>>
1 (U) (对人、主义、主张、运动的) 拥护,支持
2 (C)优胜者 [冠军] 的地位
win [lose] a world swimming ~
获得[失去]世界游泳冠军
the ~ flag [cup]
优胜锦旗 [奖杯]
3 (C)[常 ~s]锦标赛,冠军赛
the world tennis ~ for 1985-1985
年世界网球锦标赛
在线英汉－汉英词典
n. 锦标赛,冠军赛 冠军的地位(称号、等级、保持称号的时期) 维护;支持
===
contest
新世纪英汉科技大词典
竞
竞
竞赛
竞赛
21世纪英汉汉英双向词典
con.test
(`kBntZst; 5kCntest)`14`《源自拉丁文“共同作证”的意思》
<<可数名词>>
1 (为夺取胜利或奖赏的) 竞争; 竞技,竞赛,比赛
win a beauty~
在选美中获胜
a speech ~
演讲比赛
2 斗争,抗争; 争议,争论
a bloody ~ for power
血腥的权力斗争
(kEn`tZst; kEn5test)
<<及物动词>>
((文语))
1 争取 <胜利、奖赏、议员席等>
~ a seat in Parliament (
选举时) 争取国会议席
2 a. 议论
~ a suit
争讼
b. 对 <选举、决定等的结果> 提出异议,怀疑…的正当性
<<不及物动词>>
((文语))争 [求…] ; 互相争
论; 竞争[with, against][for]
~ with [against] one's rival (for a prize)
与对手争 (奖)
在线英汉－汉英词典
vt. 争辩；提出质疑vi. 竞争；争辩
===
]]
[[
round_robin_schedule
===
方案
21世纪英汉汉英双向词典
1.[Formal] a plan; a program
2.a scheme; a formula; a proposal
新世纪汉英科技大词典
programme
scheme
version
===
调度schedule
21世纪英汉汉英双向词典
1.to dispatch (buses, trains, etc.)
2.[Military] to deploy
新世纪汉英科技大词典
dispatching
scheduling
===
配对mate
21世纪英汉汉英双向词典
1.to pair; to make a pair; to mate; to match
新世纪汉英科技大词典
association
matched pair
mating partner
===
]]


mate_schedule

====
[[[
===
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=1
[1, 0]
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=2
[1, 0, 3, 2]
[2, 3, 0, 1]
[3, 2, 1, 0]
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=3
[1, 0, 3, 2, 5, 4]
[2, 4, 0, 5, 1, 3]
[3, 5, 4, 0, 2, 1]
[4, 3, 5, 1, 0, 2]
[5, 2, 1, 4, 3, 0]
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=4
[1, 0, 3, 2, 5, 4, 7, 6]
[2, 3, 0, 1, 6, 7, 4, 5]
[3, 2, 1, 0, 7, 6, 5, 4]
[4, 5, 6, 7, 0, 1, 2, 3]
[5, 4, 7, 6, 1, 0, 3, 2]
[6, 7, 4, 5, 2, 3, 0, 1]
[7, 6, 5, 4, 3, 2, 1, 0]
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=5
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8]
[2, 3, 0, 1, 6, 8, 4, 9, 5, 7]
[3, 2, 1, 0, 7, 9, 8, 4, 6, 5]
[4, 5, 6, 9, 0, 1, 2, 8, 7, 3]
[5, 4, 7, 8, 1, 0, 9, 2, 3, 6]
[6, 7, 8, 5, 9, 3, 0, 1, 2, 4]
[7, 8, 9, 4, 3, 6, 5, 0, 1, 2]
[8, 9, 4, 6, 2, 7, 3, 5, 0, 1]
[9, 6, 5, 7, 8, 2, 1, 3, 4, 0]
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=7
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12]
[2, 3, 0, 1, 6, 7, 4, 5, 10, 12, 8, 13, 9, 11]
[3, 2, 1, 0, 7, 6, 5, 4, 11, 13, 12, 8, 10, 9]
[4, 5, 6, 7, 0, 1, 2, 3, 12, 11, 13, 9, 8, 10]
[5, 4, 7, 6, 1, 0, 3, 2, 13, 10, 9, 12, 11, 8]
[6, 8, 9, 10, 11, 12, 0, 13, 1, 2, 3, 4, 5, 7]
[7, 9, 8, 11, 10, 13, 12, 0, 2, 1, 4, 3, 6, 5]
[8, 6, 10, 9, 13, 11, 1, 12, 0, 3, 2, 5, 7, 4]
[9, 7, 11, 8, 12, 10, 13, 1, 3, 0, 5, 2, 4, 6]
[10, 12, 4, 13, 2, 8, 9, 11, 5, 6, 0, 7, 1, 3]
[11, 13, 5, 12, 8, 2, 10, 9, 4, 7, 6, 0, 3, 1]
[12, 10, 13, 4, 3, 9, 11, 8, 7, 5, 1, 6, 0, 2]
[13, 11, 12, 5, 9, 3, 8, 10, 6, 4, 7, 1, 2, 0]
$ py_adhoc_call   script.循环对抗赛配对方案   ,蛮力搜索冫循环对抗赛配对方案冖冖最小化扌  --队伍数半数=9
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16]
[2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 16, 12, 17, 13, 15]
[3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 17, 16, 12, 14, 13]
[4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 17, 8, 9, 10, 16, 15, 11]
[5, 4, 7, 6, 1, 0, 3, 2, 13, 12, 15, 16, 9, 8, 17, 10, 11, 14]
[6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 16, 13, 17, 11, 8, 9, 10, 12]
[7, 6, 5, 4, 3, 2, 1, 0, 15, 16, 17, 12, 11, 14, 13, 8, 9, 10]
[8, 9, 10, 11, 12, 14, 16, 17, 0, 1, 2, 3, 4, 15, 5, 13, 6, 7]
[9, 8, 11, 10, 13, 15, 17, 14, 1, 0, 3, 2, 16, 4, 7, 5, 12, 6]
[10, 11, 8, 12, 14, 13, 15, 16, 2, 17, 0, 1, 3, 5, 4, 6, 7, 9]
[11, 10, 9, 13, 15, 16, 14, 12, 17, 2, 1, 0, 7, 3, 6, 4, 5, 8]
[12, 13, 14, 8, 16, 17, 9, 10, 3, 6, 7, 15, 0, 1, 2, 11, 4, 5]
[13, 12, 15, 14, 17, 9, 10, 11, 16, 5, 6, 7, 1, 0, 3, 2, 8, 4]
[14, 15, 16, 17, 8, 11, 12, 9, 4, 7, 13, 5, 6, 10, 0, 1, 2, 3]
[15, 14, 17, 16, 9, 8, 11, 13, 5, 4, 12, 6, 10, 7, 1, 0, 3, 2]
[16, 17, 12, 15, 11, 10, 13, 8, 7, 14, 5, 4, 2, 6, 9, 3, 0, 1]
[17, 16, 13, 9, 10, 12, 8, 15, 6, 3, 4, 14, 5, 2, 11, 7, 1, 0]
===
]]]

[[[
===
>>> from seed.iters.apply_may_args4islice_ import list_islice_, show_islice_, stable_show_islice_, stable_list_islice_
>>> 鬽队伍数半数纟最大许可 = None
>>> 队伍数半数纟最小许可 = 1
>>> 欤不输出冫奇数的队伍数半数 = False
>>> 欤不输出冫偶数的队伍数半数 = False
>>> 欤不输出冫非二幂的队伍数半数 = False
>>> 欤不输出冫非二幂加一的队伍数半数 = False

[choose(4;0) == 1]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals()))
[1, 2, 3, 4, 5, 6, 7, 8, 9]


[choose(4;1) == 4]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True))
[2, 4, 6, 8, 10, 12, 14, 16, 18]


>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True))
[1, 3, 5, 7, 9, 11, 13, 15, 17]


>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫非二幂的队伍数半数=True))
[1, 2, 4, 8, 16, 32, 64, 128, 256]


>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫非二幂加一的队伍数半数=True))
[2, 3, 5, 9, 17, 33, 65, 129, 257]



[choose(4;2) == 6]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫偶数的队伍数半数=True))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫非二幂的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True))
[1]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[2]

>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True))
[2, 4, 8, 16, 32, 64, 128, 256, 512]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[3, 5, 9, 17, 33, 65, 129, 257, 513]






[choose(4;3) == 4]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[]




[choose(4;4) == 1]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True))
[]




鬽队伍数半数纟最大许可
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 鬽队伍数半数纟最大许可=5))
[1, 2, 3, 4, 5]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 鬽队伍数半数纟最大许可=5, 队伍数半数纟最小许可=5))
[5]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 鬽队伍数半数纟最大许可=5, 队伍数半数纟最小许可=6))
[]


>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=1, 队伍数半数纟最小许可=1))
[1]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=2, 队伍数半数纟最小许可=2))
[2]


>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=9, 队伍数半数纟最小许可=2))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=9, 队伍数半数纟最小许可=3))
[]

>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=0, 队伍数半数纟最小许可=0))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=1, 队伍数半数纟最小许可=1))
[]



>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=3, 队伍数半数纟最小许可=2))
[2]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=4, 队伍数半数纟最小许可=3))
[3]

>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=4, 队伍数半数纟最小许可=2))
[2, 4]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=5, 队伍数半数纟最小许可=3))
[3, 5]

>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=3, 队伍数半数纟最小许可=3))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=4, 队伍数半数纟最小许可=4))
[]

>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=4, 队伍数半数纟最小许可=3))
[4]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=5, 队伍数半数纟最小许可=4))
[5]

>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫奇数的队伍数半数=True, 欤不输出冫非二幂的队伍数半数=True, 鬽队伍数半数纟最大许可=1, 队伍数半数纟最小许可=1))
[]
>>> list_islice_(9, 枚举冫队伍数半数巛变量环境扌(locals(), 欤不输出冫偶数的队伍数半数=True, 欤不输出冫非二幂加一的队伍数半数=True, 鬽队伍数半数纟最大许可=2, 队伍数半数纟最小许可=2))
[]


===
]]]

[[[
===
py_adhoc_call   script.循环对抗赛配对方案   ,枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌  --鬽队伍数半数纟最大许可=9 +欤扁平化冫配对方案 +欤输出冫队伍数总数
===
>>> def print_iter(it, /):
...     for x in it:print(x)
>>> print_iter(枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌(鬽队伍数半数纟最大许可=9, 欤扁平化冫配对方案=True, 欤输出冫队伍数总数=True))
2
[1, 0]
4
[1, 0, 3, 2]
[2, 3, 0, 1]
[3, 2, 1, 0]
6
[1, 0, 3, 2, 5, 4]
[2, 4, 0, 5, 1, 3]
[3, 5, 4, 0, 2, 1]
[4, 3, 5, 1, 0, 2]
[5, 2, 1, 4, 3, 0]
8
[1, 0, 3, 2, 5, 4, 7, 6]
[2, 3, 0, 1, 6, 7, 4, 5]
[3, 2, 1, 0, 7, 6, 5, 4]
[4, 5, 6, 7, 0, 1, 2, 3]
[5, 6, 7, 4, 3, 0, 1, 2]
[6, 7, 4, 5, 2, 3, 0, 1]
[7, 4, 5, 6, 1, 2, 3, 0]
10
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8]
[2, 4, 0, 5, 1, 3, 8, 9, 6, 7]
[3, 5, 4, 0, 2, 1, 9, 8, 7, 6]
[4, 9, 6, 7, 0, 8, 2, 3, 5, 1]
[5, 6, 8, 9, 7, 0, 1, 4, 2, 3]
[6, 3, 7, 1, 8, 9, 0, 2, 4, 5]
[7, 8, 5, 6, 9, 2, 3, 0, 1, 4]
[8, 7, 9, 4, 3, 6, 5, 1, 0, 2]
[9, 2, 1, 8, 6, 7, 4, 5, 3, 0]
12
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10]
[2, 4, 0, 5, 1, 3, 8, 10, 6, 11, 7, 9]
[3, 5, 4, 0, 2, 1, 9, 11, 10, 6, 8, 7]
[4, 3, 5, 1, 0, 2, 10, 9, 11, 7, 6, 8]
[5, 2, 1, 4, 3, 0, 11, 8, 7, 10, 9, 6]
[6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]
[7, 8, 9, 10, 11, 6, 5, 0, 1, 2, 3, 4]
[8, 9, 10, 11, 6, 7, 4, 5, 0, 1, 2, 3]
[9, 10, 11, 6, 7, 8, 3, 4, 5, 0, 1, 2]
[10, 11, 6, 7, 8, 9, 2, 3, 4, 5, 0, 1]
[11, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 0]
14
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12]
[2, 3, 0, 1, 6, 7, 4, 5, 10, 12, 8, 13, 9, 11]
[3, 2, 1, 0, 7, 6, 5, 4, 11, 13, 12, 8, 10, 9]
[4, 5, 6, 7, 0, 1, 2, 3, 12, 11, 13, 9, 8, 10]
[5, 6, 7, 4, 3, 0, 1, 2, 13, 10, 9, 12, 11, 8]
[6, 8, 9, 10, 12, 13, 0, 11, 1, 2, 3, 7, 4, 5]
[7, 11, 12, 13, 8, 9, 10, 0, 4, 5, 6, 1, 2, 3]
[8, 9, 10, 5, 13, 3, 11, 12, 0, 1, 2, 6, 7, 4]
[9, 10, 4, 8, 2, 11, 12, 13, 3, 0, 1, 5, 6, 7]
[10, 7, 8, 9, 11, 12, 13, 1, 2, 3, 0, 4, 5, 6]
[11, 12, 13, 6, 9, 10, 3, 8, 7, 4, 5, 0, 1, 2]
[12, 13, 5, 11, 10, 2, 8, 9, 6, 7, 4, 3, 0, 1]
[13, 4, 11, 12, 1, 8, 9, 10, 5, 6, 7, 2, 3, 0]
16
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14]
[2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13]
[3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12]
[4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11]
[5, 6, 7, 4, 3, 0, 1, 2, 13, 14, 15, 12, 11, 8, 9, 10]
[6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9]
[7, 4, 5, 6, 1, 2, 3, 0, 15, 12, 13, 14, 9, 10, 11, 8]
[8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7]
[9, 10, 11, 12, 13, 14, 15, 8, 7, 0, 1, 2, 3, 4, 5, 6]
[10, 11, 12, 13, 14, 15, 8, 9, 6, 7, 0, 1, 2, 3, 4, 5]
[11, 12, 13, 14, 15, 8, 9, 10, 5, 6, 7, 0, 1, 2, 3, 4]
[12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3]
[13, 14, 15, 8, 9, 10, 11, 12, 3, 4, 5, 6, 7, 0, 1, 2]
[14, 15, 8, 9, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 0, 1]
[15, 8, 9, 10, 11, 12, 13, 14, 1, 2, 3, 4, 5, 6, 7, 0]
18
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16]
[2, 4, 0, 5, 1, 3, 8, 9, 6, 7, 12, 13, 10, 11, 16, 17, 14, 15]
[3, 5, 4, 0, 2, 1, 9, 8, 7, 6, 13, 12, 11, 10, 17, 16, 15, 14]
[4, 9, 6, 7, 0, 8, 2, 3, 5, 1, 14, 15, 16, 17, 10, 11, 12, 13]
[5, 6, 8, 9, 7, 0, 1, 4, 2, 3, 15, 16, 17, 14, 13, 10, 11, 12]
[6, 3, 7, 1, 8, 9, 0, 2, 4, 5, 16, 17, 14, 15, 12, 13, 10, 11]
[7, 8, 5, 6, 9, 2, 3, 0, 1, 4, 17, 14, 15, 16, 11, 12, 13, 10]
[8, 17, 10, 11, 15, 16, 12, 13, 0, 14, 2, 3, 6, 7, 9, 4, 5, 1]
[9, 10, 14, 15, 12, 13, 16, 17, 11, 0, 1, 8, 4, 5, 2, 3, 6, 7]
[10, 7, 11, 12, 16, 17, 13, 1, 14, 15, 0, 2, 3, 6, 8, 9, 4, 5]
[11, 14, 12, 13, 17, 6, 5, 10, 15, 16, 7, 0, 2, 3, 1, 8, 9, 4]
[12, 15, 13, 4, 3, 14, 10, 11, 16, 17, 6, 7, 0, 2, 5, 1, 8, 9]
[13, 16, 9, 10, 14, 15, 11, 12, 17, 2, 3, 6, 7, 0, 4, 5, 1, 8]
[14, 11, 15, 16, 13, 7, 17, 5, 12, 10, 9, 1, 8, 4, 0, 2, 3, 6]
[15, 12, 16, 17, 6, 10, 4, 14, 13, 11, 5, 9, 1, 8, 7, 0, 2, 3]
[16, 13, 17, 8, 10, 11, 14, 15, 3, 12, 4, 5, 9, 1, 6, 7, 0, 2]
[17, 2, 1, 14, 11, 12, 15, 16, 10, 13, 8, 4, 5, 9, 3, 6, 7, 0]


===
>>> print_iter(枚举冫循环对抗赛配对方案冖冖规则化扌(版本名='蛮力最小化版', 鬽队伍数半数纟最大许可=9, 欤扁平化冫配对方案=True, 欤输出冫队伍数总数=True, 欤标准压缩=True))
2
4
[[0, 2, 1, 3]]
6
[[0, 2, 4, 1, 5, 3]]
[[0, 4, 3, 1, 2, 5]]
8
[[0, 2, 1, 3], [4, 6, 5, 7]]
[[0, 4, 1, 5], [2, 6, 3, 7]]
[[0, 6, 1, 7], [2, 4, 3, 5]]
10
[[0, 2, 1, 3], [4, 6, 8, 5, 9, 7]]
[[0, 4, 1, 5], [2, 6, 9, 3, 8, 7]]
[[0, 6, 5, 3, 4, 9, 2, 8, 1, 7]]
[[0, 8, 4, 2, 5, 7, 3, 6, 1, 9]]
12
[[0, 2, 1, 3], [4, 6, 5, 7], [8, 10, 9, 11]]
[[0, 4, 1, 5], [2, 8, 3, 9], [6, 10, 7, 11]]
[[0, 6, 1, 7], [2, 10, 3, 11], [4, 8, 5, 9]]
[[0, 8, 1, 9], [2, 6, 3, 7], [4, 10, 5, 11]]
[[0, 10, 1, 11], [2, 4, 3, 5], [6, 8, 7, 9]]
14
[[0, 2, 1, 3], [4, 6, 5, 7], [8, 10, 12, 9, 13, 11]]
[[0, 4, 1, 5], [2, 6, 3, 7], [8, 12, 11, 9, 10, 13]]
[[0, 6, 12, 5, 13, 7], [1, 8, 2, 9], [3, 10, 4, 11]]
[[0, 8, 3, 9], [1, 6, 13, 4, 12, 7], [2, 10, 5, 11]]
[[0, 10, 6, 9, 7, 11], [1, 12, 3, 13], [2, 4, 8, 5]]
[[0, 12, 2, 13], [1, 10, 7, 8, 6, 11], [3, 4, 9, 5]]
16
[[0, 2, 1, 3], [4, 6, 5, 7], [8, 10, 9, 11], [12, 14, 13, 15]]
[[0, 4, 1, 5], [2, 6, 3, 7], [8, 12, 9, 13], [10, 14, 11, 15]]
[[0, 6, 1, 7], [2, 4, 3, 5], [8, 14, 9, 15], [10, 12, 11, 13]]
[[0, 8, 1, 9], [2, 10, 3, 11], [4, 12, 5, 13], [6, 14, 7, 15]]
[[0, 10, 1, 11], [2, 8, 3, 9], [4, 14, 5, 15], [6, 12, 7, 13]]
[[0, 12, 1, 13], [2, 14, 3, 15], [4, 8, 5, 9], [6, 10, 7, 11]]
[[0, 14, 1, 15], [2, 12, 3, 13], [4, 10, 5, 11], [6, 8, 7, 9]]
18
[[0, 2, 1, 3], [4, 6, 5, 7], [8, 10, 9, 11], [12, 14, 16, 13, 17, 15]]
[[0, 4, 1, 5], [2, 6, 3, 7], [8, 12, 9, 13], [10, 14, 17, 11, 16, 15]]
[[0, 6, 1, 7], [2, 4, 3, 5], [8, 14, 13, 11, 12, 17, 10, 16, 9, 15]]
[[0, 8, 1, 9], [2, 10, 3, 11], [4, 12, 16, 6, 17, 7, 14, 5, 15, 13]]
[[0, 10, 1, 11], [2, 8, 17, 9], [3, 12, 7, 16, 5, 13], [4, 14, 6, 15]]
[[0, 12, 1, 13], [2, 14, 3, 8, 16, 4, 17, 5, 9, 6, 10, 7, 11, 15]]
[[0, 14, 1, 15], [2, 16, 3, 17], [4, 8, 5, 11, 6, 12, 10, 13, 7, 9]]
[[0, 16, 1, 17], [2, 12, 5, 10, 4, 11, 14, 9, 3, 15, 7, 8, 6, 13]]

[:二轮定理:循环赛配对方案中任意两轮赛事交错成环丶环长为偶数丶环长大于等于四]:goto
>>> print_iter(枚举冫循环对抗赛配对方案冖冖规则化扌(版本名='蛮力最小化版', 鬽队伍数半数纟最大许可=9, 欤扁平化冫配对方案=True, 欤输出冫队伍数总数=True, 欤标准压缩=True, 欤紧凑文本化=True))
2
4
[0,2,1,3;]
6
[0,2,4,1,5,3;]
[0,4,3,1,2,5;]
8
[0,2,1,3;4,6,5,7;]
[0,4,1,5;2,6,3,7;]
[0,6,1,7;2,4,3,5;]
10
[0,2,1,3;4,6,8,5,9,7;]
[0,4,1,5;2,6,9,3,8,7;]
[0,6,5,3,4,9,2,8,1,7;]
[0,8,4,2,5,7,3,6,1,9;]
12
[0,2,1,3;4,6,5,7;8,10,9,11;]
[0,4,1,5;2,8,3,9;6,10,7,11;]
[0,6,1,7;2,10,3,11;4,8,5,9;]
[0,8,1,9;2,6,3,7;4,10,5,11;]
[0,10,1,11;2,4,3,5;6,8,7,9;]
14
[0,2,1,3;4,6,5,7;8,10,12,9,13,11;]
[0,4,1,5;2,6,3,7;8,12,11,9,10,13;]
[0,6,12,5,13,7;1,8,2,9;3,10,4,11;]
[0,8,3,9;1,6,13,4,12,7;2,10,5,11;]
[0,10,6,9,7,11;1,12,3,13;2,4,8,5;]
[0,12,2,13;1,10,7,8,6,11;3,4,9,5;]
16
[0,2,1,3;4,6,5,7;8,10,9,11;12,14,13,15;]
[0,4,1,5;2,6,3,7;8,12,9,13;10,14,11,15;]
[0,6,1,7;2,4,3,5;8,14,9,15;10,12,11,13;]
[0,8,1,9;2,10,3,11;4,12,5,13;6,14,7,15;]
[0,10,1,11;2,8,3,9;4,14,5,15;6,12,7,13;]
[0,12,1,13;2,14,3,15;4,8,5,9;6,10,7,11;]
[0,14,1,15;2,12,3,13;4,10,5,11;6,8,7,9;]
18
[0,2,1,3;4,6,5,7;8,10,9,11;12,14,16,13,17,15;]
[0,4,1,5;2,6,3,7;8,12,9,13;10,14,17,11,16,15;]
[0,6,1,7;2,4,3,5;8,14,13,11,12,17,10,16,9,15;]
[0,8,1,9;2,10,3,11;4,12,16,6,17,7,14,5,15,13;]
[0,10,1,11;2,8,17,9;3,12,7,16,5,13;4,14,6,15;]
[0,12,1,13;2,14,3,8,16,4,17,5,9,6,10,7,11,15;]
[0,14,1,15;2,16,3,17;4,8,5,11,6,12,10,13,7,9;]
[0,16,1,17;2,12,5,10,4,11,14,9,3,15,7,8,6,13;]

===
]]]
[[[
[:所有算法版本名]:here
===
>>> print_iter(列表化冫所有版本名扌())
尾二版
平分版
蛮力最小化版
非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版
非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版
非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版
非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版
>>> print_iter(枚举冫循环对抗赛配对方案冖冖规则化扌(版本名='尾二版', 鬽队伍数半数纟最大许可=2, 欤扁平化冫配对方案=True, 欤输出冫队伍数总数=True, 欤紧凑文本化=True))
2
[[1,0]
]
4
[[1,0,3,2]
,[2,3,0,1]
,[3,2,1,0]
]
>>> for 版本名 in 列表化冫所有版本名扌():
...     print(版本名)
...     for n in range(3,5):#主要是因为部分构造器不完整:
...         print(f'队伍数半数:={n}')
...         try:
...             print_iter(枚举冫循环对抗赛配对方案冖冖规则化扌(版本名=版本名, 鬽队伍数半数纟最大许可=n, 队伍数半数纟最小许可=n, 欤扁平化冫配对方案=True, 欤紧凑文本化=True))
...         except TypeError as e:
...             print('TypeError:', e)
尾二版
队伍数半数:=3
[[1,0,3,2,5,4]
,[2,4,0,5,1,3]
,[3,5,4,0,2,1]
,[4,3,5,1,0,2]
,[5,2,1,4,3,0]
]
队伍数半数:=4
[[1,0,3,2,5,4,7,6]
,[2,3,0,1,6,7,4,5]
,[3,2,1,0,7,6,5,4]
,[4,5,6,7,0,1,2,3]
,[5,6,7,4,3,0,1,2]
,[6,7,4,5,2,3,0,1]
,[7,4,5,6,1,2,3,0]
]
平分版
队伍数半数:=3
[[1,0,5,4,3,2]
,[2,4,0,5,1,3]
,[3,2,1,0,5,4]
,[4,5,3,2,0,1]
,[5,3,4,1,2,0]
]
队伍数半数:=4
[[1,0,3,2,5,4,7,6]
,[2,3,0,1,6,7,4,5]
,[3,2,1,0,7,6,5,4]
,[4,5,6,7,0,1,2,3]
,[5,6,7,4,3,0,1,2]
,[6,7,4,5,2,3,0,1]
,[7,4,5,6,1,2,3,0]
]
蛮力最小化版
队伍数半数:=3
[[1,0,3,2,5,4]
,[2,4,0,5,1,3]
,[3,5,4,0,2,1]
,[4,3,5,1,0,2]
,[5,2,1,4,3,0]
]
队伍数半数:=4
[[1,0,3,2,5,4,7,6]
,[2,3,0,1,6,7,4,5]
,[3,2,1,0,7,6,5,4]
,[4,5,6,7,0,1,2,3]
,[5,4,7,6,1,0,3,2]
,[6,7,4,5,2,3,0,1]
,[7,6,5,4,3,2,1,0]
]
非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版
队伍数半数:=3
TypeError: 前置条件:[is_even 队伍数半数]
队伍数半数:=4
[[6,5,4,7,2,1,0,3]
,[2,7,0,5,6,3,4,1]
,[4,3,6,1,0,7,2,5]
,[1,0,7,6,5,4,3,2]
,[3,2,1,0,7,6,5,4]
,[5,4,3,2,1,0,7,6]
,[7,6,5,4,3,2,1,0]
]
非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版
队伍数半数:=3
TypeError: 前置条件:[is_even 队伍数半数]
队伍数半数:=4
[[1,0,3,2,5,4,7,6]
,[3,6,5,0,7,2,1,4]
,[5,4,7,6,1,0,3,2]
,[7,2,1,4,3,6,5,0]
,[6,5,4,7,2,1,0,3]
,[2,7,0,5,6,3,4,1]
,[4,3,6,1,0,7,2,5]
]
非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版
队伍数半数:=3
[[1,0,3,2,5,4]
,[5,2,1,4,3,0]
,[3,5,4,0,2,1]
,[2,4,0,5,1,3]
,[4,3,5,1,0,2]
]
队伍数半数:=4
[[1,0,3,2,5,4,7,6]
,[3,6,5,0,7,2,1,4]
,[5,4,7,6,1,0,3,2]
,[7,2,1,4,3,6,5,0]
,[6,5,4,7,2,1,0,3]
,[2,7,0,5,6,3,4,1]
,[4,3,6,1,0,7,2,5]
]
非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版
队伍数半数:=3
[[1,0,3,2,5,4]
,[5,2,1,4,3,0]
,[3,5,4,0,2,1]
,[2,4,0,5,1,3]
,[4,3,5,1,0,2]
]
队伍数半数:=4
TypeError: 前置条件:[is_odd 队伍数半数]
>>> def 鬽结果扌(版本名,队伍数半数,/):
...     try:
...         return 构建冫循环对抗赛配对方案冖冖规则化冖冖易用接口扌(版本名=版本名, 队伍数半数=队伍数半数)
...     except TypeError:
...         return None
>>> def 对比结果扌(版本名纟甲,版本名纟乙,队伍数半数,/):
...     if 版本名纟甲 == 版本名纟乙:
...         return '-'
...     鬽配对方案纟甲 = 鬽结果扌(版本名纟甲, 队伍数半数)
...     鬽配对方案纟乙 = 鬽结果扌(版本名纟乙, 队伍数半数)
...     return str(int(鬽配对方案纟甲 == 鬽配对方案纟乙))
>>> def 对比结果冫所有版本扌(队伍数半数,/):
...     列表纟版本名 = 列表化冫所有版本名扌()
...     #js = range(len(列表纟版本名))
...     for 版本名纟甲 in 列表纟版本名:
...         ss = (对比结果扌(版本名纟甲,版本名纟乙,队伍数半数) for 版本名纟乙 in 列表纟版本名)
...         s = ''.join(ss)
...         print(f'{版本名纟甲}:{s}')
>>> 对比结果冫所有版本扌(队伍数半数:=3)
尾二版:-010000
平分版:0-00000
蛮力最小化版:10-0000
非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版:000-100
非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版:0001-00
非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版:00000-1
非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版:000001-
>>> 对比结果冫所有版本扌(队伍数半数:=4)
尾二版:-100000
平分版:1-00000
蛮力最小化版:00-0000
非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版:000-000
非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版:0000-10
非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版:00001-0
非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版:000000-

上面证明:各版本算法并不等同


===
]]]
[[[
#失败#蛮力搜索冫只差一对的拟遍历圈纟循环对抗赛配对方案冖冖扩张预备扌
===
#失败#>>> for 配对方案 in 枚举冫循环对抗赛配对方案冖冖规则化扌(版本名='蛮力最小化版', 鬽队伍数半数纟最大许可=9): 蛮力搜索冫只差一对的拟遍历圈纟循环对抗赛配对方案冖冖扩张预备扌(配对方案)

===
]]]
[[[
#py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌 +欤读取 --输出路径:./script/循环对抗赛配对方案.py.out.txt  +verbose --队伍数半数纟最大许可=6
#py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌 +欤读取 --输出路径:./script/循环对抗赛配对方案.py.out.txt  +verbose --队伍数半数纟最大许可=9
#py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌 +欤读取 --输出路径:./script/循环对抗赛配对方案.py.out.txt  +verbose --队伍数半数纟最大许可=20
#py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌 +欤读取 --输出路径:./script/循环对抗赛配对方案.py.out.txt  +verbose --队伍数半数纟最大许可=36
###py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌 +欤读取 --输出路径:./script/循环对抗赛配对方案.py.out.txt  --队伍数半数纟最大许可=256 +verbose
view ./script/循环对抗赛配对方案.py.out.txt
rm ./script/循环对抗赛配对方案.py.out.txt
du -h ./script/循环对抗赛配对方案.py.out.txt
52MB #[队伍数半数<-[1..=206]]
101MB #[队伍数半数<-[1..=256]]
44KB #[队伍数半数<-[1..=20]]
240KB #[队伍数半数<-[1..=36]]
116KB #[队伍数半数<-[1,3..<36]]
    #未删空格前

[:命令行冫输出到文件]:here
===
py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化扌 +欤读取 --版本名:尾二版 --输出路径:./script/循环对抗赛配对方案.py.尾二版.仅奇半数.out.txt  +verbose +欤不输出冫偶数的队伍数半数 --队伍数半数纟最大许可=36
view ./script/循环对抗赛配对方案.py.尾二版.仅奇半数.out.txt
du -h ./script/循环对抗赛配对方案.py.尾二版.仅奇半数.out.txt
88KB #[队伍数半数<-[1,3..<36]]
    #删空格后
===
py_adhoc_call   script.循环对抗赛配对方案   @输出枚举冫循环对抗赛配对方案冖冖规则化扌 +欤读取 --版本名:平分版 --输出路径:./script/循环对抗赛配对方案.py.平分版.仅奇半数.out.txt  +verbose +欤不输出冫偶数的队伍数半数 --队伍数半数纟最大许可=36
view ./script/循环对抗赛配对方案.py.平分版.仅奇半数.out.txt
du -h ./script/循环对抗赛配对方案.py.平分版.仅奇半数.out.txt
88KB #[队伍数半数<-[1,3..<36]]
    #删空格后
diff    ./script/循环对抗赛配对方案.py.尾二版.仅奇半数.out.txt    ./script/循环对抗赛配对方案.py.平分版.仅奇半数.out.txt
5c5
< [[1,0,3,2,5,4]
---
> [[1,0,5,4,3,2]
7,9c7,9
... ...
##补偿:]]
du -h ./script/循环对抗赛配对方案.py
52KB
128KB
===
]]]
[[[
===
仅限于 奇数 队伍数半数(2*v+1):
    哪个奇数拆分后生成大量其他奇数？
    哪些奇数拆分后生成的奇数重叠最少？
===
尾二版:
总数:(2*v+1)*2 --> (2*v+2)+(2*v)
半数:(2*v+1) --> (v+1)+(v)
* [v == 2*u]:
    半数:(2*v+1) --> (v+1)+(v)
    半数:(4*u+1) --> (2*u+1)+2*(u)
    半半数:(2*u+1) --> (u+1)+(u)
        (u) 重复
    只需考虑:(4*u+1) --> (2*u+1)
* [v == 2*u+1]:
    半数:(2*v+1) --> (v+1)+(v)
    半数:(4*u+3) --> 2*(u+1)+(2*u+1)
    半半数:(2*u+1) --> (u+1)+(u)
        (u+1) 重复
    只需考虑:(4*u+3) --> (2*u+1)
只需考虑:(2*v+1) --> ((2*v+1)//4*2+1)
只需考虑:(2*u+1) <-- {(4*u+1),(4*u+3)}

===
平分版:
总数:(2*v+1)*2
半数:(2*v+1)
虚胖总数:(2*v+2) --> 2*(v+1)
虚胖半数:(v+1)
只需考虑:(2*v+1) --> (v+1)
只需考虑:(2*v+1) --> ((2*v+1)//2*2+1)
* [v == 2*u]:
    半数:(2*v+1) == (4*u+1)
    虚胖半数:(v+1) == (2*u+1)
    只需考虑:(4*u+1) --> (2*u+1)
* [v == 2*u+1]:
    半数:(2*v+1) == (4*u+3)
    虚胖半数:(v+1) == (2*u+2) == 2*(u+1)
    只需考虑:(4*u+3) --> (u+1)
    #####
    [is_odd v]
    [(e,t) :=> [v+1 == 2**e *(2*t+1)]]
    !! [is_odd v]
    [e>=1]
    #####
    [v == 2**e *(2*t+1) -1 == (2**(e+1) *t +(2**e -1))]
    半数:(2*v+1) == (2**(e+2) *t +(2**(e+1) -1))
    虚胖半数:(v+1) == (2**e)*(2*t +1)
    只需考虑:(2**(e+1) *t +(2**e -1)) --> (2*t +1)
只需考虑:(2**(e+1) *t +(2**e -1)) --> (2*t +1)
只需考虑:(2*t +1) <-- (2**(e+1) *t +(2**e -1))
===
平分版+非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版:
* [总数 == 0bxxx00]:
    <==> [半数 == 0bxxx0]
    非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版:直接解决
* [总数 == 0bxxx10]:
    <==> [半数 == 0bxxx1]
    平分版:递归
    [虚胖总数 == 半数+1 == 0bxxx1+1 == 0bzzy0]
    [虚胖半数 == 0bzzy]
    * [总数 == 0bxx010]:
        <==> [半数 == 0bxx01]
        [虚胖总数 == 0bxx01+1 == 0bxx10]
        [虚胖半数 == 0bxx1]
        平分版:递归:继续深入
    * [总数 == 0bxx110]:
        <==> [半数 == 0bxx11]
        [虚胖总数 == 0bxx11+1 == 0bzy00]
        [虚胖半数 == 0bzy0]
        非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版:直接解决
==>>:
最麻烦的情形:
    [半数 == 0bxx01] --> [虚胖半数 == 0bxx1]
    [半数 == 0bxx0000001]
    [半数 == odd*2**e +1]
===
非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版:
    !! 是:完整的非递归算法冫循环赛配对方案
    => 无所谓麻不麻烦

===
]]]



#]]]'''
__all__ = r'''
检查冫圆满配对方案扌
列表化冫所有版本名扌

魖循环对抗赛配对方案冖冖规则化冖冖分而治之
    就地适配队伍号冫配对方案扌
    组间配对冖冖相同扌
    组间配对冖冖差一扌


输出枚举冫循环对抗赛配对方案冖冖规则化扌
    构建冫循环对抗赛配对方案冖冖规则化扌
        构建冫循环对抗赛配对方案冖冖规则化冖冖易用接口扌
            构建冫循环对抗赛配对方案巛变量环境扌
    枚举冫循环对抗赛配对方案冖冖规则化扌
        枚举冫队伍数半数扌
            枚举冫队伍数半数巛变量环境扌
        紧凑文本化冫配对方案扌
        紧凑文本化冫合并轮纟二轮扌
        合并冫二轮纟配对方案扌
            压缩冫配对方案扌
                标准压缩冫配对方案扌














欤二幂扌

蛮力检查冫非合数扌

魖循环对抗赛配对方案冖冖规则化冖冖分而治之
    乸循环对抗赛配对方案冖冖规则化冖冖尾二版
    乸循环对抗赛配对方案冖冖规则化冖冖平分版

乸循环对抗赛配对方案冖冖规则化冖冖尾二版
    输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌
        枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌
        构建冫循环对抗赛配对方案冖冖规则化冖冖尾二扌

构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌
构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称扌
    构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌
    构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌

蛮力搜索冫循环对抗赛配对方案冖冖最小化扌
'''.split()#'''
#失败:构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫交错位移日字绕圈扌
#   简单位移:只能用于二幂

__all__
from seed.tiny_.check import check_type_is, check_uint_lt, check_int_ge
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.math.floor_ceil import floor_log2, ceil_log2
from seed.tiny_.constants import inf
from itertools import count


def 蛮力搜索冫循环对抗赛配对方案冖冖最小化扌(*, 队伍数半数):
    n = 队伍数半数
    m = 队伍数总数 = 队伍数半数*2
    def f(j2j, js, j, /):
        '-> ok/bool'
        if j == m:
            return True
        if j in js:
            return f(j2j, js, j+1)
        i = j
        while 1:
            for i in range(i+1,m):
                if i in js:continue
                if i in j2js[j]:continue
                break
            else:
                return False
                raise Exception(n,m,j,lsls,j2j)
            j, i
            j2j[j] = i
            j2j[i] = j
            js.add(i)
            if f(j2j, js, j+1):
                return True
            j2j[j] = None
            j2j[i] = None
            js.remove(i)
        return False
    j2js = [{j} for j in range(m)]
        # j - 第j队
        # js - 已排除的队伍
    lsls = []
    for k in range(1, m):
        #第k轮
        j2j = [None]*m
        js = set()
        if not f(j2j, js, 0):
            raise Exception(n,m,lsls,j2j)
        lsls.append(j2j)
        for j,i in enumerate(j2j):
            j2js[j].add(i)
    检查冫圆满配对方案扌(队伍数半数, lsls)
    return lsls


def 检查冫圆满配对方案扌(鬽队伍数半数, 配对方案, /):
    '圆满-配对方案 :: [[int]]'
    try:
        _检查冫圆满配对方案扌(鬽队伍数半数, 配对方案)
    except Exception as e:
        raise TypeError(配对方案) from e
def _检查冫圆满配对方案扌(鬽队伍数半数, 配对方案, /):
    check_type_is(list, 配对方案)
    for 队伍号讠对手队伍号 in 配对方案:
        check_type_is(list, 队伍号讠对手队伍号)
    ######################

    队伍数总数 = 1+len(配对方案)
    if not 队伍数总数&1 == 0:raise TypeError
    队伍数半数 = 队伍数总数>>1
    for 队伍号讠对手队伍号 in 配对方案:
        if not len(队伍号讠对手队伍号) == 队伍数总数:raise TypeError
    ######################
    if not 鬽队伍数半数 is None:
        check_int_ge(1, 鬽队伍数半数)
    if not (鬽队伍数半数 is None or 鬽队伍数半数 == 队伍数半数):raise TypeError(鬽队伍数半数, 队伍数半数)
    ######################

    for 队伍号讠对手队伍号 in 配对方案:
        for 对手队伍号 in 队伍号讠对手队伍号:
            check_uint_lt(队伍数总数, 对手队伍号)
    ######################
    for 队伍号讠对手队伍号 in 配对方案:
        for 队伍号,对手队伍号 in enumerate(队伍号讠对手队伍号):
            if not 队伍号讠对手队伍号[对手队伍号] == 队伍号:raise TypeError
    ######################
    预期值 = [1]*队伍数总数
    for 队伍号 in range(队伍数总数):
        对手队伍号讠遭遇次数 = [0]*队伍数总数
        对手队伍号讠遭遇次数[队伍号] += 1
        for 队伍号讠对手队伍号 in 配对方案:
            对手队伍号 = 队伍号讠对手队伍号[队伍号]
            对手队伍号讠遭遇次数[对手队伍号] += 1
        if not 对手队伍号讠遭遇次数 == 预期值:raise TypeError(队伍号,对手队伍号讠遭遇次数)
    ######################
    return
    ######################
    ######################

def 就地适配队伍号冫配对方案扌(*, 新配对方案, 起始轮次纟适配, 旧配对方案, 旧队伍号讠新队伍号):
    '输入输出都是:未圆满-配对方案 :: [[may uint]]'
    for 轮次序号纟新, 队伍号讠鬽对手队伍号纟旧 in enumerate(旧配对方案, 起始轮次纟适配):
        队伍号讠鬽对手队伍号纟新 = 新配对方案[轮次序号纟新]
        for 队伍号纟旧,鬽对手队伍号纟旧 in enumerate(队伍号讠鬽对手队伍号纟旧):
            if 鬽对手队伍号纟旧 is None:continue
            对手队伍号纟旧 = 鬽对手队伍号纟旧
            队伍号纟新 = 旧队伍号讠新队伍号[队伍号纟旧]
            对手队伍号纟新 = 旧队伍号讠新队伍号[对手队伍号纟旧]
            assert 队伍号讠鬽对手队伍号纟新[队伍号纟新] is None
            队伍号讠鬽对手队伍号纟新[队伍号纟新] = 对手队伍号纟新
    return

def 组间配对冖冖相同扌(*, 队伍数纟每组, 欤最大当作最小队伍号纟第二组=False):
    '-> 圆满:配对方案/[[uint]]'
    n = 队伍数半数 = 队伍数纟每组
    m = 队伍数总数 = 队伍数半数*2
    第一组所有队伍号 = range(n)
    第二组所有队伍号 = range(n, m)
    配对方案 = [[*range(j,m), *range(n,j), *range(m-j,n), *range(0,m-j)] for j in 第二组所有队伍号]
    if 欤最大当作最小队伍号纟第二组:
        last = 配对方案.pop()
        配对方案.insert(0, last)
    return 配对方案
        # 轮次序号讠该轮配对
        # 轮次序号讠队伍号讠该轮对手队伍号
def _就地替换冫列表冖冖映射版扌(ls, old2new, /):
    Nothing = object()
    for j in range(len(ls)):
        old = ls[j]
        m = old2new.get(old, Nothing)
        if not m is Nothing:
            new = m
            ls[j] = new
    return
def _就地替换冫矩阵冖冖映射版扌(lsls, old2new, /):
    for ls in lsls:
        _就地替换冫列表冖冖映射版扌(ls, old2new)
def _就地替换冫矩阵扌(lsls, old, new, /):
    for ls in lsls:
        _就地替换冫列表扌(ls, old, new)
def _就地替换冫列表扌(ls, old, new, /):
    i = -1
    try:
        while 1:
            i = ls.index(old, i+1)
            ls[i] = new
    except ValueError:
        return ls
    raise 000
def 组间配对冖冖差一扌(*, 队伍数纟少, 欤轮空当作最小队伍号纟小组):
    '-> 未圆满:配对方案/[[may uint]]#大组队伍号排在前头'
    a = 队伍数纟少
    b = 队伍数纟多 = 队伍数纟少+1
    m = 队伍数总数 = 队伍数纟少 + 队伍数纟多
    未圆满冫配对方案 = 组间配对冖冖相同扌(队伍数纟每组=队伍数纟多, 欤最大当作最小队伍号纟第二组=欤轮空当作最小队伍号纟小组)
    m1 = m-1
    #_就地替换冫矩阵扌(未圆满冫配对方案, old:=m, new:=None)
    for 队伍号讠鬽对手队伍号 in 未圆满冫配对方案:
        j = 队伍号讠鬽对手队伍号.pop()
        #bug:assert 队伍号讠鬽对手队伍号[j] == m1, (a,b,m,m1,队伍号讠鬽对手队伍号, 未圆满冫配对方案)
        assert 队伍号讠鬽对手队伍号[j] == m
        队伍号讠鬽对手队伍号[j] = None
            # 遭遇 虚拟队伍=>轮空
    return 未圆满冫配对方案
class 魖循环对抗赛配对方案冖冖规则化冖冖分而治之(ABC):
    __slots__ = ()
    def __init__(sf, 队伍数半数讠配对方案=None, /):
        if not 队伍数半数讠配对方案:
            队伍数半数讠配对方案 = {1:[[1, 0]]}
        #n2mate_schedule
        sf.队伍数半数讠配对方案 = 队伍数半数讠配对方案
            #缓存
    def 构建冫循环对抗赛配对方案冖冖规则化扌(sf, /, *, 队伍数半数):
        return sf.recur_(队伍数半数)
    def recur_(sf, 队伍数半数, /):
        '-> 配对方案#含取自缓存'
        assert 队伍数半数 > 0
        if 0:
            if 队伍数半数 == 1:
                配对方案 = [[1, 0]]
                return 配对方案
        队伍数半数讠配对方案 = sf.队伍数半数讠配对方案
        if not 队伍数半数 in 队伍数半数讠配对方案:
            assert 队伍数半数 >= 2
            配对方案 = sf._recur_(队伍数半数)
            if 1:
                #非必要，但 更逼近『最小化-配对方案』
                配对方案 = sorted(配对方案)
            检查冫圆满配对方案扌(队伍数半数, 配对方案)
            队伍数半数讠配对方案[队伍数半数] = 配对方案
        配对方案 = 队伍数半数讠配对方案[队伍数半数]
        if 1:
            #deepcopy:
            配对方案 = [j2j.copy() for j2j in 配对方案]
        return 配对方案
    def _recur_(sf, 队伍数半数, /):
        '-> 配对方案#分派任务'
        assert 队伍数半数 >= 2
        if (队伍数半数&1) == 0:
            return sf._recur_even(队伍数半数)
        else:
            return sf._recur_odd(队伍数半数)
        ######################
    def _recur_even(sf, 队伍数半数, /):
        '-> 配对方案#递归算法'
        assert (队伍数半数&1) == 0
        assert 队伍数半数 >= 2
        #偶数
        #=>递归:平分
        v = 队伍数半数 >> 1
        配对方案纟半 = sf.recur_(v)
            # matrix[2*v-1,2*v]
        队伍数总数 = 队伍数半数*2
            # == (v+v)*2
            # == 4*v
        配对方案 = [[None]*队伍数总数 for _ in range(队伍数总数-1)]
            # matrix[4*v-1,4*v]
        配对方案纟半纟组间 = 组间配对冖冖相同扌(队伍数纟每组=队伍数半数)
            # matrix[2*v,4*v]
        #######
        if 0b0000:
            if 队伍数总数==8:
                print(队伍数半数)
                print(v)
                print(队伍数总数)
                print(配对方案纟半)
                print(配对方案纟半纟组间)
        #######
        就地适配队伍号冫配对方案扌(新配对方案=配对方案, 起始轮次纟适配=0, 旧配对方案=配对方案纟半, 旧队伍号讠新队伍号=range(队伍数半数))
            # matrix[2*v-1,2*v]@(0,0)@matrix[4*v-1,4*v]
        就地适配队伍号冫配对方案扌(新配对方案=配对方案, 起始轮次纟适配=0, 旧配对方案=配对方案纟半, 旧队伍号讠新队伍号=range(队伍数半数,队伍数总数))
            # matrix[2*v-1,2*v]@(0,2*v)@matrix[4*v-1,4*v]
        就地适配队伍号冫配对方案扌(新配对方案=配对方案, 起始轮次纟适配=队伍数半数-1, 旧配对方案=配对方案纟半纟组间, 旧队伍号讠新队伍号=range(队伍数总数))
            # matrix[2*v,4*v]@(2*v-1,0)@matrix[4*v-1,4*v]
        #######
        return 配对方案
        ######################
    @abstractmethod
    def _recur_odd(sf, 队伍数半数, /):
        '-> 配对方案#递归算法'
        assert (队伍数半数&1) == 1
        assert 队伍数半数 >= 3
        ######################

#end-class 魖循环对抗赛配对方案冖冖规则化冖冖分而治之(ABC):
class 乸循环对抗赛配对方案冖冖规则化冖冖尾二版(魖循环对抗赛配对方案冖冖规则化冖冖分而治之):
    r'''[[[
[:循环对抗赛配对方案尾二版算法大纲暨证明]:here
大纲:
    分而治之
    重点在于:(4*v+2)型 队伍数总数:分成大小两组:大组组内循环赛尾二轮拆开分散到每一轮组间赛中
===
前提:[is_even 队伍数总数]
    !! 否则，每轮必有一队轮空，不能达到最优值
[[队伍数总数 > 0] -> [is_even 队伍数总数] -> [最少轮数纟循环赛 == 队伍数总数-1]]
[[proof:
!! [每轮至多一个对手，必须与其余队伍遭遇]
[最少轮数纟循环赛 >= 队伍数总数-1]
===
下面证明:[最少轮数纟循环赛 <= 队伍数总数-1]
!! [is_even 队伍数总数]
[队伍数半数 := 队伍数总数///2]
!! [队伍数总数 > 0]
[队伍数总数 >= 2]
[队伍数半数 >= 1]
* [队伍数半数==1]:
    [配对方案 == [[1, 0]]]
    [最少轮数纟循环赛 <= len(配对方案) == 1 == 队伍数总数-1]
* [队伍数半数>=2][is_even 队伍数半数]:
    分而治之:对半平分
    拆成两半/两个大组
    [队伍数总数纟每组 == 队伍数半数 >= 2]
    [队伍数总数纟每组 > 0][is_even 队伍数总数纟每组]
        #=> 归纳法前提
    先进行组内循环赛:并行各(队伍数总数纟每组-1)轮
        !! 归纳法
    再进行组间循环赛:共(队伍数总数纟每组)轮
    [最少轮数纟循环赛 <= (队伍数总数纟每组-1) + (队伍数总数纟每组) == 队伍数总数-1]

* [队伍数半数>=2][is_odd 队伍数半数]:
    分而治之:差一平分
    拆成相近两半/一大一小两个组
    [队伍数总数纟大组-1 == 队伍数半数 == 队伍数总数纟小组+1 >= 2]
    [队伍数总数纟大组-2 == 队伍数半数-1 == 队伍数总数纟小组 >= 1]
    [队伍数总数纟大组 > 0][is_even 队伍数总数纟大组]
        #=> 归纳法前提
    [队伍数总数纟小组 > 0][is_even 队伍数总数纟小组]
        #=> 归纳法前提
    先进行小组组内循环赛 暨 除了最后两轮的大组组内循环赛:并行各(队伍数总数纟小组-1)轮
        !! 归纳法
    根据 大组组内循环赛的配对方案的最后两轮(尾二轮) 设计 组间循环赛
    #证明:尾二轮赛事交错成环:见下面:二轮定理
    !! [大组内循环赛还剩两轮]
    [大组内每支队伍还剩两个对手未遭遇]
    [大组内每支队伍未遭遇的两个对手必然在尾二轮遭遇，每一轮遭遇一个对手]
    [将大组内尾二轮对手连线并染色，必然是多个环，并且连线着色交错]
    #
    [大组内队伍可分成满足后列条件的两半大组:半大组内队伍于尾二轮不遭遇]
    [队伍数总数纟大组 == 2*队伍数总数纟半大组]
    [小组内队伍可任意分成两半小组]
    [队伍数总数纟小组 == 2*队伍数总数纟半小组]
    !! [队伍数总数纟大组-1 == 队伍数半数 == 队伍数总数纟小组+1]
    [2*队伍数总数纟半大组-1 == 队伍数半数 == 2*队伍数总数纟半小组+1]
    [队伍数总数纟半大组 == 队伍数总数纟半小组+1]
    将 虚拟队伍 加入 半小组 得到 虚胖半小组
    [队伍数总数纟半大组 == 队伍数总数纟半小组+1 == 队伍数总数纟虚胖半小组]
    安排 半大组、虚胖半小组 之间的 组间循环赛:
        遭遇 虚拟队伍 相当于 轮空
        每轮必然有一队轮空，这一队属于 半大组
        共(队伍数总数纟半大组)即(队伍数总数纟虚胖半小组)轮
    由于 有两套 (半大组、虚胖半小组) 之间的 组间循环赛 同时进行，可以 调整次序 使得 轮空的两队 正好是 尾二轮 中 遭遇的对手，使之不再轮空
    由于 有两套 (半大组、虚胖半小组) 之间的 组间循环赛 同时进行 之后，还需 交换 再来一次:
        共(2*队伍数总数纟半大组)轮
        共(队伍数总数纟大组)轮
    这样一来，配对方案 完成
    [最少轮数纟循环赛 <= (队伍数总数纟小组-1) + (队伍数总数纟大组) == (队伍数半数-1-1) + (队伍数半数+1) == 队伍数总数-1]
[最少轮数纟循环赛 <= 队伍数总数-1]
!! [最少轮数纟循环赛 >= 队伍数总数-1]
[最少轮数纟循环赛 == 队伍数总数-1]
DONE!!
]]

[:二轮定理:循环赛配对方案中任意两轮赛事交错成环丶环长为偶数丶环长大于等于四]:goto
重要定理:可用于精简化输出:
    (2*n-1)轮:假设第一轮为(2*j+1,2*j)
    剩下(2*n-2)轮，分为(n-1)个两轮
    两轮可合并起来表达为:[a--[首轮]->b--[次轮]->c--[首轮]->...--[次轮]->a; x--[首轮]->...--[次轮]->x; ...; ...;... ...]
def 压缩冫配对方案扌(轮次纟跳过, 配对方案, /, *, 欤紧凑文本化=False):goto
def 标准压缩冫配对方案扌(配对方案, /, *, 欤紧凑文本化=False):goto
例如:配对方案[队伍数半数==2]:
[1, 0, 3, 2]
[2, 3, 0, 1]
[3, 2, 1, 0]
==>>:可精简表达为:
[0,2,1,3;]

例如:配对方案[队伍数半数==3]:
[1, 0, 3, 2, 5, 4]
[2, 4, 0, 5, 1, 3]
[3, 5, 4, 0, 2, 1]
[4, 3, 5, 1, 0, 2]
[5, 2, 1, 4, 3, 0]
==>>:可精简表达为:
[0,2,4,1,5,3;]
[0,4,3,1,2,5;]

例如:配对方案[队伍数半数==4]:
[1, 0, 3, 2, 5, 4, 7, 6]
[2, 3, 0, 1, 6, 7, 4, 5]
[3, 2, 1, 0, 7, 6, 5, 4]
[4, 5, 6, 7, 0, 1, 2, 3]
[5, 4, 7, 6, 1, 0, 3, 2]
[6, 7, 4, 5, 2, 3, 0, 1]
[7, 6, 5, 4, 3, 2, 1, 0]
==>>:可精简表达为:
[0,2,1,3;4,6,5,7;]
[0,4,1,5;2,6,3,7;]
[0,6,1,7;2,4,3,5;]

例如:配对方案[队伍数半数==5]:
[1, 0, 3, 2, 5, 4, 7, 6, 9, 8]
[2, 3, 0, 1, 6, 8, 4, 9, 5, 7]
[3, 2, 1, 0, 7, 9, 8, 4, 6, 5]
[4, 5, 6, 9, 0, 1, 2, 8, 7, 3]
[5, 4, 7, 8, 1, 0, 9, 2, 3, 6]
[6, 7, 8, 5, 9, 3, 0, 1, 2, 4]
[7, 8, 9, 4, 3, 6, 5, 0, 1, 2]
[8, 9, 4, 6, 2, 7, 3, 5, 0, 1]
[9, 6, 5, 7, 8, 2, 1, 3, 4, 0]
==>>:可精简表达为:
[0,2,1,3;4,6,8,5,9,7;]
[0,4,1,5;2,6,9,3,8,7;]
[0,6,5,3,4,9,2,8,1,7;]
[0,8,4,2,5,7,3,6,1,9;]


#
[:二轮定理:循环赛配对方案中任意两轮赛事交错成环丶环长为偶数丶环长大于等于四]:here
证明:二轮定理
[[proof:
若首轮遭遇，则两队间连白线
若次轮遭遇，则两队间连黑线
若两轮皆不遭遇，则两队间无连线
由于 循环赛配对方案的配对紧凑性，每一轮每队必不轮空
由于 循环赛配对方案的配对唯一性，每轮每队有且只有一个对手
=>各队两轮两对手，一白线一黑线
=>以各队伍为点，得一无向图，所有节点度数皆为二
!! 节点数量有限
该无向图 不可能 包含 无限长路径
!! 所有节点度数皆为二
该无向图 各连通分量 均为 环
!! 该无向图中任一环:环上线段黑白交替
该无向图中任一环:环长为偶数
由于 循环赛配对方案的配对唯一性，两队最多遭遇一次
该无向图中任一环:环长不等于二
!! 环长为偶数
该无向图中任一环:环长大于等于四
DONE!!
]]



    #]]]'''#'''
    ___no_slots_ok___ = True
    #乸循环对抗赛配对方案冖冖规则化冖冖尾二版
    '尾二版'
    @override
    def _recur_odd(sf, 队伍数半数, /):
        '-> 配对方案#递归算法'
        assert (队伍数半数&1) == 1
        assert 队伍数半数 >= 3
        #奇数
        #=>递归:差一
        v = 队伍数半数 >> 1
        assert v >= 1
        assert 队伍数半数 == v+1+v

        配对方案纟半纟少 = sf.recur_(v)
            # matrix[2*v-1,2*v]
        配对方案纟半纟多 = sf.recur_(v+1)
            # matrix[2*v+1,2*v+2]
        尾二纟配对方案纟半纟多 = 配对方案纟半纟多[-2:]
            # matrix[2,2*v+2]
        if 1:
            del 配对方案纟半纟多[-2:]
            配对方案纟半纟多冖冖缺尾二 = 配对方案纟半纟多
            配对方案纟半纟多 = None
        配对方案纟半纟多冖冖缺尾二
            # matrix[2*v-1,2*v+2]
        ###########
        if 1:
            #bug:分离后尾二纟配对方案纟半纟多 = [*_分离对手(尾二纟配对方案纟半纟多)]
            分离后尾二纟配对方案纟半纟多 = [*_分离对手冖冖版本二(尾二纟配对方案纟半纟多)]
        ###########

        队伍数总数 = 队伍数半数*2
            # == (v+1+v)*2
            # == (4*v+2)
        待圆满冫配对方案 = [[None]*队伍数总数 for _ in range(队伍数总数-1)]
            # matrix[4*v+1,4*v+2]
        未圆满冫配对方案纟半半纟组间 = 组间配对冖冖差一扌(队伍数纟少=v, 欤轮空当作最小队伍号纟小组=True)
            # matrix[v+1,2*v+1]
        #######
        就地适配队伍号冫配对方案扌(新配对方案=待圆满冫配对方案, 起始轮次纟适配=0, 旧配对方案=配对方案纟半纟多冖冖缺尾二, 旧队伍号讠新队伍号=range(2*v+2))
            # matrix[2*v-1,2*v+2]@(0,0)@matrix[4*v+1,4*v+2]
        就地适配队伍号冫配对方案扌(新配对方案=待圆满冫配对方案, 起始轮次纟适配=0, 旧配对方案=配对方案纟半纟少, 旧队伍号讠新队伍号=range(2*v+2, 队伍数总数))
            # matrix[2*v-1,2*v]@(0,2*v+2)@matrix[4*v+1,4*v+2]
        for 队伍号列表纟小大, 轮次序号, 欤反转 in zip(分离后尾二纟配对方案纟半纟多, [2*v-1, 3*v], [False, True]):
            if 0b0000:
                print(队伍数半数, 轮次序号, 欤反转, 队伍号列表纟小大, range(2*v+2,3*v+2), range(3*v+2,队伍数总数))
            #(队伍号列表纟小,队伍号列表纟大) = 队伍号列表纟小大
            (队伍号列表纟先,队伍号列表纟后) = 队伍号列表纟小大[::-1 if 欤反转 else +1]
            就地适配队伍号冫配对方案扌(新配对方案=待圆满冫配对方案, 起始轮次纟适配=轮次序号, 旧配对方案=未圆满冫配对方案纟半半纟组间, 旧队伍号讠新队伍号=[*队伍号列表纟先, *range(2*v+2,3*v+2)])
                # matrix[v+1,2*v+1]@(轮次序号,???)@matrix[4*v+1,4*v+2]
            就地适配队伍号冫配对方案扌(新配对方案=待圆满冫配对方案, 起始轮次纟适配=轮次序号, 旧配对方案=未圆满冫配对方案纟半半纟组间, 旧队伍号讠新队伍号=[*队伍号列表纟后, *range(3*v+2,队伍数总数)])
                # matrix[v+1,2*v+1]@(轮次序号,???)@matrix[4*v+1,4*v+2]
        #######
        for 轮次序号 in range(2*v-1, 4*v+1):
            队伍号讠鬽对手队伍号 = 待圆满冫配对方案[轮次序号]
            i = 队伍号讠鬽对手队伍号.index(None)
            j = 队伍号讠鬽对手队伍号.index(None, i+1)
            队伍号讠鬽对手队伍号[i] = j
            队伍号讠鬽对手队伍号[j] = i
        #######
        #已圆满:
        配对方案 = 待圆满冫配对方案
        return 配对方案
        ######################
    ######################
    ######################
def _分离对手(尾二纟配对方案纟半纟多, /):
    #bug:逻辑性错误:必须 分离成 一个 两套(两个 两套 但 『两个』划分 集合等价) 而非 两个 两套(『两个』划分 集合不等价)
    for 队伍号讠对手队伍号 in 尾二纟配对方案纟半纟多:
        队伍号列表纟小 = []
        队伍号列表纟大 = []
        for 队伍号,对手队伍号 in enumerate(队伍号讠对手队伍号):
            if 队伍号 < 对手队伍号:
                队伍号列表纟小.append(队伍号)
                队伍号列表纟大.append(对手队伍号)
        yield (队伍号列表纟小,队伍号列表纟大)
def _分离对手冖冖版本二(尾二纟配对方案纟半纟多, /):
    #尾二:交错成环:多环
    j2j0, j2j1 = 尾二纟配对方案纟半纟多
    js0 = []
    js1 = []
    js2 = []
    io2js = js0, js1
    L = len(j2j0)
    j2io = [None]*L
    def put_(io, j, /):
        assert j2io[j] is None
        j2io[j] = io
        io2js[io].append(j)
        return
    for j in range(L):
        if not j2io[j] is None:continue
        s = len(js0)
        put_(0, j)
        i = j
        while 1:
            j = j2j0[j]
            assert not j == i
            put_(1, j)
            j = j2j1[j]
            if j == i:break
            put_(0, j)
        assert len(js0) == len(js1)
        t = len(js0)
        js2 += [js1[t-1], *js1[s:t-1]]
        assert len(js0) == len(js2)
    assert len(js0) == len(js1)
    assert len(js0) + len(js1) == L
    assert len(js0) == len(js2)
    yield from sorted(
        [_排序冖冖非必要扌(js0, js1)
        ,_排序冖冖非必要扌(js0, js2)
        ])
    return
def _排序冖冖非必要扌(js0, js1, /):
    #非必要，但 更逼近『最小化-配对方案』
    L = len(js0)
    idc = sorted(range(L), key=js0.__getitem__)
    js0 = [js0[i] for i in idc]
    js1 = [js1[i] for i in idc]
    return js0, js1
#end-class 乸循环对抗赛配对方案冖冖规则化冖冖尾二版:
class 乸循环对抗赛配对方案冖冖规则化冖冖平分版(魖循环对抗赛配对方案冖冖规则化冖冖分而治之):
    r'''[[[
[:循环对抗赛配对方案平分版算法大纲暨证明]:here
大纲:
    分而治之
    重点在于:(4*v+2)型 队伍数总数:分成等大两组:
        每组组内循环赛加入虚拟队伍
        遭遇虚拟队伍等价于轮空
        由于两组采用相同方案，并行赛事时，轮空两队的队伍号的大小关系为:半数平移
        让各轮轮空两队遭遇，并移除组间循环赛的相应轮(半数平移=>刚好一轮)
===
[[队伍数总数 > 0] -> [is_even 队伍数总数] -> [最少轮数纟循环赛 == 队伍数总数-1]]
证明:见:
    [:循环对抗赛配对方案尾二版算法大纲暨证明]:goto

    #]]]'''#'''
    ___no_slots_ok___ = True
    #乸循环对抗赛配对方案冖冖规则化冖冖平分版
    '平分版'
    @override
    def _recur_odd(sf, 队伍数半数, /):
        '-> 配对方案#递归算法'
        assert (队伍数半数&1) == 1
        assert 队伍数半数 >= 3
        #奇数
        #=>递归:平分
        #增加一支 虚拟队伍:
        队伍数总数纟虚胖组 = 队伍数半数+1
        队伍数半数纟虚胖组 = 队伍数总数纟虚胖组 >> 1
        v = 队伍数半数 >> 1
        # !! [is_odd 队伍数半数]
        # [v :=> [2*v+1 == 队伍数半数]]
        # [2*v+1 == 队伍数半数]
        # [2*v+2 == 队伍数总数纟虚胖组]
        # [v+1 == 队伍数半数纟虚胖组]
        #
        assert 2*v+1 == 队伍数半数
        assert v+1 == 队伍数半数纟虚胖组
        assert 2*v+2 == 队伍数总数纟虚胖组

        # !! [is_odd 队伍数半数]
        # [is_even (1+队伍数半数)]
        # [is_even 队伍数总数纟虚胖组]
        # !! [队伍数半数 >= 3]
        # [2*v+1 == 队伍数半数 >= 3]
        # [v >= 1]
        # !! [v+1 == 队伍数半数纟虚胖组]
        # !! [2*v+1 == 队伍数半数]
        # [队伍数半数 -队伍数半数纟虚胖组 == v >= 1]
        # [队伍数半数纟虚胖组 < 队伍数半数]
        #
        #
        #
        #
        # !! [is_even 队伍数总数纟虚胖组]
        assert 队伍数总数纟虚胖组&1 == 0
        assert 队伍数总数纟虚胖组 == 队伍数半数纟虚胖组<<1
            # 偶数 => _recur_even
        # !! [队伍数半数纟虚胖组 < 队伍数半数]
        assert 队伍数半数纟虚胖组 < 队伍数半数
            # => 确保 严格递降，没有 死循环
        ######################
        未圆满冫配对方案纟虚胖组 = sf.recur_(队伍数半数纟虚胖组)
            # 临时:matrix[2*v+1,2*v+2]
        for 队伍号讠鬽对手队伍号 in 未圆满冫配对方案纟虚胖组:
            j = 队伍号讠鬽对手队伍号.pop()
            assert 队伍号讠鬽对手队伍号[j] == 队伍数半数
            队伍号讠鬽对手队伍号[j] = None
                # 遭遇 虚拟队伍=>轮空
        未圆满冫配对方案纟虚胖组
            # matrix[2*v+1,2*v+1]
        assert len(未圆满冫配对方案纟虚胖组) == 队伍数半数
        assert len(未圆满冫配对方案纟虚胖组[0]) == 队伍数半数
        ######################
        ###########
        队伍数总数 = 队伍数半数*2
            # == (2*v+1)*2
            # == (4*v+2)
        #待圆满冫配对方案 = [[None]*队伍数总数 for _ in range(队伍数总数-1)]
            # matrix[4*v+1,4*v+2]
        待圆满冫配对方案 = [[None]*队伍数总数 for _ in range(队伍数半数)]
            # 临时:matrix[2*v+1,4*v+2]
            # 目标:matrix[4*v+1,4*v+2]
        #######
        配对方案纟半纟组间 = 组间配对冖冖相同扌(队伍数纟每组=队伍数半数)
            # 临时:matrix[2*v+1,4*v+2]
        for j, i in enumerate(配对方案纟半纟组间[0][:队伍数半数]):
            assert i == j + 队伍数半数
            #半数平移:与下面相匹配
        del 配对方案纟半纟组间[0]
        配对方案纟半纟组间
            # matrix[2*v,4*v+2]
        #######
        就地适配队伍号冫配对方案扌(新配对方案=待圆满冫配对方案, 起始轮次纟适配=0, 旧配对方案=未圆满冫配对方案纟虚胖组, 旧队伍号讠新队伍号=range(队伍数半数))
            # matrix[2*v+1,2*v+1]@(0,0)@matrix[4*v+1,4*v+2]
        就地适配队伍号冫配对方案扌(新配对方案=待圆满冫配对方案, 起始轮次纟适配=0, 旧配对方案=未圆满冫配对方案纟虚胖组, 旧队伍号讠新队伍号=range(队伍数半数, 队伍数总数))
            # matrix[2*v+1,2*v+1]@(0,2*v+1)@matrix[4*v+1,4*v+2]
        #######
        for 队伍号讠鬽对手队伍号 in 待圆满冫配对方案:
            # 临时:matrix[2*v+1,4*v+2]
            #for 队伍号讠鬽对手队伍号 in 待圆满冫配对方案[:队伍数半数]:
            j = 队伍号讠鬽对手队伍号.index(None)
            i = j + 队伍数半数
            assert 队伍号讠鬽对手队伍号[i] is None
            #半数平移:与上面相匹配
            队伍号讠鬽对手队伍号[i] = j
            队伍号讠鬽对手队伍号[j] = i
        待圆满冫配对方案
            # 已圆满:待圆满冫配对方案[:队伍数半数]
            # 已圆满:待圆满冫配对方案[:2*v+1]
        #######
        配对方案纟半纟组间
            # matrix[2*v,4*v+2]
        待圆满冫配对方案[队伍数半数:] = 配对方案纟半纟组间
            # matrix[4*v+1,4*v+2]
        #######
        #已圆满:
        配对方案 = 待圆满冫配对方案
        return 配对方案
        ######################
    ######################
#end-class 乸循环对抗赛配对方案冖冖规则化冖冖平分版(魖循环对抗赛配对方案冖冖规则化冖冖分而治之):

_匴构造器冫尾二版 = 乸循环对抗赛配对方案冖冖规则化冖冖尾二版()
_匴构造器冫平分版 = 乸循环对抗赛配对方案冖冖规则化冖冖平分版()

_版本名讠匴构造器 = (dict
(尾二版=_匴构造器冫尾二版
,平分版=_匴构造器冫平分版
))

def _更新缓存冫循环对抗赛配对方案冖冖规则化扌(*, 版本名, 队伍数半数讠配对方案):
    匴构造器 = _版本名讠匴构造器[版本名]
    匴构造器.队伍数半数讠配对方案.update(队伍数半数讠配对方案)
    return
def 构建冫循环对抗赛配对方案冖冖规则化冖冖易用接口扌(*, 版本名, 队伍数半数, 欤压缩=False, 欤标准压缩=False, 欤紧凑文本化=False):
    配对方案 = 构建冫循环对抗赛配对方案巛变量环境扌(locals())
    return 配对方案
def 构建冫循环对抗赛配对方案巛变量环境扌(变量环境, /, **_kwds):
    return _调用函数巛变量环境扌(构建冫循环对抗赛配对方案冖冖规则化扌, _nms4arg4构建冫循环对抗赛配对方案冖冖规则化扌, 变量环境, **_kwds)
_nms4arg4构建冫循环对抗赛配对方案冖冖规则化扌='版本名,队伍数半数,欤压缩,欤标准压缩,欤紧凑文本化'.split(',')
def 构建冫循环对抗赛配对方案冖冖规则化扌(*, 版本名, 队伍数半数, 欤压缩, 欤标准压缩, 欤紧凑文本化):
    check_int_ge(1, 队伍数半数)
    if 版本名 in _版本名讠非递归构造器:
        f = _版本名讠非递归构造器[版本名]
    else:
        匴构造器 = _版本名讠匴构造器[版本名]
        f = 匴构造器.构建冫循环对抗赛配对方案冖冖规则化扌
    配对方案 = f(队伍数半数=队伍数半数)
    if 欤标准压缩:
        标准压缩后配对方案 = 标准压缩冫配对方案扌(配对方案, 欤紧凑文本化=欤紧凑文本化)
        return 标准压缩后配对方案
    elif 欤压缩:
        压缩后配对方案 = 压缩冫配对方案扌(配对方案, 欤紧凑文本化=欤紧凑文本化)
        return 压缩后配对方案
    elif 欤紧凑文本化:
        紧凑文本 = 紧凑文本化冫配对方案扌(配对方案)
        return 紧凑文本
    else:
        return 配对方案
def 欤二幂扌(二幂, /):
    check_int_ge(1, 二幂)
    return 二幂 == (1<<floor_log2(二幂))
def 枚举冫队伍数半数扌(*, 鬽队伍数半数纟最大许可, 队伍数半数纟最小许可, 欤不输出冫奇数的队伍数半数, 欤不输出冫偶数的队伍数半数, 欤不输出冫非二幂的队伍数半数, 欤不输出冫非二幂加一的队伍数半数):
    队伍数半数纟最小许可 = max(1, 队伍数半数纟最小许可)
    if 欤不输出冫非二幂的队伍数半数:
        # 输出 &= {2**e}
            # 包含 1==2**0
        if 队伍数半数纟最小许可 >= 2:
            欤不输出冫奇数的队伍数半数 = True
                # 输出 &= {2*v}
    if 欤不输出冫非二幂加一的队伍数半数:
        # 输出 &= {1+2**e}
            # 包含 2==1+2**0
        if 队伍数半数纟最小许可 >= 3:
            欤不输出冫偶数的队伍数半数 = True
                # 输出 &= {2*v+1}


    if 鬽队伍数半数纟最大许可 is None:
        it = count(队伍数半数纟最小许可)
        队伍数半数纟最大许可 = inf
    else:
        队伍数半数纟最大许可 = 鬽队伍数半数纟最大许可
        it = range(队伍数半数纟最小许可, 1+队伍数半数纟最大许可)
    it

    # [choose(4;3),choose(4;4) 其处理蕴含在 choose(4;2) 的头两个况型中]
    # [choose(4;2) == 3*4/2 == 6]
    # [choose(4;1) == 4]
    # [choose(4;0) == 1]
    if 欤不输出冫偶数的队伍数半数 and 欤不输出冫奇数的队伍数半数:
        return
    if 欤不输出冫非二幂的队伍数半数 and 欤不输出冫非二幂加一的队伍数半数:
        return
    if 欤不输出冫非二幂的队伍数半数 and 欤不输出冫偶数的队伍数半数:
        #只能是:1
        if 队伍数半数纟最小许可 <= 1 <= 队伍数半数纟最大许可:
            yield 1
        return
    if 欤不输出冫非二幂加一的队伍数半数 and 欤不输出冫奇数的队伍数半数:
        #只能是:2
        if 队伍数半数纟最小许可 <= 2 <= 队伍数半数纟最大许可:
            yield 2
        return
    if 欤不输出冫非二幂的队伍数半数 and 欤不输出冫奇数的队伍数半数:
        #排除:1#2==2**1
        队伍数半数纟最小许可 = max(2, 队伍数半数纟最小许可)
    if 欤不输出冫非二幂加一的队伍数半数 and 欤不输出冫偶数的队伍数半数:
        #排除:2
        #排除:1,2#3==1+2**1
        队伍数半数纟最小许可 = max(3, 队伍数半数纟最小许可)
    if 欤不输出冫非二幂的队伍数半数:
        i = ceil_log2(队伍数半数纟最小许可)
        if 鬽队伍数半数纟最大许可 is None:
            it = (1<<e for e in count(i))
        else:
            j = floor_log2(队伍数半数纟最大许可)
            it = (1<<e for e in range(i,j+1))
        it
    elif 欤不输出冫奇数的队伍数半数:
        i = 队伍数半数纟最小许可
        i += (i&1)
        if 鬽队伍数半数纟最大许可 is None:
            it = count(i, 2)
        else:
            j = 队伍数半数纟最大许可
            it = range(i, j+1, 2)
        it
    else:
        it
    it
    if 欤不输出冫非二幂加一的队伍数半数:
        #最小:2
        队伍数半数纟最小许可 = max(2, 队伍数半数纟最小许可)
        i = ceil_log2(队伍数半数纟最小许可-1)
        if 鬽队伍数半数纟最大许可 is None:
            it = ((1<<e)+1 for e in count(i))
        else:
            if 队伍数半数纟最大许可 < 2:
                return
            j = floor_log2(队伍数半数纟最大许可-1)
            it = ((1<<e)+1 for e in range(i,j+1))
        it
    elif 欤不输出冫偶数的队伍数半数:
        i = 队伍数半数纟最小许可
        i |= 1
        if 鬽队伍数半数纟最大许可 is None:
            it = count(i, 2)
        else:
            j = 队伍数半数纟最大许可
            it = range(i, j+1, 2)
        it
    else:
        it
    it

    for 队伍数半数 in it:
        if 欤不输出冫非二幂的队伍数半数:
            #if not 队伍数半数 >= 1: raise 000
            if not 欤二幂扌(二幂 := 队伍数半数):raise 000

        if 欤不输出冫非二幂加一的队伍数半数:
            if not 队伍数半数 >= 2:raise 000
            if not 欤二幂扌(二幂 := 队伍数半数-1):raise 000

        if 欤不输出冫偶数的队伍数半数:
            if 队伍数半数&1 == 0: raise 000#continue
        if 欤不输出冫奇数的队伍数半数:
            if 队伍数半数&1 == 1: raise 000#continue
        yield 队伍数半数

_nms4arg4枚举冫队伍数半数扌 = '鬽队伍数半数纟最大许可,队伍数半数纟最小许可,欤不输出冫奇数的队伍数半数,欤不输出冫偶数的队伍数半数,欤不输出冫非二幂的队伍数半数,欤不输出冫非二幂加一的队伍数半数'.split(',')
def _调用函数巛变量环境扌(f, nms4arg, 变量环境, /, **_kwds):
    kwds = {nm:变量环境[nm] for nm in nms4arg if nm in 变量环境}
    kwds.update(_kwds)
    return f(**kwds)
def 枚举冫队伍数半数巛变量环境扌(变量环境, /, **_kwds):
    return _调用函数巛变量环境扌(枚举冫队伍数半数扌, _nms4arg4枚举冫队伍数半数扌, 变量环境, **_kwds)

def 枚举冫循环对抗赛配对方案冖冖规则化扌(*, 版本名, 鬽队伍数半数纟最大许可, 欤输出冫队伍数总数=False, 欤扁平化冫配对方案=False, 队伍数半数纟最小许可=1, 欤不输出冫奇数的队伍数半数=False, 欤不输出冫偶数的队伍数半数=False, 欤不输出冫非二幂的队伍数半数=False, 欤不输出冫非二幂加一的队伍数半数=False, 欤压缩=False, 欤标准压缩=False, 欤紧凑文本化=False):
    欤分割成行 = 欤扁平化冫配对方案 and 欤紧凑文本化 and not (欤标准压缩 or 欤压缩)
    it = 枚举冫队伍数半数巛变量环境扌(locals())
    for 队伍数半数 in it:
        配对方案 = 构建冫循环对抗赛配对方案冖冖规则化扌(版本名=版本名, 队伍数半数=队伍数半数, 欤压缩=欤压缩, 欤标准压缩=欤标准压缩, 欤紧凑文本化=欤紧凑文本化)
        队伍数总数 = 队伍数半数*2
        if 欤输出冫队伍数总数:
            yield 队伍数总数
        if 欤扁平化冫配对方案:
            assert type(配对方案) is (str if 欤分割成行 else list), sorted(locals().items())
            if 欤分割成行:
                txt = 配对方案
                lines = txt.strip().split('\n')
                yield from lines
            else:
                yield from 配对方案
        else:
            yield 配对方案
    return
def _读取暨求值冖冖标准库扌(输入路径, /, *, verbose, encoding):
    #导致宕机:52MB #[队伍数半数<-[1..=206]]
    from ast import literal_eval
    from seed.tiny import print_err
    txt = 输入路径.read_text(encoding=encoding)
    txt = txt.strip()
    if txt and not txt.startswith(','): raise Exception('bad format')
    s = txt[1:]
    s = f'{{ {s!s} }}'
    if verbose:
        print_err(f'求值中...')
    d = literal_eval(s)
    if verbose:
        print_err(f'求值结束')
    return d
def _读取暨求值冖冖人工扌(输入路径, /, *, verbose, encoding):
    from seed.tiny import print_err
    def f(ifile, /):
        for line in ifile:
            line = line.strip()
            if line and not line.startswith('#'):
                yield line
        return
    with open(输入路径, 'rt', encoding=encoding) as ifile:
        it = f(ifile)
        if verbose:
            print_err(f'求值中...')
        队伍数半数讠配对方案 = {}
        for line in it:
            if not (line.startswith(',') and line.endswith(':')): raise Exception('bad format')
            s = line[1:-1]
            队伍数半数 = int(s)
            if verbose:
                print_err(f'求值中...:{队伍数半数}')
            lsls = []
            ch = '['
            for line in it:
                if line == ']':
                    break
                if not line.startswith(ch): raise Exception('bad format')
                line = line[1:]
                ch = ','
                if not (line.startswith('[') and line.endswith(']')): raise Exception('bad format')
                line = line[1:-1]
                ss = line.split(',')
                j2j = [*map(int, ss)]
                lsls.append(j2j)
            队伍数半数讠配对方案[队伍数半数] = 配对方案 = lsls
        if verbose:
            print_err(f'求值结束')
    return 队伍数半数讠配对方案

def 输出枚举冫循环对抗赛配对方案冖冖规则化扌(*, 版本名, 欤读取, 输出路径, 队伍数半数纟最大许可, 欤不输出冫奇数的队伍数半数=False, 欤不输出冫偶数的队伍数半数=False, 欤不输出冫非二幂的队伍数半数=False, 欤不输出冫非二幂加一的队伍数半数=False, encoding='utf8', verbose=False, 欤压缩=False, 欤标准压缩=False):
    #, 欤紧凑文本化=False???True
    if 欤压缩 or 欤标准压缩:raise NotImplementedError

    from pathlib import Path
    from seed.tiny import mk_fprint, print_err
    输出路径 = Path(输出路径)
    if 欤读取 and 输出路径.exists():
        if verbose:
            print_err(f'读取文件中...')
        输入路径 = 输出路径
        if 0:
            #导致宕机:52MB #[队伍数半数<-[1..=206]]
            d = _读取暨求值冖冖标准库扌(输入路径, verbose=verbose, encoding=encoding)
        else:
            d = _读取暨求值冖冖人工扌(输入路径, verbose=verbose, encoding=encoding)
        if verbose:
            print_err(f'读取文件结束')
    else:
        d = {}
    d
    if not 版本名 in _版本名讠非递归构造器:
        _更新缓存冫循环对抗赛配对方案冖冖规则化扌(版本名=版本名, 队伍数半数讠配对方案=d)

    队伍数半数纟最小许可 = 1+max(d, default=0)
    it = range(队伍数半数纟最小许可, 1+队伍数半数纟最大许可)
        #旨在:check not None/鬽队伍数半数纟最大许可

    if 1:
        鬽队伍数半数纟最大许可 = 队伍数半数纟最大许可
        it = 枚举冫队伍数半数巛变量环境扌(locals())

    with open(输出路径, 'at', encoding=encoding) as ofile:
        fprint = mk_fprint(ofile)
        for 队伍数半数 in it:
            if verbose:
                print_err(f':>>{队伍数半数}')
            配对方案 = 构建冫循环对抗赛配对方案冖冖规则化扌(版本名=版本名, 队伍数半数=队伍数半数, 欤压缩=欤压缩, 欤标准压缩=欤标准压缩)
            #队伍数总数 = 队伍数半数*2
            fprint(f',{队伍数半数}:')
            _紧凑输出冫配对方案扌(fprint, 队伍数半数, 配对方案)
            if verbose:
                print_err(f':<<{队伍数半数}')
    return
def _紧凑输出冫配对方案扌(fprint, 队伍数半数, 配对方案, /):
    ch = '['
    for 队伍号讠对手队伍号 in 配对方案:
        fprint(f'{ch}{队伍号讠对手队伍号}'.replace(' ', ''))
        ch = ','
    ch = ']'
    fprint(f'{ch}')
def 紧凑文本化冫配对方案扌(配对方案, /):
    '-> str'
    #see:紧凑文本化冫合并轮纟二轮扌
    from seed.tiny import mk_fprint
    from io import StringIO
    ofile = StringIO()
    fprint = mk_fprint(ofile)
    队伍数总数 = len(配对方案[0])
    队伍数半数 = 队伍数总数>>1
    _紧凑输出冫配对方案扌(fprint, 队伍数半数, 配对方案)
    txt = ofile.getvalue()
    return txt
def 构建冫循环对抗赛配对方案冖冖规则化冖冖尾二扌(*, 队伍数半数, 欤压缩=False, 欤标准压缩=False, 欤紧凑文本化=False):
    配对方案 = 构建冫循环对抗赛配对方案冖冖规则化扌(版本名='尾二版', *locals())
    return 配对方案
def 枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌(*, 鬽队伍数半数纟最大许可, 欤输出冫队伍数总数=False, 欤扁平化冫配对方案=False, 队伍数半数纟最小许可=1, 欤压缩=False, 欤标准压缩=False, 欤紧凑文本化=False):
    return 枚举冫循环对抗赛配对方案冖冖规则化扌(版本名='尾二版', **locals())
def 输出枚举冫循环对抗赛配对方案冖冖规则化冖冖尾二扌(*, 欤读取, 输出路径, 队伍数半数纟最大许可, 欤不输出冫奇数的队伍数半数=False, 欤不输出冫偶数的队伍数半数=False, 欤不输出冫非二幂的队伍数半数=False, 欤不输出冫非二幂加一的队伍数半数=False, encoding='utf8', verbose=False, 欤压缩=False, 欤标准压缩=False):
    #, 欤紧凑文本化=False???True
    输出枚举冫循环对抗赛配对方案冖冖规则化扌(版本名='尾二版', **locals())
    return


#构建冫循环对抗赛配对方案冖冖规则化扌
def 蛮力检查冫非合数扌(n, /):
    check_int_ge(1, n)
    for k in range(2, n//2+1):
        if n%k == 0: raise TypeError(n, k)
def __():
    #失败品:
  pass
  def 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫交错位移日字绕圈扌(*, 队伍数半数):
    r'''[[[
    '直接构造:非递归'
失败:方法:交错单步长:日字绕圈:简单的交错位移
失败:版本名:非递归冫交错位移日字绕圈版
失败:[队伍数半数==3][步长==2]
    见下面:AssertionError#[t==i]
[t==i]即[奇数步自反]:
    [(队伍号+步长*某个奇数)%队伍数总数 == 队伍号]
    [(步长*某个奇数)%队伍数总数 == 0]
    [(e,s) :=> [队伍数总数 == 2**e *(2*s+1)]]
    [队伍数总数 == 2**e *(2*s+1)]
    [(步长*某个奇数)%(2**e *(2*s+1)) == 0]
    [步长%2**e == 0]
    [((步长///2**e)*某个奇数)%(2*s+1) == 0]
    [d := (步长///2**e)]
    [(d*某个奇数)%(2*s+1) == 0]
    [自反奇数扌(队伍数总数;步长) == 某个奇数 == (2*s+1)///gcd((2*s+1),(步长///2**e))]
    [自反奇数扌(队伍数总数;步长) == 队伍数总数///gcd(队伍数总数,步长)]
[自反数扌(队伍数总数;步长) =[def]= 队伍数总数///gcd(队伍数总数,步长)]
[is_odd 自反数扌(队伍数总数;步长)]:
    [自反奇数扌(队伍数总数;步长) =[def]= 自反数扌(队伍数总数;步长)]

[欤步长自反数为奇数扌(队伍数总数;步长) =[def]= [is_odd 自反数扌(队伍数总数;步长)]]
简单点，排除所有 自反数为奇数的步长 即:[步长 <- [0,2**e..<队伍数总数]]
    只剩下(队伍数总数-(2*s+1))个 有效步长
    [s==0]
        <==> [队伍数总数==2**e]
        <==> [有效步长数量==所需轮数]
    只能直接用于(2**e)型 队伍数总数
[步长集合扌(队伍数总数) := {步长 :<- [1..<队伍数总数]}]
[步长集合纟绕道扌(队伍数总数) := {步长 :<- [1..<队伍数总数] | [is_odd 自反数扌(队伍数总数;步长)]}]
交错单步长:日字绕圈:
    #绕过去，8型绕圈:
    队伍号纟原 + 自反数扌(队伍数总数;步长)*步长 --> 队伍号纟回
    尝试定义:[求冫队伍号纟回扌(队伍数总数;步长,队伍号纟原) -> 队伍号纟回]
    前置条件纟单:
        [步长 <- 步长集合纟绕道扌(队伍数总数)]
        [步长 =!= 0]
    要求一纟单:
        [队伍号纟回(队伍数总数;步长,队伍号纟原) =!= 队伍号纟原]
            #绕道=>不相等
    要求二纟单:
        [队伍号纟回(队伍数总数;步长,队伍号纟回(队伍数总数;步长,队伍号纟原)) == 队伍号纟原]
            #日字绕圈=>回旋相等
    要求三纟单:
        ??? [not$ (队伍号纟回(队伍数总数;步长,队伍号纟原) -(队伍号纟原-步长))%队伍数总数 <- 步长集合扌(队伍数总数)]
            #不同轮次采用不同步长=>避免重复配对
            # [(队伍号纟原-步长)%队伍数总数 -->[绕过:队伍号纟原]--> 队伍号纟回]
            # 步长 却配对了 ((队伍号纟原-步长)%队伍数总数,队伍号纟回)
            不可能 符合要求！
            改用:交错双步长

    方案一:
        [队伍号纟回 := (-1 -队伍号纟原)%队伍数总数]
        [队伍号纟回 == (队伍数总数-1 -队伍号纟原)]
        !! [队伍数总数 == 2*队伍数半数]
        [is_even 队伍数总数]
        [队伍号纟回 =[%2]= (队伍数总数-1 -队伍号纟原) =[%2]= (1 +队伍号纟原)]
        [队伍号纟回-队伍号纟原 =[%2]= 1]
        [队伍号纟回 =!= 队伍号纟原]
        #还要求 [(队伍号纟回 -队伍号纟原) %(2**e) =!= 0]
        [(队伍号纟回 -队伍号纟原) %2 == 1]
            也没毛病
        还要求 所有 自反数为奇数的步长 下:队伍号纟回 不同: 要求三纟单:失败

    方案二:
        ...

日字绕圈:失败:见上面:要求三纟单
    改用:交错双步长

[[
bug:交错双步长:严重逻辑性错误:连锁排斥=>[欤步长自反数为奇数扌(队伍数总数;步长纟起)]这样的步长是无用的！
===
交错双步长:
#交错单步长 可视为 交错双步长 的特例(双步长相等)
(步长纟起,步长纟讫)
[t := (j+步长纟起)%队伍数总数]
[next_j := (j+步长纟起+步长纟讫)%队伍数总数]
其他步长:
    [not$ 步长 <- 步长集合纟绕道扌(队伍数总数)]
    [步长 =!= 0]
    采用:交错单步长，最简单版(无需绕道)
        相当于 [步长纟起 == 步长纟讫]
前置条件纟双:
    [步长纟起 <- 步长集合纟绕道扌(队伍数总数)]
    [步长纟起 =!= 0]
    [步长纟讫 <- 步长集合纟绕道扌(队伍数总数)]
    [步长纟讫 =!= 0]
    必须绕道 ==>> [步长纟起 =!= 步长纟讫]
        #否则 见上面:其他步长
[总步长纟双 := (步长纟起+步长纟讫)%队伍数总数]
# 允许:[总步长纟双 == 0]
[g0 := gcd(步长纟起,队伍数总数)]
[g1 := gcd(步长纟讫,队伍数总数)]
[ggg := gcd(总步长纟双,队伍数总数)]
[a0 := 步长纟起///g0]
[a1 := 步长纟讫///g1]
[aaa := 总步长纟双///ggg]
[b0 := 队伍数总数///g0]
[b1 := 队伍数总数///g1]
[bbb := 队伍数总数///ggg]
[gcd(a0,b0) == 1]
[gcd(a1,b1) == 1]
[gcd(aaa,bbb) == 1]
[(e,s) :=> [队伍数总数 == 2**e *(2*s+1)]]
[sss := (2*s+1)]
[队伍数总数 == 2**e *(2*s+1)]
* [not$ 欤步长自反数为奇数扌(队伍数总数;步长纟起)]:
    [步长纟起 == 步长纟讫]
        # 包含 [步长纟起 == 步长纟讫 == 队伍数半数 == sss*2**(e-1)]
    简单
* [欤步长自反数为奇数扌(队伍数总数;步长纟起)][步长纟起 =!= 步长纟讫][总步长纟双 == 0]:
    [步长纟起 <- {2**e *d0 | [d0 :<- [1..<sss]]}]
    [d0 := 步长纟起///2**e]
    [d0 <- [1..<sss]]
    !! [总步长纟双 == 0]
    [步长纟讫 == (总步长纟双 -步长纟起)%队伍数总数 == 队伍数总数-步长纟起 == (sss-d0)*2**e]
    [步长纟讫%2**e == 0]
    [欤步长自反数为奇数扌(队伍数总数;步长纟讫)]
    [d1 := 步长纟讫///2**e]
    [d1 == sss-d0]
    [d1 <- [1..<sss]]
* [欤步长自反数为奇数扌(队伍数总数;步长纟起)][步长纟起 =!= 步长纟讫][总步长纟双 >= 1]:
    已无需此况态
    ===
    要求一纟双:
        # 不在中间自反
        [步长纟起%ggg =!= 0]
            #<==> [步长纟讫%ggg =!= 0]
            #==>> [ggg =!= 1]
        #####
        <<==:
        # 原貌:要求一纟双:
        # 不在中间自反
        @k.[(队伍号+步长纟起+k*总步长纟双)%队伍数总数 =!= 队伍号]
        <==>
        @k.[(步长纟起+k*总步长纟双)%队伍数总数 =!= 0]
        <==>
        @k.[(k*总步长纟双)%队伍数总数 =!= 步长纟起%队伍数总数]
        <==>
        @k.[(k*ggg*aaa)%(ggg*bbb) =!= 步长纟起%(ggg*bbb)]
        <==>
        @k.[ggg*(k*aaa%bbb)%(ggg*bbb) =!= 步长纟起%(ggg*bbb)]
        !! [gcd(aaa,bbb) == 1]
        <==>
        @k.[ggg*k%(ggg*bbb) =!= 步长纟起%(ggg*bbb)]
        <==>
        @k.[ggg*k =!= 步长纟起]
        <==>
        [步长纟起%ggg =!= 0]
            #==>> [ggg =!= 1]
        !! [总步长纟双 := (步长纟起+步长纟讫)%队伍数总数]
        <==>
        [步长纟讫%ggg =!= 0]
        #####
        !! [步长纟起 <- 步长集合纟绕道扌(队伍数总数)]
        [欤步长自反数为奇数扌(队伍数总数;步长纟起)]
        [步长纟起%2**e == 0]
        [步长纟讫%2**e == 0]
        [d0 := 步长纟起///2**e]
        [d1 := 步长纟讫///2**e]
        [ddd := 总步长纟双///2**e]
        [ddd == (d0+d1)%sss]
    ===
    要求二纟双:
        # 整个配对方案里配对唯一性
        [步长纟起(作为角色:步长纟起) 只出现一次]
        [步长纟起 与 步长纟讫 一一对应]
        [在不同轮里，(步长纟起,步长纟讫)互换角色] #除非两者相等
            !! [总步长纟双 > 0] #=>成环不止两步，来回 是两个不同配对
            !! [步长纟起 =!= 步长纟讫] #=>互换角色 产生不同轮次
        #####
        [步长纟起 <- {2**e *d0 | [d0 :<- [1..<sss]]}]
            #共(2*s)个
        感觉 可以 安排到 上面的况态:[欤步长自反数为奇数扌(队伍数总数;步长纟起)][步长纟起 =!= 步长纟讫][总步长纟双 == 0]
    ===
    ===

]]

    #]]]'''#'''
    def 欤步长自反数为奇数扌(掩码纟队伍数总数,步长, /):
        return not (步长&掩码纟队伍数总数)
    def 求冫队伍号纟回扌(队伍数总数缺一, 队伍号纟原, /):
        return 队伍数总数缺一 -队伍号纟原
    def loop_body_(队伍数总数, j0, jt, 步长, j, 队伍号讠对手队伍号, /):
        #####jt 可能用到，可能用不到，取决于 是否[is_odd 自反数扌(队伍数总数;步长)]
        #
        #目标:配对 (j,j+步长)
        #但不配对 (j+步长,j+2*步长)
        #   因为:{j+步长,j+2*步长} <==> {(j+2*步长), (j+2*步长)+(队伍数总数-步长)}
        #   (队伍数总数-步长) 出现在 range(1, 队伍数总数)
        # 注意:[步长 =!= 0]
        # 注意:[步长 == 队伍数半数] 只出现一次
        t = (j + 步长) %队伍数总数
        assert 队伍号讠对手队伍号[j] is None, (队伍数半数, (j0, j, 步长, t), 队伍号讠对手队伍号)
            #日字绕圈:方案一:[j==jt]未break:AssertionError: (3, (0, 5, 2, 1), [2, 3, 0, 1, 5, 4])
        if t == j0:
            #[is_odd 自反数扌(队伍数总数;步长)]
            #解决办法:日字绕圈
            t = jt
        assert 队伍号讠对手队伍号[t] is None, (队伍数半数, (j, 步长, t), 队伍号讠对手队伍号)
            #日字绕圈 之前:AssertionError: (3, (4, 2, 0), [2, None, 0, None, None, None])
        队伍号讠对手队伍号[j] = t
        队伍号讠对手队伍号[t] = j
        j = (t + 步长) %队伍数总数
        return j
    def main1(*, 队伍数半数):
        #xxx:蛮力检查冫非合数扌(队伍数半数)
        check_int_ge(1, 队伍数半数)
        队伍数总数 = 队伍数半数*2
        配对方案 = []
        队伍数总数缺一 = 队伍数总数-1
        for 步长 in range(1, 队伍数总数):
            队伍号讠对手队伍号 = [None]*队伍数总数
            #####
            for j in range(队伍数总数):
                if not 队伍号讠对手队伍号[j] is None:continue
                j0 = j
                jt = 队伍号纟回 = 求冫队伍号纟回扌(队伍数总数缺一, 队伍号纟原:=j0)
                while 1:
                    j = loop_body_(队伍数总数, j0, jt, 步长, j, 队伍号讠对手队伍号)
                    if j == j0:break
                    if j == jt:break
                        #相当于 jt再回环一次，变成j0

            #####
            配对方案.append(队伍号讠对手队伍号)
        检查冫圆满配对方案扌(队伍数半数, 配对方案)
        return 配对方案
    def main2(*, 队伍数半数):
        #bug:交错双步长:严重逻辑性错误:连锁排斥=>[欤步长自反数为奇数扌(队伍数总数;步长纟起)]这样的步长是无用的！
        check_int_ge(1, 队伍数半数)
        队伍数总数 = 队伍数半数*2
        配对方案 = []
        队伍数总数缺一 = 队伍数总数-1
        掩码纟队伍数总数 = (队伍数总数^队伍数总数缺一) >> 1
        最大二幂因子纟队伍数总数 = 1+掩码纟队伍数总数
        列表纟步长纟起 = range(最大二幂因子纟队伍数总数,队伍数总数,最大二幂因子纟队伍数总数)
        for 步长 in range(1, 队伍数总数):
            if 1:
                #if 欤步长自反数为奇数扌(掩码纟队伍数总数,步长):
                步长纟起 = 步长
                步长纟讫 = 队伍数总数 -步长
            else:
                步长纟起 = 步长
                步长纟讫 = 队伍数总数 -步长
            #队伍号讠对手队伍号 = [None]*队伍数总数
            队伍号讠对手队伍号 = [(j+步长纟起)%队伍数总数 for j in range(队伍数总数)]
                #bug:连锁排斥=>[欤步长自反数为奇数扌(队伍数总数;步长纟起)]这样的步长是无用的！
            #####

            #####
            配对方案.append(队伍号讠对手队伍号)
        检查冫圆满配对方案扌(队伍数半数, 配对方案)
        return 配对方案

def _构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌():
    r'''[[[
    '直接构造:非递归'
方法:简单的中心对称
* 版本名:非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版
* 版本名:非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版
* 版本名:非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版
* 版本名:非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版
    这是 首个 完整的非递归算法冫循环赛配对方案

[[
[:循环对抗赛配对方案位移辻对称版算法大纲暨证明]:here
    #非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版
    #构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称扌
===
分两种情况:
    ===
    * [is_odd 队伍数半数]:
        #非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版
        #构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌
    ===
    * [is_even 队伍数半数]:
        #非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版
        #构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌
    ===
===
* [is_odd 队伍数半数]:
    !! 偶中心对称
    =>两个 半偶中心 奇偶性不同
    !! 当轮就地配对 两个 半偶中心
    =>刚好 抵消 一轮奇位移{奇位移==队伍数半数}
    => 两部分(偶中心对称,奇位移) 重叠一轮
    => 两部分(偶中心对称,缺一轮奇位移) 不重叠
    !! [轮次数{奇位移}==奇位移数量==(队伍数总数///2)==队伍数半数]
    !! [轮次数{缺一轮奇位移}==奇位移数量-1==队伍数半数-1]
    !! [轮次数{偶中心对称}==偶中心数量==(队伍数总数///2)==队伍数半数]
    => [轮次总数 == 队伍数总数-1]
    !! 两部分(偶中心对称,缺一轮奇位移) 不重叠
    => 配对方案 完整
* [is_even 队伍数半数]:
    隔离 最后两队，前面(队伍数总数-2)队 后缀之以『纟偏心』
    [队伍数总数纟偏心 == 队伍数总数-2]
    [队伍数半数纟偏心 == 队伍数半数-1]
    [is_odd 队伍数半数纟偏心]
    !! 偶偏心对称
    =>两个 半偶偏心 奇偶性不同
    !! 被隔离的最后两队 奇偶性不同
    =>当轮就地配对 (两个 半偶偏心)与(被隔离的最后两队) 使得 配对奇偶性相同
    =>偶偏心对称 这一部分配对方案里，配对奇偶性相同
    !! 奇位移 这一部分配对方案里，配对奇偶性不同
    => 两部分 不重叠
    !! [轮次数{奇位移}==奇位移数量==(队伍数总数///2)==队伍数半数]
    !! [轮次数{偶偏心对称}==偶偏心数量==(队伍数总数纟偏心///2)==队伍数半数-1]
    => [轮次总数 == 队伍数总数-1]
    !! 两部分 不重叠
    => 配对方案 完整
===
]]









[中心 <- [0..<队伍数总数]]
    ???(队伍数总数)个 有效中心???
        比预期(队伍数总数-1)个 多了一个
[中心 <- [1,3..<队伍数总数]]
    见下面:[中心 不能为偶数]
    ???(队伍数总数///2)个 有效中心???
        比预期(队伍数总数-1)个 少了许多
非特殊情况: [中心 =[%队伍数总数]= 队伍号+对手队伍号]
特殊情况: [中心 =[%队伍数总数]= 队伍号*2]
    [中心 == 队伍号*2 %队伍数总数]
    [中心 == 队伍号*2 %(2*队伍数半数)]
    [中心 == 2*(队伍号%队伍数半数)]
    [is_even 中心][(队伍号%队伍数半数) == 中心///2]

特殊情况:
    <==> [[半中心 <- [0..<队伍数半数]][中心 == 2*半中心][{队伍号,对手队伍号} == {半中心, 半中心+队伍数半数}]]
    [(队伍号+对手队伍号)%队伍数总数 == (2*半中心+队伍数半数)%队伍数总数 == (中心+队伍数半数)%队伍数总数 == 其他中心]
    [(中心+队伍数半数)%队伍数总数 == 其他中心]

    [中心 == 其他中心]:
        [(中心+队伍数半数)%队伍数总数 == 其他中心 == 中心]
        [(队伍数半数)%队伍数总数 == 0]
        [队伍数半数 == 0]
        _L
    [中心 =!= 其他中心]
    * [is_odd 队伍数半数]:
        [is_odd 其他中心]
        [{队伍号,对手队伍号} 已经被 奇数的 其他中心 导出]
        [{队伍号,对手队伍号} 已经被 奇数的 其他中心 在非特殊情况下导出 导出]
    * [is_even 队伍数半数]:
        [is_even 其他中心]
        [半其他中心 := 其他中心///2]
        !! [中心 =!= 其他中心]
        [半中心 =!= 半其他中心]
        !! [0 <= 其他中心 < 队伍数总数]
        [0 <= 半其他中心 < 队伍数半数]
        [0 <= 半其他中心+队伍数半数 < 队伍数总数]
        [半中心 == (半其他中心+队伍数半数)%队伍数总数]:
            !! [0 <= 半其他中心+队伍数半数 < 队伍数总数]
            [半中心 == (半其他中心+队伍数半数)]
            !! [(中心+队伍数半数)%队伍数总数 == 其他中心]
            [(2*半中心+队伍数半数)%队伍数总数 == 2*半其他中心]
            [(2*(半其他中心+队伍数半数)+队伍数半数)%队伍数总数 == 2*半其他中心]
            [(2*半其他中心+3*队伍数半数)%队伍数总数 == 2*半其他中心]
            [队伍数半数%队伍数总数 == 0]
            [队伍数半数 == 0]
            _L
        [半中心 =!= (半其他中心+队伍数半数)%队伍数总数]
        !! [半中心 =!= 半其他中心]
        [{队伍号,对手队伍号} == {半中心, 半中心+队伍数半数} =!= {半其他中心, 半其他中心+队伍数半数}]
        [{队伍号,对手队伍号} 已经被 偶数的 其他中心 在非特殊情况下导出]
    [{队伍号,对手队伍号} 已经被 其他中心 在非特殊情况下导出]
    [无效:中心]
    [中心 不能为偶数]

非特殊情况:
    * [中心 <- [1,3..<队伍数总数]]
    * [[半中心 <- [0..<队伍数半数]][中心 == 2*半中心][not$ 队伍号 <- {半中心, 半中心+队伍数半数}]]
    #####
    [中心 =[%队伍数总数]= 队伍号+对手队伍号]
    [对手队伍号 == (中心-队伍号)%队伍数总数 =!= 队伍号]
    [队伍号 == (中心-对手队伍号)%队伍数总数 =!= 对手队伍号]


==>>:偶数半数
    前置条件:[is_even 队伍数半数]
    * 奇中心:使用 奇数 中心%队伍数总数，得(队伍数半数)轮
        无 特殊情况
        # 只能配对:奇偶
        # 不能配对:奇奇,偶偶
    * 偶偏心:使用 偶数 中心%(队伍数总数-2)，得(队伍数半数-1)轮
        # 只能配对:奇奇,偶偶
        # 不能配对:奇偶
        特殊情况:半偶偏心两队 配对 保留的最后两队
            #注意:同奇偶性
        保留的最后两队 奇偶性不同
            => 半偶偏心两队 也需得是奇偶性不同
            !! [{队伍号,对手队伍号} == {半中心, 半中心+队伍数半数}]
            偶偏心:[{队伍号,对手队伍号} == {半偶偏心, 半偶偏心+队伍数半数纟偏心}]
            => [is_odd 队伍数半数纟偏心]
            => [is_odd (队伍数半数-1)]
            => 前置条件:[is_even 队伍数半数]
    共(队伍数总数-1)轮
==>>:奇数半数
    前置条件:[is_odd 队伍数半数]
    * 偶中心:使用 偶数 中心%(队伍数总数)，得(队伍数半数)轮
        非特殊情况:
            只能配对:奇奇,偶偶
            不能配对:奇偶
        特殊情况:半偶中心两队 配对:奇偶
            !! [{队伍号,对手队伍号} == {半中心, 半中心+队伍数半数}]
            偶中心:[{队伍号,对手队伍号} == {半偶中心, 半偶中心+队伍数半数}]
            !! [is_odd 队伍数半数]
            半偶中心两队 奇偶性不同
    * 奇中心:取消
        !! 偶中心情形:侵占了 部分奇偶配对
        取消 奇中心 配对方案
        侵占部分 刚好是 [位移==队伍数半数]的一轮简单位移
    * 简单位移:配对奇偶:使用 奇位移:只跳过[位移==队伍数半数]，得(队伍数半数-1)轮
        只有 奇位移 能 保证 成环长度为偶数
            见:欤步长自反数为奇数扌
    共(队伍数总数-1)轮

    #]]]'''#'''
    #非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版
    #非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版
    #非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版
    #非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版
    def 篡改配对扌(ls, j, i, /):
        ls[j] = i
        ls[i] = j
    def 伪配对暨不动点扌(队伍数半数, 队伍数总数, 中心, /):
        队伍号讠对手队伍号纟伪 = 伪配对扌(队伍数半数, 队伍数总数, 中心)
        列表纟不动点 = [队伍号 for 队伍号, 对手队伍号纟伪 in enumerate(队伍号讠对手队伍号纟伪) if 队伍号 == 对手队伍号纟伪]
        欤偶偏心 = 中心&1 == 0
        assert len(列表纟不动点) == (2*欤偶偏心)
        if 欤偶偏心:
            半偏心 = 中心>>1
            assert 列表纟不动点 == [半偏心, 半偏心+队伍数半数]
        return (队伍号讠对手队伍号纟伪, 列表纟不动点)
    def 伪配对扌(队伍数半数, 队伍数总数, 中心, /):
        return (队伍号讠对手队伍号纟伪 := [对称扌(队伍数半数, 队伍数总数, 中心, 队伍号) for 队伍号 in range(队伍数总数)])
    def 对称扌(队伍数半数, 队伍数总数, 中心, 队伍号, /):
        对手队伍号纟伪 = (中心 -队伍号)%队伍数总数
        return 对手队伍号纟伪
    def 乊奇中心扌(队伍数半数, 队伍数总数, 奇中心, /):
        # 只能配对:奇偶
        # 不能配对:奇奇,偶偶
        assert 奇中心&1 == 1
        (队伍号讠对手队伍号纟伪, 列表纟不动点) = 伪配对暨不动点扌(队伍数半数, 队伍数总数, 奇中心)
        assert len(列表纟不动点) == 0
        # !! 没有 不动点
        return (队伍号讠对手队伍号 := 队伍号讠对手队伍号纟伪)
    def 乊偶偏心扌(剩余两队纟偏心, 队伍数半数纟偏心, 队伍数总数纟偏心, 偶偏心, /):
        # 只能配对:奇奇,偶偶
        # 不能配对:奇偶

        ###前置条件:[is_even 队伍数半数]
        # !! 前置条件:[is_odd 队伍数半数纟偏心]
        assert 队伍数半数纟偏心&1 == 1
        assert 偶偏心&1 == 0
        (队伍号讠对手队伍号纟伪, 列表纟不动点) = 伪配对暨不动点扌(队伍数半数纟偏心, 队伍数总数纟偏心, 偶偏心)
        assert len(列表纟不动点) == 2
        #
        #特殊情况:配对剩余两队
            #注意:同奇偶性
        # !! 前置条件:[is_odd 队伍数半数纟偏心]
        assert not 列表纟不动点[0]&1 == 列表纟不动点[1]&1, (队伍数半数纟偏心, 列表纟不动点)
        if 列表纟不动点[0]&1 == 1:
            列表纟不动点 = 列表纟不动点[::-1]
        assert 列表纟不动点[0]&1 == 剩余两队纟偏心[0]&1 == 0
        队伍号讠对手队伍号纟伪 += 列表纟不动点
            #<==> 队伍号讠对手队伍号纟伪[队伍号纟剩余] = 队伍号纟不动点
        for 队伍号纟不动点, 队伍号纟剩余 in zip(列表纟不动点, 剩余两队纟偏心):
            队伍号讠对手队伍号纟伪[队伍号纟不动点] = 队伍号纟剩余
        return (队伍号讠对手队伍号 := 队伍号讠对手队伍号纟伪)
    def 乊偶中心扌(队伍数半数, 队伍数总数, 偶中心, /):
        # 特殊情况:配对:奇偶
        # 非特殊情况:
        #       只能配对:奇奇,偶偶
        #       不能配对:奇偶

        # !! 前置条件:[is_odd 队伍数半数]
            # ==>>特殊情况:配对:奇偶
        assert 队伍数半数&1 == 1
        assert 偶中心&1 == 0
        (队伍号讠对手队伍号纟伪, 列表纟不动点) = 伪配对暨不动点扌(队伍数半数, 队伍数总数, 偶中心)
        assert len(列表纟不动点) == 2
        #
        #特殊情况:配对:半偶中心两队
            #注意:奇偶性不同
        # !! 前置条件:[is_odd 队伍数半数]
        assert not 列表纟不动点[0]&1 == 列表纟不动点[1]&1, (队伍数半数, 列表纟不动点)
        for 队伍号纟不动点, 对手队伍号纟不动点 in (列表纟不动点, 列表纟不动点[::-1]):
            队伍号讠对手队伍号纟伪[队伍号纟不动点] = 对手队伍号纟不动点
        return (队伍号讠对手队伍号 := 队伍号讠对手队伍号纟伪)

    def 乊奇位移扌(队伍数半数, 队伍数总数, 奇位移, /):
        #只有 奇位移 能 保证 成环长度为偶数#见:欤步长自反数为奇数扌
        check_uint_lt(队伍数总数, 奇位移)
        if not 奇位移&1 == 1:raise TypeError
        队伍号讠对手队伍号 = [None]*队伍数总数
        j2next = [*range(奇位移,队伍数总数), *range(奇位移)]
        j2used = [False]*队伍数总数
        def put(j, /):
            if j2used[j]:raise 000
            j2used[j] = True
            交错环.append(j)
            return
        for j in range(队伍数总数):
            if j2used[j]:continue
            交错环 = []
            j0 = j
            while 1:
                put(j)
                队伍号 = j
                j = j2next[j]
                put(j)
                对手队伍号 = j
                j = j2next[j]
                队伍号讠对手队伍号[队伍号] = 对手队伍号
                队伍号讠对手队伍号[对手队伍号] = 队伍号
                if j == j0:break
            assert len(交错环)&1 == 0
        return 队伍号讠对手队伍号
    #def main(*, 队伍数半数):
    def 部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅部分奇位移扌(配对方案, 队伍数半数, 列表纟奇位移, /):
        #只止于:指定奇位移:(len(列表纟奇位移))轮
        #只有 奇位移 能 保证 成环长度为偶数#见:欤步长自反数为奇数扌
        check_int_ge(1, 队伍数半数)
        队伍数总数 = 队伍数半数*2
        for 奇位移 in 列表纟奇位移:
            队伍号讠对手队伍号 = 乊奇位移扌(队伍数半数, 队伍数总数, 奇位移)
            配对方案.append(队伍号讠对手队伍号)
        return#配对方案
    def 部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅偶中心对称部分乊仅限于奇数半数扌(配对方案, 队伍数半数, /):
        #只止于:偶中心对称部分:(队伍数半数)轮
        check_int_ge(1, 队伍数半数)
        if not 队伍数半数&1 == 1: raise TypeError('前置条件:[is_odd 队伍数半数]')
        # 前置条件:[is_odd 队伍数半数]
        队伍数总数 = 队伍数半数*2
        ######################
        for 偶中心 in range(0, 队伍数总数, 2):
            队伍号讠对手队伍号 = 乊偶中心扌(队伍数半数, 队伍数总数, 偶中心)
            配对方案.append(队伍号讠对手队伍号)
        return#配对方案
    def 部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅偶偏心对称部分乊仅限于偶数半数扌(配对方案, 队伍数半数, /):
        #只止于:偶偏心对称部分:(队伍数半数-1)轮
        check_int_ge(1, 队伍数半数)
        if not 队伍数半数&1 == 0: raise TypeError('前置条件:[is_even 队伍数半数]')
        # 前置条件:[is_even 队伍数半数]
        # 前置条件:[is_odd 队伍数半数纟偏心]
        队伍数总数 = 队伍数半数*2
        队伍数总数纟偏心 = 队伍数总数-2
        剩余两队纟偏心 = range(队伍数总数纟偏心, 队伍数总数)
        assert len(剩余两队纟偏心) == 2
        队伍数半数纟偏心 = 队伍数半数-1
        ######################
        for 偶偏心 in range(0, 队伍数总数纟偏心, 2):
            队伍号讠对手队伍号 = 乊偶偏心扌(剩余两队纟偏心, 队伍数半数纟偏心, 队伍数总数纟偏心, 偶偏心)
            配对方案.append(队伍号讠对手队伍号)
        return#配对方案
    def 部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅部分奇中心对称扌(配对方案, 队伍数半数, 列表纟奇位移, /):
        #只止于:奇中心对称部分:(len(列表纟奇位移))轮
        队伍数总数 = 队伍数半数*2
        for 奇中心 in 列表纟奇位移:
            队伍号讠对手队伍号 = 乊奇中心扌(队伍数半数, 队伍数总数, 奇中心)
            配对方案.append(队伍号讠对手队伍号)
        return#配对方案
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    def 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌(*, 队伍数半数):
        #非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版
        check_int_ge(1, 队伍数半数)
        if not 队伍数半数&1 == 0: raise TypeError('前置条件:[is_even 队伍数半数]')
        ######################
        配对方案 = []
        部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅偶偏心对称部分乊仅限于偶数半数扌(配对方案, 队伍数半数)
        队伍数总数 = 队伍数半数*2
        部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅部分奇中心对称扌(配对方案, 队伍数半数, 列表纟奇位移:=range(1, 队伍数总数, 2))
        ######################
        检查冫圆满配对方案扌(队伍数半数, 配对方案)
        return 配对方案
    #end-def main():
    def 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌(*, 队伍数半数):
        #非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版
        check_int_ge(1, 队伍数半数)
        if not 队伍数半数&1 == 0: raise TypeError('前置条件:[is_even 队伍数半数]')
        ######################
        配对方案 = []
        队伍数总数 = 队伍数半数*2
        部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅部分奇位移扌(配对方案, 队伍数半数, 列表纟奇位移:=range(1, 队伍数总数, 2))
        部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅偶偏心对称部分乊仅限于偶数半数扌(配对方案, 队伍数半数)
        ######################
        检查冫圆满配对方案扌(队伍数半数, 配对方案)
        return 配对方案
    #end-def main():
    def 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌(*, 队伍数半数):
        #非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版
        check_int_ge(1, 队伍数半数)
        if not 队伍数半数&1 == 1: raise TypeError('前置条件:[is_odd 队伍数半数]')
        ######################
        配对方案 = []
        队伍数总数 = 队伍数半数*2
        列表纟奇位移纟缺一轮 = [*range(1, 队伍数总数, 2)]
        列表纟奇位移纟缺一轮.remove(队伍数半数)
        部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅部分奇位移扌(配对方案, 队伍数半数, 列表纟奇位移:=列表纟奇位移纟缺一轮)
        部分构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫仅偶中心对称部分乊仅限于奇数半数扌(配对方案, 队伍数半数)
        ######################
        检查冫圆满配对方案扌(队伍数半数, 配对方案)
        return 配对方案
    #end-def main():
    def 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称扌(*, 队伍数半数):
        #非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版
        check_int_ge(1, 队伍数半数)
        if 队伍数半数&1 == 0:
            # 偶数半数
            f = 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌
        else:
            # 奇数半数
            f = 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌
        return f(队伍数半数=队伍数半数)
    #end-def main():
    main4偶数半数冖冖对称 = 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌
    main4偶数半数冖冖对称辻位移 = 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌
    main4奇数半数冖冖对称辻位移 = 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌
    main4合成 = 构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称扌
    return (main4偶数半数冖冖对称, main4偶数半数冖冖对称辻位移, main4奇数半数冖冖对称辻位移, main4合成)
def __():
    mk_fs_ = _构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌
    fs = mk_fs_()
    for f in fs:
        f.__doc__ = mk_fs_.__doc__
    return fs
[构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌
,构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌
,构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌
,构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称扌
] = __()




def __():
    #失败品:
  def 蛮力搜索冫只差一对的拟遍历圈纟循环对抗赛配对方案冖冖扩张预备扌(配对方案, /):
    '[O(队伍数总数**2)]: -> (鬽 队伍号纟起,列表纟轮次,拟遍历圈) #==>>拟遍历圈/[队伍号]{len=队伍数总数-2}) #拟遍历圈:只差一对/两支队伍 #用途:新增两队 #退化:[队伍数总数==4]:[len(拟遍历圈)==2][两队，但只有一个轮次，即 圈 退化为 线段]'
    首轮 = 配对方案[0]
        #跳过，只使用 后面 (队伍数总数-2)轮
    队伍数总数 = len(首轮)
    assert 队伍数总数 >= 2
    assert 队伍数总数&1 == 0
    轮次总数 = len(配对方案)
    assert 队伍数总数 == 1+轮次总数
    队伍数半数 = 队伍数总数>>1
    assert 队伍数总数 == 队伍数半数*2
    if 队伍数总数 == 4:
        return NotImplemented
    列表纟轮次 = []
    拟遍历圈 = []
    if 队伍数总数==2:
        return (鬽队伍号纟起:=None, 列表纟轮次,拟遍历圈)
    from seed.data_funcs.idc_mngr import DoublyList4Idc
    #xxx:剩余队伍集合 = DoublyList4Idc(队伍数总数, range(队伍数总数))
    if 0:
        #bug:见下面:Exception(队伍数总数, 队伍数半数, 配对方案, (队伍号纟起, 列表纟轮次,拟遍历圈), 队伍号, 剩余队伍集合, 剩余轮次集合)
        #Exception: (4, 2, [[1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]], (3, [], []), 3, DoublyList4Idc(4, [2, 3]), DoublyList4Idc(3, [1, 2]))
        剩余队伍集合 = DoublyList4Idc(max1:=队伍数总数, range(2, 队伍数总数))
            #强制排除 第0队,第1队
        剩余轮次集合 = DoublyList4Idc(max1:=轮次总数, range(1, 轮次总数))
            #强制排除 首轮
        assert 轮次总数-1 == len(剩余轮次集合) == len(剩余队伍集合) == 队伍数总数-2
    else:
        #bug:Exception: (4, 2, [[1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]], (3, [0, 1], [2, 1]), 3, DoublyList4Idc(4, [3]), DoublyList4Idc(3, [2]))
        剩余队伍集合 = DoublyList4Idc(max1:=队伍数总数, range(1, 队伍数总数))
            #强制排除 第0队
        剩余轮次集合 = DoublyList4Idc(max1:=轮次总数, range(轮次总数))

    队伍号纟起 = 剩余队伍集合.last
    assert len(剩余轮次集合) == len(剩余队伍集合)
    def 消耗冫轮次扌(轮次,/):
        剩余轮次集合.remove(轮次)
        列表纟轮次.append(轮次)
    def 消耗冫队伍号扌(队伍号, /):
        剩余队伍集合.remove(队伍号)
        拟遍历圈.append(队伍号)
    def 搜索冫轮次对手巛队伍号扌(队伍号, /):
        '[O(队伍数总数)]: -> (轮次,对手队伍号)'
        if len(拟遍历圈) == (队伍数总数-3):
            # 目标:(队伍数总数-2)
            # 只差:加入:队伍号纟起
            # 只需:找到 [对手队伍号==队伍号纟起] 的 轮次
            欤结束 = True
        else:
            欤结束 = False
        for 轮次 in 剩余轮次集合:
            对手队伍号 = 配对方案[轮次][队伍号]
            if 对手队伍号 in 剩余队伍集合:
                #if 欤结束 and not 对手队伍号==队伍号纟起:
                #    continue
                #if not 欤结束 and 对手队伍号==队伍号纟起:
                #    continue
                if not 欤结束 is (对手队伍号==队伍号纟起):
                    continue
                #可能:[对手队伍号==队伍号纟起]
                return (轮次,对手队伍号)
        raise Exception(队伍数总数, 队伍数半数, 配对方案, (队伍号纟起, 列表纟轮次,拟遍历圈), 队伍号, 剩余队伍集合, 剩余轮次集合)
        #Exception: (4, 2, [[1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]], (3, [], []), 3, DoublyList4Idc(4, [2, 3]), DoublyList4Idc(3, [1, 2]))
        #   #原因:
        #   #强制排除 第0队,第1队
        #   #强制排除 首轮
        #
        #Exception: (4, 2, [[1, 0, 3, 2], [2, 3, 0, 1], [3, 2, 1, 0]], (3, [0, 1], [2, 1]), 3, DoublyList4Idc(4, [3]), DoublyList4Idc(3, [2]))
        #   #原因:
        #   #强制排除 第0队
        #
        #Exception: (6, 3, [[1, 0, 3, 2, 5, 4], [2, 4, 0, 5, 1, 3], [3, 5, 4, 0, 2, 1], [4, 3, 5, 1, 0, 2], [5, 2, 1, 4, 3, 0]], (5, [0, 1, 3], [4, 1, 3]), 3, DoublyList4Idc(6, [2, 5]), DoublyList4Idc(5, [2, 4]))
        #   感觉不太行:(3-->5)只出现在 第1轮, 而 第一轮 用于 (4-->1)
    队伍号 = 队伍号纟起
    while 1:
        #while 剩余轮次集合:
        assert len(剩余轮次集合) == len(剩余队伍集合)
        (轮次,对手队伍号) = 搜索冫轮次对手巛队伍号扌(队伍号)
        消耗冫轮次扌(轮次)
        #可能:[对手队伍号==队伍号纟起]
        消耗冫队伍号扌(对手队伍号)
        if 对手队伍号 == 队伍号纟起:
            #assert not len(剩余队伍集合)
            assert len(剩余队伍集合) == 1, (剩余队伍集合, 队伍号纟起, 列表纟轮次,拟遍历圈)
            break
        assert len(剩余队伍集合) >= 2
        队伍号 = 对手队伍号


    return (鬽队伍号纟起:=队伍号纟起, 列表纟轮次,拟遍历圈)

_版本名讠匴构造器
_版本名讠非递归构造器 = (dict
    (蛮力最小化版=蛮力搜索冫循环对抗赛配对方案冖冖最小化扌
    ,非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数版=构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫偶偏心对称辻奇中心对称乊仅限于偶数半数扌
    ,非递归冫奇位移辻偶偏心对称乊仅限于偶数半数版=构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫奇位移辻偶偏心对称乊仅限于偶数半数扌
    ,非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数版=构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫缺一轮奇位移辻偶中心对称乊仅限于奇数半数扌
    ,非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称版=构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫惑缺一轮奇位移辻惑偶偏心偶中心对称扌
    #失败# ,非递归冫交错位移日字绕圈版=构建冫循环对抗赛配对方案冖冖规则化冖冖非递归冫交错位移日字绕圈扌
    ))
assert not (_版本名讠匴构造器.keys() & _版本名讠非递归构造器.keys())
def 列表化冫所有版本名扌():
    列表纟版本名 = [*_版本名讠匴构造器.keys(), *_版本名讠非递归构造器.keys()]
    列表纟版本名.sort()
    return 列表纟版本名

def 合并冫二轮纟配对方案扌(首轮, 次轮, /, *, 欤紧凑文本化=False):
    '-> 合并轮纟二轮/[[uint]] if not 欤紧凑文本化 else 紧凑文本/str'
    # [:二轮定理:循环赛配对方案中任意两轮赛事交错成环丶环长为偶数丶环长大于等于四]:goto
    合并轮纟二轮 = []
    队伍数总数 = len(首轮)
    j2used = [False]*队伍数总数
    def put(j, /):
        if j2used[j]:raise 000
        j2used[j] = True
        交错环.append(j)
        return
    for j in range(队伍数总数):
        if j2used[j]:continue
        交错环 = []
        j0 = j
        while 1:
            put(j)
            j = 首轮[j]
            put(j)
            j = 次轮[j]
            if j == j0:break
        assert len(交错环)&1 == 0
        合并轮纟二轮.append(交错环)
    assert sum(map(len, 合并轮纟二轮)) == 队伍数总数
    if 欤紧凑文本化:
        紧凑文本 = 紧凑文本化冫合并轮纟二轮扌(合并轮纟二轮)
        return 紧凑文本
    return 合并轮纟二轮
def 紧凑文本化冫合并轮纟二轮扌(合并轮纟二轮, /):
    '-> str'
    def f(交错环,/):
        return ','.join(map(str, 交错环))
    def ff(合并轮纟二轮,/):
        return ';'.join(map(f, 合并轮纟二轮))
    s = ff(合并轮纟二轮)
    return f'[{s!s};]'

def 标准压缩冫配对方案扌(配对方案, /, *, 欤紧凑文本化=False):
    '-> 标准压缩后配对方案/[合并轮纟二轮]/[[[uint]]]'
    轮次纟跳过 = 0
    轮纟跳过 = 配对方案[轮次纟跳过]
    队伍数总数 = len(配对方案[0])
    标准首轮纟跳过 = [None]*队伍数总数
    标准首轮纟跳过[0::2] = range(队伍数总数)[1::2]
    标准首轮纟跳过[1::2] = range(队伍数总数)[0::2]
    if not 轮纟跳过 == 标准首轮纟跳过:raise ValueError(配对方案)
    压缩后配对方案 = 压缩冫配对方案扌(轮次纟跳过, 配对方案, 欤紧凑文本化=欤紧凑文本化)
    (轮次纟跳过,轮纟跳过,主体纟压缩后配对方案) = 压缩后配对方案
    标准压缩后配对方案 = 主体纟压缩后配对方案
    return 标准压缩后配对方案
def 压缩冫配对方案扌(轮次纟跳过, 配对方案, /, *, 欤紧凑文本化=False):
    '-> 压缩后配对方案/(轮次纟跳过,轮纟跳过,主体纟压缩后配对方案/[合并轮纟二轮]/[[[uint]]])'
    # [:二轮定理:循环赛配对方案中任意两轮赛事交错成环丶环长为偶数丶环长大于等于四]:goto
    轮次总数 = len(配对方案)
    队伍数总数 = len(配对方案[0])
    assert 队伍数总数 == 1+轮次总数
    队伍数半数 = 队伍数总数>>1
    assert 队伍数总数 == 队伍数半数*2
    assert 0 <= 轮次纟跳过 < 轮次总数
    轮纟跳过 = 配对方案[轮次纟跳过]
    def __(配对方案, /):
        配对方案 = 配对方案.copy()
        del 配对方案[轮次纟跳过]
        for j in range(0, 轮次总数-1, 2):
            首轮 = 配对方案[j]
            次轮 = 配对方案[j+1]
            合并轮纟二轮 = 合并冫二轮纟配对方案扌(首轮, 次轮, 欤紧凑文本化=欤紧凑文本化)
            yield 合并轮纟二轮
    主体纟压缩后配对方案 = [*__(配对方案)]
    压缩后配对方案 = (轮次纟跳过,轮纟跳过,主体纟压缩后配对方案)
    return 压缩后配对方案


__all__

from script.循环对抗赛配对方案 import 检查冫圆满配对方案扌,列表化冫所有版本名扌

from script.循环对抗赛配对方案 import 魖循环对抗赛配对方案冖冖规则化冖冖分而治之
from script.循环对抗赛配对方案 import 就地适配队伍号冫配对方案扌,组间配对冖冖相同扌,组间配对冖冖差一扌

from script.循环对抗赛配对方案 import 紧凑文本化冫配对方案扌,紧凑文本化冫合并轮纟二轮扌,合并冫二轮纟配对方案扌,压缩冫配对方案扌,标准压缩冫配对方案扌

from script.循环对抗赛配对方案 import 输出枚举冫循环对抗赛配对方案冖冖规则化扌,构建冫循环对抗赛配对方案冖冖规则化扌,枚举冫循环对抗赛配对方案冖冖规则化扌


from script.循环对抗赛配对方案 import 构建冫循环对抗赛配对方案冖冖规则化扌,构建冫循环对抗赛配对方案冖冖规则化冖冖易用接口扌,构建冫循环对抗赛配对方案巛变量环境扌

from script.循环对抗赛配对方案 import 枚举冫循环对抗赛配对方案冖冖规则化扌,枚举冫队伍数半数扌,枚举冫队伍数半数巛变量环境扌





from script.循环对抗赛配对方案 import *
