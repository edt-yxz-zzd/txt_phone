#__all__:goto
r'''[[[
e ./script/完全错装数.py
view ./script/complete_diffusion.py
view ../../python3_src/seed/math/combination.py
[[
当下:已完成:
    证明:比例夹逼定理纟完全错装数
    新构造器:完全错装数爫隔离索引零扌
    蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌
    枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
    #xxx:bug:蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌
    枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌
    枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌
        枚举冫环节长度列表扌
    #初步:各枚举版一具现
    枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌

当下:待办:
    填充:枚举冫某某某某某...
    填充:索取冫某某某某某...
    填充:定位冫某某某某某...
    填充:变换冫某某某某某...
    ...
]]


[[
命名规范:
view ../../python3_src/useful__cjk_naming.txt
『爫』:using/via
『牜』:指定小分类/细化约束条件/版本
『耂』:正向『的』:『形容词-耂-名词性短语』
孑孓:孑/孓:prev,next/succ:上一个,下一个:前一个,后一个:左一个,右一个
]]

[[
为何再次? #已有view ./script/complete_diffusion.py
    主要原因:新的构造法:
        * 旧方法:面向 置换循环小节
            # [置换循环小节::[uint]]
            # [置换环节表达::[置换循环小节]]
            #??可能用于 枚举冫完全错装耂置换环节表达冖冖已排序版扌
        * 新方法:面向 置换映射表达
            #用于:枚举冫完全错装耂置换映射表达冖冖已排序版扌
]]



script.完全错装数
py -m nn_ns.app.debug_cmd   script.完全错装数 -x
py -m nn_ns.app.doctest_cmd script.完全错装数:__doc__
py_adhoc_call   script.完全错装数   ,枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌 =7  --固实丷视图丨变换器=False  -欤变换器翨甤视图


py_adhoc_call   script.完全错装数   ,枚举冫不定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌 =1 '=[*range(4)[::-1]]'   =[]  =[]
py_adhoc_call   script.完全错装数   ,枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌  =7


py_adhoc_call   script.完全错装数   ,枚举冫定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌 =5 =1 =2 '=[*range(8)[::-1]]'   =[]  =[]
    不显示:固定的:[0,1]
        <<== 『=2』
    显示:固定的:[2]
        <<== 『=1』
    限定长度:0+5
        <<== 『=5』+『=[]』

py_adhoc_call   script.完全错装数   ,枚举冫定长耂泛排列牜记录位次冖冖已排序版扌 =3 '=[*range(8)[::-1]]'

py_adhoc_call   script.完全错装数   ,枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌  =7


py_adhoc_call   script.完全错装数   ,枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌  --固实丷视图丨变换器=False  -欤变换器翨甤视图  =7









[[证明区:
[比例夹逼定理纟完全错装数:偶总数的完全错装数占比递减丶奇总数的完全错装数占比递增丶偶总数的完全错装数占比大于奇总数的完全错装数占比丶两序列极限值相同丶该极限值为自然对数底的倒数]
    # 用于:蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌
    #   #占比极限:0.3~0.4
    #
    [[k >= 0] -> [完全错装数占比(2*k) > 完全错装数占比(2*k+2)]]
        #偶总数的完全错装数占比递减
    [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3)]]
        #奇总数的完全错装数占比递增
    [[m,n >= 0] -> [完全错装数占比(2*m+1) < 完全错装数占比(2*n)]]
        #偶总数的完全错装数占比大于奇总数的完全错装数占比
        !! 一递减，一递增
        <==> [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k)]]

    上面三式 <==> [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
    [limit [完全错装数占比(2*m+1) | [m :<- [0..]]] == limit [完全错装数占比(2*n) | [n :<- [0..]]]]
        #两序列极限值相同
        !! 单调有界=>极限存在
        <==> [limit [完全错装数占比(2*k) -完全错装数占比(2*k+1) | [k :<- [0..]]] == 0]

    [limit [完全错装数占比(m) | [m :<- [0..]]] == 1/math.e]
        #该极限值为自然对数底的倒数
===
目标一: [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
目标二: [limit [完全错装数占比(2*k) -完全错装数占比(2*k+1) | [k :<- [0..]]] == 0]
目标三: [limit [完全错装数占比(m) | [m :<- [0..]]] == 1/math.e]

===
证明:目标一
* 基本情形纟归纳法:
* 基本情形纟归纳法冫偶总数:
    #偶总数的完全错装数占比序列:
    [完全错装数占比(总数:=0) == 完全错装数(0;)/阶乘扌(0) == 1/1 == 1]
    [完全错装数占比(总数:=2) == 完全错装数(2;)/阶乘扌(2) == 1/2 == 0.5]

* 基本情形纟归纳法冫奇总数:
    #奇总数的完全错装数占比序列:
    [完全错装数占比(总数:=1) == 完全错装数(1;)/阶乘扌(1) == 0/1 == 0]
    [完全错装数占比(总数:=3) == 完全错装数(3;)/阶乘扌(3) == 2/6 ~= 0.33]
基本情形纟归纳法==>>[目标一:在[k==0]时成立]

* 递归情形纟归纳法:
归纳假设: [n >= 1][@[k :<- [0..<n]] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
归纳目标: [完全错装数占比(2*n+1) < 完全错装数占比(2*n+3) < 完全错装数占比(2*n+2) < 完全错装数占比(2*n)]

    [[
    ###[本小段失败:移至下一段]
    !! [完全错装数爫排除法扌(总数;) =[def]= (阶乘扌(总数) -sum [组合数扌(总数;错装数)*完全错装数(总数:=错装数;) | [错装数:<-[0..<总数]]])]
        # [:定义冫完全错装数爫排除法扌]:goto

    [完全错装数(m;) == (阶乘扌(m) -sum [组合数扌(m;u)*完全错装数(u;) | [u:<-[0..<m]]])]

    [完全错装数占比(m;)
    == (1 -sum [组合数扌(m;u)*阶乘扌(u)/阶乘扌(m)*完全错装数占比(u;) | [u:<-[0..<m]]])
    == (1 -sum [完全错装数占比(u;)/阶乘扌(m-u) | [u:<-[0..<m]]])
    ]
    [完全错装数占比(m;) == (1 -sum [完全错装数占比(u;)/阶乘扌(m-u) | [u:<-[0..<m]]])]
    [完全错装数占比(m+2;) == (1 -sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<m+2]]])]
    [完全错装数占比(m+2;) -完全错装数占比(m;)
    == (1 -sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<m+2]]])
    -  (1 -sum [完全错装数占比(u;)/阶乘扌(m-u) | [u:<-[0..<m]]])
    == sum [完全错装数占比((u-2);)/阶乘扌(m-(u-2)) | [(u-2):<-[0..<m]]]
    -  sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<m+2]]]
    == sum [(完全错装数占比(u-2;) -完全错装数占比(u;))/阶乘扌(m+2-u) | [u:<-[2..<m+2]]]
    -  sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<2]]]
    == sum [(完全错装数占比(u-2;) -完全错装数占比(u;))/阶乘扌(m+2-u) | [u:<-[2..<m+2]]]
    -  1/阶乘扌(m+2)
    * [[is_odd u][u < 2*n+3]]:
        !! 归纳假设
        [(完全错装数占比(u-2;) -完全错装数占比(u;)) < 0]
        #bug:... < 0
        #有正有负...???
    * [[is_even u][u < 2*n+2]]:
        !! 归纳假设
        [(完全错装数占比(u-2;) -完全错装数占比(u;)) > 0]
    #失败！改用: [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:goto
    ]
    ###[本小段失败:移至下一段]
    ]]

    ###新尝试:
    !! [完全错装数爫隔离索引零扌(总数;) =[def]= if 总数 < 0 then 0 elif 总数 < 2 then 1-总数 else (总数-1)*(完全错装数(总数-2;) +完全错装数(总数-1;))]
        # [:定义冫完全错装数爫隔离索引零扌]:goto

    [m >= 2]:
        [完全错装数(m;) == (m-1)*(完全错装数(m-2;) +完全错装数(m-1;))]

        [完全错装数占比(m;)
        == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m
        ]
        !! [1/m + (m-1)/m == 1]
        !! [m-1 > 0]
        [完全错装数占比(m;) between {完全错装数占比(m-2;), 完全错装数占比(m-1;)}]
        #
    [[m >= 2] -> [完全错装数占比(m;) == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m]]
    [[m >= 2] -> [完全错装数占比(m;) between {完全错装数占比(m-2;), 完全错装数占比(m-1;)}]]
    !! [n >= 1]
    [2*n >= 2]
    [完全错装数占比(2*n+2;) between {完全错装数占比(2*n;), 完全错装数占比(2*n+1;)}]
    [完全错装数占比(2*n+3;) between {完全错装数占比(2*n+1;), 完全错装数占比(2*n+2;)}]

    [k := n-1]:
        !! [@[k :<- [0..<n]] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
        [完全错装数占比(2*(n-1)+1) < 完全错装数占比(2*(n-1)+3) < 完全错装数占比(2*(n-1)+2) < 完全错装数占比(2*(n-1))]
    [完全错装数占比(2*n-1) < 完全错装数占比(2*n+1) < 完全错装数占比(2*n) < 完全错装数占比(2*n-2)]
    !! [完全错装数占比(2*n+2;) between {完全错装数占比(2*n;), 完全错装数占比(2*n+1;)}]
    !! [完全错装数占比(2*n+1) < 完全错装数占比(2*n)]
    [完全错装数占比(2*n+1) < 完全错装数占比(2*n+2;) < 完全错装数占比(2*n)]
    !! [完全错装数占比(2*n+3;) between {完全错装数占比(2*n+1;), 完全错装数占比(2*n+2;)}]
    [完全错装数占比(2*n+1) < 完全错装数占比(2*n+3;) < 完全错装数占比(2*n+2;) < 完全错装数占比(2*n)]
    证毕:归纳目标
证毕:目标一
===
证明:目标二
    !! [[m >= 2] -> [完全错装数占比(m;) == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m]]
        #见上面
    [m >= 2]:
        [完全错装数占比(m;) == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m]
        [完全错装数占比(m-1;) -完全错装数占比(m;) == -(完全错装数占比(m-2;) -完全错装数占比(m-1;))/m]
    [m >= 3]:
        [完全错装数占比(m-2;) -完全错装数占比(m-1;) == -(完全错装数占比(m-3;) -完全错装数占比(m-2;))/(m-1)]
        [完全错装数占比(m-1;) -完全错装数占比(m;) == (完全错装数占比(m-3;) -完全错装数占比(m-2;))/m/(m-1)]
    [k >= 1]:
        [2*k+1 >= 3]
        # [m := 2*k+1]
        [(完全错装数占比(2*k) -完全错装数占比(2*k+1)) == (完全错装数占比(2*k-2;) -完全错装数占比(2*k-1;))/(2*k+1)/(2*k) == (完全错装数占比(0;) -完全错装数占比(1;))/阶乘扌(2*k+1) == 1/阶乘扌(2*k+1)]
    [(完全错装数占比(2*k) -完全错装数占比(2*k+1)) == 1/阶乘扌(2*k+1)]
    [limit [(完全错装数占比(2*k) -完全错装数占比(2*k+1)) | [k :<- [0..]]] == limit [1/阶乘扌(2*k+1) | [k :<- [0..]]] == 0]
证毕:目标二

证明:目标三
    [m >= 2]:
        [完全错装数占比(m-1;) -完全错装数占比(m;) == -(完全错装数占比(m-2;) -完全错装数占比(m-1;))/m]
    [m >= 2]:
        [f(m)-f(m-1) == -(f(m-1)-f(m-2))/m]
        [f(m)-f(m-1) == (-1)**(m-1) *(f(1)-f(0))/m/.../2]
        [f(m)-f(m-1) == (-1)**m/m!]
        ... ...
        [f(2)-f(1) == (-1)**2/2!]
        [f(m)-f(1) == sum [(-1)**k/k! | [k:<-[2..=m]]]]
        [f(m) == sum [(-1)**k/k! | [k:<-[2..=m]]]]
            # [:等式纟非递归构造法]:goto
        !! [e**x == sum x**k/k! {k :<- [0..]}]
        [limit f(m) {m-->+oo} == 1/e -(1 -1) = 1/e]
            # ~= 0.36787944117144233
    [limit [完全错装数占比(m) | [m :<- [0..]]] == 1/math.e]
证毕:目标三
证毕:比例夹逼定理纟完全错装数


===
]]
[[定义区:
===
重点:
枚举冫完全错装耂置换映射表达冖冖已排序版扌
索取冫完全错装耂置换映射表达巛流水号扌
变换冫索引乊流水号纟完全错装耂置换映射表达扌
===
===
#置换:
#加密用变换:
#一对一映射:
* 置换映射表达
    #等价类平凡冫唯我
* 置换环节表达
    等价类非平凡
* 置换环节紧凑表达
    等价类非平凡
[整数列表 :: [int]]:
    [欤整数列表是置换映射表达扌(整数列表) =[def]= let [总数:=len(整数列表)] in (all(0 <= i < 总数 for i in 整数列表) and sorted(整数列表) == [0..<总数])]
    [[整数列表::置换映射表达] =[def]= 欤整数列表是置换映射表达扌(整数列表)]
    # [置换映射表达::[新索引]]
    # [置换映射表达==旧索引讠新索引]
[整数列表列表 :: [[int]]]:
    [欤整数列表列表是置换环节表达扌(整数列表列表) =[def]= (all(整数列表列表) and 欤整数列表是置换映射表达扌(foldr (++) [] 整数列表列表))]
    [[整数列表列表::置换环节表达] =[def]= 欤整数列表列表是置换环节表达扌(整数列表列表)]
    # [置换环节表达::[置换循环小节]]
    # [置换循环小节::[索引]]
    # [置换循环小节<==>置换循环(小节[0]-->小节[1]-->小节[2]-->...-->小节[-1]-->小节[0])]
[整数列表有序对 :: ([int],[int])]:
    [欤整数列表有序对是置换环节紧凑表达扌(整数列表有序对) =[def]= let [(环节长度列表,环节合并冃置换映射表达) := 整数列表有序对] in (all(环节长度 > 0 for 环节长度 in 环节长度列表) and (sum(环节长度列表) == len(环节合并冃置换映射表达)) and 欤整数列表是置换映射表达扌(环节合并冃置换映射表达))]
    [[整数列表有序对::置换环节紧凑表达] =[def]= 欤整数列表有序对是置换环节紧凑表达扌(整数列表有序对)]
    # [置换环节紧凑表达::(环节长度列表,环节合并冃置换映射表达)]
    # [环节长度列表::[环节长度]]
    # [环节长度列表==环节号讠环节长度]
    # [环节合并冃置换映射表达::[索引]]


[置换环节紧凑表达讠置换环节表达扌 :: 置换环节紧凑表达 -> 置换环节表达]
[置换环节表达讠置换环节紧凑表达扌 :: 置换环节表达 -> 置换环节紧凑表达]
[置换环节表达讠置换映射表达扌 :: 置换环节表达 -> 置换映射表达]
[置换映射表达讠置换环节表达扌 :: 置换映射表达 -> 置换环节表达]

===
===
#完全错装:
#不含不动点的置换:
[不动点数目巛置换映射表达扌(置换映射表达) =[def]= (sum(旧索引==新索引 for 旧索引,新索引 in enumerate(置换映射表达)))]
[错装数巛置换映射表达扌(置换映射表达) =[def]= (len(置换映射表达) -不动点数目巛置换映射表达扌(置换映射表达))]
[欤置换映射表达是完全错装扌(置换映射表达) =[def]= (not any(旧索引==新索引 for 旧索引,新索引 in enumerate(置换映射表达)))]
[欤置换环节表达是完全错装扌(置换环节表达) =[def]= (not any(1==len(置换循环小节) for 置换循环小节 in 置换环节表达))]
[欤置换环节紧凑表达是完全错装扌(置换环节紧凑表达) =[def]= (not any(1==环节长度 for 环节长度 in 置换环节紧凑表达.环节长度列表))]


[完全错装数(总数;) =[def]= len {置换映射表达 :<- permutations(range(总数)) | [欤置换映射表达是完全错装扌(置换映射表达)]}]
[部分错装数(总数;错装数) =[def]= len {置换映射表达 :<- permutations(range(总数)) | [错装数 == 错装数巛置换映射表达扌(置换映射表达)]}]
[完全错装数占比(总数) =[def]= 完全错装数(总数;)/阶乘扌(总数)]

[[not 0 <= 错装数 <= 总数] -> [0 == 部分错装数(总数;错装数)]]
    # [:等式一纟终止纟置换环节消减]:here

[0 <= 错装数 <= 总数]:
    [0 == 部分错装数(总数;错装数:=1)]
        # [:等式二纟终止纟置换环节消减]:here
    [阶乘扌(总数) == 部分错装数(总数;错装数:=0)]
        # [:等式三纟终止纟置换环节消减]:here

[完全错装数(总数;) == 部分错装数(总数;错装数:=总数)]
    # [:等式纟联系冫完全丶部分]:here
[完全错装数(0;) == 部分错装数(0;错装数:=0) == 1]
[完全错装数(1;) == 部分错装数(1;错装数:=1) == 0]
[部分错装数(总数;错装数) == 组合数扌(总数;错装数)*完全错装数(总数:=错装数;)]
    # [:等式纟联系冫部分丶完全]:here
[组合数扌(总数;2) == 部分错装数(总数;错装数:=2)]
[完全错装数(2;) == 部分错装数(2;错装数:=2) == 组合数扌(总数=2;2) == 1]
[完全错装数(0;) == 1]
[完全错装数(1;) == 0]
[完全错装数(2;) == 1]
[阶乘扌(总数) == sum [部分错装数(总数;错装数) | [错装数:<-[0..=总数]]]]
    # [:等式纟排除法]:here
    #用于:排除法:完全错装数爫排除法扌

[完全错装数占比(总数;) == [总数==0] + sum [(-1)**保底不动点数目/阶乘扌(保底不动点数目) | [保底不动点数目 :<- [2..=总数]]]]
    <<==:
[完全错装数(总数;) == [总数==0] + 阶乘扌(总数)*sum [(-1)**保底不动点数目/阶乘扌(保底不动点数目) | [保底不动点数目 :<- [2..=总数]]]]
    # [:等式纟非递归构造法]:here
    <<==:
    !! [len(A \-/ B) == len(A) + len(B) -len(A /-\ B)]
    [len(A \-/ B \-/ C)
    == len(A) + len(B \-/ C) -len(A /-\ (B \-/ C))
    == len(A) + len(B \-/ C) -len((A /-\ B) \-/ (A /-\ C))
    == len(A) + len(B \-/ C) -(len(A /-\ B) + len(A /-\ C) -len(A /-\ B /-\ C))
    == len(A) + (len(B) + len(C) - len(B /-\ C)) -(len(A /-\ B) + len(A /-\ C)) +len(A /-\ B /-\ C)
    == (len(A) + len(B) + len(C)) -(len(A /-\ B) + len(B /-\ C) + len(A /-\ C)) +len(A /-\ B /-\ C)
    ]
    [完全错装数(总数;)
    == 阶乘扌(总数) -sum [-(-1)**保底不动点数目 *组合数扌(总数;保底不动点数目)*阶乘扌(总数-保底不动点数目) | [保底不动点数目 :<- [1..=总数]]]
    == 阶乘扌(总数) +sum [(-1)**保底不动点数目 *排列数扌(总数;总数-保底不动点数目) | [保底不动点数目 :<- [1..=总数]]]
    # [k:=保底不动点数目]
    == 阶乘扌(总数) +sum [(-1)**k *阶乘扌(总数)///阶乘扌(k) | [k :<- [1..=总数]]]
    == [总数==0] + 阶乘扌(总数)*sum [(-1)**k/阶乘扌(k) | [k :<- [2..=总数]]]
    ]
    [完全错装数(总数;) == [总数==0] + 阶乘扌(总数)*sum [(-1)**k/阶乘扌(k) | [k :<- [2..=总数]]]]

[部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) =[def]= len {置换映射表达 :<- permutations(range(总数)) | [错装数 == 错装数巛置换映射表达扌(置换映射表达)][not any((旧索引 < 前缀长度 and 新索引 < 前缀长度) for 旧索引,新索引 in enumerate(置换映射表达))]}]


[[not 0 <= 前缀长度*2 <= 错装数 <= 总数] -> [部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 0]]
    # [:等式一纟终止纟前缀扩张]:here
[[0 <= 前缀长度*2 == 错装数 <= 总数] -> [部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 阶乘扌(前缀长度)*排列数扌(总数-前缀长度;错装数-前缀长度)]]
    # [:等式二纟终止纟前缀扩张]:here
[[0 <= 前缀长度*2 <= 错装数 <= 总数] -> [部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 排列数扌(总数-前缀长度;前缀长度)*sum [排列数扌(前缀长度;前缀回旋数)*组合数扌(前缀长度;前缀回旋数)*部分错装数牜前缀变换到后缀(新耂总数,新耂前缀长度;新耂错装数) | [前缀回旋数:<-[0..=前缀长度]][新耂总数:=总数-前缀长度-前缀回旋数][新耂前缀长度:=前缀长度-前缀回旋数][新耂错装数:=错装数-前缀长度-前缀回旋数][0 <= 新耂前缀长度*2 <= 新耂错装数 <= 新耂总数]]]]
    # [:等式纟联系冫部分灬前缀丶部分灬无印]:here
    #   [:等式纟联系冫部分灬无印丶部分灬前缀]:goto
    #   调换联系方向:命名仿照: [:等式纟联系冫部分丶完全]:goto
    #   递归退化:直至[[前缀长度==0]or[前缀长度*2 >= 错装数]]
    #
    #外层:排列数扌:于后缀中选出前缀的变换像-称为『中继』
    #内层:组合数扌:于中继中选出中继回旋部
    #内层:排列数扌:于前缀中选出中继回旋部的变换像
    #
    #仅用于:校验上一式:即特例[前缀长度*2 == 错装数]
    #由于:特例[前缀长度 == 0]等号左右两侧表达式等同，故:无用
    #
    #
    #条件简化:[[前缀回旋数:<-[0..=前缀长度]][0 <= 新耂前缀长度*2 <= 新耂错装数 <= 新耂总数]]
    #<=> [[前缀回旋数:<-[0..=前缀长度]][新耂前缀长度*2 <= 新耂错装数]]
    #<=> [[前缀回旋数:<-[0..=前缀长度]][(前缀长度-前缀回旋数)*2 <= (错装数-前缀长度-前缀回旋数)]]
    #<=> [[前缀回旋数:<-[0..=前缀长度]][前缀回旋数 >= (3*前缀长度-错装数)]]
    #<=> [前缀回旋数:<-[max(0, 3*前缀长度-错装数)..=前缀长度]]

# 完全错装数 <-- 部分错装数 <-- 部分错装数牜前缀变换到后缀
[部分错装数(总数;错装数) == 部分错装数牜前缀变换到后缀(总数,前缀长度:=0;错装数)]
    # [:等式纟联系冫部分灬无印丶部分灬前缀]:here

#部分错装数牜前缀变换到后缀:前缀长度 <-- (总数-1)or(前缀长度+1)or(总数-2,前缀长度-1;错装数-2)or(总数-1;错装数-1)
[部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 部分错装数牜前缀变换到后缀(总数-1,前缀长度;错装数) + 部分错装数牜前缀变换到后缀(总数,前缀长度+1;错装数) + 组合数扌(前缀长度;1)*部分错装数牜前缀变换到后缀(总数-2,前缀长度-1;错装数-2) + 2*组合数扌(前缀长度;1)*部分错装数牜前缀变换到后缀(总数-1,前缀长度;错装数-1)]
    # [:等式纟步进纟前缀扩张:试改用:等式纟步进纟隔离索引零]:here
        # 发现冫两者完全等同
    #因为:目标是用于:枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌
    #所以:次第步进，不乱序
    :试图扩张前缀到 后缀首索引，根据 变换出入方向，将遇到以下六种情形:
    * [后缀首索引 是 不动点]:
        [后缀首索引 <--> 后缀首索引]
        => (总数-1)
    * [后缀首索引 是 正向接力点]:
        [出口纟更前线段甲 --> 后缀首索引 --> 更后]
        => [后缀首索引 合并到 更前线段甲]
        => (总数-1,错装数-1)
    * [后缀首索引 是 反向接力点]:
        [入口纟更前线段甲 <-- 后缀首索引 <-- 更后]
        => [后缀首索引 合并到 更前线段甲]
        => (总数-1,错装数-1)
    * [后缀首索引 是 前缀扩张点]:
        [后缀首索引 <--> 更后]
        => (前缀长度+1)
    * [后缀首索引 是 开环回旋点]:
        [(出口纟更前线段甲,入口纟更前线段乙) <--> 后缀首索引][更前线段甲=!=更前线段乙]
        => [后缀首索引 合并暨连结 (更前线段甲,更前线段乙)]
        => (总数-2,前缀长度-1,错装数-2)
    * [后缀首索引 是 闭环回旋点]:
        [(出口纟更前线段甲,入口纟更前线段甲) <--> 后缀首索引]
        => [后缀首索引 合并到 (更前线段甲)，使之成环]
        => (总数-2,前缀长度-1,错装数-2)
    #用于:完全错装数爫置换映射前缀扩张扌

[部分错装数(总数;错装数) == if (not 0 <= 错装数 <= 总数) then 0 elif 错装数==0 then 阶乘扌(总数) else sum [排列数扌(总数-1;环节长度纟索引零-1)*部分错装数(总数-环节长度纟索引零;错装数-环节长度纟索引零) | [环节长度纟索引零:<- [2..=错装数]]]]
    # [:等式纟置换环节消减]:here
    !! [:等式一纟终止纟置换环节消减]:goto
    !! [:等式二纟终止纟置换环节消减]:goto
    !! [:等式三纟终止纟置换环节消减]:goto
    !! 置换环节表达
    => [任一索引 必属于 唯一一个 置换循环小节]
    !! 置换环节表达
    => [任一 置换循环小节 长度大于一]
    固定 索引0, 假设 其所处 置换循环小节R 长度为sz:
        置换循环小节R的可能取值范围大小为:组合数扌(总数-1;sz-1)
    #
    #用于:完全错装数爫置换环节消减扌

[完全错装数(总数;) == if 总数 < 0 then 0 elif 总数 < 2 then 1-总数 else (总数-1)*(完全错装数(总数-2;) +完全错装数(总数-1;))]
    # [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:here
    #用于:完全错装数爫隔离索引零扌
    被隔离的索引零与其余索引之间的变换出入关系:
    * [双向链接成交换环]:
        => 组合数扌(总数-1;1)*recur(总数-2)
    * [单向链接]:
        #bug:三角形变不动点:=> 排列数扌(总数-1;2)*recur(总数-2)
        * [单向链接闭环成三角形]:
        * [单向链接开环]:
        #
        !! 只与出点合并(二并一 而非 三并一)，保证不能是『大』不动点
        => 组合数扌(总数-1;1)*recur(总数-1)
    => 组合数扌(总数-1;1)*(recur(总数-2) +recur(总数-1))

===
# 枚举,索引,定位,变换:
# 『已排序版』指『枚举输出已排序』
[蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌 :: 总数 -> Iter 置换映射表达{总数}]
[枚举冫完全错装耂置换映射表达冖冖已排序版扌 :: 总数 -> Iter 置换映射表达{总数}]
[蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌 :: 总数 -> Iter 置换环节表达{总数}]
[枚举冫完全错装耂置换环节表达冖冖已排序版扌 :: 总数 -> Iter 置换环节表达{总数}]
[蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌 :: 总数 -> Iter 置换环节紧凑表达{总数}]
[枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌 :: 总数 -> Iter 置换环节紧凑表达{总数}]

# 『流水号』指『已排序枚举输出里的流水号』
[索取冫完全错装耂置换映射表达巛流水号扌 :: 总数 -> 流水号纟置换映射表达 -> 置换映射表达{总数,流水号纟置换映射表达}]
[索取冫完全错装耂置换环节表达巛流水号扌 :: 总数 -> 流水号纟置换环节表达 -> 置换环节表达{总数,流水号纟置换环节表达}]
[索取冫完全错装耂置换环节紧凑表达巛流水号扌 :: 总数 -> 流水号纟置换环节紧凑表达 -> 置换环节紧凑表达{总数,流水号纟置换环节紧凑表达}]


[定位冫完全错装耂置换映射表达讠流水号扌 :: 置换映射表达{总数,流水号纟置换映射表达} -> 流水号纟置换映射表达]
[定位冫完全错装耂置换环节表达讠流水号扌 :: 置换环节表达{总数,流水号纟置换环节表达} -> 流水号纟置换环节表达]
[定位冫完全错装耂置换环节紧凑表达讠流水号扌 :: 置换环节紧凑表达{总数,流水号纟置换环节紧凑表达} -> 流水号纟置换环节紧凑表达]



[变换冫索引乊流水号纟完全错装耂置换映射表达扌 :: 总数 -> 流水号纟置换映射表达 -> 索引{总数} -> 索引{总数}]
[变换冫索引乊流水号纟完全错装耂置换环节表达扌 :: 总数 -> 流水号纟置换环节表达 -> 索引{总数} -> 索引{总数}]
[变换冫索引乊流水号纟完全错装耂置换环节紧凑表达扌 :: 总数 -> 流水号纟置换环节紧凑表达 -> 索引{总数} -> 索引{总数}]


[变换冫索引乊流水号纟完全错装耂置换映射表达扌(总数,流水号纟置换映射表达;旧索引) =[def]= 索取冫完全错装耂置换映射表达巛流水号扌(总数;流水号纟置换映射表达)[旧索引]]
[变换冫索引乊流水号纟完全错装耂置换环节表达扌(总数,流水号纟置换环节表达;旧索引) =[def]= 置换环节表达讠置换映射表达扌(索取冫完全错装耂置换环节表达巛流水号扌(总数;流水号纟置换环节表达))[旧索引]]
[变换冫索引乊流水号纟完全错装耂置换环节紧凑表达扌(总数,流水号纟置换环节紧凑表达;旧索引) =[def]= 置换环节紧凑表达讠置换映射表达扌(索取冫完全错装耂置换环节紧凑表达巛流水号扌(总数;流水号纟置换环节紧凑表达))[旧索引]]



最小、最大
#
[鬽最小冫完全错装耂置换映射表达扌 :: 总数 -> 鬽 置换映射表达{总数}]
[鬽最小冫完全错装耂置换环节表达扌 :: 总数 -> 鬽 置换环节表达{总数}]
[鬽最小冫完全错装耂置换环节紧凑表达扌 :: 总数 -> 鬽 置换环节紧凑表达{总数}]
#
[鬽最小冫完全错装耂泛排列映射表达扌 :: 数量 -> {入口/int}{len=数量} -> {出口/int}{len=数量} -> 鬽 泛排列映射表达/{入口:出口}{[len==数量][not$ 入口==出口]}]
[鬽最小冫完全错装耂排列环节表达扌 :: 数量 -> 出入口集合/{出入口/int}{len=数量} -> 鬽 排列环节表达/[[出入口]{len>=2}]{[sum.len==数量;sum.set==]}]
[鬽最小冫完全错装耂排列环节紧凑表达扌 :: 数量 -> 出入口集合/{出入口/int}{len=数量} -> 鬽 排列环节紧凑表达/(环节长度列表/[环节长度/uint], 排列环节表达/[[出入口]{len>=2}]{[sum.len==数量;sum.set==]}])
#
#
[鬽最大冫完全错装耂置换映射表达扌 :: 总数 -> 鬽 置换映射表达{总数}]
[鬽最大冫完全错装耂置换环节表达扌 :: 总数 -> 鬽 置换环节表达{总数}]
[鬽最大冫完全错装耂置换环节紧凑表达扌 :: 总数 -> 鬽 置换环节紧凑表达{总数}]
#
[鬽最大冫完全错装耂泛排列映射表达扌 :: 数量 -> {入口/int}{len=数量} -> {出口/int}{len=数量} -> 鬽 泛排列映射表达/{入口:出口}{[len==数量][not$ 入口==出口]}]
[鬽最大冫完全错装耂排列环节表达扌 :: 数量 -> {出入口/int}{len=数量} -> 鬽 排列环节表达/{入口:出口}{[len==数量][not$ 入口==出口]}]
[鬽最大冫完全错装耂排列环节紧凑表达扌 :: 数量 -> {出入口/int}{len=数量} -> 鬽 排列环节紧凑表达/{入口:出口}{[len==数量][not$ 入口==出口]}]
#
#
[鬽最小冫完全错装耂泛排列映射表达扌(数量;入口集合,出口集合)
==  if 数量==1 and 入口集合==出口集合 then None
    elif 数量==0 then {}
    else let
        [(入口集合牜缺最小,最小入口) := 入口集合.ipop_min()]
        [(出口集合牜缺最小,最小出口) := 出口集合.ipop_min()]
    in if 最小入口==最小出口
    then assert (数量 >= 2)
    let [(出口集合牜缺次小,次小出口) := 出口集合.ipop_snd_min()]
        [_d := 鬽最小冫完全错装耂泛排列映射表达扌(数量-1;入口集合牜缺最小,出口集合牜缺次小)]
        !! [数量 >= 2]
        => [len(出口集合牜缺次小) == len(入口集合牜缺最小) == 数量-1 >= 1]
        !! [min 出口集合牜缺次小 == 最小出口 == 最小入口 < min 入口集合牜缺最小]
        => [出口集合牜缺次小 =!= 入口集合牜缺最小]
        => [not$ _d is None]
    in {最小入口:次小出口,**_d}
    else let [_md := 鬽最小冫完全错装耂泛排列映射表达扌(数量-1;入口集合牜缺最小,出口集合牜缺最小)]
    in if _md is None
    then assert [数量-1==1][入口集合牜缺最小==出口集合牜缺最小]
    let [{最小入口,次小入口} := sorted(入口集合)]
        [{最小出口,次小出口} := sorted(出口集合)]
        !! [次小入口 == 次小出口]
        !! [最小入口 =!= 次小入口]
        => [最小入口 =!= 次小出口]

        !! [次小入口 == 次小出口]
        !! [最小出口 =!= 次小出口]
        => [最小出口 =!= 次小入口]
    in {最小入口:次小出口,次小入口:最小出口}
    else {最小入口:最小出口,**_d}
]
==>>:
[鬽最小冫完全错装耂置换映射表达扌(总数)
== if 总数 == 1 then None
    elif is_odd 总数
    then [*鬽最小冫完全错装耂置换映射表达扌(总数-3), 总数-2, 总数-1, 总数-3]
    else [*鬽最小冫完全错装耂置换映射表达扌(总数-3), 总数-1, 总数-2]
]

[鬽最大冫完全错装耂泛排列映射表达扌(数量;入口集合,出口集合)
==  if 数量==1 and 入口集合==出口集合 then None
    elif 数量==0 then {}
    else let
        [(入口集合牜缺最小,最小入口) := 入口集合.ipop_min()]
        [(出口集合牜缺最大,最大出口) := 出口集合.ipop_max()]
    in if 最小入口==最大出口
    then assert (数量 >= 2)
    let [(出口集合牜缺次大,次大出口) := 出口集合.ipop_snd_max()]
        [_d := 鬽最小冫完全错装耂泛排列映射表达扌(数量-1;入口集合牜缺最小,出口集合牜缺次大)]
        !! [数量 >= 2]
        => [len(出口集合牜缺次大) == len(入口集合牜缺最小) == 数量-1 >= 1]
        !! [max 出口集合牜缺次大 == 最大出口 == 最小入口 < min 入口集合牜缺最小]
        => [出口集合牜缺次大 =!= 入口集合牜缺最小]
        => [not$ _d is None]
    in {最小入口:次大出口,**_d}
    else let [_md := 鬽最大冫完全错装耂泛排列映射表达扌(数量-1;入口集合牜缺最小,出口集合牜缺最大)]
    in if _md is None
    then assert [数量-1==1][入口集合牜缺最小==出口集合牜缺最大]
    let [{最小入口,次小入口} := sorted(入口集合)]
        [{次大出口,最大出口} := sorted(出口集合)]
        !! [次小入口 == 次大出口]
        !! [最小入口 =!= 次小入口]
        => [最小入口 =!= 次大出口]

        !! [次小入口 == 次大出口]
        !! [最大出口 =!= 次大出口]
        => [最大出口 =!= 次小入口]
    in {最小入口:次大出口,次小入口:最大出口}
    else {最小入口:最大出口,**_d}
]
==>>:
[鬽最大冫完全错装耂泛排列映射表达扌(数量;入口集合,出口集合):
    升序排列:入口集合
    降序排列:出口集合)
    一一对应之后，至多一个不动点
    [[总数>=2] -> [至多一次微调]]
    => 计数型
]
==>>:
[鬽最大冫完全错装耂置换映射表达扌(总数)
== if 总数 == 1 then None
    elif is_odd 总数
    then let [中心 := (总数-1)///2]
    in [*range(中心+1, 总数)[::-1], 中数-1, 中数, *range(中心-1)[::-1]]
    else [*range(总数)[::-1]]
]




[鬽最小冫完全错装耂排列环节表达扌 :: 数量 -> 出入口集合/{出入口/int}{len=数量} -> 鬽 排列环节表达/[[出入口]{len>=2}]{[sum.len==数量;sum.set==]}]
[鬽最小冫完全错装耂排列环节表达扌(数量;出入口集合)
==  if 数量==1 then None
    elif 数量==0 then []
    elif 数量==3 then [sorted(出入口集合)]
    else let
        [(出入口集合牜缺最小,最小出入口) := 出入口集合.ipop_min()]
        [(出入口集合牜缺最小次小,次小出入口) := 出入口集合牜缺最小.ipop_min()]
        [_lsls := 鬽最小冫完全错装耂排列环节表达扌(数量-2;出入口集合牜缺最小次小)]
        !! [数量=!=3]
        => [len(出入口集合牜缺最小次小) == 数量-2 =!= 1]
        => [not$ _lsls is None]
    in [[最小出入口,次小出入口], *_lsls]
== if 数量==1 then None else
    let [ls := sorted(出入口集合)]
        [_03 := if [数量%2==0] then 0 else 3]
        [(ls_, _ls) := (ls[:数量-_03],ls[数量-_03:])]
    in   [ls_[2*i:2*i+2] | [i :<- [0..=len(ls_)///2]]] ++ ([_ls] if _ls else [])
]
==>>:
[鬽最小冫完全错装耂排列环节紧凑表达扌(数量;出入口集合)
== let [m := 鬽最小冫完全错装耂排列环节表达扌(数量;出入口集合)]
    in if m is None then None else
    (map len m, m)
]

[鬽最大冫完全错装耂排列环节表达扌(数量;出入口集合)
== if 数量==1 then None else
    let [ls := sorted(出入口集合)[::-1]]
    in [ls[-1:]++ls[:-1]]
]
==>>:
[鬽最大冫完全错装耂排列环节紧凑表达扌(数量;出入口集合)
== let [m := 鬽最大冫完全错装耂排列环节表达扌(数量;出入口集合)]
    in if m is None then None else
    (map len m, m)
]


孑孓:孑/孓:prev,next/succ:上一个,下一个:前一个,后一个:左一个,右一个
[鬽孑冫完全错装耂泛排列映射表达扌 :: 数量 -> 排列纟孓/泛排列映射表达/{入口:出口}{[len==数量][not$ 入口==出口]} -> 鬽 排列纟孑/泛排列映射表达/{入口:出口}{[len==数量][not$ 入口==出口]}]
[鬽孓冫完全错装耂泛排列映射表达扌 :: 数量 -> 排列纟孑/泛排列映射表达/{入口:出口}{[len==数量][not$ 入口==出口]} -> 鬽 排列纟孓/泛排列映射表达/{入口:出口}{[len==数量][not$ 入口==出口]}]
    计数型
    用于:枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌

[鬽孓冫完全错装耂泛排列映射表达扌(数量; 排列纟孑)
== f(len(排列纟孑)-2, 出口列表[-1:]) where
    入口列表 = sorted(排列纟孑.keys())
    出口列表 = [排列纟孑[入口] | [入口:<-入口列表]]
    f(j,出口列表纟尾纟逆序) = if j < 0 then None else
        if 出口列表[j] > 出口列表纟尾纟逆序[0]
        then f(j-1, 出口列表[j]:出口列表纟尾纟逆序)
        else let
            i = find_insert_position_(出口列表[j], 出口列表纟尾纟逆序)
            # [[i+1 < len 出口列表纟尾纟逆序] -> [出口列表纟尾纟逆序[i] > 出口列表[j] > 出口列表纟尾纟逆序[i+1]]]
        in if not 出口列表纟尾纟逆序[i] == 入口列表[j]
        then mk(j, 出口列表纟尾纟逆序[i])
        elif not i == 0
        then mk(j, 出口列表纟尾纟逆序[i+1])
        else f(j-1, 出口列表[j]:出口列表纟尾纟逆序)
    mk(j, 出口) = {**dict(zip(入口列表[:j], 出口列表[:j])), 入口列表[j]:出口, **鬽最小冫完全错装耂置换映射表达扌(数量-j-1;入口列表[j+1:],remove 出口 出口列表[j:])}
]

===
]]
[[具现区:
===
===
#完全错装数(总数;)
#部分错装数(总数;错装数)

#递归终点:
[完全错装数(0;) := 1]
[完全错装数(1;) := 0]
[完全错装数(2;) := 1]

[完全错装数爫非递归构造法扌(总数;) =[def]= [总数==0] + 阶乘扌(总数)*sum [(-1)**保底不动点数目/阶乘扌(保底不动点数目) | [保底不动点数目 :<- [2..=总数]]]]
    # [:定义冫完全错装数爫非递归构造法扌]:here
    !! [:等式纟非递归构造法]:goto

[完全错装数爫排除法扌(总数;) =[def]= (阶乘扌(总数) -sum [部分错装数(总数;错装数) | [错装数:<-[0..<总数]]]) ==== (阶乘扌(总数) -sum [组合数扌(总数;错装数)*完全错装数(总数:=错装数;) | [错装数:<-[0..<总数]]])]
    # [:定义冫完全错装数爫排除法扌]:here
    !! [:等式纟联系冫完全丶部分]:goto
    !! [:等式纟联系冫部分丶完全]:goto
    !! [:等式纟排除法]:goto



[完全错装数爫置换环节消减扌(总数;) =[def]= 部分错装数(总数;错装数:=总数) ==== if 总数==0 then 1 else sum [排列数扌(总数-1;环节长度纟索引零-1)*完全错装数(总数-环节长度纟索引零;) | [环节长度纟索引零:<- [2..=总数]]]]
    # [:定义冫完全错装数爫置换环节消减扌]:here
    !! [:等式纟联系冫完全丶部分]:goto
    !! [:等式一纟终止纟置换环节消减]:goto
    !! [:等式二纟终止纟置换环节消减]:goto
    !! [:等式三纟终止纟置换环节消减]:goto
    !! [:等式纟置换环节消减]:goto


[完全错装数爫置换映射前缀扩张扌(总数;) =[def]= 部分错装数牜前缀变换到后缀(总数,前缀长度:=0;错装数:=总数)]
    # [:定义冫完全错装数爫置换映射前缀扩张扌]:here
    !! [:等式纟联系冫完全丶部分]:goto
    !! [:等式纟联系冫部分灬无印丶部分灬前缀]:goto
    !! [:等式一纟终止纟前缀扩张]:goto
    !! [:等式二纟终止纟前缀扩张]:goto
    !! [:等式纟步进纟前缀扩张:试改用:等式纟步进纟隔离索引零]:goto
        # 发现冫两者完全等同


[完全错装数爫隔离索引零扌(总数;) =[def]= if 总数 < 0 then 0 elif 总数 < 2 then 1-总数 else (总数-1)*(完全错装数(总数-2;) +完全错装数(总数-1;))]
    # [:定义冫完全错装数爫隔离索引零扌]:here
    !! [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:goto

===
===
]]


>>> from seed.iters.apply_may_args4islice_ import list_islice_, show_islice_, stable_show_islice_, stable_list_islice_

[[
_测试冫枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
>>> f = _测试冫枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
>>> g = lambda 总数:show_islice_(99*阶乘扌(总数), f(总数))
>>> g(0)
()
>>> g(1)
>>> g(2)
(1, 0)
>>> g(3)
(1, 2, 0)
(2, 0, 1)
>>> g(4)
(1, 0, 3, 2)
(1, 2, 3, 0)
(1, 3, 0, 2)
(2, 0, 3, 1)
(2, 3, 0, 1)
(2, 3, 1, 0)
(3, 0, 1, 2)
(3, 2, 0, 1)
(3, 2, 1, 0)
>>> g(5)
(1, 0, 3, 4, 2)
(1, 0, 4, 2, 3)
(1, 2, 0, 4, 3)
(1, 2, 3, 4, 0)
(1, 2, 4, 0, 3)
(1, 3, 0, 4, 2)
(1, 3, 4, 0, 2)
(1, 3, 4, 2, 0)
(1, 4, 0, 2, 3)
(1, 4, 3, 0, 2)
(1, 4, 3, 2, 0)
(2, 0, 1, 4, 3)
(2, 0, 3, 4, 1)
(2, 0, 4, 1, 3)
(2, 3, 0, 4, 1)
(2, 3, 1, 4, 0)
(2, 3, 4, 0, 1)
(2, 3, 4, 1, 0)
(2, 4, 0, 1, 3)
(2, 4, 1, 0, 3)
(2, 4, 3, 0, 1)
(2, 4, 3, 1, 0)
(3, 0, 1, 4, 2)
(3, 0, 4, 1, 2)
(3, 0, 4, 2, 1)
(3, 2, 0, 4, 1)
(3, 2, 1, 4, 0)
(3, 2, 4, 0, 1)
(3, 2, 4, 1, 0)
(3, 4, 0, 1, 2)
(3, 4, 0, 2, 1)
(3, 4, 1, 0, 2)
(3, 4, 1, 2, 0)
(4, 0, 1, 2, 3)
(4, 0, 3, 1, 2)
(4, 0, 3, 2, 1)
(4, 2, 0, 1, 3)
(4, 2, 1, 0, 3)
(4, 2, 3, 0, 1)
(4, 2, 3, 1, 0)
(4, 3, 0, 1, 2)
(4, 3, 0, 2, 1)
(4, 3, 1, 0, 2)
(4, 3, 1, 2, 0)

#>>> g(6)
#>>> g(7)

]]


#]]]'''
__all__ = r'''
魖完全错装数

检查冫整数列表扌
检查冫整数列表列表扌
检查冫整数列表有序对扌

欤整数列表是置换映射表达扌
欤整数列表列表是置换环节表达扌
欤整数列表有序对是置换环节紧凑表达扌

欤置换映射表达是完全错装扌
欤置换环节表达是完全错装扌
欤置换环节紧凑表达是完全错装扌

检查冫完全错装耂置换映射表达扌
检查冫完全错装耂置换环节表达扌
检查冫完全错装耂置换环节紧凑表达扌

置换环节紧凑表达讠置换环节表达扌
置换环节表达讠置换环节紧凑表达扌
置换环节表达讠置换映射表达扌
置换映射表达讠置换环节表达扌

欤置换环节表达已规范最小化扌
欤置换环节紧凑表达已规范最小化扌

检查冫完全错装耂置换环节表达已规范最小化扌
检查冫完全错装耂置换环节紧凑表达已规范最小化扌



蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌
    枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌

枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌
    枚举冫不定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌
枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌
    枚举冫环节长度列表扌
    枚举冫定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌

枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌
    枚举冫完全错装耂泛排列映射表达牜记录位次冖冖已排序版扌












枚举冫不定长耂泛排列牜比较大小冖冖已排序版扌
    惑就地修改为孓冫不定长耂泛排列牜比较大小扌
枚举冫不定长耂泛排列牜记录位次冖冖已排序版扌
    枚举冫不定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌
        惑就地修改为孓冫不定长耂泛排列牜记录位次扌



枚举冫定长耂泛排列牜记录位次冖冖已排序版扌
    枚举冫定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌
        惑就地修改为孓冫定长耂泛排列牜记录位次扌



枚举冫完全错装耂泛排列映射表达牜记录位次冖冖已排序版扌
    惑就地修改为孓冫完全错装耂泛排列映射表达扌

'''.split()#'''
#TODO:待办:魖完全错装数牜枚举
#bug:蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌
#    枚举冫置换环节表达巛置换映射表达牜位次不更改丶规范最小化扌
__all__
from seed.math.floor_ceil import floor_log2
from seed.types.view.View import SeqView
#from math import factorial
#import itertools #permutations
from itertools import zip_longest, pairwise


from seed.math.combination import 排列数扌, 组合数扌
from seed.math.combination import factorial,阶乘扌,置换数扌
from seed.math.combination import combinations, combinations_with_replacement, permutations, product
from seed.math.combination import 枚举冫组合牜无重复扌,枚举冫组合牜带重复扌,枚举冫排列扌,枚举冫正交外直积元组扌
from seed.iters.is_sorted import is_sorted, is_strict_sorted
from seed.iters.ensure_sorted import ensure_sorted, ensure_strict_sorted

from seed.tiny_.check import check_type_is, check_uint_lt, check_uint_le, check_uint
from seed.tiny import chains, ifNone, echo, null_iter
from seed.tiny import print_err

from seed.data_funcs.idc_mngr import DoublyList4Idc, DoublyList4Idc__rollbackable

from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots

def _缓冲(d, arg, f, /):
    if not arg in d:
        r = f(arg)
        d[arg] = r
    r = d[arg]
    return r
class 魖完全错装数(ABC):
    __slots__ = ()
    #___no_slots_ok___ = True
    def __init__(sf, /):
        sf._缓存纟完全 = {} #{0:1,1:0,2:1}
        sf._缓存纟部分灬无印 = {}
        sf._缓存纟部分灬前缀 = {}
    @abstractmethod
    def 罓完全错装数扌(sf, 总数, /):
        '-> 完全错装数(总数;)'
    def 完全错装数扌(sf, 总数, /):
        '-> 完全错装数(总数;)'
        d = sf._缓存纟完全
        return _缓冲(d, 总数, sf.罓完全错装数扌)


    def 部分错装数扌(sf, 总数, 错装数, /):
        '-> 部分错装数(总数;错装数)'
        # [:等式一纟终止纟置换环节消减]:goto
        # [:等式二纟终止纟置换环节消减]:goto
        # [:等式三纟终止纟置换环节消减]:goto
        #
        if not 0 <= 错装数 <= 总数:
            return 0
        if 错装数 == 1:
            return 0
        if 错装数 == 0:
            #return 阶乘扌(总数)
            pass
        d = sf._缓存纟部分灬无印
        return _缓冲(d, (总数,错装数), lambda xy:sf.罓部分错装数扌(*xy))
    def 部分错装数牜前缀变换到后缀扌(sf, 总数, 前缀长度, 错装数, /):
        '-> 部分错装数牜前缀变换到后缀(总数,前缀长度;错装数)'
        # [:等式一纟终止纟前缀扩张]:goto
        # [:等式二纟终止纟前缀扩张]:goto
        #
        if not 0 <= 前缀长度*2 <= 错装数 <= 总数:
            return 0
        if 前缀长度*2 == 错装数:
            #return 阶乘扌(前缀长度)*排列数扌(总数-前缀长度;前缀长度)
            pass
        d = sf._缓存纟部分灬前缀
        return _缓冲(d, (总数,前缀长度,错装数), lambda xyz:sf.罓部分错装数牜前缀变换到后缀扌(*xyz))


    def 罓部分错装数扌(sf, 总数, 错装数, /):
        '-> 部分错装数(总数;错装数)'
        # [:等式纟置换环节消减]:goto
        #
        if not 0 <= 错装数 <= 总数:
            raise 000
            return 0
        if 错装数 == 1:
            raise 000
            return 0
        if 错装数 == 0:
            #raise 000
            return 阶乘扌(总数)
        def lazy_mul_():
            for 环节长度纟索引零 in range(2, 1+错装数):
                n = sf.部分错装数扌(总数-环节长度纟索引零,错装数-环节长度纟索引零)
                if n:
                    #lazy mul:
                    yield n*排列数扌(总数-1,环节长度纟索引零-1)
        return sum(lazy_mul_())

    def 罓部分错装数牜前缀变换到后缀扌(sf, 总数, 前缀长度, 错装数, /):
        '-> 部分错装数牜前缀变换到后缀(总数,前缀长度;错装数)'
        # [:等式纟步进纟前缀扩张:试改用:等式纟步进纟隔离索引零]:goto
        #
        if not 0 <= 前缀长度*2 <= 错装数 <= 总数:
            raise 000
            return 0
        if 前缀长度*2 == 错装数:
            #raise 000
            return 阶乘扌(前缀长度)*排列数扌(总数-前缀长度,前缀长度)

        return (
        (sf.部分错装数牜前缀变换到后缀扌(总数-1,前缀长度,错装数)
        +sf.部分错装数牜前缀变换到后缀扌(总数,前缀长度+1,错装数)
        +前缀长度*sf.部分错装数牜前缀变换到后缀扌(总数-2,前缀长度-1,错装数-2)
        +2*前缀长度*sf.部分错装数牜前缀变换到后缀扌(总数-1,前缀长度,错装数-1)
        ))

    def 罓完全错装数爫非递归构造法扌(sf, 总数, /):
        '-> 完全错装数爫非递归构造法扌(总数;)'
        # [:定义冫完全错装数爫非递归构造法扌]:goto
        # [:等式纟非递归构造法]:goto
        return (总数==0) + sum((-1)**保底不动点数目 *排列数扌(总数,总数-保底不动点数目) for 保底不动点数目 in range(2,1+总数))

    def 罓完全错装数爫排除法扌(sf, 总数, /):
        '-> 完全错装数爫排除法扌(总数;)'
        # [:定义冫完全错装数爫排除法扌]:goto
        # [:等式纟联系冫完全丶部分]:goto
        # [:等式纟联系冫部分丶完全]:goto
        # [:等式纟排除法]:goto
        return (阶乘扌(总数) -sum (组合数扌(总数,错装数)*sf.完全错装数扌(_总数:=错装数) for 错装数 in range(总数)))
            # !! 部分错装数扌(总数,错装数) 是 依照 [:等式纟置换环节消减] 计算 而非 [:等式纟排除法]
        return (阶乘扌(总数) -sum (sf.部分错装数扌(总数,错装数) for 错装数 in range(总数)))

    def 罓完全错装数爫置换环节消减扌(sf, 总数, /):
        '-> 完全错装数爫置换环节消减扌(总数;)'
        # [:定义冫完全错装数爫置换环节消减扌]:goto
        return sf.部分错装数扌(总数,错装数:=总数)
        if 总数 == 0:
            return 1
        return sum(排列数扌(总数-1,环节长度纟索引零-1)*sf.完全错装数扌(总数-环节长度纟索引零) for 环节长度纟索引零 in range(2, 1+总数))

    def 罓完全错装数爫置换映射前缀扩张扌(sf, 总数, /):
        '-> 完全错装数爫置换映射前缀扩张扌(总数;)'
        # [:定义冫完全错装数爫置换映射前缀扩张扌]:goto
        return sf.部分错装数牜前缀变换到后缀扌(总数,前缀长度:=0,错装数:=总数)

    def 罓完全错装数爫隔离索引零扌(sf, 总数, /):
        '-> 完全错装数爫隔离索引零扌(总数;)'
        # [:定义冫完全错装数爫隔离索引零扌]:goto
        # [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:goto
        if 总数 < 0:
            return 0
        if 总数 < 2:
            return 1-总数
        return (总数-1)*(sf.完全错装数扌(总数-2) +sf.完全错装数扌(总数-1))
#end-class 魖完全错装数(ABC):

__all__
def 检查冫整数列表扌(x, /):
    check_type_is(tuple, x)
    for z in x:
        check_type_is(int, z)
def 检查冫整数列表列表扌(x, /):
    check_type_is(tuple, x)
    for z in x:
        检查冫整数列表扌(z)
def 检查冫整数列表有序对扌(x, /):
    check_type_is(tuple, x)
    if not len(x) == 2: raise TypeError
    检查冫整数列表列表扌(x)
def 欤整数列表是置换映射表达扌(整数列表, /):
    #检查冫整数列表扌(整数列表)
    总数 = len(整数列表)
    if not all(0 <= i < 总数 for i in 整数列表):
        return False
    索引号讠计数值 = [0]*总数
    for j in 整数列表:
        索引号讠计数值[j] += 1
    return 索引号讠计数值 == [1]*总数
def 欤整数列表列表是置换环节表达扌(整数列表列表, /):
    #检查冫整数列表列表扌(整数列表列表)
    #总数 = sum(map(len, 整数列表列表))
    if not all(整数列表列表):
        return False
    整数列表 = tuple(chains(整数列表列表))
    return 欤整数列表是置换映射表达扌(整数列表)
def 欤整数列表有序对是置换环节紧凑表达扌(整数列表有序对, /):
    #检查冫整数列表有序对扌(整数列表有序对)
    整数列表有序对
    (环节长度列表,环节合并冃置换映射表达) = 整数列表有序对
    return (
    all(环节长度 > 0 for 环节长度 in 环节长度列表)
    and (sum(环节长度列表) == len(环节合并冃置换映射表达)) #总数
    and 欤整数列表是置换映射表达扌(环节合并冃置换映射表达)
    )

def 欤置换映射表达是完全错装扌(置换映射表达, /):
    return (not any(旧索引==新索引 for 旧索引,新索引 in enumerate(置换映射表达)))
def 欤置换环节表达是完全错装扌(置换环节表达, /):
    return (not any(1==len(置换循环小节) for 置换循环小节 in 置换环节表达))
def 欤置换环节紧凑表达是完全错装扌(置换环节紧凑表达, /):
    (环节长度列表,环节合并冃置换映射表达) = 置换环节紧凑表达
    return (not any(1==环节长度 for 环节长度 in 环节长度列表))




def 检查冫完全错装耂置换映射表达扌(整数列表, /):
    检查冫整数列表扌(整数列表)
    if not 欤整数列表是置换映射表达扌(整数列表):raise TypeError
def 检查冫完全错装耂置换环节表达扌(整数列表列表, /):
    检查冫整数列表列表扌(整数列表列表)
    if not 欤整数列表列表是置换环节表达扌(整数列表列表):raise TypeError
def 检查冫完全错装耂置换环节紧凑表达扌(整数列表有序对, /):
    检查冫整数列表有序对扌(整数列表有序对)
    if not 欤整数列表有序对是置换环节紧凑表达扌(整数列表有序对):raise TypeError

def 置换环节紧凑表达讠置换环节表达扌(置换环节紧凑表达, /):
    '置换环节紧凑表达 -> 置换环节表达'
    (环节长度列表,环节合并冃置换映射表达) = 置换环节紧凑表达
    def __():
        i = 0
        for 环节长度 in 环节长度列表:
            j = i + 环节长度
            置换循环小节 = 环节合并冃置换映射表达[i:j]
            i = j
            yield 置换循环小节
    置换环节表达 = tuple(__())
    检查冫完全错装耂置换环节表达扌(置换环节表达)
    return 置换环节表达

def 置换环节表达讠置换环节紧凑表达扌(置换环节表达, /):
    '置换环节表达 -> 置换环节紧凑表达'
    环节合并冃置换映射表达 = tuple(chains(置换环节表达))
    环节长度列表 = tuple(map(len, 置换环节表达))
    置换环节紧凑表达 = (环节长度列表,环节合并冃置换映射表达)
    检查冫完全错装耂置换环节紧凑表达扌(置换环节紧凑表达)
    return 置换环节紧凑表达

def 置换环节表达讠置换映射表达扌(置换环节表达, /):
    '置换环节表达 -> 置换映射表达'
    总数 = sum(map(len, 置换环节表达))
    old2new = [None]*总数
    for 置换循环小节 in 置换环节表达:
        old = 置换循环小节[-1]
        for new in 置换循环小节:
            old2new[old] = new
            old = new
    置换映射表达 = tuple(old2new)
    检查冫完全错装耂置换映射表达扌(置换映射表达)
    return 置换映射表达

def 置换映射表达讠置换环节表达扌(置换映射表达, /):
    '置换映射表达 -> 置换环节表达'
    总数 = len(置换映射表达)
    j2used = [False]*总数
    def iter_lsls_():
        for j in range(总数):
            if j2used[j]:continue
            置换循环小节 = tuple(iter_ls_(j))
            yield 置换循环小节
    def iter_ls_(j, /):
        while not j2used[j]:
            yield j
            j2used[j] = True
            j = 置换映射表达[j]
    置换环节表达 = tuple(iter_lsls_())
    检查冫完全错装耂置换环节表达扌(置换环节表达)
    return 置换环节表达



def 欤置换环节表达已规范最小化扌(置换环节表达, /):
    return (
    (not 置换环节表达 or 置换环节表达[0][0] == 0)
    and is_strict_sorted(置换循环小节[0] for 置换循环小节 in 置换环节表达)
    and all(置换循环小节[0] == min(置换循环小节) for 置换循环小节 in 置换环节表达)
    )
def 欤置换环节紧凑表达已规范最小化扌(置换环节紧凑表达, /):
    置换环节表达 = 置换环节紧凑表达讠置换环节表达扌(置换环节紧凑表达)
    return 欤置换环节表达已规范最小化扌(置换环节表达)

def 检查冫完全错装耂置换环节表达已规范最小化扌(置换环节表达, /):
    if not 欤置换环节表达已规范最小化扌(置换环节表达):raise TypeError
def 检查冫完全错装耂置换环节紧凑表达已规范最小化扌(置换环节紧凑表达, /):
    if not 欤置换环节紧凑表达已规范最小化扌(置换环节紧凑表达):raise TypeError

#begin-class 魖完全错装数牜枚举(魖完全错装数):
######################
######################
def __():
    def 最小冫泛排列映射表达扌(总数, /):
        '词典序,非定长'
    def 最大冫泛排列映射表达扌(总数, /):
        '词典序,非定长'
    def 鬽最小冫完全错装耂泛排列映射表达扌(总数, /):
        '词典序,非定长'
    def 鬽最大冫完全错装耂泛排列映射表达扌(总数, /):
        '词典序,非定长'
    def 枚举冫完全错装耂不定长耂泛排列冖冖已排序版扌(总数, /):
        '词典序,非定长'

def 惑就地修改为孓冫不定长耂泛排列牜比较大小扌(逆序集合纟剩余纟就地修改, 泛排列纟孑纟就地修改, /, *, __lt__):
    'Ord k => INOUT:reversed-sorted:[k] -> INOUT:[k] -> 新丷旧/bool #词典序,非定长'
    #惑就地修改为孓冫不定长耂泛排列牜比较大小扌
    #惑就地修改为孓冫不定长耂泛排列牜记录位次扌
    #
    if 逆序集合纟剩余纟就地修改:
        最小值纟剩余 = 逆序集合纟剩余纟就地修改.pop()
        泛排列纟就地修改 = 泛排列纟孑纟就地修改
        泛排列纟就地修改.append(最小值纟剩余)
        泛排列纟孓纟就地修改 = 泛排列纟就地修改
    else:
        泛排列纟完整 = 泛排列纟孑纟就地修改
        总数 = len(泛排列纟完整)
        for i in range(0, 总数-1)[::-1]:
            if __lt__(泛排列纟完整[i], 泛排列纟完整[i+1]):
                break
        else:
            #完全逆序:泛排列纟完整
            if 1:
                #还原
                逆序集合纟剩余纟就地修改 += 泛排列纟完整
                del 泛排列纟完整[:]
            return True#旧
            return None
        #完全逆序:泛排列纟完整[i+1:]
        xi = 泛排列纟完整[i]
        for j in range(i+2, 总数)[::-1]:
            if __lt__(泛排列纟完整[i], 泛排列纟完整[j]):
                break
        else:
            j = i+1
        # xi:between:泛排列纟完整[i+1:j+1] >>> xi >>> 泛排列纟完整[j+1:]
        xj = 泛排列纟完整[j]
        #互换:xi<->xj
        泛排列纟完整[j] = xi
        泛排列纟完整[i] = xj
        逆序集合纟剩余纟就地修改 += 泛排列纟完整[i+1:]
        del 泛排列纟完整[i+1:]
        泛排列纟孓纟就地修改 = 泛排列纟完整
    泛排列纟孓纟就地修改
    return False#新
    return 泛排列纟孓纟就地修改




def 枚举冫不定长耂泛排列牜比较大小冖冖已排序版扌(逆序集合纟就地修改, /, *, __lt__):
    'Ord k => INOUT:reversed-sorted:[k] -> Iter (INOUT:[k]) #词典序,非定长'
    #枚举冫不定长耂泛排列牜比较大小冖冖已排序版扌
    #枚举冫不定长耂泛排列牜记录位次冖冖已排序版扌
    #
    #最小冫不定长耂泛排列扌(总数)
    #最大冫不定长耂泛排列扌(总数)
    if 0:
        for x, y in pairwise(逆序集合纟就地修改):
            if not __lt__(y, x): raise ValueError('非逆序')
    逆序集合纟剩余纟就地修改 = 逆序集合纟就地修改
    泛排列纟就地修改 = []
    新丷旧 = False
    while not 新丷旧:
        yield 泛排列纟就地修改
        新丷旧 = 惑就地修改为孓冫不定长耂泛排列牜比较大小扌(逆序集合纟剩余纟就地修改, 泛排列纟就地修改, __lt__=__lt__)
    return

def 惑就地修改为孓冫定长耂泛排列牜记录位次扌(固化前缀长度, 逆序列表纟剩余纟就地修改, 泛排列纟孑纟就地修改, 位置乚泛排列讠位置乚逆序后缀, /):
    'uint -> INOUT:reversed:[k] -> INOUT:[k] -> INOUT:[idx] -> 新丷旧/bool #词典序,定长'
    限定长度 = len(泛排列纟孑纟就地修改)
    check_uint_le(限定长度, 固化前缀长度)
    assert len(位置乚泛排列讠位置乚逆序后缀) == len(泛排列纟孑纟就地修改)
    有效长度 = 限定长度 - 固化前缀长度
    剩余数量 = len(逆序列表纟剩余纟就地修改)
    # [总数 == 限定长度+剩余数量]
    # [总数 == 固化前缀长度+有效长度+剩余数量]

    if 0:
        if 有效长度 == 0:
            return True#旧
    def _最小化诸后扌(i, /):
        #前置条件:[完全逆序:泛排列纟完整[i:]]
        #前置条件:[固化前缀长度 <= i <= 限定长度]
        assert 固化前缀长度 <= i <= 限定长度
        assert 限定长度 == len(泛排列纟就地修改)
        L0 = 限定长度-i
        L1 = 剩余数量
        if 1:
            #非必要
            #if i == 限定长度:
            if L0 == 0:
                return

        位置乚泛排列讠位置乚逆序后缀[i:] = [*range(剩余数量, 剩余数量+L0)[::-1]]
        if 1:
            #非必要
            #if 剩余数量 == 0:
            if L1 == 0:
                if L0 == 1:
                    pass
                elif i == 0:
                    泛排列纟就地修改.reverse()
                else:
                    泛排列纟就地修改[i:] = reversed(泛排列纟就地修改[i:])
                assert not 逆序列表纟剩余纟就地修改#empty
                return
        else:
            assert L0 and L1
        ######################
        #无条件:任意L0,L1:
        泛排列纟最小化纟完整逆序 = 泛排列纟就地修改[i:] + 逆序列表纟剩余纟就地修改
        L = len(泛排列纟最小化纟完整逆序)
        assert L == L0+L1
        逆序列表纟剩余纟就地修改[:] = 泛排列纟最小化纟完整逆序[:L1]
        #bug:泛排列纟就地修改[i:] = 泛排列纟最小化纟完整逆序[L1::-1]
        #   => ???obj[:L1-1:-1]
        泛排列纟就地修改[i:] = reversed(泛排列纟最小化纟完整逆序[L1:])
        #####
        assert len(位置乚泛排列讠位置乚逆序后缀) == len(泛排列纟就地修改) == 限定长度, ((len(位置乚泛排列讠位置乚逆序后缀), len(泛排列纟就地修改), 限定长度), (i, L0, L1, L), 泛排列纟就地修改)
        assert len(逆序列表纟剩余纟就地修改) == 剩余数量
        return
    #end-def _最小化诸后扌(i, /):

    # [泛排列纟完整 := 泛排列纟孑纟就地修改++逆序列表纟剩余纟就地修改]
    泛排列纟就地修改 = 泛排列纟孑纟就地修改
    for i in range(固化前缀长度, 限定长度)[::-1]:
        if not 位置乚泛排列讠位置乚逆序后缀[i] == 0:
            break
    else:
        #完全逆序:泛排列纟完整[固化前缀长度:]
        if 1:
            #还原
            _最小化诸后扌(固化前缀长度)
        return True#旧
    #完全逆序:泛排列纟完整[i+1:]
    xi = 泛排列纟孑纟就地修改[i]
    ki = 位置乚泛排列讠位置乚逆序后缀[i]
    # xi:between:泛排列纟完整[i+1:i+1+ki] >>> xi >>> 泛排列纟完整[i+1+ki:]
    j = i+ki
    assert i >= 固化前缀长度
    assert ki >= 1
    总数 = (限定长度+剩余数量)
    assert ki <= 总数 -(i+1), (限定长度, i, ki, 泛排列纟孑纟就地修改, 逆序列表纟剩余纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    assert 固化前缀长度 <= i < j < 总数
    if j < 限定长度:
        ls4jjj = 泛排列纟孑纟就地修改
        jjj = j
    else:
        ls4jjj = 逆序列表纟剩余纟就地修改
        jjj = j -限定长度
    ls4jjj
    jjj

    # xi:between:泛排列纟完整[i+1:j+1] >>> xi >>> 泛排列纟完整[j+1:]
    xj = ls4jjj[jjj]
    #kj = 位置乚泛排列讠位置乚逆序后缀[j]
    kj = ki-1
    #互换:xi<->xj
    ls4jjj[jjj] = xi
    泛排列纟孑纟就地修改[i] = xj
    位置乚泛排列讠位置乚逆序后缀[i] = kj
    _最小化诸后扌(i+1)
    泛排列纟孓纟就地修改 = 泛排列纟孑纟就地修改
    泛排列纟孓纟就地修改
    return False#新


def 惑就地修改为孓冫不定长耂泛排列牜记录位次扌(固化前缀长度, 逆序列表纟剩余纟就地修改, 泛排列纟孑纟就地修改, 位置乚泛排列讠位置乚逆序后缀, /):
    'uint -> INOUT:reversed:[k] -> INOUT:[k] -> INOUT:[idx] -> 新丷旧/bool #词典序,非定长'
    #惑就地修改为孓冫不定长耂泛排列牜比较大小扌
    #惑就地修改为孓冫不定长耂泛排列牜记录位次扌
    #
    check_uint_le(len(泛排列纟孑纟就地修改), 固化前缀长度)
    assert len(位置乚泛排列讠位置乚逆序后缀) == len(泛排列纟孑纟就地修改)
    if 逆序列表纟剩余纟就地修改:
        最小值纟剩余 = 逆序列表纟剩余纟就地修改.pop()
        位置纟最小纟逆序 = len(逆序列表纟剩余纟就地修改)
        泛排列纟就地修改 = 泛排列纟孑纟就地修改
        泛排列纟就地修改.append(最小值纟剩余)
        泛排列纟孓纟就地修改 = 泛排列纟就地修改
        位置乚泛排列讠位置乚逆序后缀.append(位置纟最小纟逆序)
    else:
        泛排列纟完整 = 泛排列纟孑纟就地修改
        总数 = len(泛排列纟完整)
        for i in range(固化前缀长度, 总数-1)[::-1]:
            if not 位置乚泛排列讠位置乚逆序后缀[i] == 0:
                break
        else:
            #完全逆序:泛排列纟完整[固化前缀长度:]
            if 1:
                #还原
                逆序列表纟剩余纟就地修改 += 泛排列纟完整[固化前缀长度:]
                del 泛排列纟完整[固化前缀长度:]
                del 位置乚泛排列讠位置乚逆序后缀[固化前缀长度:]
            return True#旧
        #完全逆序:泛排列纟完整[i+1:]
        xi = 泛排列纟完整[i]
        ki = 位置乚泛排列讠位置乚逆序后缀[i]
        # xi:between:泛排列纟完整[i+1:i+1+ki] >>> xi >>> 泛排列纟完整[i+1+ki:]
        j = i+ki
        assert i >= 固化前缀长度
        assert ki >= 1
        assert ki <= 总数 -(i+1), (总数, i, ki, 泛排列纟完整, 位置乚泛排列讠位置乚逆序后缀)
        assert 固化前缀长度 <= i < j < 总数
        # xi:between:泛排列纟完整[i+1:j+1] >>> xi >>> 泛排列纟完整[j+1:]
        xj = 泛排列纟完整[j]
        #kj = 位置乚泛排列讠位置乚逆序后缀[j]
        kj = ki-1
        #互换:xi<->xj
        泛排列纟完整[j] = xi
        泛排列纟完整[i] = xj
        位置乚泛排列讠位置乚逆序后缀[i] = kj
        逆序列表纟剩余纟就地修改 += 泛排列纟完整[i+1:]
        del 泛排列纟完整[i+1:]
        del 位置乚泛排列讠位置乚逆序后缀[i+1:]
        泛排列纟孓纟就地修改 = 泛排列纟完整
    泛排列纟孓纟就地修改
    assert len(位置乚泛排列讠位置乚逆序后缀) == len(泛排列纟孓纟就地修改)
    return False#新

def _预处理冫增量纟长度扌(增量纟长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀, /):
    check_uint_le(len(逆序列表纟剩余纟就地修改), 增量纟长度)
    #长度
    长度纟旧 = len(泛排列纟初始纟就地修改)
    for _ in range(增量纟长度):
        泛排列纟初始纟就地修改.append(最小值纟剩余:=逆序列表纟剩余纟就地修改.pop())
        位置乚泛排列讠位置乚逆序后缀.append(位置纟最小纟逆序:=len(逆序列表纟剩余纟就地修改))

    ######################
    长度纟新 = len(泛排列纟初始纟就地修改)
    return (长度纟旧, 长度纟新)
def 枚举冫不定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌(增量纟固化前缀长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀, /):
    'uint -> INOUT:reversed:[k] -> INOUT:[k] -> INOUT:[idx] -> Iter (INOUT:[k]) #词典序,非定长'
    (固化前缀长度纟旧, 固化前缀长度纟新) = _预处理冫增量纟长度扌(增量纟固化前缀长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    固化前缀长度纟旧
        #用于:减少输出冗余
    固化前缀长度纟新
        #用于:真-固化前缀

    泛排列纟就地修改 = 泛排列纟初始纟就地修改
    新丷旧 = False
    while not 新丷旧:
        yield 泛排列纟就地修改[固化前缀长度纟旧:]
        新丷旧 = 惑就地修改为孓冫不定长耂泛排列牜记录位次扌(固化前缀长度纟新, 逆序列表纟剩余纟就地修改, 泛排列纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    ######################
    #还原:
    _后处理冫增量纟长度扌(增量纟固化前缀长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    assert len(泛排列纟初始纟就地修改) == 固化前缀长度纟旧
    return
def _后处理冫增量纟长度扌(增量纟长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀, /):
    #还原:
    for _ in range(增量纟长度):
        逆序列表纟剩余纟就地修改.append(最小值纟剩余:=泛排列纟初始纟就地修改.pop())
        位置乚泛排列讠位置乚逆序后缀.pop()
    return

def 枚举冫定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌(增量纟限定长度, 增量纟固化前缀长度, 鬽固化前缀长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀, /):
    'uint -> uint -> may uint -> INOUT:reversed:[k] -> INOUT:[k] -> INOUT:[idx] -> Iter (INOUT:[k]) #词典序,定长'
    check_uint(增量纟限定长度)
    _限定长度纟旧 = len(泛排列纟初始纟就地修改)
    限定长度 = _限定长度纟旧 + 增量纟限定长度
    固化前缀长度 = ifNone(鬽固化前缀长度, _限定长度纟旧)

    check_uint_le(限定长度, 固化前缀长度)
    check_uint_le(限定长度-固化前缀长度, 增量纟固化前缀长度)

    固化前缀长度纟旧 = 固化前缀长度
        #用于:减少输出冗余
    固化前缀长度纟新 = 固化前缀长度 + 增量纟固化前缀长度
        #用于:真-固化前缀

    (限定长度纟旧, 限定长度纟新) = _预处理冫增量纟长度扌(增量纟限定长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    限定长度纟旧
        #用于:???还原...
    限定长度纟新
        #用于:真-限定长度

    泛排列纟就地修改 = 泛排列纟初始纟就地修改
    新丷旧 = False
    while not 新丷旧:
        yield 泛排列纟就地修改[固化前缀长度纟旧:]
        新丷旧 = 惑就地修改为孓冫定长耂泛排列牜记录位次扌(固化前缀长度纟新, 逆序列表纟剩余纟就地修改, 泛排列纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    ######################
    #还原:
    _后处理冫增量纟长度扌(增量纟限定长度, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
    assert len(泛排列纟初始纟就地修改) == 限定长度纟旧
    return



def 枚举冫不定长耂泛排列牜记录位次冖冖已排序版扌(逆序列表纟就地修改, /):
    'INOUT:reversed:[k] -> Iter (INOUT:[k]) #词典序,非定长'
    #枚举冫不定长耂泛排列牜比较大小冖冖已排序版扌
    #枚举冫不定长耂泛排列牜记录位次冖冖已排序版扌
    #
    #最小冫不定长耂泛排列扌(总数)
    #最大冫不定长耂泛排列扌(总数)
    逆序列表纟剩余纟就地修改 = 逆序列表纟就地修改
    泛排列纟初始纟就地修改 = []
    位置乚泛排列讠位置乚逆序后缀 = []
    return 枚举冫不定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌(0, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀)

def 枚举冫定长耂泛排列牜记录位次冖冖已排序版扌(限定长度, 逆序列表纟就地修改, /):
    'uint -> INOUT:reversed:[k] -> Iter (INOUT:[k]) #词典序,定长'
    #
    逆序列表纟剩余纟就地修改 = 逆序列表纟就地修改
    泛排列纟初始纟就地修改 = []
    位置乚泛排列讠位置乚逆序后缀 = []
    return 枚举冫定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌(增量纟限定长度:=限定长度, 增量纟固化前缀长度:=0, 固化前缀长度:=0, 逆序列表纟剩余纟就地修改, 泛排列纟初始纟就地修改, 位置乚泛排列讠位置乚逆序后缀)










def 惑就地修改为孓冫完全错装耂泛排列映射表达扌(逆序列表纟入口纟只读, 逆序列表纟出口纟剩余纟就地修改, 泛排列映射表达纟孑纟就地修改, 入口讠位置乚逆序后缀纟出口纟就地修改, /, *, __O_to_K__, __I_eq_K__):
    r'''[[[
    :: (Ord i,Ord k) => IN:reversed:[i] -> INOUT:reversed:[o] -> INOUT:{i:o} -> INOUT:{o:idx/uint} -> (o->k) -> (i->k->bool) -> 新丷旧/bool
    #Ord必要性:确保:最大情形:至多一对邻居升序
    #严格递降，不得重复
    #
    #词典序,定长
    #映射:不使用len/bool/iter
    #只使用__getitem__/__setitem__:确保:列表{填充None}为有效参数

    #即:鬽孓冫完全错装耂泛排列映射表达扌
    #类同:惑就地修改为孓冫定长耂泛排列牜记录位次扌

    #至多一对邻居升序:当前版:强行消除升序对:不论是否错装
    #   居后部分:严格递降:逆序出位~全零
    #
    #]]]'''#'''
    #因为最后有操作『_最小化诸后扌()』所以 可以直接交换 升序对 不论是否 错装
    #   若发现 _最小化诸后扌()失败，则 再执行一次(必然是 其中某一位:(I,O)发生碰撞/非错装，并且『诸后』到达 最大)
    汆逆序列表纟入口 = 逆序列表纟入口纟只读
    廽逆序列表纟出口纟剩余 = 逆序列表纟出口纟剩余纟就地修改
    廽泛排列映射表达 = 泛排列映射表达纟孑纟就地修改
    廽入口讠出位乚逆序后缀 = 入口讠位置乚逆序后缀纟出口纟就地修改

    ######################
    #bug:无关:assert len(汆逆序列表纟入口) == len(廽逆序列表纟出口纟剩余)
        #剩余出口:可用于替换在任出口
        #
    ######################
    #禁用:len:assert len(廽入口讠出位乚逆序后缀) == len(廽泛排列映射表达)
        #禁用:len(廽入口讠出位乚逆序后缀)
        #禁用:len(廽泛排列映射表达)
        #可能是:填充了None的列表,len无意义
    ######################
    现任数量 = len(汆逆序列表纟入口)
    #固化前缀长度 = 0
    #有效长度 = 限定长度 = 现任数量
    剩余数量 = len(廽逆序列表纟出口纟剩余)

    def _最小化诸后扌(max1_iii, /):
        '-> 欤非错装/bool'
        #至多一对邻居升序:当前版:强行消除升序对:不论是否错装
        #   居后部分:严格递降:逆序出位~全零
        #
        #if 0b001:print_err('_最小化诸后扌', max1_iii, 廽泛排列映射表达, 廽入口讠出位乚逆序后缀)
        assert 0 <= max1_iii <= 现任数量
        逆序入口列表纟一 = 汆逆序列表纟入口[:max1_iii]
        for I in 逆序入口列表纟一:
            # !! 居后部分:严格递降:逆序出位~全零
            assert 廽入口讠出位乚逆序后缀[I] == 0
        出口列表纟一 = [廽泛排列映射表达[I] for I in 逆序入口列表纟一]
        升序出口列表 = 廽逆序列表纟出口纟剩余[::-1] + 出口列表纟一
        #if 0b001:print_err('_最小化诸后扌', 出口列表纟一, 升序出口列表)
        出口列表纟一纟新 = 升序出口列表[:max1_iii]
        廽逆序列表纟出口纟剩余[:] = 升序出口列表[max1_iii:]
        #bug:for I, O in zip(逆序入口列表纟一, 出口列表纟一纟新):
        for I, O in zip(reversed(逆序入口列表纟一), 出口列表纟一纟新):
            廽泛排列映射表达[I] = O

        for ki, I in enumerate(逆序入口列表纟一, 剩余数量):
            廽入口讠出位乚逆序后缀[I] = ki

        #逆序入口列表纟一
        for iii in range(max1_iii)[::-1]:
            if 欤错装扌(iii):
                continue
            if iii > 0 or 剩余数量 > 0:
                盲交换冫升序对扌(iii)
            elif max1_iii == 1:
                assert iii == 0
                assert 剩余数量 == 0
                assert max1_iii == 1
                return (欤非错装:=True)
            else:
                盲交换冫升序对扌(iii+1)
        return (欤非错装:=False)
    #end-def _最小化诸后扌(max1_iii, /):

    def 盲交换冫升序对扌(iii, /):
        'iii <-> iii-1#升序对'
        assert iii > 0 or 剩余数量 > 0
        #if 0b001:print_err('盲交换冫升序对扌', iii, 廽泛排列映射表达, 廽入口讠出位乚逆序后缀)
        Oi = 取冫出口巛真实位置扌(iii,0)
        Oj = 取冫出口巛真实位置扌(iii,1)
        置冫出口乊真实位置扌(iii, 1, Oi)
        置冫出口乊真实位置扌(iii, 0, Oj)
        I = 汆逆序列表纟入口[iii]
        ki = 廽入口讠出位乚逆序后缀[I]
        kj = ki - 1
            #<<==升序对
        if iii > 0:
            J = 汆逆序列表纟入口[iii-1]
            廽入口讠出位乚逆序后缀[J] = kj
        廽入口讠出位乚逆序后缀[I] = kj
    def 换成更大扌(iii, /):
        #不论是否错装
        '只能用于:居后逆序阶段#不能用在 _最小化诸后扌()/升序阶段'
        I = 汆逆序列表纟入口[iii]
        ki = 廽入口讠出位乚逆序后缀[I]
        if ki == 0:
            return False
        kj = ki-1
        j = 真实位置巛逆序出位扌(iii, kj)
            #'只能用于:居后逆序阶段#不能用在 _最小化诸后扌()/升序阶段'
        Oj = 取冫出口巛真实位置扌(iii, j)
        Oi = 取冫出口巛真实位置扌(iii,0)
        #互换:Oi<->Oj
        廽泛排列映射表达
        廽逆序列表纟出口纟剩余
        置冫出口乊真实位置扌(iii, 0, Oj)
        置冫出口乊真实位置扌(iii, j, Oi)
        #还有:
        廽入口讠出位乚逆序后缀
        廽入口讠出位乚逆序后缀[I] -= 1
        if 0:
            if j <= iii:
                _iii = iii-j
                J = 汆逆序列表纟入口[_iii]
                廽入口讠出位乚逆序后缀[J] = 0
                    #已是0
                    #   !! 居后严格逆序
        汆逆序列表纟入口
        return True
    def 换成更大直至错装或失败扌(iii, /):
        '-> 失败丷错装'
        '只能用于:居后逆序阶段#不能用在 _最小化诸后扌()/升序阶段'
        while 1:
            if not 换成更大扌(iii):
                return False
            if 欤错装扌(iii):
                break
        return True

    def 欤错装扌(iii, /):
        I = 汆逆序列表纟入口[iii]
        O = 取冫出口巛真实位置扌(iii, 0)
        K = __O_to_K__(O)
        return not __I_eq_K__(I, K)

    def 置冫出口乊真实位置扌(iii, j, O, /):
        assert j >= 0
        if j <= iii:
            I = 汆逆序列表纟入口[iii -j]
            廽泛排列映射表达[I] = O
        else:
            廽逆序列表纟出口纟剩余[j-iii-1] = O
        return
    def 取冫出口巛真实位置扌(iii, j, /):
        # j 自 后缀/iii诸后(含iii)
        assert j >= 0
        if j <= iii:
            I = 汆逆序列表纟入口[iii -j]
            O = 廽泛排列映射表达[I]
        else:
            O = 廽逆序列表纟出口纟剩余[j-iii-1]
        return O
    def 真实位置巛逆序出位扌(iii, k, /):
        '只能用于:居后逆序阶段#不能用在 _最小化诸后扌()/升序阶段'
        assert k >= 0
        # !! 当前版:强行消除升序对
        j = k+1
        return j
        # k 自 后缀/iii居后(不含iii)
        #   并且 被升序 扭曲#要求是:逆序后的位置
        #
        # [升序位置 >= 0]
        # [[升序位置 >= 3] -> [O{升序位置-1} > O{升序位置} > O{升序位置-2} > O{升序位置-3}]]
        #   !! 升序位置 绑定于 逆序的入口列表 所以 看起来像降序
        # [[升序位置 == 0] -> [O{逆出.0} > O{逆入.0} > O{逆出.1} > O{逆出.2} > ...]]
        # ... [... > O{升序位置+2} > O{升序位置+1} > O{升序位置-1} > O{升序位置} > O{升序位置-2} > O{升序位置-3} > ...]



    # [泛排列纟完整 := 廽泛排列映射表达++廽逆序列表纟出口纟剩余]
    def main(cnt, /):
        #if 0b001:print_err('main', cnt)
        if not cnt < 2:
            raise 000
        for iii in range(现任数量):
            if 换成更大直至错装或失败扌(iii):
                #错装
                max1_iii = iii
                新丷旧 = False#新
                break
        else:
            #至多一对邻居升序:当前版:强行消除升序对:不论是否错装
            #   居后部分:严格递降:逆序出位~全零
            #
            if 1:
                #还原
                max1_iii = 现任数量
                新丷旧 = True#旧
        #至多一对邻居升序:当前版:强行消除升序对:不论是否错装
        #   iii-居后部分:严格递降:逆序出位~全零
        #
        max1_iii
        新丷旧
        欤非错装 = _最小化诸后扌(max1_iii)
        if 欤非错装:
            return main(cnt+1)
        return 新丷旧
    return main(0)
#end-def 惑就地修改为孓冫完全错装耂泛排列映射表达扌(逆序列表纟入口纟只读, 逆序列表纟出口纟剩余纟就地修改, 泛排列映射表达纟孑纟就地修改, 入口讠位置乚逆序后缀纟出口纟就地修改, /, *, __O_to_K__, __I_eq_K__):
def 枚举冫完全错装耂泛排列映射表达牜记录位次冖冖已排序版扌(逆序列表纟入口纟只读, 逆序列表纟出口纟剩余纟就地修改, 泛排列映射表达纟就地修改, 入口讠位置乚逆序后缀纟出口纟就地修改, /, *, __O_to_K__, __I_eq_K__, 固实丷视图丨变换器, 欤变换器翨甤视图):
    'INOUT:reversed:[i] -> INOUT:reversed:[o] -> INOUT:{i:o} -> INOUT:{o:idx/uint} -> Iter (INOUT:{i:o}) #词典序,非定长 #映射:不使用len/bool/iter,只使用__getitem__/__setitem__:确保:列表{填充None}为有效参数'
    构造冫置换扌 = _预处理冫视图灬扌(总数:=len(泛排列映射表达纟就地修改), 泛排列映射表达纟就地修改, 固实丷视图丨变换器=固实丷视图丨变换器, 欤变换器翨甤视图=欤变换器翨甤视图)
    while 1:
        #yield tuple(泛排列映射表达纟就地修改)
        yield 构造冫置换扌()
        if 惑就地修改为孓冫完全错装耂泛排列映射表达扌(逆序列表纟入口纟只读, 逆序列表纟出口纟剩余纟就地修改, 泛排列映射表达纟就地修改, 入口讠位置乚逆序后缀纟出口纟就地修改, __O_to_K__=__O_to_K__, __I_eq_K__=__I_eq_K__):
            break
    return




######################
######################
ensure_strict_sorted
######################
def _枚举冫某某某冖冖已排序版扌(sf, 总数, iter__, total_, /, **kwds):
    it = ensure_strict_sorted(iter__(sf, 总数, **kwds))
    total = 0
    for total, x in enumerate(it, 1):
        yield x
    if not total == (total2 := total_(总数)):raise Exception(total, total2)
    return
######################
def _蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换映射表达 #效率保证:0.3~0.4#见:比例夹逼定理纟完全错装数:[完全错装数(2*k+1)/(2*k+1)! < 1/e < 完全错装数(2*k)/(2*k)!]'
    return filter(欤置换映射表达是完全错装扌, 枚举冫排列扌(range(总数)))
######################
def 枚举冫置换环节表达巛置换映射表达牜位次不更改丶规范最小化扌(置换映射表达, /):
    '-> 置换环节表达'
    if 置换映射表达 and 置换映射表达[0]:
        return
    总数 = len(置换映射表达)
    #环节长度列表 = []
    置换环节表达 = []
    剩余索引集合 = DoublyList4Idc__rollbackable(总数, range(总数))
    def 占用扌(i, j, /):
        '-> 还原点'
        还原点 = 剩余索引集合.tell()
        for kkk in 置换映射表达[i:j]:
            剩余索引集合.remove(kkk)
        return 还原点
    def 乊新环开始扌(j, /):
        if j == 总数:
            assert not 剩余索引集合
            #r = (tuple(环节长度列表), tuple(置换环节表达))
            r = tuple(置换环节表达)
            if 0b001:print_err(r)
            yield r
            return
        assert 剩余索引集合
        assert 置换映射表达[j] == 剩余索引集合.first
        yield from 乊环增长扌(j)
    def 乊环增长扌(i, /):
        j = i+2
        if not j <= 总数:
            return
        还原点纟甲 = 占用扌(i, j)
        for k in range(j, 1+总数):
            if not (k == 总数 or 置换映射表达[k] == 剩余索引集合.first):
                continue
            还原点纟乙 = 占用扌(j, k)
            置换环节表达.append(置换循环小节:= 置换映射表达[i:k])
            #环节长度列表.append(len(置换循环小节))
            yield from 乊新环开始扌(k)
            #环节长度列表.pop()
            置换环节表达.pop()
            剩余索引集合.rollback(还原点纟乙)
        剩余索引集合.rollback(还原点纟甲)

    return 乊新环开始扌(0)
def _蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换环节表达 #效率保证:0.3~0.4#见:比例夹逼定理纟完全错装数:[完全错装数(2*k+1)/(2*k+1)! < 1/e < 完全错装数(2*k)/(2*k)!]'

    #old:bug:

    r'''[[[
    bug:[总数==5]:
((0, 1), (2, 3, 4))
((0, 1, 2, 3, 4),)
((0, 1), (2, 4, 3))
    !!出错!!

    #]]]'''#'''
    raise 000
    for 置换映射表达 in 枚举冫排列扌(range(总数)):
        if 置换映射表达 and 置换映射表达[0]:
            break
        yield from 枚举冫置换环节表达巛置换映射表达牜位次不更改丶规范最小化扌(置换映射表达)
    return
######################
def _蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换环节紧凑表达 #效率保证:0.3~0.4#见:比例夹逼定理纟完全错装数:[完全错装数(2*k+1)/(2*k+1)! < 1/e < 完全错装数(2*k)/(2*k)!]'
    return ...

######################
######################
######################
DoublyList4Idc__rollbackable
def _预处理冫视图灬扌(总数, ls, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):
    SeqView
    if callable(固实丷视图丨变换器):
        变换器 = 固实丷视图丨变换器
            # 可能是:SeqView
    else:
        固实丷视图 = 固实丷视图丨变换器
        check_type_is(bool, 固实丷视图)
        变换器 = tuple if not 固实丷视图 else SeqView
    变换器# 可能是:SeqView
    check_type_is(bool, 欤变换器翨甤视图)
    欤变换器翨甤视图 = 变换器 is SeqView or 欤变换器翨甤视图
    #if 变换器 is SeqView:
    if 欤变换器翨甤视图:
        #视图
        #只包装一次
        #
        #待填充冫完全错装耂置换映射表达 = SeqView(ls)
        待填充冫完全错装耂置换映射表达 = 变换器(ls)
        def 构造冫置换扌():
            assert len(ls) == 总数
            return 待填充冫完全错装耂置换映射表达
    else:
        #变换or固实
        #构造每一次
        #
        assert not 变换器 is SeqView
        def 构造冫置换扌():
            assert len(ls) == 总数
            return 变换器(ls)
    构造冫置换扌
    return 构造冫置换扌

def _枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(sf, 总数, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):
  '' \
    '-> Iter 置换映射表达'
    # [:定义冫完全错装数爫隔离索引零扌]:goto
  #init-while 1:
  if 1:
    ls = [] #待填充冫完全错装耂置换映射表达
    构造冫置换扌 = _预处理冫视图灬扌(总数, ls, 固实丷视图丨变换器=固实丷视图丨变换器, 欤变换器翨甤视图=欤变换器翨甤视图)


  if 1:
    DoublyList4Idc__rollbackable
    线段出口讠入口 = [*range(总数)]
    线段出口巛入口 = [*range(总数)]
        ######################
        # 初始化:指向自己:不动点
        ######################
        #匡串联:链接扌:改:外端点指向，不改:内端点指向
        #所以:这俩 不是 逆映射！！
        ######################
    线段出口集合 = DoublyList4Idc__rollbackable(总数, range(总数))
    线段入口集合 = DoublyList4Idc__rollbackable(总数, range(总数))
    列表纟集合纟还原 = (线段出口集合,线段入口集合)

    ######################
    #流程况态:
    匡全新开始 = object()
    匡串联 = object()
    匡断联 = object()
    帧栈 = []
    ######################
    构造冫置换扌
    ######################
    ######################
    def 构造冫帧扌(出口纟前, 入口纟后, 还原点, /):

        帧纟前 = (出口纟前, 入口纟后, 还原点)
        return 帧纟前
    def 构造冫还原点扌():
        还原点 = tuple(集合.tell() for 集合 in 列表纟集合纟还原)
        return 还原点
    def 还原扌(还原点, /):
        for 还原点纟集合, 集合 in zip(还原点,列表纟集合纟还原):
            集合.rollback(还原点纟集合)

    def 链接扌(出口纟前, 入口纟后, /):
        '只修改半边，因为 断开扌 还要用到'
        入口纟前 = 线段出口讠入口[出口纟前]
        出口纟后 = 线段出口巛入口[入口纟后]
        ######################
        #改:外端点指向，不改:内端点指向
        线段出口讠入口[出口纟后] = 入口纟前
        线段出口巛入口[入口纟前] = 出口纟后
    def 断开扌(出口纟前, 入口纟后, /):
        入口纟前 = 线段出口讠入口[出口纟前]
        出口纟后 = 线段出口巛入口[入口纟后]
        ######################
        #改:外端点指向，不改:内端点指向
        线段出口讠入口[出口纟后] = 入口纟后
        线段出口巛入口[入口纟前] = 出口纟前
    ######################
    ######################

  #begin-while 1:
  def 乊匡串联扌(流程况态, 出口纟前, 入口纟后, 还原点,   入口纟前, 出口纟后, /):
    '' \
      '-> 流程况态'
    assert 出口纟前 == len(ls)
    链接扌(出口纟前, 入口纟后)
    ls.append(入口纟后)
        # !! [出口纟前 == len(ls)]
        # 置换映射表达:变换:出口纟前-->入口纟后
    ##################
    ##################简化:
    if 出口纟后 == 出口纟前 and 出口纟前 == 入口纟前:
        # 不动点
        # 跳过
        流程况态 = 匡断联
    else:
        # 闭合成环or线段接力串联
        流程况态 = 匡全新开始
    return 流程况态
    #<<== 源自:下面简化:
    ##################
    ##################展开:
    if 出口纟后 == 出口纟前:
        # 闭合成环vs不动点
        if 出口纟前 == 入口纟前:
            # 不动点
            # 跳过
            流程况态 = 匡断联
            return 流程况态
        # 闭合成环
        #
        #已删除:
        #线段入口集合.remove(入口纟后)
        #线段出口集合.remove(出口纟前)
        流程况态 = 匡全新开始
        return 流程况态
    else:
        # 线段接力串联
        assert 出口纟后 > 出口纟前
            # !! 前 是 当前轮 被隔离的索引零
            # => 出口纟前 是 min(当前轮 所有 出口)
        assert not 入口纟后 == 入口纟前
        assert 线段入口集合
        ##############
        ##############新:
        流程况态 = 匡全新开始
        return 流程况态
        ##############
        ##############旧:bug:
        还原点 = 构造冫还原点扌()
        if 1:
            #bug:
            #出口纟后 = 线段出口集合.pop_first()
            # 但:出口纟后 不一定 最小
            if not 出口纟后 == 线段出口集合.pop_first():raise 000
        入口纟更后 = 线段入口集合.pop_first()
        帧纟后 = 构造冫帧扌(出口纟后, 入口纟更后, 还原点)
        帧栈.append(帧纟后)
        流程况态 = 匡串联
        return 流程况态
    raise 000
  #end-def 乊匡串联扌(流程况态, 出口纟前, 入口纟后, 还原点,   入口纟前, 出口纟后, /):
  def 乊匡断联扌(流程况态, 出口纟前, 入口纟后, 还原点,   入口纟前, 出口纟后, /):
    '' \
      '-> 流程况态'
    还原扌(还原点)
    帧栈.pop()
    if not ls.pop() == 入口纟后:raise 000
    断开扌(出口纟前, 入口纟后)
    入口纟后纟新 = 线段入口集合.next_(入口纟后)
    # !! 入口纟后 递增 <<== 置换映射表达 递增
    if not 入口纟后纟新 > 入口纟后:
        #已是 最大 入口纟后
        assert 入口纟后 == 线段入口集合.last
        流程况态 = 匡断联
        return 流程况态
    else:
        assert not 入口纟后 == 线段入口集合.last
        还原点 = 构造冫还原点扌()
        if not 出口纟前 == 线段出口集合.pop_first():raise 000
        线段入口集合.remove(入口纟后纟新)
        帧纟新 = 构造冫帧扌(出口纟前, 入口纟后纟新, 还原点)
        帧栈.append(帧纟新)
        流程况态 = 匡串联
        return 流程况态
    raise 000
  #end-def 乊匡断联扌(流程况态, 出口纟前, 入口纟后, 还原点,   入口纟前, 出口纟后, /):
  def 乊匡全新开始乊非完整扌(流程况态, /):
    '' \
      '-> 流程况态'
    assert 线段出口集合
        # 非完整
    还原点 = 构造冫还原点扌()
    出口纟前 = 线段出口集合.pop_first()
    入口纟后 = 线段入口集合.pop_first()
    帧纟前 = 构造冫帧扌(出口纟前, 入口纟后, 还原点)
    帧栈.append(帧纟前)
    assert 出口纟前 == len(ls)
    流程况态 = 匡串联
    return 流程况态
  #end-def 乊匡全新开始乊非完整扌(流程况态, /):
  def 乊非匡全新开始乊非结束扌(流程况态, /):
    '' \
      '-> 流程况态'
    assert 帧栈
        #非结束
    帧纟前 = 帧栈[-1]
    (出口纟前, 入口纟后, 还原点) = 帧纟前
    assert not 入口纟后 in 线段入口集合
    assert not 出口纟前 in 线段出口集合
    入口纟前 = 线段出口讠入口[出口纟前]
    出口纟后 = 线段出口巛入口[入口纟后]
    if 出口纟后 == 出口纟前:
        # 闭合成环vs不动点
        assert 入口纟后 == 入口纟前
    else:
        # 线段接力串联
        assert not 入口纟后 == 入口纟前
        assert 入口纟前 in 线段入口集合
        assert 出口纟后 in 线段出口集合
    ######################
    if 流程况态 is 匡串联:
        流程况态 = 乊匡串联扌(流程况态, 出口纟前, 入口纟后, 还原点,   入口纟前, 出口纟后)
    elif 流程况态 is 匡断联:
        流程况态 = 乊匡断联扌(流程况态, 出口纟前, 入口纟后, 还原点,   入口纟前, 出口纟后)
    else:
        raise 000
    return 流程况态
  #end-def 乊非匡全新开始乊非结束扌(流程况态, /):
  def main():
    流程况态 = 匡全新开始
    while 1:
        assert len(线段出口集合) == len(线段入口集合)
        assert len(帧栈) == (流程况态 is 匡串联) + len(ls)
        assert len(帧栈) + len(线段出口集合) == 总数
        if 流程况态 is 匡全新开始:
            assert len(帧栈) == len(ls)
            if not 线段出口集合:
                # 完整:
                #yield tuple(ls)
                yield 构造冫置换扌()
                流程况态 = 匡断联
                continue
            # 非完整:
            流程况态 = 乊匡全新开始乊非完整扌(流程况态)
            continue
        ######################
        ######################
        if 流程况态 is 匡全新开始:
            assert len(帧栈) == len(ls)
        elif 流程况态 is 匡断联:
            assert len(帧栈) == len(ls)
        elif 流程况态 is 匡串联:

            assert len(帧栈) == 1+len(ls)
        else:
            raise 000
        ######################
        ######################
        if not 帧栈:
            #结束:
            assert 流程况态 is 匡断联
            assert len(帧栈) == len(ls)
            break
        ######################
        ######################
        #非结束:
        流程况态 = 乊非匡全新开始乊非结束扌(流程况态)
        continue
    #end-while 1:
    return
  #end-def main():
  if 1:
    return main()
#end-def _枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(sf, 总数, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):

######################
def _枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换映射表达'
    # [:定义冫完全错装数爫置换映射前缀扩张扌]:goto
    raise NotImplementedError('发现冫两者完全等同:隔离索引零vs前缀扩张')
    if 1:
        # 发现冫两者完全等同:
        _枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
        _枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌
    return ...
######################
def _枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌(sf, 总数, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):
    '-> Iter 置换映射表达'
    #计数型
    #鬽孓冫完全错装耂泛排列映射表达扌:goto
    if 总数 == 1:
        return null_iter

    逆序列表纟入口纟只读 = range(总数)[::-1]
    #逆序列表纟出口纟剩余纟就地修改 = [*逆序列表纟入口纟只读]
    逆序列表纟出口纟剩余纟就地修改 = []
    泛排列映射表达纟就地修改 = [None]*总数
    入口讠位置乚逆序后缀纟出口纟就地修改 = [None]*总数
    泛排列映射表达纟就地修改[::2] = range(总数+1)[1::2]
    泛排列映射表达纟就地修改[1::2] = range(总数-1)[::2]
    if 总数&1:
        泛排列映射表达纟就地修改[-2:] = [总数-1,总数-3]
    入口讠位置乚逆序后缀纟出口纟就地修改[::2] = range(-1, 总数-1)[::-2]
    入口讠位置乚逆序后缀纟出口纟就地修改[1::2] = range(总数-1)[::-2]
    if 总数&1:
        入口讠位置乚逆序后缀纟出口纟就地修改[-2:] = [0,0]

    it = 枚举冫完全错装耂泛排列映射表达牜记录位次冖冖已排序版扌(逆序列表纟入口纟只读, 逆序列表纟出口纟剩余纟就地修改, 泛排列映射表达纟就地修改, 入口讠位置乚逆序后缀纟出口纟就地修改, __O_to_K__=echo, __I_eq_K__=int.__eq__, 固实丷视图丨变换器=固实丷视图丨变换器, 欤变换器翨甤视图=欤变换器翨甤视图)
    return it
    def __():
        for x in it:
            #if 0b001:print_err(泛排列映射表达纟就地修改, 入口讠位置乚逆序后缀纟出口纟就地修改)
            yield x
    return __()
    return it

######################
######################
def _枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换环节表达'
    # [:定义冫完全错装数爫置换环节消减扌]:goto
    check_uint(总数)
    #if 总数 == 1: return
    逆序列表纟剩余纟就地修改 = [*range(总数)[::-1]]
    泛排列纟就地修改 = []
    位置乚泛排列讠位置乚逆序后缀 = []
    ls = []
    its = []
    def 乊新环扌():
        assert not len(逆序列表纟剩余纟就地修改) == 1
        增量纟固化前缀长度 = int(bool(逆序列表纟剩余纟就地修改))
            # <<== 规范最小化
        it = 枚举冫不定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌(增量纟固化前缀长度, 逆序列表纟剩余纟就地修改, 初始:=泛排列纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
        its.append(it)
        return
    if not len(逆序列表纟剩余纟就地修改) == 1:
        乊新环扌()
            #:语句甲
    while its:
        #if 0b001:print_err(ls, 逆序列表纟剩余纟就地修改)
        if not 逆序列表纟剩余纟就地修改:
            #对应于:初始乊总数零or语句乙耂分支二
            assert len(泛排列纟就地修改) == 总数
            置换环节表达 = tuple(ls)
            #if 0b001:print_err(置换环节表达)
            yield 置换环节表达
            if ls:
                #对应于:语句乙耂分支二
                ls.pop()
        em = next(its[-1], ...)
        if em is ...:
            its.pop()
                #对应于:语句甲or语句乙耂分支一
            if ls:
                #对应于:语句乙耂分支一
                ls.pop()
            continue
        环 = em
        #assert 环 or 总数==0
        if not 环:
            assert 总数==0
            break
        if len(环) >= 2 and not len(逆序列表纟剩余纟就地修改) == 1:
            ls.append(tuple(环))
                #:语句乙
            if 逆序列表纟剩余纟就地修改:
                #:语句乙耂分支一
                assert len(逆序列表纟剩余纟就地修改) >= 2
                乊新环扌()
            else:
                #:语句乙耂分支二
                pass
        else:
            assert 逆序列表纟剩余纟就地修改
    return
#end-def _枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌(sf, 总数, /):
######################
def _枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换环节表达'

######################
######################
def 枚举冫环节长度列表扌(总数,/):
    '-> Iter 环节长度列表 #词典序'
    check_uint(总数)
    if 总数 < 2:
        if 总数 == 0:
            yield ()
        return
    szs = []
    def 追加冫最小展开扌(n, /, *, szs=szs):
        assert n >= 2
        szs += [2]*(n//2)
        if n&1:
            szs[-1] += 1
    追加冫最小展开扌(总数)
    assert sum(szs) == 总数
    assert all(sz >= 2 for sz in szs)
    while 1:
        yield tuple(szs)
        n = szs.pop()
        if not szs:
            break
        if n == 2:
            szs[-1] += n
        else:
            szs[-1] += 1
            追加冫最小展开扌(n-1)

def _枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换环节紧凑表达'
    # [:定义冫完全错装数爫置换环节消减扌]:goto
    check_uint(总数)
    if 0:
        if 总数 < 2:
            if 总数 == 0:
                yield ()
            return

    逆序列表纟剩余纟就地修改 = [*range(总数)[::-1]]
    泛排列纟就地修改 = []
    位置乚泛排列讠位置乚逆序后缀 = []
    #ls = []
    it_ls = []

    def 填充扌():
        #assert len(it_ls) == len(ls)
        for sz in 环节长度列表[len(it_ls):]:
            it = 乊新环扌(sz)
            it_ls.append(it)
            环 = next(it)
            #ls.append(tuple(环))
    def 惑孓扌():
        while it_ls and ... is (环:=next(it_ls[-1], ...)):
            it_ls.pop()
            #ls.pop()
        if it_ls:
            #ls[-1] = tuple(环)
            填充扌()
        return
    def 乊新环扌(环节长度, /):
        assert 环节长度 >= 2
        增量纟固化前缀长度 = int(bool(逆序列表纟剩余纟就地修改))
            # <<== 规范最小化
        it = 枚举冫定长耂泛排列牜记录位次牜前缀固化冖冖已排序版扌(增量纟限定长度:=环节长度, 增量纟固化前缀长度, 鬽固化前缀长度:=None, 逆序列表纟剩余纟就地修改, 泛排列纟就地修改, 位置乚泛排列讠位置乚逆序后缀)
        return it
    for 环节长度列表 in 枚举冫环节长度列表扌(总数):
        填充扌()
        while 1:
            if 0:
                r'''[[[
                #bug:
                置换环节表达 = tuple(ls)
                置换环节紧凑表达 = (环节长度列表,置换环节表达)
                #]]]'''#'''
            置换环节紧凑表达 = (环节长度列表,tuple(泛排列纟就地修改))
            yield 置换环节紧凑表达
            惑孓扌()
            if not it_ls:
                break
    return
#end-def _枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌(sf, 总数, /):
######################
def _枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌(sf, 总数, /):
    '-> Iter 置换环节表达'

######################
######################
######################
class 魖完全错装数牜枚举(魖完全错装数):
    __slots__ = ()
    #枚举冫完全错装耂置换映射表达冖冖已排序版扌
        #蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌 # 效率为(0.3~0.4)
        #枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
        #枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌
        #枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌
    #枚举冫完全错装耂置换环节表达冖冖已排序版扌
        #蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌
        #枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌
        #枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌
    #枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌
        #蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌
        #枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌
        #枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌
    ######################
    ######################
    ######################
    @abstractmethod
    def 枚举冫完全错装耂置换映射表达冖冖已排序版扌(sf, 总数, /):
        '-> Iter 置换映射表达'
        # [:定义冫完全错装数爫隔离索引零扌]:goto
        # [:定义冫完全错装数爫置换映射前缀扩张扌]:goto
        sf.蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌
        sf.枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
        sf.枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌
        sf.枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌
    ######################
    @abstractmethod
    def 枚举冫完全错装耂置换环节表达冖冖已排序版扌(sf, 总数, /):
        '-> Iter 置换环节表达'
        # [:定义冫完全错装数爫置换环节消减扌]:goto
        sf.蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌
        sf.枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌
        sf.枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌
    ######################
    @abstractmethod
    def 枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌(sf, 总数, /):
        '-> Iter 置换环节紧凑表达'
        # [:定义冫完全错装数爫置换环节消减扌]:goto
        sf.蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌
        sf.枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌
        sf.枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌

    ######################
    ######################
    ######################
    def 蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌, sf.完全错装数扌)
    蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌.__doc__ = _蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌.__doc__
    ######################
    def 蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌, sf.完全错装数扌)
    蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌.__doc__ = _蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌.__doc__
    ######################
    def 蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌, sf.完全错装数扌)
    蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌.__doc__ = _蛮力枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌.__doc__
    ######################
    ######################
    def 枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(sf, 总数, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌, sf.完全错装数扌, 固实丷视图丨变换器=固实丷视图丨变换器, 欤变换器翨甤视图=欤变换器翨甤视图)
    枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌.__doc__
    ######################
    def 枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌(sf, 总数, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌, sf.完全错装数扌, 固实丷视图丨变换器=固实丷视图丨变换器, 欤变换器翨甤视图=欤变换器翨甤视图)
    枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换映射表达爫前缀扩张冖冖已排序版扌.__doc__
    ######################
    def 枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌(sf, 总数, /, *, 固实丷视图丨变换器, 欤变换器翨甤视图):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌, sf.完全错装数扌, 固实丷视图丨变换器=固实丷视图丨变换器, 欤变换器翨甤视图=欤变换器翨甤视图)
    枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌.__doc__
    ######################
    ######################
    def 枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌, sf.完全错装数扌)
    枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌.__doc__
    ######################
    def 枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌, sf.完全错装数扌)
    枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换环节表达爫计数型冖冖已排序版扌.__doc__
    ######################
    ######################
    def 枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌, sf.完全错装数扌)
    枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌.__doc__
    ######################
    def 枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌(sf, 总数, /):
        return _枚举冫某某某冖冖已排序版扌(sf, 总数, _枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌, sf.完全错装数扌)
    枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌.__doc__ = _枚举冫完全错装耂置换环节紧凑表达爫计数型冖冖已排序版扌.__doc__

    ######################
    ######################
    ######################
######################
######################
class _乸完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试(魖完全错装数牜枚举):
    ___no_slots_ok___ = True
    @override
    def 罓完全错装数扌(sf, 总数, /):
        '-> 完全错装数(总数;)'
        return sf.罓完全错装数爫隔离索引零扌(总数)
    @override
    def 枚举冫完全错装耂置换映射表达冖冖已排序版扌(sf, 总数, /):
        '-> Iter 置换映射表达'
        raise NotImplementedError
        return sf.枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(总数, 固实丷视图丨变换器=False, 欤变换器翨甤视图=False)
        raise NotImplementedError
    @override
    def 枚举冫完全错装耂置换环节表达冖冖已排序版扌(sf, 总数, /):
        '-> Iter 置换环节表达'
        raise NotImplementedError
    @override
    def 枚举冫完全错装耂置换环节紧凑表达冖冖已排序版扌(sf, 总数, /):
        '-> Iter 置换环节紧凑表达'
        raise NotImplementedError
    pass
_匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试 = _乸完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试()
枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试.枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌
蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试.蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌
枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试.枚举冫完全错装耂置换映射表达爫计数型冖冖已排序版扌
def _测试冫枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(总数, /):
    匴 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试
    it0 = 匴.枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(总数)
    it1 = 匴.蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌(总数)
    for x0, x1 in zip_longest(it0, it1):
        assert x0 == x1
        yield x0
    return
    return 匴.枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌(总数)
    return 匴.枚举冫完全错装耂置换映射表达冖冖已排序版扌(总数)

def __():
    #bug:
    蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试.蛮力枚举冫完全错装耂置换环节表达冖冖已排序版扌
枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试.枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌
枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌 = _匴完全错装数牜枚举冫完全错装耂置换映射表达爫隔离索引零牜测试.枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌

__all__
class 魖完全错装数牜索引(魖完全错装数):
    __slots__ = ()
    #索取冫完全错装耂置换映射表达巛流水号扌
    #索取冫完全错装耂置换环节表达巛流水号扌
class 魖完全错装数牜定位(魖完全错装数):
    __slots__ = ()
    #定位冫完全错装耂置换映射表达讠流水号扌
    #定位冫完全错装耂置换环节表达讠流水号扌
class 魖完全错装数牜变换(魖完全错装数):
    __slots__ = ()
    #变换冫索引乊流水号纟完全错装耂置换映射表达扌
    #变换冫索引乊流水号纟完全错装耂置换环节表达扌
    #变换冫索引乊流水号纟完全错装耂置换环节紧凑表达扌


__all__
from script.完全错装数 import 蛮力枚举冫完全错装耂置换映射表达冖冖已排序版扌,枚举冫完全错装耂置换映射表达爫隔离索引零冖冖已排序版扌,枚举冫完全错装耂置换环节表达爫环节消减冖冖已排序版扌,枚举冫完全错装耂置换环节紧凑表达爫环节消减冖冖已排序版扌
from script.完全错装数 import *
