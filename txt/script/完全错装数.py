#__all__:goto
r'''[[[
e ./script/完全错装数.py
view ./script/complete_diffusion.py
view ../../python3_src/seed/math/combination.py
[[
当下:已完成:
    证明:比例夹逼定理纟完全错装数
    新构造器:完全错装数爫隔离索引零扌
当下:待办:
    填充:枚举冫某某某某某...
    填充:定位冫某某某某某...
    ...
]]


[[
命名规范:
view ../../python3_src/useful__cjk_naming.txt
『爫』:using/via
『牜』:指定小分类/细化约束条件
]]

[[
为何再次? #已有view ./script/complete_diffusion.py
    主要原因:新的构造法:
        * 旧方法:面向 置换循环小节
            # [置换循环小节::[uint]]
            # [置换环节表达::[置换循环小节]]
            #??可能用于 枚举冫置换环节表达冖冖已排序版扌
        * 新方法:面向 置换映射表达
            #用于:枚举冫置换映射表达冖冖已排序版扌
]]



script.完全错装数
py -m nn_ns.app.debug_cmd   script.完全错装数 -x
py -m nn_ns.app.doctest_cmd script.完全错装数:__doc__
py_adhoc_call   script.完全错装数   @f
from script.完全错装数 import *


[[证明区:
[比例夹逼定理纟完全错装数:偶总数的完全错装数占比递减丶奇总数的完全错装数占比递增丶偶总数的完全错装数占比大于奇总数的完全错装数占比丶两序列极限值相同丶该极限值为自然对数底的倒数]
    # 用于:蛮力枚举冫置换映射表达冖冖已排序版扌
    #   #占比极限:0.3~0.4
    #
    [[k >= 0] -> [完全错装数占比(2*k) > 完全错装数占比(2*k+2)]]
        #偶总数的完全错装数占比递减
    [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3)]]
        #奇总数的完全错装数占比递增
    [[m,n >= 0] -> [完全错装数占比(2*m+1) < 完全错装数占比(2*n)]]
        #偶总数的完全错装数占比大于奇总数的完全错装数占比
        !! 一递减，一递增
        <==> [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k)]]

    上面三式 <==> [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
    [limit [完全错装数占比(2*m+1) | [m :<- [0..]]] == limit [完全错装数占比(2*n) | [n :<- [0..]]]]
        #两序列极限值相同
        !! 单调有界=>极限存在
        <==> [limit [完全错装数占比(2*k) -完全错装数占比(2*k+1) | [k :<- [0..]]] == 0]

    [limit [完全错装数占比(m) | [m :<- [0..]]] == 1/math.e]
        #该极限值为自然对数底的倒数
===
目标一: [[k >= 0] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
目标二: [limit [完全错装数占比(2*k) -完全错装数占比(2*k+1) | [k :<- [0..]]] == 0]
目标三: [limit [完全错装数占比(m) | [m :<- [0..]]] == 1/math.e]

===
证明:目标一
* 基本情形纟归纳法:
* 基本情形纟归纳法冫偶总数:
    #偶总数的完全错装数占比序列:
    [完全错装数占比(总数:=0) == 完全错装数(0;)/阶乘扌(0) == 1/1 == 1]
    [完全错装数占比(总数:=2) == 完全错装数(2;)/阶乘扌(2) == 1/2 == 0.5]

* 基本情形纟归纳法冫奇总数:
    #奇总数的完全错装数占比序列:
    [完全错装数占比(总数:=1) == 完全错装数(1;)/阶乘扌(1) == 0/1 == 0]
    [完全错装数占比(总数:=3) == 完全错装数(3;)/阶乘扌(3) == 2/6 ~= 0.33]
基本情形纟归纳法==>>[目标一:在[k==0]时成立]

* 递归情形纟归纳法:
归纳假设: [n >= 1][@[k :<- [0..<n]] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
归纳目标: [完全错装数占比(2*n+1) < 完全错装数占比(2*n+3) < 完全错装数占比(2*n+2) < 完全错装数占比(2*n)]

    [[
    ###[本小段失败:移至下一段]
    !! [完全错装数爫排除法扌(总数;) =[def]= (阶乘扌(总数) -sum [组合数扌(总数;错装数)*完全错装数(总数:=错装数;) | [错装数:<-[0..<总数]]])]
        # [:定义冫完全错装数爫排除法扌]:goto

    [完全错装数(m;) == (阶乘扌(m) -sum [组合数扌(m;u)*完全错装数(u;) | [u:<-[0..<m]]])]

    [完全错装数占比(m;)
    == (1 -sum [组合数扌(m;u)*阶乘扌(u)/阶乘扌(m)*完全错装数占比(u;) | [u:<-[0..<m]]])
    == (1 -sum [完全错装数占比(u;)/阶乘扌(m-u) | [u:<-[0..<m]]])
    ]
    [完全错装数占比(m;) == (1 -sum [完全错装数占比(u;)/阶乘扌(m-u) | [u:<-[0..<m]]])]
    [完全错装数占比(m+2;) == (1 -sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<m+2]]])]
    [完全错装数占比(m+2;) -完全错装数占比(m;)
    == (1 -sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<m+2]]])
    -  (1 -sum [完全错装数占比(u;)/阶乘扌(m-u) | [u:<-[0..<m]]])
    == sum [完全错装数占比((u-2);)/阶乘扌(m-(u-2)) | [(u-2):<-[0..<m]]]
    -  sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<m+2]]]
    == sum [(完全错装数占比(u-2;) -完全错装数占比(u;))/阶乘扌(m+2-u) | [u:<-[2..<m+2]]]
    -  sum [完全错装数占比(u;)/阶乘扌(m+2-u) | [u:<-[0..<2]]]
    == sum [(完全错装数占比(u-2;) -完全错装数占比(u;))/阶乘扌(m+2-u) | [u:<-[2..<m+2]]]
    -  1/阶乘扌(m+2)
    * [[is_odd u][u < 2*n+3]]:
        !! 归纳假设
        [(完全错装数占比(u-2;) -完全错装数占比(u;)) < 0]
        #bug:... < 0
        #有正有负...???
    * [[is_even u][u < 2*n+2]]:
        !! 归纳假设
        [(完全错装数占比(u-2;) -完全错装数占比(u;)) > 0]
    #失败！改用: [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:goto
    ]
    ###[本小段失败:移至下一段]
    ]]

    ###新尝试:
    !! [完全错装数爫隔离索引零扌(总数;) =[def]= if 总数 < 0 then 0 elif 总数 < 2 then 1-总数 else (总数-1)*(完全错装数(总数-2;) +完全错装数(总数-1;))]
        # [:定义冫完全错装数爫隔离索引零扌]:goto

    [m >= 2]:
        [完全错装数(m;) == (m-1)*(完全错装数(m-2;) +完全错装数(m-1;))]

        [完全错装数占比(m;)
        == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m
        ]
        !! [1/m + (m-1)/m == 1]
        !! [m-1 > 0]
        [完全错装数占比(m;) between {完全错装数占比(m-2;), 完全错装数占比(m-1;)}]
        #
    [[m >= 2] -> [完全错装数占比(m;) == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m]]
    [[m >= 2] -> [完全错装数占比(m;) between {完全错装数占比(m-2;), 完全错装数占比(m-1;)}]]
    !! [n >= 1]
    [2*n >= 2]
    [完全错装数占比(2*n+2;) between {完全错装数占比(2*n;), 完全错装数占比(2*n+1;)}]
    [完全错装数占比(2*n+3;) between {完全错装数占比(2*n+1;), 完全错装数占比(2*n+2;)}]

    [k := n-1]:
        !! [@[k :<- [0..<n]] -> [完全错装数占比(2*k+1) < 完全错装数占比(2*k+3) < 完全错装数占比(2*k+2) < 完全错装数占比(2*k)]]
        [完全错装数占比(2*(n-1)+1) < 完全错装数占比(2*(n-1)+3) < 完全错装数占比(2*(n-1)+2) < 完全错装数占比(2*(n-1))]
    [完全错装数占比(2*n-1) < 完全错装数占比(2*n+1) < 完全错装数占比(2*n) < 完全错装数占比(2*n-2)]
    !! [完全错装数占比(2*n+2;) between {完全错装数占比(2*n;), 完全错装数占比(2*n+1;)}]
    !! [完全错装数占比(2*n+1) < 完全错装数占比(2*n)]
    [完全错装数占比(2*n+1) < 完全错装数占比(2*n+2;) < 完全错装数占比(2*n)]
    !! [完全错装数占比(2*n+3;) between {完全错装数占比(2*n+1;), 完全错装数占比(2*n+2;)}]
    [完全错装数占比(2*n+1) < 完全错装数占比(2*n+3;) < 完全错装数占比(2*n+2;) < 完全错装数占比(2*n)]
    证毕:归纳目标
证毕:目标一
===
证明:目标二
    !! [[m >= 2] -> [完全错装数占比(m;) == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m]]
        #见上面
    [m >= 2]:
        [完全错装数占比(m;) == 完全错装数占比(m-2;)/m +完全错装数占比(m-1;)*(m-1)/m]
        [完全错装数占比(m-1;) -完全错装数占比(m;) == -(完全错装数占比(m-2;) -完全错装数占比(m-1;))/m]
    [m >= 3]:
        [完全错装数占比(m-2;) -完全错装数占比(m-1;) == -(完全错装数占比(m-3;) -完全错装数占比(m-2;))/(m-1)]
        [完全错装数占比(m-1;) -完全错装数占比(m;) == (完全错装数占比(m-3;) -完全错装数占比(m-2;))/m/(m-1)]
    [k >= 1]:
        [2*k+1 >= 3]
        # [m := 2*k+1]
        [(完全错装数占比(2*k) -完全错装数占比(2*k+1)) == (完全错装数占比(2*k-2;) -完全错装数占比(2*k-1;))/(2*k+1)/(2*k) == (完全错装数占比(0;) -完全错装数占比(1;))/阶乘扌(2*k+1) == 1/阶乘扌(2*k+1)]
    [(完全错装数占比(2*k) -完全错装数占比(2*k+1)) == 1/阶乘扌(2*k+1)]
    [limit [(完全错装数占比(2*k) -完全错装数占比(2*k+1)) | [k :<- [0..]]] == limit [1/阶乘扌(2*k+1) | [k :<- [0..]]] == 0]
证毕:目标二

证明:目标三
    [m >= 2]:
        [完全错装数占比(m-1;) -完全错装数占比(m;) == -(完全错装数占比(m-2;) -完全错装数占比(m-1;))/m]
    [m >= 2]:
        [f(m)-f(m-1) == -(f(m-1)-f(m-2))/m]
        [f(m)-f(m-1) == (-1)**(m-1) *(f(1)-f(0))/m/.../2]
        [f(m)-f(m-1) == (-1)**m/m!]
        ... ...
        [f(2)-f(1) == (-1)**2/2!]
        [f(m)-f(1) == sum [(-1)**k/k! | [k:<-[2..=m]]]]
        [f(m) == sum [(-1)**k/k! | [k:<-[2..=m]]]]
        !! [e**x == sum x**k/k! {k :<- [0..]}]
        [limit f(m) {m-->+oo} == 1/e -(1 -1) = 1/e]
            # ~= 0.36787944117144233
    [limit [完全错装数占比(m) | [m :<- [0..]]] == 1/math.e]
证毕:目标三
证毕:比例夹逼定理纟完全错装数


===
]]
[[定义区:
===
重点:
枚举冫置换映射表达冖冖已排序版扌
定位冫置换映射表达巛流水号扌
变换冫索引乊流水号纟置换映射表达扌
===
===
#置换:
#加密用变换:
#一对一映射:
* 置换映射表达
    #等价类平凡冫唯我
* 置换环节表达
    等价类非平凡
* 置换环节紧凑表达
    等价类非平凡
[整数列表 :: [int]]:
    [欤整数列表是置换映射表达扌(整数列表) =[def]= let [总数:=len(整数列表)] in (all(0 <= i < 总数 for i in 整数列表) and sorted(整数列表) == [0..<总数])]
    [[整数列表::置换映射表达] =[def]= 欤整数列表是置换映射表达扌(整数列表)]
    # [置换映射表达::[新索引]]
    # [置换映射表达==旧索引讠新索引]
[整数列表列表 :: [[int]]]:
    [欤整数列表列表是置换环节表达扌(整数列表列表) =[def]= (all(整数列表列表) and 欤整数列表是置换映射表达扌(foldr (++) [] 整数列表列表))]
    [[整数列表列表::置换环节表达] =[def]= 欤整数列表列表是置换环节表达扌(整数列表列表)]
    # [置换环节表达::[置换循环小节]]
    # [置换循环小节::[索引]]
    # [置换循环小节<==>置换循环(小节[0]-->小节[1]-->小节[2]-->...-->小节[-1]-->小节[0])]
[整数列表有序对 :: ([int],[int])]:
    [欤整数列表有序对是置换环节紧凑表达扌(整数列表有序对) =[def]= let [(环节长度列表,环节合并冃置换映射表达) := 整数列表有序对] in (all(环节长度 > 0 for 环节长度 in 环节长度列表) and (sum(环节长度列表) == len(环节合并冃置换映射表达)) and 欤整数列表是置换映射表达扌(环节合并冃置换映射表达))]
    [[整数列表有序对::置换环节紧凑表达] =[def]= 欤整数列表有序对是置换环节紧凑表达扌(整数列表有序对)]
    # [置换环节紧凑表达::(环节长度列表,环节合并冃置换映射表达)]
    # [环节长度列表::[环节长度]]
    # [环节长度列表==环节号讠环节长度]
    # [环节合并冃置换映射表达::[索引]]


[置换环节紧凑表达讠置换环节表达扌 :: 置换环节紧凑表达 -> 置换环节表达]
[置换环节表达讠置换映射表达扌 :: 置换环节表达 -> 置换映射表达]
[置换映射表达讠置换环节表达扌 :: 置换映射表达 -> 置换环节表达]

===
===
#完全错装:
#不含不动点的置换:
[不动点数目巛置换映射表达扌(置换映射表达) =[def]= (sum(旧索引==新索引 for 旧索引,新索引 in enumerate(置换映射表达)))]
[错装数巛置换映射表达扌(置换映射表达) =[def]= (len(置换映射表达) -不动点数目巛置换映射表达扌(置换映射表达))]
[欤置换映射表达是完全错装扌(置换映射表达) =[def]= (not any(旧索引==新索引 for 旧索引,新索引 in enumerate(置换映射表达)))]
[欤置换环节表达是完全错装扌(置换环节表达) =[def]= (not any(1==len(置换循环小节) for 置换循环小节 in 置换环节表达))]
[欤置换环节紧凑表达是完全错装扌(置换环节紧凑表达) =[def]= (not any(1==环节长度 for 环节长度 in 置换环节紧凑表达.环节长度列表))]


[完全错装数(总数;) =[def]= len {置换映射表达 :<- permutations(range(总数)) | [欤置换映射表达是完全错装扌(置换映射表达)]}]
[部分错装数(总数;错装数) =[def]= len {置换映射表达 :<- permutations(range(总数)) | [错装数 == 错装数巛置换映射表达扌(置换映射表达)]}]
[完全错装数占比(总数) =[def]= 完全错装数(总数;)/阶乘扌(总数)]

[[not 0 <= 错装数 <= 总数] -> [0 == 部分错装数(总数;错装数)]]
    # [:等式一纟终止纟置换环节消减]:here

[0 <= 错装数 <= 总数]:
    [0 == 部分错装数(总数;错装数:=1)]
        # [:等式二纟终止纟置换环节消减]:here
    [阶乘扌(总数) == 部分错装数(总数;错装数:=0)]
        # [:等式三纟终止纟置换环节消减]:here

[完全错装数(总数;) == 部分错装数(总数;错装数:=总数)]
    # [:等式纟联系冫完全丶部分]:here
[完全错装数(0;) == 部分错装数(0;错装数:=0) == 1]
[完全错装数(1;) == 部分错装数(1;错装数:=1) == 0]
[部分错装数(总数;错装数) == 组合数扌(总数;错装数)*完全错装数(总数:=错装数;)]
    # [:等式纟联系冫部分丶完全]:here
[组合数扌(总数;2) == 部分错装数(总数;错装数:=2)]
[完全错装数(2;) == 部分错装数(2;错装数:=2) == 组合数扌(总数=2;2) == 1]
[完全错装数(0;) == 1]
[完全错装数(1;) == 0]
[完全错装数(2;) == 1]
[阶乘扌(总数) == sum [部分错装数(总数;错装数) | [错装数:<-[0..=总数]]]]
    # [:等式纟排除法]:here
    #用于:排除法:完全错装数爫排除法扌

[部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) =[def]= len {置换映射表达 :<- permutations(range(总数)) | [错装数 == 错装数巛置换映射表达扌(置换映射表达)][not any((旧索引 < 前缀长度 and 新索引 < 前缀长度) for 旧索引,新索引 in enumerate(置换映射表达))]}]


[[not 0 <= 前缀长度*2 <= 错装数 <= 总数] -> [部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 0]]
    # [:等式一纟终止纟前缀扩张]:here
[[0 <= 前缀长度*2 == 错装数 <= 总数] -> [部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 阶乘扌(前缀长度)*排列数扌(总数-前缀长度;错装数-前缀长度)]]
    # [:等式二纟终止纟前缀扩张]:here
[[0 <= 前缀长度*2 <= 错装数 <= 总数] -> [部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 排列数扌(总数-前缀长度;前缀长度)*sum [排列数扌(前缀长度;前缀回旋数)*组合数扌(前缀长度;前缀回旋数)*部分错装数牜前缀变换到后缀(新冫总数,新冫前缀长度;新冫错装数) | [前缀回旋数:<-[0..=前缀长度]][新冫总数:=总数-前缀长度-前缀回旋数][新冫前缀长度:=前缀长度-前缀回旋数][新冫错装数:=错装数-前缀长度-前缀回旋数][0 <= 新冫前缀长度*2 <= 新冫错装数 <= 新冫总数]]]]
    # [:等式纟联系冫部分灬前缀丶部分灬无印]:here
    #   [:等式纟联系冫部分灬无印丶部分灬前缀]:goto
    #   调换联系方向:命名仿照: [:等式纟联系冫部分丶完全]:goto
    #   递归退化:直至[[前缀长度==0]or[前缀长度*2 >= 错装数]]
    #
    #外层:排列数扌:于后缀中选出前缀的变换像-称为『中继』
    #内层:组合数扌:于中继中选出中继回旋部
    #内层:排列数扌:于前缀中选出中继回旋部的变换像
    #
    #仅用于:校验上一式:即特例[前缀长度*2 == 错装数]
    #由于:特例[前缀长度 == 0]等号左右两侧表达式等同，故:无用
    #
    #
    #条件简化:[[前缀回旋数:<-[0..=前缀长度]][0 <= 新冫前缀长度*2 <= 新冫错装数 <= 新冫总数]]
    #<=> [[前缀回旋数:<-[0..=前缀长度]][新冫前缀长度*2 <= 新冫错装数]]
    #<=> [[前缀回旋数:<-[0..=前缀长度]][(前缀长度-前缀回旋数)*2 <= (错装数-前缀长度-前缀回旋数)]]
    #<=> [[前缀回旋数:<-[0..=前缀长度]][前缀回旋数 >= (3*前缀长度-错装数)]]
    #<=> [前缀回旋数:<-[max(0, 3*前缀长度-错装数)..=前缀长度]]

# 完全错装数 <-- 部分错装数 <-- 部分错装数牜前缀变换到后缀
[部分错装数(总数;错装数) == 部分错装数牜前缀变换到后缀(总数,前缀长度:=0;错装数)]
    # [:等式纟联系冫部分灬无印丶部分灬前缀]:here

#部分错装数牜前缀变换到后缀:前缀长度 <-- (总数-1)or(前缀长度+1)or(总数-2,前缀长度-1;错装数-2)or(总数-1;错装数-1)
[部分错装数牜前缀变换到后缀(总数,前缀长度;错装数) == 部分错装数牜前缀变换到后缀(总数-1,前缀长度;错装数) + 部分错装数牜前缀变换到后缀(总数,前缀长度+1;错装数) + 组合数扌(前缀长度;1)*部分错装数牜前缀变换到后缀(总数-2,前缀长度-1;错装数-2) + 2*组合数扌(前缀长度;1)*部分错装数牜前缀变换到后缀(总数-1,前缀长度;错装数-1)]
    # [:等式纟步进纟前缀扩张:试改用:等式纟步进纟隔离索引零]:here
    #因为:目标是用于:枚举冫置换映射表达冖冖已排序版扌
    #所以:次第步进，不乱序
    :试图扩张前缀到 后缀首索引，根据 变换出入方向，将遇到以下六种情形:
    * [后缀首索引 是 不动点]:
        [后缀首索引 <--> 后缀首索引]
        => (总数-1)
    * [后缀首索引 是 正向接力点]:
        [出口纟更前线段甲 --> 后缀首索引 --> 更后]
        => [后缀首索引 合并到 更前线段甲]
        => (总数-1,错装数-1)
    * [后缀首索引 是 反向接力点]:
        [入口纟更前线段甲 <-- 后缀首索引 <-- 更后]
        => [后缀首索引 合并到 更前线段甲]
        => (总数-1,错装数-1)
    * [后缀首索引 是 前缀扩张点]:
        [后缀首索引 <--> 更后]
        => (前缀长度+1)
    * [后缀首索引 是 开环回旋点]:
        [(出口纟更前线段甲,入口纟更前线段乙) <--> 后缀首索引][更前线段甲=!=更前线段乙]
        => [后缀首索引 合并暨连结 (更前线段甲,更前线段乙)]
        => (总数-2,前缀长度-1,错装数-2)
    * [后缀首索引 是 闭环回旋点]:
        [(出口纟更前线段甲,入口纟更前线段甲) <--> 后缀首索引]
        => [后缀首索引 合并到 (更前线段甲)，使之成环]
        => (总数-2,前缀长度-1,错装数-2)
    #用于:完全错装数爫置换映射表达扌

[部分错装数(总数;错装数) == if (not 0 <= 错装数 <= 总数) then 0 elif 错装数==0 then 阶乘扌(总数) else sum [排列数扌(总数-1;环节长度纟索引零-1)*部分错装数(总数-环节长度纟索引零;错装数-环节长度纟索引零) | [环节长度纟索引零:<- [2..=错装数]]]]
    # [:等式纟置换环节消减]:here
    !! [:等式一纟终止纟置换环节消减]:goto
    !! [:等式二纟终止纟置换环节消减]:goto
    !! [:等式三纟终止纟置换环节消减]:goto
    !! 置换环节表达
    => [任一索引 必属于 唯一一个 置换循环小节]
    !! 置换环节表达
    => [任一 置换循环小节 长度大于一]
    固定 索引0, 假设 其所处 置换循环小节R 长度为sz:
        置换循环小节R的可能取值范围大小为:组合数扌(总数-1;sz-1)
    #
    #用于:完全错装数爫置换环节表达扌

[完全错装数(总数;) == if 总数 < 0 then 0 elif 总数 < 2 then 1-总数 else (总数-1)*(完全错装数(总数-2;) +完全错装数(总数-1;))]
    # [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:here
    #用于:完全错装数爫隔离索引零扌
    被隔离的索引零与其余索引之间的变换出入关系:
    * [双向链接成交换环]:
        => 组合数扌(总数-1;1)*recur(总数-2)
    * [单向链接]:
        #bug:三角形变不动点:=> 排列数扌(总数-1;2)*recur(总数-2)
        * [单向链接闭环成三角形]:
        * [单向链接开环]:
        #
        !! 只与出点合并(二并一 而非 三并一)，保证不能是『大』不动点
        => 组合数扌(总数-1;1)*recur(总数-1)
    => 组合数扌(总数-1;1)*(recur(总数-2) +recur(总数-1))

===
# 枚举,定位,反定位,变换:
# 『已排序版』指『枚举输出已排序』
[蛮力枚举冫置换映射表达冖冖已排序版扌 :: 总数 -> Iter 置换映射表达{总数}]
[枚举冫置换映射表达冖冖已排序版扌 :: 总数 -> Iter 置换映射表达{总数}]
[枚举冫置换环节表达冖冖已排序版扌 :: 总数 -> Iter 置换环节表达{总数}]

# 『流水号』指『已排序枚举输出里的流水号』
[定位冫置换映射表达巛流水号扌 :: 总数 -> 流水号纟置换映射表达 -> 置换映射表达{总数,流水号纟置换映射表达}]
[定位冫置换环节表达巛流水号扌 :: 总数 -> 流水号纟置换环节表达 -> 置换环节表达{总数,流水号纟置换环节表达}]


[反定位冫置换映射表达讠流水号扌 :: 置换映射表达{总数,流水号纟置换映射表达} -> 流水号纟置换映射表达]
[反定位冫置换环节表达讠流水号扌 :: 置换环节表达{总数,流水号纟置换环节表达} -> 流水号纟置换环节表达]



[变换冫索引乊流水号纟置换映射表达扌 :: 总数 -> 流水号纟置换映射表达 -> 索引{总数} -> 索引{总数}]
[变换冫索引乊流水号纟置换环节表达扌 :: 总数 -> 流水号纟置换环节表达 -> 索引{总数} -> 索引{总数}]


[变换冫索引乊流水号纟置换映射表达扌(总数,流水号纟置换映射表达;旧索引) =[def]= 定位冫置换映射表达巛流水号扌(总数;流水号纟置换映射表达)[旧索引]]
[变换冫索引乊流水号纟置换环节表达扌(总数,流水号纟置换环节表达;旧索引) =[def]= 置换环节表达讠置换映射表达扌(定位冫置换环节表达巛流水号扌(总数;流水号纟置换环节表达))[旧索引]]

===
]]
[[具现区:
===
===
#完全错装数(总数;)
#部分错装数(总数;错装数)

#递归终点:
[完全错装数(0;) := 1]
[完全错装数(1;) := 0]
[完全错装数(2;) := 1]

[完全错装数爫排除法扌(总数;) =[def]= (阶乘扌(总数) -sum [部分错装数(总数;错装数) | [错装数:<-[0..<总数]]]) ==== (阶乘扌(总数) -sum [组合数扌(总数;错装数)*完全错装数(总数:=错装数;) | [错装数:<-[0..<总数]]])]
    # [:定义冫完全错装数爫排除法扌]:here
    !! [:等式纟联系冫完全丶部分]:goto
    !! [:等式纟联系冫部分丶完全]:goto
    !! [:等式纟排除法]:goto

[完全错装数爫置换环节表达扌(总数;) =[def]= 部分错装数(总数;错装数:=总数) ==== if 总数==0 then 1 else sum [排列数扌(总数-1;环节长度纟索引零-1)*完全错装数(总数-环节长度纟索引零;) | [环节长度纟索引零:<- [2..=总数]]]]
    # [:定义冫完全错装数爫置换环节表达扌]:here
    !! [:等式纟联系冫完全丶部分]:goto
    !! [:等式一纟终止纟置换环节消减]:goto
    !! [:等式二纟终止纟置换环节消减]:goto
    !! [:等式三纟终止纟置换环节消减]:goto
    !! [:等式纟置换环节消减]:goto


[完全错装数爫置换映射表达扌(总数;) =[def]= 部分错装数牜前缀变换到后缀(总数,前缀长度:=0;错装数:=总数)]
    # [:定义冫完全错装数爫置换映射表达扌]:here
    !! [:等式纟联系冫完全丶部分]:goto
    !! [:等式纟联系冫部分灬无印丶部分灬前缀]:goto
    !! [:等式一纟终止纟前缀扩张]:goto
    !! [:等式二纟终止纟前缀扩张]:goto
    !! [:等式纟步进纟前缀扩张:试改用:等式纟步进纟隔离索引零]:goto


[完全错装数爫隔离索引零扌(总数;) =[def]= if 总数 < 0 then 0 elif 总数 < 2 then 1-总数 else (总数-1)*(完全错装数(总数-2;) +完全错装数(总数-1;))]
    # [:定义冫完全错装数爫隔离索引零扌]:here
    !! [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:goto

===
===
]]



#]]]'''
__all__ = r'''
'''.split()#'''
__all__
from seed.math.floor_ceil import floor_log2
#from math import factorial
#import itertools #permutations
from seed.math.combination import 排列数扌, 组合数扌
from seed.math.combination import factorial,阶乘扌,置换数扌
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots

def _缓冲(d, arg, f, /):
    if not arg in d:
        r = f(arg)
        d[arg] = r
    r = d[arg]
    return r
class 魖完全错装数(ABC):
    __slots__ = ()
    #___no_slots_ok___ = True
    def __init__(sf, /):
        sf._缓存纟完全 = {} #{0:1,1:0,2:1}
        sf._缓存纟部分灬无印 = {}
        sf._缓存纟部分灬前缀 = {}
    @abstractmethod
    def 罓完全错装数扌(sf, 总数, /):
        '-> 完全错装数(总数;)'
    def 完全错装数扌(sf, 总数, /):
        '-> 完全错装数(总数;)'
        d = sf._缓存纟完全
        return _缓冲(d, 总数, sf.罓完全错装数扌)


    def 部分错装数扌(sf, 总数, 错装数, /):
        '-> 部分错装数(总数;错装数)'
        # [:等式一纟终止纟置换环节消减]:goto
        # [:等式二纟终止纟置换环节消减]:goto
        # [:等式三纟终止纟置换环节消减]:goto
        #
        if not 0 <= 错装数 <= 总数:
            return 0
        if 错装数 == 1:
            return 0
        if 错装数 == 0:
            #return 阶乘扌(总数)
            pass
        d = sf._缓存纟部分灬无印
        return _缓冲(d, (总数,错装数), lambda xy:sf.罓部分错装数扌(*xy))
    def 部分错装数牜前缀变换到后缀扌(sf, 总数, 前缀长度, 错装数, /):
        '-> 部分错装数牜前缀变换到后缀(总数,前缀长度;错装数)'
        # [:等式一纟终止纟前缀扩张]:goto
        # [:等式二纟终止纟前缀扩张]:goto
        #
        if not 0 <= 前缀长度*2 <= 错装数 <= 总数:
            return 0
        if 前缀长度*2 == 错装数:
            #return 阶乘扌(前缀长度)*排列数扌(总数-前缀长度;前缀长度)
            pass
        d = sf._缓存纟部分灬前缀
        return _缓冲(d, (总数,前缀长度,错装数), lambda xyz:sf.罓部分错装数牜前缀变换到后缀扌(*xyz))


    def 罓部分错装数扌(sf, 总数, 错装数, /):
        '-> 部分错装数(总数;错装数)'
        # [:等式纟置换环节消减]:goto
        #
        if not 0 <= 错装数 <= 总数:
            raise 000
            return 0
        if 错装数 == 1:
            raise 000
            return 0
        if 错装数 == 0:
            #raise 000
            return 阶乘扌(总数)
        def lazy_mul_():
            for 环节长度纟索引零 in range(2, 1+错装数):
                n = sf.部分错装数扌(总数-环节长度纟索引零,错装数-环节长度纟索引零)
                if n:
                    #lazy mul:
                    yield n*排列数扌(总数-1;环节长度纟索引零-1)
        return sum(lazy_mul_())

    def 罓部分错装数牜前缀变换到后缀扌(sf, 总数, 前缀长度, 错装数, /):
        '-> 部分错装数牜前缀变换到后缀(总数,前缀长度;错装数)'
        # [:等式纟步进纟前缀扩张:试改用:等式纟步进纟隔离索引零]:goto
        #
        if not 0 <= 前缀长度*2 <= 错装数 <= 总数:
            raise 000
            return 0
        if 前缀长度*2 == 错装数:
            #raise 000
            return 阶乘扌(前缀长度)*排列数扌(总数-前缀长度;前缀长度)

        return (
        (sf.部分错装数牜前缀变换到后缀扌(总数-1,前缀长度,错装数)
        +sf.部分错装数牜前缀变换到后缀扌(总数,前缀长度+1,错装数)
        +前缀长度*sf.部分错装数牜前缀变换到后缀扌(总数-2,前缀长度-1,错装数-2)
        +2*前缀长度*sf.部分错装数牜前缀变换到后缀扌(总数-1,前缀长度,错装数-1)
        ))

    def 罓完全错装数爫排除法扌(sf, 总数, /):
        '-> 完全错装数爫排除法扌(总数;)'
        # [:定义冫完全错装数爫排除法扌]:goto
        # [:等式纟联系冫完全丶部分]:goto
        # [:等式纟联系冫部分丶完全]:goto
        # [:等式纟排除法]:goto
        return (阶乘扌(总数) -sum (组合数扌(总数,错装数)*sf.完全错装数扌(_总数:=错装数) for 错装数 in range(总数)))
            # !! 部分错装数扌(总数,错装数) 是 依照 [:等式纟置换环节消减] 计算 而非 [:等式纟排除法]
        return (阶乘扌(总数) -sum (sf.部分错装数扌(总数,错装数) for 错装数 in range(总数)))

    def 罓完全错装数爫置换环节表达扌(sf, 总数, /):
        '-> 完全错装数爫置换环节表达扌(总数;)'
        # [:定义冫完全错装数爫置换环节表达扌]:goto
        return sf.部分错装数扌(总数,错装数:=总数)
        if 总数 == 0:
            return 1
        return sum(排列数扌(总数-1,环节长度纟索引零-1)*sf.完全错装数扌(总数-环节长度纟索引零) for 环节长度纟索引零 in range(2, 1+总数))

    def 罓完全错装数爫置换映射表达扌(sf, 总数, /):
        '-> 完全错装数爫置换映射表达扌(总数;)'
        # [:定义冫完全错装数爫置换映射表达扌]:goto
        return sf.部分错装数牜前缀变换到后缀扌(总数,前缀长度:=0,错装数:=总数)

    def 罓完全错装数爫隔离索引零扌(sf, 总数, /):
        '-> 完全错装数爫隔离索引零扌(总数;)'
        # [:定义冫完全错装数爫隔离索引零扌]:goto
        # [:等式纟步进纟隔离索引零:试取代:等式纟步进纟前缀扩张]:goto
        if 总数 < 0:
            return 0
        if 总数 < 2:
            return 1-总数
        return (总数-1)*(sf.完全错装数扌(总数-2) +sf.完全错装数扌(总数-1))

class 魖完全错装数牜枚举(魖完全错装数):
    __slots__ = ()
    #蛮力枚举冫置换映射表达冖冖已排序版扌 # 效率为(0.3~0.4)
    #枚举冫置换映射表达冖冖已排序版扌
    #枚举冫置换映射表达爫隔离索引零冖冖已排序版扌
    #枚举冫置换环节表达冖冖已排序版扌
class 魖完全错装数牜定位(魖完全错装数):
    __slots__ = ()
    #定位冫置换映射表达巛流水号扌
    #定位冫置换环节表达巛流水号扌
class 魖完全错装数牜反定位(魖完全错装数):
    __slots__ = ()
    #反定位冫置换映射表达讠流水号扌
    #反定位冫置换环节表达讠流水号扌
class 魖完全错装数牜变换(魖完全错装数):
    __slots__ = ()
    #变换冫索引乊流水号纟置换映射表达扌
    #变换冫索引乊流水号纟置换环节表达扌


__all__
from script.完全错装数 import *
