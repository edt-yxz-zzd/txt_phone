#__all__:goto
r'''[[[
e script/码距.py

感觉算法有毛病:老是出现重复的总数:顺序检测选择下一个数果然太简单？
    +自然数次序丷比特数次序
    [f(16;3)==2048==f(15;3)]
        但是 根据 估计冫上限纟纠错能力扌/估计冫上限纟纠错能力牜码长范围牜各有效位扌:
            (16, (9, 11), (1, 3))
            (15, (9, 11), (1, 3))
            『2048』已是『限定二幂(有效位数)』情形下的最佳结果
    [f(9;5,自然数次序)==4 < 6==f(9;5,比特数次序)]
        『6』不是『二幂』！！！
        (9, (2, 3), (2, 5))
        『2**3==8』是『限定二幂(有效位数)』情形下的估值
        也许存在码距至少为5而编码总数不少于8的编码方案

...???不可约域上多项式???

限定最小码距牜二进制定长编码扌

f(3;2) --> {000,011,101,110}


script.码距
py -m nn_ns.app.debug_cmd   script.码距 -x
py -m nn_ns.app.doctest_cmd script.码距:__doc__ -ht
from script.码距 import *


py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数    =3  =2
'000'
'011'
'101'
'110'
total: 4

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数    =8  =3
'00000000'
'00000111'
'00011001'
'00011110'
'00101010'
'00101101'
'00110011'
'00110100'
'01001011'
'01001100'
'01010010'
'01010101'
'01100001'
'01100110'
'01111000'
'01111111'
total: 16
:xxx:py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数  +欤最多紧致优先   =8  =3

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数    =3  =3
'000'
'111'
total: 2

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(3,11)'  '=[3]'
(3, 3)
'000'
'111'
total: 2
(4, 3)
'0000'
'0111'
total: 2
(5, 3)
'00000'
'00111'
'11001'
'11110'
total: 4
(6, 3)
'000000'
'000111'
'011001'
'011110'
'101010'
'101101'
'110011'
'110100'
total: 8
(7, 3)
'0000000'
'0000111'
'0011001'
'0011110'
'0101010'
'0101101'
'0110011'
'0110100'
'1001011'
'1001100'
'1010010'
'1010101'
'1100001'
'1100110'
'1111000'
'1111111'
total: 16
(8, 3)
'00000000'
'00000111'
'00011001'
'00011110'
'00101010'
'00101101'
'00110011'
'00110100'
'01001011'
'01001100'
'01010010'
'01010101'
'01100001'
'01100110'
'01111000'
'01111111'
total: 16
(9, 3)
'000000000'
'000000111'
'000011001'
'000011110'
'000101010'
'000101101'
'000110011'
'000110100'
'001001011'
'001001100'
'001010010'
'001010101'
'001100001'
'001100110'
'001111000'
'001111111'
'110000001'
'110000110'
'110011000'
'110011111'
'110101011'
'110101100'
'110110010'
'110110101'
'111001010'
'111001101'
'111010011'
'111010100'
'111100000'
'111100111'
'111111001'
'111111110'
total: 32
(10, 3)
'0000000000'
'0000000111'
'0000011001'
'0000011110'
'0000101010'
'0000101101'
'0000110011'
'0000110100'
'0001001011'
'0001001100'
'0001010010'
'0001010101'
'0001100001'
'0001100110'
'0001111000'
'0001111111'
'0110000001'
'0110000110'
'0110011000'
'0110011111'
'0110101011'
'0110101100'
'0110110010'
'0110110101'
'0111001010'
'0111001101'
'0111010011'
'0111010100'
'0111100000'
'0111100111'
'0111111001'
'0111111110'
'1010000010'
'1010000101'
'1010011011'
'1010011100'
'1010101000'
'1010101111'
'1010110001'
'1010110110'
'1011001001'
'1011001110'
'1011010000'
'1011010111'
'1011100011'
'1011100100'
'1011111010'
'1011111101'
'1100000011'
'1100000100'
'1100011010'
'1100011101'
'1100101001'
'1100101110'
'1100110000'
'1100110111'
'1101001000'
'1101001111'
'1101010001'
'1101010110'
'1101100010'
'1101100101'
'1101111011'
'1101111100'
total: 64

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(5,15)'  '=[5]'
(5, 5)
'00000'
'11111'
total: 2
(6, 5)
'000000'
'011111'
total: 2
(7, 5)
'0000000'
'0011111'
total: 2
(8, 5)
'00000000'
'00011111'
'11100011'
'11111100'
total: 4
(9, 5)
'000000000'
'000011111'
'011100011'
'011111100'
total: 4
(10, 5)
'0000000000'
'0000011111'
'0011100011'
'0011111100'
'1100100101'
'1100111010'
'1111000110'
'1111011001'
total: 8
(11, 5)
'00000000000'
'00000011111'
'00011100011'
'00011111100'
'01100100101'
'01100111010'
'01111000110'
'01111011001'
'10101001010'
'10101010101'
'10110101001'
'10110110110'
'11001101111'
'11001110000'
'11010001100'
'11010010011'
total: 16
(12, 5)
'000000000000'
'000000011111'
'000011100011'
'000011111100'
'001100100101'
'001100111010'
'001111000110'
'001111011001'
'010101001010'
'010101010101'
'010110101001'
'010110110110'
'011001101111'
'011001110000'
'011010001100'
'011010010011'
total: 16
(13, 5)
'0000000000000'
'0000000011111'
'0000011100011'
'0000011111100'
'0001100100101'
'0001100111010'
'0001111000110'
'0001111011001'
'0010101001010'
'0010101010101'
'0010110101001'
'0010110110110'
'0011001101111'
'0011001110000'
'0011010001100'
'0011010010011'
'1100000100110'
'1100000111001'
'1100011000101'
'1100011011010'
'1101100000011'
'1101100011100'
'1101111100000'
'1101111111111'
'1110101101100'
'1110101110011'
'1110110001111'
'1110110010000'
'1111001001001'
'1111001010110'
'1111010101010'
'1111010110101'
total: 32
(14, 5)
'00000000000000'
'00000000011111'
'00000011100011'
'00000011111100'
'00001100100101'
'00001100111010'
'00001111000110'
'00001111011001'
'00010101001010'
'00010101010101'
'00010110101001'
'00010110110110'
'00011001101111'
'00011001110000'
'00011010001100'
'00011010010011'
'01100000100110'
'01100000111001'
'01100011000101'
'01100011011010'
'01101100000011'
'01101100011100'
'01101111100000'
'01101111111111'
'01110101101100'
'01110101110011'
'01110110001111'
'01110110010000'
'01111001001001'
'01111001010110'
'01111010101010'
'01111010110101'
'10100001001011'
'10100001010100'
'10100010101000'
'10100010110111'
'10101101101110'
'10101101110001'
'10101110001101'
'10101110010010'
'10110100000001'
'10110100011110'
'10110111100010'
'10110111111101'
'10111000100100'
'10111000111011'
'10111011000111'
'10111011011000'
'11000001101101'
'11000001110010'
'11000010001110'
'11000010010001'
'11001101001000'
'11001101010111'
'11001110101011'
'11001110110100'
'11010100100111'
'11010100111000'
'11010111000100'
'11010111011011'
'11011000000010'
'11011000011101'
'11011011100001'
'11011011111110'
total: 64







py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(3,17)'  '=[3]' +欤隐藏冫数据
(3, 3)
total: 2
(4, 3)
total: 2
(5, 3)
total: 4
(6, 3)
total: 8
(7, 3)
total: 16
(8, 3)
total: 16
(9, 3)
total: 32
(10, 3)
total: 64
(11, 3)
total: 128
(12, 3)
total: 256
(13, 3)
total: 512
(14, 3)
total: 1024
(15, 3)
total: 2048
(16, 3)
total: 2048

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(5,18)'  '=[5]' +欤隐藏冫数据
(5, 5)
total: 2
(6, 5)
total: 2
(7, 5)
total: 2
(8, 5)
total: 4
(9, 5)
total: 4
(10, 5)
total: 8
(11, 5)
total: 16
(12, 5)
total: 16
(13, 5)
total: 32
(14, 5)
total: 64
(15, 5)
total: 128
(16, 5)
total: 256
(17, 5)
total: 512





py_adhoc_call   script.码距   ,枚举冫二幂牜比特数次序扌 =3
0
1
2
4
3
5
6
7




py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(3,17)'  '=[3]' +欤隐藏冫数据 +自然数次序丷比特数次序
(3, 3)
total: 2
(4, 3)
total: 2
(5, 3)
total: 4
(6, 3)
total: 8
(7, 3)
total: 16
(8, 3)
total: 16
(9, 3)
total: 32
(10, 3)
total: 64
(11, 3)
total: 128
(12, 3)
total: 256
(13, 3)
total: 512
(14, 3)
total: 1024
(15, 3)
total: 2048
(16, 3)
total: 2048

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(5,18)'  '=[5]' +欤隐藏冫数据 +自然数次序丷比特数次序
(5, 5)
total: 2
(6, 5)
total: 2
(7, 5)
total: 2
(8, 5)
total: 4
(9, 5)
total: 6
(10, 5)
total: 12
(11, 5)
total: 12
(12, 5)
total: 25
(13, 5)
total: 33
(14, 5)
total: 54
(15, 5)
total: 97
(16, 5)
total: 164
(17, 5)
total: 277

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数  '=7'  '=5' +欤隐藏冫数据 +欤最多紧致优先
total: 2
py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数  '=8'  '=5' +欤隐藏冫数据 +欤最多紧致优先
total: 4
py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数  '=9'  '=5'  +欤最多紧致优先
'000000000'
'000011111'
'011100011'
'011111100'
total: 4
py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数  '=9'  '=5'  +自然数次序丷比特数次序
'000000000'
'000011111'
'011100011'
'101101100'
'110110101'
'111011010'
total: 6
py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码扌 +欤打印冫总数  '=9'  '=5'  -自然数次序丷比特数次序
'000000000'
'000011111'
'011100011'
'011111100'
total: 4


py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(2,12)'  '=[2]' +欤隐藏冫数据
    同下:『+自然数次序丷比特数次序』
py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(2,12)'  '=[2]' +欤隐藏冫数据 +自然数次序丷比特数次序
(2, 2)
total: 2
(3, 2)
total: 4
(4, 2)
total: 8
(5, 2)
total: 16
(6, 2)
total: 32
(7, 2)
total: 64
(8, 2)
total: 128
(9, 2)
total: 256
(10, 2)
total: 512
(11, 2)
total: 1024

py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(4,12)'  '=[4]' +欤隐藏冫数据
    同下:『+自然数次序丷比特数次序』
py_adhoc_call   script.码距   ,限定最小码距牜二进制定长编码牜范围扌 +欤打印冫总数  '=range(4,12)'  '=[4]' +欤隐藏冫数据 +自然数次序丷比特数次序
(4, 4)
total: 2
(5, 4)
total: 2
(6, 4)
total: 4
(7, 4)
total: 8
(8, 4)
total: 16
(9, 4)
total: 16
(10, 4)
total: 32
(11, 4)
total: 64




估计冫上限纟纠错能力扌(有效位数,冗余位数)
py_adhoc_call   script.码距   @估计冫上限纟纠错能力扌  =8 =2
2
py_adhoc_call   script.码距   @估计冫上限纟纠错能力扌  =8 =4 +欤拓展输出冫下限纟最小码距
(1, 3)
py_adhoc_call   script.码距   @估计冫上限纟纠错能力扌  =8 =5 +欤拓展输出冫下限纟最小码距
(0, 1)

py_adhoc_call   script.码距   ,估计冫上限纟纠错能力牜各有效位扌  =8
((1, 1), (3, 7))
((2, 2), (2, 5))
((3, 4), (1, 3))
((5, 7), (0, 1))
py_adhoc_call   script.码距   ,估计冫上限纟纠错能力牜各有效位扌  =2
((1, 1), (0, 1))

py_adhoc_call   script.码距   ,估计冫上限纟纠错能力牜码长范围牜各有效位扌  '=range(2,18)'
(2, (1, 1), (0, 1))
(3, (1, 1), (1, 3))
(3, (2, 2), (0, 1))
(4, (1, 1), (1, 3))
(4, (2, 3), (0, 1))
(5, (1, 1), (2, 5))
(5, (2, 2), (1, 3))
(5, (3, 4), (0, 1))
(6, (1, 1), (2, 5))
(6, (2, 3), (1, 3))
(6, (4, 5), (0, 1))
(7, (1, 1), (3, 7))
(7, (2, 2), (2, 5))
(7, (3, 4), (1, 3))
(7, (5, 6), (0, 1))
(8, (1, 1), (3, 7))
(8, (2, 2), (2, 5))
(8, (3, 4), (1, 3))
(8, (5, 7), (0, 1))
(9, (1, 1), (4, 9))
(9, (2, 3), (2, 5))
(9, (4, 5), (1, 3))
(9, (6, 8), (0, 1))
(10, (1, 1), (4, 9))
(10, (2, 2), (3, 7))
(10, (3, 4), (2, 5))
(10, (5, 6), (1, 3))
(10, (7, 9), (0, 1))
(11, (1, 1), (5, 11))
(11, (2, 3), (3, 7))
(11, (4, 4), (2, 5))
(11, (5, 7), (1, 3))
(11, (8, 10), (0, 1))
(12, (1, 1), (5, 11))
(12, (2, 2), (4, 9))
(12, (3, 3), (3, 7))
(12, (4, 5), (2, 5))
(12, (6, 8), (1, 3))
(12, (9, 11), (0, 1))
(13, (1, 1), (6, 13))
(13, (2, 2), (4, 9))
(13, (3, 4), (3, 7))
(13, (5, 6), (2, 5))
(13, (7, 9), (1, 3))
(13, (10, 12), (0, 1))
(14, (1, 1), (6, 13))
(14, (2, 2), (5, 11))
(14, (3, 3), (4, 9))
(14, (4, 5), (3, 7))
(14, (6, 7), (2, 5))
(14, (8, 10), (1, 3))
(14, (11, 13), (0, 1))
(15, (1, 1), (7, 15))
(15, (2, 2), (5, 11))
(15, (3, 4), (4, 9))
(15, (5, 5), (3, 7))
(15, (6, 8), (2, 5))
(15, (9, 11), (1, 3))
(15, (12, 14), (0, 1))
(16, (1, 1), (7, 15))
(16, (2, 2), (6, 13))
(16, (3, 3), (5, 11))
(16, (4, 4), (4, 9))
(16, (5, 6), (3, 7))
(16, (7, 8), (2, 5))
(16, (9, 11), (1, 3))
(16, (12, 15), (0, 1))
(17, (1, 1), (8, 17))
(17, (2, 2), (6, 13))
(17, (3, 3), (5, 11))
(17, (4, 5), (4, 9))
(17, (6, 7), (3, 7))
(17, (8, 9), (2, 5))
(17, (10, 12), (1, 3))
(17, (13, 16), (0, 1))

[限定最小码距牜二进制定长编码扌(16;3)==2048==限定最小码距牜二进制定长编码扌(15;3)]
(16, (9, 11), (1, 3))
(15, (9, 11), (1, 3))
py_adhoc_call   script.码距   @估计冫上限纟纠错能力扌 +欤拓展输出冫下限纟最小码距  =16 =11
(1, 3)
py_adhoc_call   script.码距   @估计冫上限纟纠错能力扌 +欤拓展输出冫下限纟最小码距  =16 =12
(0, 1)



#]]]'''
__all__ = r'''
'''.split()#'''
__all__


from math import comb#, factorial, perm, prod
from itertools import combinations
if 0b01:
    from seed.types.BitList import BitList

def 估计冫上限纟纠错能力牜码长范围牜各有效位扌(范围冫码长, **kwds):
    '-> Iter (码长, (下确界冫有效位数,上确界冫有效位数), (上限纟纠错位数, 下限纟最小码距))'
    for 码长 in 范围冫码长:
        for ((下确界冫有效位数,上确界冫有效位数), (上限纟纠错位数, 下限纟最小码距)) in 估计冫上限纟纠错能力牜各有效位扌(码长, **kwds):
            yield (码长, (下确界冫有效位数,上确界冫有效位数), (上限纟纠错位数, 下限纟最小码距))
    return
def 估计冫上限纟纠错能力牜各有效位扌(码长, **kwds):
    '-> Iter ((下确界冫有效位数,上确界冫有效位数), (上限纟纠错位数, 下限纟最小码距))'
    for 有效位数 in range(1, 码长):
        r = 估计冫上限纟纠错能力扌(码长, 有效位数, 欤拓展输出冫下限纟最小码距=True, **kwds)
        if 有效位数 == 1:
            #init
            pass
        elif r == prev_r:
            #same
            continue
        else:
            #diff
            yield ((prev_n,有效位数-1), prev_r)
        #######
        if not r[0]:
            yield ((有效位数,码长-1), r)
            break
        prev_r = r
        prev_n = 有效位数
    return
#def 估计冫上限纟纠错能力扌(码长, 有效位数,冗余位数):
def 估计冫上限纟纠错能力扌(码长, 有效位数, *, 欤拓展输出冫下限纟最小码距=False):
    '-> 上限纟纠错位数 if not 欤拓展输出冫下限纟最小码距 else (上限纟纠错位数, 下限纟最小码距) #上限/下限:非确界'
    冗余位数 = 码长 -有效位数
    #码长 = 有效位数+冗余位数
    assert 1 <= 有效位数 < 码长
    assert 1 <= 冗余位数 < 码长
    assert 2 <= 有效位数+冗余位数 <= 码长
    #最小码距 = 2*纠错位数+1
    上限纟领地每码 = (1 << 冗余位数)
    累计值纟领地每码 = 0
    for 错码位数 in range(冗余位数+1):
        囗领地每码 = 累计值纟领地每码 + comb(码长,错码位数)
        #if 0b001:print('囗领地每码:', 囗领地每码, '; 上限纟领地每码:', 上限纟领地每码)
        if not 囗领地每码 <= 上限纟领地每码:
            上限纟纠错位数 = 错码位数-1
            错码位数 = None
            break
        累计值纟领地每码 = 囗领地每码
    else:
        raise 000
    上限纟纠错位数
    下限纟最小码距 = 2*上限纟纠错位数+1

    assert 0 <= 上限纟纠错位数 <= 冗余位数//2
    领地每码 = sum(comb(码长,错码位数) for 错码位数 in range(上限纟纠错位数+1))
    #assert (领地每码 << 有效位数) <= (1 << 码长)
    assert 领地每码 <= 上限纟领地每码
        #各码领地不相交
    if 欤拓展输出冫下限纟最小码距:
        return (上限纟纠错位数, 下限纟最小码距)
    return 上限纟纠错位数
def 限定最小码距牜二进制定长编码牜范围扌(范围冫码长, 范围冫最小码距, **kwds):
    for 码长 in 范围冫码长:
        for 最小码距 in 范围冫最小码距:
            yield (码长, 最小码距)
            yield from 限定最小码距牜二进制定长编码扌(码长, 最小码距, **kwds)

def 枚举冫二幂牜比特数次序扌(码长):
    L = 码长
    whole_ks = range(L)
    bs = BitList('0')*L
    offset = 1 << L
    L1 = L-1
    for n in range(L+1):
        for ks in combinations(whole_ks, n):
            ks = [L1-k for k in ks]
            bs.flip_01s__at__emplace(ks)
            try:
                yield bs.to_payload_pint() -offset
            finally:
                bs.flip_01s__at__emplace(ks)
    return
#def 限定最小码距牜二进制定长编码扌(码长, 最小码距, *, 欤打印冫总数=False, 欤最多紧致优先=False):
def 限定最小码距牜二进制定长编码扌(码长, 最小码距, *, 欤打印冫总数=False, 欤隐藏冫数据=False, 自然数次序丷比特数次序=False, 欤最多紧致优先=False):
    if 0b00:
        欤最多紧致优先=False
        assert not 欤最多紧致优先
    assert 码长 < 20
    assert 1 <= 最小码距 <= 码长
    if 0b00:
        sz = 1 << 码长
        j2set = BitList('0')*sz

    if 0b00:
        offset = 1 << 码长
        us = set()
            # :: {payload_pint}
            #   [payload_pint =[def]= offset+j]
        for payload_pint in range(offset, 2*offset):
            assert not payload_pint in us
    offset = 1 << 码长
    js4ok = []
    fmt = f'{{:0>{码长}b}}'
    #max_same = 码长 -最小码距
    def on_ok(j, /):
        js4ok.append(j)
        if not 欤隐藏冫数据:
            yield fmt.format(j)
        return
    def 求冫码距扌(i, j, /):
        return (i ^ j).bit_count()
    ######################
    if not 欤最多紧致优先:
      it = range(offset) if not 自然数次序丷比特数次序 else 枚举冫二幂牜比特数次序扌(码长)

      for i in it:
        #assert not i in js4ok
        for j in js4ok:
            码距 = 求冫码距扌(i, j)
            if 码距 < 最小码距:
                #bad
                break
        else:
            #ok
            yield from on_ok(i)
    ######################
    else:
      # +欤最多紧致优先
      # > O(码数*(2**码长)**2)
      assert 码长 < 11
      #from seed.data_funcs.rngs import make_Ranges
      #js4remain = make_Ranges([(0,offset)])
      #from seed.types.linked_list import DoublyLinkedList
      #iter_js4remain = iter(range(offset))
      #saved_js4remain = DoublyLinkedList()
      #hd, ed = saved_js4remain.head_and_end_xnode_pair
      #ptr = hd
      js4remain = [*range(offset)[::-1]]
      i2d2count = [[0]*(码长+1) for _ in range(offset)]
        # i 与 当前js4ok的码距统计表
      def update_js4remain(js4remain, new_j4ok):
        for i in js4remain:
            if i == new_j4ok:
                i2d2count[i] = None
                continue
            码距 = 求冫码距扌(i, new_j4ok)
            assert 码距 > 0
            #if 0b001:print('i,new_j4ok,diff:', i,new_j4ok,码距)
            if 码距 < 最小码距:
                #bad
                i2d2count[i] = None
            else:
                i2d2count[i][码距] += 1
        new_js4remain = [i for i in js4remain if not i2d2count[i] is None]
        return new_js4remain
      def key5ki(ki):
          i = js4remain[ki]
          return key5i(i)
      def key5i(i):
          return (i2d2count[i], -i)
      while js4remain:
        #if 0b001:print('js4remain:', js4remain)
        #if 0b001:print('i2d2count:', i2d2count)
        #kj = max(range(len(js4remain)), key=key5ki)
        #new_j4ok = js4remain[kj]
        #del js4remain[kj]
        #if 0b001:print('kj,new_j4ok:', kj,new_j4ok)
        new_j4ok = max(js4remain, key=key5i)
        #if 0b001:print('new_j4ok:', new_j4ok)
        #if 0b001:print('js4remain:', js4remain)
        js4remain = update_js4remain(js4remain, new_j4ok)
        yield from on_ok(new_j4ok)

    #######old:
    if 0 and 欤最多紧致优先:
      # +欤最多紧致优先
      raise Exception('逻辑出错:不可能均分@[最小码距<-奇数]:eg:(码长=8,最小码距=3)')
      js4bad = []
      max_count = comb(码长,最小码距)
      j2num_remain_neighbors = {}
        # [1 <= num_remain_neighbors <= max_count]
      ls = []; it = iter(range(offset))
      save = []
        # ls: descending order
        # it: ascending order
        # save: ascending order
        # [whole_it =[def]= save ++ ls[::-1] ++ it]
      while 1:
        if ls:
            i = ls.pop()
        else:
            for i in it:
                break
            else:
                break
            i
        i
        if 0b001:print('i:', i)
        acc = 0
        expected_acc = len(j2num_remain_neighbors)
        bad = False
        js8neighbors4i = []
        for j in js4ok:
            码距 = 求冫码距扌(i, j)
            if 0b001:print('i,j,diff:', i,j,码距)
            if 码距 < 最小码距:
                #bad
                bad = True
            ###########
            if 码距 == 最小码距:
                acc += 1
                js8neighbors4i.append(j)
        if 0b001:print('i,acc,js8neighbors4i:', i,acc,js8neighbors4i)
        if bad or acc == expected_acc:
            #bad or ok
            #   <==> not save...
            for j in js8neighbors4i:
                if 0b001:print(i, j, j2num_remain_neighbors)
                if j2num_remain_neighbors[j] == 1:
                    del j2num_remain_neighbors[j]
                else:
                    j2num_remain_neighbors[j] -= 1
        if bad:
            if 0b001:print('bad:', i)
            js4bad.append(i)
            #discard i
        else:
            #not bad
            if acc == expected_acc:
                #ok
                yield from on_ok(i)
                if not expected_acc == max_count:
                    j2num_remain_neighbors[i] = max_count -expected_acc
                save.reverse()
                ls += save
                save.clear()
            else:
                save.append(i)
      #end-while 1:
      if save:
          raise Exception(i, save)
      if j2num_remain_neighbors:
          raise Exception(i, j2num_remain_neighbors)
    ######################
    ######################
    ######################
    if 欤打印冫总数:
        print('total:', len(js4ok))
    return

__all__
from script.码距 import *
