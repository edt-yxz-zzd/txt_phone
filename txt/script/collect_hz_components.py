r'''[[[[[
TODO:
    列出 hz.name not startswith 'CJK UNIFIED IDEOGRAPH-'
        找到对应汉字，替换之。
        findout_and_replace_non_UNIFIED_hz

    列出 最高频 的 部件，不必考虑拆分与否，就像 压缩算法/中文形码输入法，只考察 ref_count大小。
see:
    view ../../python3_src/nn_ns/CJK/cjk_subsets/共享汉字集字形拆分树.py
        考察小字符集，再拓展到大字符集，python实在太慢。

py script/collect_hz_components.py
e script/collect_hz_components.py
view ../../python3_src/nn_ns/CJK/CJK_struct/CHISE_IDS_67b94ff_20191211/basic_decomp.txt
[[
=====
py script/collect_hz_components.py  预处理囗深入替换类型为汉字的树叶
len(outside_refs___BMP_only) = 338
len(outside_hzs___BMP_only) = 340
len(bypassed_hzs___BMP_only) = 505
len(replaced_hzs___BMP_only) = 2173

=====
py script/collect_hz_components.py  预处理囗深入替换类型为汉字的树叶囗一致使用统一区汉字 --non_UNIFIED_hz2UNIFIED_hz '⻤鬼⻌辶'
missed_non_UNIFIED_hz_set = {'⺳', 'タ', '具', '⺢', ' ⻖', '⺗', '直', '⺯', '刃', '⺜', '⺇', '⻀', '⺫', ' 𥄳', '⺃', '屮', '旣', '⺲', '⻏', '灰', '⺈', '⺊', ' 冗', '⺼', '⺧', '⻢', '穀', '⺣', '⺄', '⺆', '充', ' ⺪', '叟', '者', '⻞', '⺶', '⻃', '⺌'}
replaced_non_UNIFIED_hz_set = {'⻤', '⻌'}
len(missed_non_UNIFIED_hz_set) = 38
len(replaced_non_UNIFIED_hz_set) = 2

===
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__CJKRadicals_txt__of_ver13_0.py
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__CJKRadicals_txt.py.out.ver13_0.txt
"{'⺳', 'タ', '具', '⺢', ' ⻖', '⺗', '直', '⺯', '刃', '⺜', '⺇', '⻀', '⺫', ' 𥄳', '⺃', '屮', '旣', '⺲', '⻏', '灰', '⺈', '⺊', ' 冗', '⺼', '⺧', '⻢', '穀', '⺣', '⺄', '⺆', '充', ' ⺪', '叟', '者', '⻞', '⺶', '⻃', '⺌'}"

=====
py script/collect_hz_components.py  辅助估算被引用次数的阈值 -o /sdcard/0my_files/tmp/out4py/collect_hz_components.py.辅助估算被引用次数的阈值.out.u8
view /sdcard/0my_files/tmp/out4py/collect_hz_components.py.辅助估算被引用次数的阈值.out.u8

=====
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 300
28
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 200
34
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 1
1013
    #correct! [..., (1012, 1), (1031, 1)]


=====
py script/collect_hz_components.py  拓扑排序 -o /sdcard/0my_files/tmp/out4py/collect_hz_components.py.拓扑排序.out.u8
view /sdcard/0my_files/tmp/out4py/collect_hz_components.py.拓扑排序.out.u8

=====
py script/collect_hz_components.py  汉字分解成字根囗字根反向索引汉字 --threshold4ref_count 2 --single_stroke_hzs '一丨丿丶乀乁乙乚乛亅' --non_float_components '("hz","丶")'   -o /sdcard/0my_files/tmp/out4py/collect_hz_components.py.汉字分解成字根囗字根反向索引汉字.阈值2.out.u8
view /sdcard/0my_files/tmp/out4py/collect_hz_components.py.汉字分解成字根囗字根反向索引汉字.阈值2.out.u8

=====
py script/collect_hz_components.py 辅助人工定义哪些部件是字根  --imay_max_sz4hzs 30   -o /sdcard/0my_files/tmp/out4py/collect_hz_components.py.辅助人工定义哪些部件是字根.30.out.u8
view /sdcard/0my_files/tmp/out4py/collect_hz_components.py.辅助人工定义哪些部件是字根.30.out.u8

=====
]]

[[[
尽量少拆

===
[[
拆字:
  拆否？
    天，矢/知，广，之，鬼...
    呆果男
    ===
    点 视为 附加物
      其他单笔，如果接触其他部件，也视为 附加物，不拆出
      土士王玉主义互母舟
    部件 并非 稳定，一个 代表 多个，不断精细化归类
      月:月，青字底，肉月
      日:日，子曰，冒头
      火:火，火左旁，火底，四点水，
      木:木，木左旁，木底(带钩？)
      耳:耳，戢，左立耳，右立耳，取，最，聽
    不同地区，字形不同，部件不同
    字形有特别约束的，不拆:
      二三土士未末曰冃日
    字形排版复杂的，不拆:
      兔鬼包
  命名:
    例子减去其余部分:
      打丁==>>提手
    近似叠加+所在例子:
      口木刺==>>朿 #不是『束/呆/杏』
]]
===

view ../../python3_src/nn_ns/CJK/CJK_struct/CHISE_IDS_67b94ff_20191211/basic_decomp.txt
  generated by:
    view ../../python3_src/nn_ns/CJK/CJK_struct/CHISE_IDS_67b94ff_20191211/parse_CHISE_IDS.py
每个tree建立反向索引:
  Map tree (Set ((idx, tree)|(0,hz)))
  一tree多字形
下面 部件=tree，身兼多个字形，并非正常意义上的部件
截止:
  * 交叠类 不拆
  * 当有一直接子部件是单笔部件时，不拆
  * 其余 人工检查
  ===
  拓扑排序
  计数被引用次数-->阈值
  ===
    定义 可拆出部件(float_component)
        = 『被引用次数超过阈值』并且不是『单笔部件』并且不是『用户显式指定的不可拆出部件』的部件
        | 所有直接子部件都是『可拆出部件』的部件
  ===
    定义 可拆开部件(derived_component)
        = [op不为 交叠 的 拆分序列tree] 并且 所有直接子部件都是『可拆出部件』并且不是『用户显式指定的不可拆开部件』的部件

e script/collect_hz_components.py


op2alias__str = r'⿰川⿱三⿲川⿳三⿴回⿵冈⿶凶⿷区⿸右⿹可⿺旭⿻井'
    事实上，左右结构，上下结构，不只2/3部件
    进赵勉

不一致:
    右:('⿸', (('hz', '𠂇'), ('hz', '口')))
    有:('⿱', (('hz', '𠂇'), ('hz', '月')))
    同时使用:『辶』『⻌』『鬼』『⻤』
    py_eval --turnoff_eval --postprocess ord hex -i 辶 ⻌ 鬼 ⻤
        '0x8fb6'
        '0x2ecc'
        '0x9b3c'
        '0x2ee4'
    py_eval --startup 'import unicodedata as U' --turnoff_eval --postprocess U.name -i 辶 ⻌ 鬼 ⻤
        'CJK UNIFIED IDEOGRAPH-8FB6'
        'CJK RADICAL SIMPLIFIED WALK'
        'CJK UNIFIED IDEOGRAPH-9B3C'
        'CJK RADICAL GHOST'

    view /sdcard/0my_files/unzip/e_book/unicode_13__UCD/CJKRadicals.txt

    missed_non_UNIFIED_hz_set = {'⺳', 'タ', '具', '⺢', ' ⻖', '⺗', '直', '⺯', '刃', '⺜', '⺇', '⻀', '⺫', ' 𥄳', '⺃', '屮', '旣', '⺲', '⻏', '灰', '⺈', '⺊', ' 冗', '⺼', '⺧', '⻢', '穀', '⺣', '⺄', '⺆', '充', ' ⺪', '叟', '者', '⻞', '⺶', '⻃', '⺌'}
    replaced_non_UNIFIED_hz_set = {'⻤', '⻌'}
    py_eval --startup 'import unicodedata as U' --turnoff_eval --postprocess U.name -i ⺳ タ 具 ⺢  ⻖ ⺗ 直 ⺯ 刃 ⺜ ⺇ ⻀ ⺫  𥄳 ⺃ 屮 旣 ⺲ ⻏ 灰 ⺈ ⺊  冗 ⺼ ⺧ ⻢ 穀 ⺣ ⺄ ⺆ 充  ⺪ 叟 者 ⻞ ⺶ ⻃ ⺌
$     py_eval --startup 'import unicodedata as U' --turnoff_eval --postprocess 'lambda x:(x, U.name(x))' -i ⺳ タ 具 ⺢  ⻖ ⺗ 直 ⺯ 刃 ⺜ ⺇ ⻀ ⺫  𥄳 ⺃ 屮 旣 ⺲ ⻏ 灰 ⺈ ⺊  冗 ⺼ ⺧ ⻢ 穀 ⺣ ⺄ ⺆ 充  ⺪ 叟 者 ⻞ ⺶ ⻃ ⺌ ⻤ ⻌
    [[
('⺳', 'CJK RADICAL NET THREE')
('タ', 'KATAKANA LETTER TA')
('具', 'CJK COMPATIBILITY IDEOGRAPH-2F811')
('⺢', 'CJK RADICAL WATER TWO')
('⻖', 'CJK RADICAL MOUND TWO')
('⺗', 'CJK RADICAL HEART TWO')
('直', 'CJK COMPATIBILITY IDEOGRAPH-2F940')
('⺯', 'CJK RADICAL SILK')
('刃', 'CJK COMPATIBILITY IDEOGRAPH-2F81E')
('⺜', 'CJK RADICAL SUN')
('⺇', 'CJK RADICAL TABLE')
('⻀', 'CJK RADICAL GRASS THREE')
('⺫', 'CJK RADICAL EYE')
('𥄳', 'CJK COMPATIBILITY IDEOGRAPH-2F944')
('⺃', 'CJK RADICAL SECOND TWO')
('屮', 'CJK COMPATIBILITY IDEOGRAPH-2F878')
('旣', 'CJK COMPATIBILITY IDEOGRAPH-2F8CB')
('⺲', 'CJK RADICAL NET TWO')
('⻏', 'CJK RADICAL CITY')
('灰', 'CJK COMPATIBILITY IDEOGRAPH-2F835')
('⺈', 'CJK RADICAL KNIFE ONE')
('⺊', 'CJK RADICAL DIVINATION')
('冗', 'CJK COMPATIBILITY IDEOGRAPH-2F817')
('⺼', 'CJK RADICAL MEAT')
('⺧', 'CJK RADICAL COW')
('⻢', 'CJK RADICAL C-SIMPLIFIED HORSE')
('穀', 'CJK COMPATIBILITY IDEOGRAPH-2F959')
('⺣', 'CJK RADICAL FIRE')
('⺄', 'CJK RADICAL SECOND THREE')
('⺆', 'CJK RADICAL BOX')
('充', 'CJK COMPATIBILITY IDEOGRAPH-FA74')
('⺪', 'CJK RADICAL BOLT OF CLOTH')
('叟', 'CJK COMPATIBILITY IDEOGRAPH-2F837')
('者', 'CJK COMPATIBILITY IDEOGRAPH-FA5B')
('⻞', 'CJK RADICAL EAT TWO')
('⺶', 'CJK RADICAL SHEEP')
('⻃', 'CJK RADICAL WEST ONE')
('⺌', 'CJK RADICAL SMALL ONE')
('⻤', 'CJK RADICAL GHOST')
('⻌', 'CJK RADICAL SIMPLIFIED WALK')
    ]]


搜索:『/('⿺', (('hz', '[^𠃊廴辶尤夨木夂⻌鬼豕文]'), ('hz', '.')))』
    旭
    最终止于:『/('⿺', (('hz', '[^𠃊廴辶尤夨木夂⻌鬼豕文目⻤丸乙九也兀冘尢曳更毛永爪瓦见見風风]'), ('hz', '.')))』
        其中:『目』是bug

bug:
    塡:('⿺', (('hz', '目'), ('hz', '𠃊')))

不好判断好坏:
    搞:('⿵', (('⿳', (('hz', '亠'), ('hz', '口'), ('hz', '冂'))), ('hz', '口')))
    亭:('⿱', (('⿳', (('hz', '亠'), ('hz', '口'), ('hz', '冖'))), ('hz', '丁')))


]]]


hz :: char
op :: 12-IDS-op-char
tree :: pair
    = ('hz', hz)
    | ('ref', ref_name)
    | (op, [tree])

id_leafed_tree :: seq{len>=3}
    = leaf_identifier           :: str{len>=5}
    | (op, *id_leafed_tree...)  :: tuple{len>=3}

#]]]]]'''

import unicodedata as U
import nn_ns.CJK.CJK_struct.CHISE_IDS_67b94ff_20191211
from pathlib import Path
from ast import literal_eval
from collections import defaultdict, Counter
from pprint import pprint
from seed.tiny import MapView, check_type_is, at, update_attr, fwd_call
from seed.abc.abc__ver0 import ABC, abstractmethod, override
from seed.func_tools.fmapT.fmapT__tiny import fmapT__dict, dot
from seed.mapping_tools.dict_op import subset_keys__immutable, inv__bijection__immutable, mk_dict5key2value_keys__naive
    #inv__group_keys_by_value__immutable
#from seed.mapping_tools.dict_op import ordered_unique_hashables, mk_Dk2v_from_Fk2v_ks__naive, mk_Dk2v_from_Fk2v_ks__ordered_unique
from seed.mapping_tools.dict_op import inv__k2vs_to_v2ks#inv__k2v_to_v2k, inv__k2v_to_v2ks, inv__k2vs_to_v2k, inv__k2vs_to_v2ks
from nn_ns.CJK.cjk_subsets.hanzi import (
#hz_sp_str2hz_str
#hz_sp_str2hz_set
hz_set2sorted_hz_str
)


def load_hz2tree___BMP_only():
    _pkg_path = Path(nn_ns.CJK.CJK_struct.CHISE_IDS_67b94ff_20191211.__file__).parent
    _ipath = _pkg_path / 'basic_decomp.txt'
    _txt = _ipath.read_text(encoding='utf8')


    hz2tree___BMP_only = fmapT__dict(mutable_tree2immutable)(literal_eval(_txt))
    return hz2tree___BMP_only


def mutable_tree2immutable(tree, /):
    def recur(tree, /):
        case, payload = tree
        if type(payload) is list:
            assert len(case) == 1
            children = payload
            children = tuple(map(recur, children))
            payload = children
            tree = case, payload
        else:
            assert len(case) > 1
        return tree
    return recur(tree)


def tree2children(tree, /):
    case, payload = tree
    if type(payload) is tuple:
        assert len(case) == 1
        parent = tree
        children = payload
    else:
        assert len(case) > 1
        children = ()
    return children
def 构建反向索引表(hz2tree, /):
    '反指向直接父部件或父汉字'
    tree2parents = tree2hz_or_tree__set = defaultdict(set)
        #Map tree (Set (hz|tree))

    for hz, tree in hz2tree.items():
        tree2hz_or_tree__set[tree].add(hz)

    to_be_handled_trees = set(hz2tree.values())
    handled_trees = set()
    def add_tree_to_be_handled(tree, /):
        if not tree in handled_trees:
            to_be_handled_trees.add(tree)
    def add_backref(child_tree, parent_tree, /):
        tree2hz_or_tree__set[child_tree].add(parent_tree)
    def handle_tree(tree, /):
        children = tree2children(tree)
        parent = tree
        for child in children:
            add_backref(child, parent)
        for child in children:
            add_tree_to_be_handled(child)

        handled_trees.add(tree)
    while to_be_handled_trees:
        handle_tree(to_be_handled_trees.pop())
    tree2parents = {**tree2parents}
    return tree2parents


def 计算被引用次数(tree2parents, /):
    '不考虑重复计数(不论是多个相同直接子部件，还是父部件被引用次数多于子部件的)'
    tree2ref_count = fmapT__dict(len)(tree2parents)
    return tree2ref_count

def 辅助估算被引用次数的阈值(tree2ref_count, /):
    ref_count2repeat = Counter(tree2ref_count.values())
    sorted_ref_count_repeat_pairs = sorted(ref_count2repeat.items())
    return sorted_ref_count_repeat_pairs
def 估算被引用次数的阈值(max_num_components_can_be_handled, sorted_ref_count_repeat_pairs, /):
    r'''
    阈值...？
        主要还是看我的空闲时间
        时间少，只处理最重要也就是被引用次数最多的部件，200~300个差不多了。
        组字能力强的部件，类似 部首，可以用于对汉字作粗分类
    #'''

    acc = 0
    L = len(sorted_ref_count_repeat_pairs)

    #find i, s.t. sorted_ref_count_repeat_pairs[:i+1] are not ok, ...[i+1:] are ok
    for i, (ref_count, repeat) in zip(reversed(range(L)), reversed(sorted_ref_count_repeat_pairs)):
        acc += repeat
        if acc > max_num_components_can_be_handled:
            #(i, ref_count) is not ok
            assert i >= 0
            assert ref_count >= 1
            break
    else:
        i = -1
        ref_count = 0
    assert i >= -1
    assert ref_count >= 0
    max_non_ok_ref_count = ref_count



    min_ok_ref_count = max_non_ok_ref_count + 1
    threshold4ref_count = min_ok_ref_count
    assert threshold4ref_count >= 1
    #ok = (ref_count >= threshold4ref_count)
    #see: is_okT__ref_count
    return threshold4ref_count

def is_okT__ref_count(threshold4ref_count, /):
    def is_ok__ref_count(ref_count, /):
        return ref_count >= threshold4ref_count
    return is_ok__ref_count

class _result_of_start_n:
    'see:_start_n'
    def __getattribute__(sf, nm, /):
        prefix = 'result_of_start_'
        if not nm.startswith(prefix): raise AttributeError(nm)
        d = object.__getattribute__(sf, '__dict__')
        if nm in d:
            return d[nm]

        suffix = nm[len(prefix):]
        fnm = '_start_' + suffix
        f = getattr(_start_n, fnm)
        if fnm.endswith('__'):
            val = f
        else:
            val = f()
        d[nm] = val
        return getattr(sf, nm)
_result_of_start_n = _result_of_start_n()

class _start_n:
    'see:_result_of_start_n, _main_'
    def _start_0_1__(sf, non_UNIFIED_hz2UNIFIED_hz, /):
        result_of_start_0 = _result_of_start_n.result_of_start_0

        (deprecated_by_start_0, fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only) = result_of_start_0
        (fixed_UNIFIED__hz2tree___BMP_only, missed_non_UNIFIED_hz_set, replaced_non_UNIFIED_hz_set) = findout_and_replace_non_UNIFIED_hz(fixed__hz2tree___BMP_only, non_UNIFIED_hz2UNIFIED_hz)

        input4_start_0_1__ = (non_UNIFIED_hz2UNIFIED_hz,)
        output4_start_0_1__ = (fixed_UNIFIED__hz2tree___BMP_only, missed_non_UNIFIED_hz_set, replaced_non_UNIFIED_hz_set)
        result_of_start_0_1 = (result_of_start_0, input4_start_0_1__, output4_start_0_1__)
        return result_of_start_0_1

    def _start_0(sf, /):
        hz2tree___BMP_only = load_hz2tree___BMP_only()
        fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only = try_to_replace_hz_node_by_hz_decomp_tree(hz2tree___BMP_only)

        deprecated_by_start_0 = (hz2tree___BMP_only,)
        result_of_start_0 = (deprecated_by_start_0, fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only)
        return result_of_start_0
    def _start_1(sf, /):
        result_of_start_0 = _result_of_start_n.result_of_start_0

        (deprecated_by_start_0, fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only) = result_of_start_0
        tree2parents = 构建反向索引表(fixed__hz2tree___BMP_only)
        tree2ref_count = 计算被引用次数(tree2parents)
        sorted_ref_count_repeat_pairs = 辅助估算被引用次数的阈值(tree2ref_count)

        output4_start_1 = (tree2parents, tree2ref_count, sorted_ref_count_repeat_pairs)
        result_of_start_1 = (result_of_start_0, output4_start_1)
        return result_of_start_1


    def _start_2__(sf, max_num_components_can_be_handled, /):
        result_of_start_1 = _result_of_start_n.result_of_start_1
        (result_of_start_0, output4_start_1) = result_of_start_1
        (tree2parents, tree2ref_count, sorted_ref_count_repeat_pairs) = output4_start_1

        threshold4ref_count = 估算被引用次数的阈值(max_num_components_can_be_handled, sorted_ref_count_repeat_pairs)

        input4_start_2__ = (max_num_components_can_be_handled,)
        output4_start_2__ = (threshold4ref_count,)
        result_of_start_2 = (result_of_start_1, input4_start_2__, output4_start_2__)
        return result_of_start_2

    def _start_3(sf, /):
        result_of_start_1 = _result_of_start_n.result_of_start_1
        (result_of_start_0, output4_start_1) = result_of_start_1
        (tree2parents, tree2ref_count, sorted_ref_count_repeat_pairs) = output4_start_1


        ######################
        tree2identifier__dict = mk_dict5key2value_keys__naive(tree2identifier, tree2ref_count.keys())
        tree5identifier__dict = mk_dict5key2value_keys__naive(tree5identifier, tree2identifier__dict.values())

        if not len(tree2identifier__dict) == len(tree5identifier__dict) == len(tree2ref_count): raise logic-err
        if not tree5identifier__dict == inv__bijection__immutable(tree2identifier__dict): raise logic-err


        ######################
        topo_sorted_trees = 拓扑排序囗囗孤例化囗深入添加子部件囗囗通过部件标识名实现稳定排序(tree2ref_count.keys())
        sz_id_tree_triples = [(len(identifier4tree), identifier4tree, tree) for tree, identifier4tree in tree2identifier__dict.items()]
        sz_id_tree_triples.sort()
        topo_sorted_sz_id_tree_triples = tuple(sz_id_tree_triples)
        del sz_id_tree_triples
        if not (*map(at[2], topo_sorted_sz_id_tree_triples),) == topo_sorted_trees: raise logic-err


        ######################
        output4_start_3 = (tree2identifier__dict, tree5identifier__dict, topo_sorted_trees, topo_sorted_sz_id_tree_triples)
        result_of_start_3 = (result_of_start_1, output4_start_3)
        return result_of_start_3

    #def _start_4__(sf, threshold4ref_count, /):
    def _start_4__(sf, /, *, user_explict_specified_non_derived_components, threshold4ref_count, user_explict_specified_non_float_components, single_stroke_ref_names, single_stroke_hzs):
        #post: _start_2__ --> threshold4ref_count
        #post: _start_3
        input4_start_4__ = (user_explict_specified_non_derived_components, threshold4ref_count, user_explict_specified_non_float_components, single_stroke_ref_names, single_stroke_hzs)

        result_of_start_3 = _result_of_start_n.result_of_start_3
        (result_of_start_1, output4_start_3) = result_of_start_3
        (tree2identifier__dict, tree5identifier__dict, topo_sorted_trees, topo_sorted_sz_id_tree_triples) = output4_start_3


        (result_of_start_0, output4_start_1) = result_of_start_1
        (tree2parents, tree2ref_count, sorted_ref_count_repeat_pairs) = output4_start_1
            # for tree2ref_count

        tree2ref_count
        threshold4ref_count
        kwds = '''
        user_explict_specified_non_derived_components
        threshold4ref_count
        tree2ref_count
        user_explict_specified_non_float_components
        single_stroke_ref_names
        single_stroke_hzs
        '''.split()
        某判别可拆开部件 = fwd_call(判别可拆开部件, kwds, locals())
        #.view__tree2is_float_component/view__tree2is_derived_component/get_or_calc_topo_sorted_trees
        tree2is_derived_component = 某判别可拆开部件.view__tree2is_derived_component()

        (deprecated_by_start_0, fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only) = result_of_start_0
            #for fixed__hz2tree___BMP_only

        (hz2id_leafed_tree, leaf_identifier2tree, leaf_identifier2derived_hz_set) = mk_hz2id_leafed_tree(fixed__hz2tree___BMP_only, tree2is_derived_component, tree2identifier__dict)

        assert leaf_identifier2tree.keys() == leaf_identifier2derived_hz_set.keys()
        assert hz2id_leafed_tree.keys() == fixed__hz2tree___BMP_only.keys()
        total_sz_id4leaf_node_hzs_5ples = sz__leaf_identifier__tree8leaf__sz__sorted_derived_hz_str__5ples = sorted((len(derived_hz_set), len(leaf_identifier), leaf_identifier, leaf_identifier2tree[leaf_identifier], hz_set2sorted_hz_str(derived_hz_set)) for leaf_identifier, derived_hz_set in leaf_identifier2derived_hz_set.items())
            #vs tree2parents 直接父部件/直接父汉字
            #       tree2parents ==>> tree2ref_count


        sz_id4tree4hz_hzhex_idtree_5ples = sorted((len(identifier4tree), identifier4tree, hz+hex(ord(hz)), id_leafed_tree) for hz, id_leafed_tree in hz2id_leafed_tree.items() for identifier4tree in [tree2identifier__dict[fixed__hz2tree___BMP_only[hz]]])

        input4_start_4__
        output4_start_4__ = (tree2is_derived_component, hz2id_leafed_tree, leaf_identifier2tree, leaf_identifier2derived_hz_set, total_sz_id4leaf_node_hzs_5ples, sz_id4tree4hz_hzhex_idtree_5ples)

        result_of_start_4 = (result_of_start_3, input4_start_4__, output4_start_4__)
        return result_of_start_4

    def _start_1_1(sf, /):
        #post:_start_1
        result_of_start_1 = _result_of_start_n.result_of_start_1
        (result_of_start_0, output4_start_1) = result_of_start_1
        (tree2parents, tree2ref_count, sorted_ref_count_repeat_pairs) = output4_start_1
        (deprecated_by_start_0, fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only) = result_of_start_0


        hz2trees = mk_hz2trees(fixed__hz2tree___BMP_only)
        tree2hz_set = inv__k2vs_to_v2ks(hz2trees)
        tree2sorted_hzs = fmapT__dict(hz_set2sorted_hz_str)(tree2hz_set)

        total_sz_id4node_node_hzs_5ples = tuple(sorted(
            (len(hzs), len(identifier4tree), identifier4tree, tree, hzs)
            for tree, hzs in tree2sorted_hzs.items()
            for identifier4tree in [tree2identifier(tree)]
            ))
        output4_start_1_1 = (hz2trees, tree2hz_set, tree2sorted_hzs, total_sz_id4node_node_hzs_5ples)
        result_of_start_1_1 = (result_of_start_1, output4_start_1_1)
        return result_of_start_1_1

    def _start_1_2__(sf, imay_max_sz4hzs, /):
        if not imay_max_sz4hzs >= -1: raise TypeError
        if imay_max_sz4hzs == -1:
            #f = echo
            pass
        else:
            max_sz4hzs = imay_max_sz4hzs
            def f(hzs, /):
                return hzs[:max_sz4hzs]
        result_of_start_1_1 = _result_of_start_n.result_of_start_1_1
        (result_of_start_1, output4_start_1_1) = result_of_start_1_1
        (hz2trees, tree2hz_set, tree2sorted_hzs, total_sz_id4node_node_hzs_5ples) = output4_start_1_1
        total_sz_id4node_node_hzsL_5ples = total_sz_id4node_node_hzs_5ples if imay_max_sz4hzs < 0 else tuple(
            (total, sz, id4node, node, f(hzs))
            for (total, sz, id4node, node, hzs) in total_sz_id4node_node_hzs_5ples
            )
        output4_start_1_2__ = (total_sz_id4node_node_hzsL_5ples,)
        result_of_start_1_2 = (result_of_start_1_1, output4_start_1_2__)
        return result_of_start_1_2



_start_n = _start_n()


def mk_hz2trees(hz2tree, /):
    hz2trees = {hz:set() for hz in hz2tree}
    def recur(hz, tree, /):
        hz2trees[hz].add(tree)
        children = tree2children(tree)
        for child in children:
            recur(hz, child)
    def main():
        for hz, tree in hz2tree.items():
            recur(hz, tree)
        return hz2trees
    return main()

def mk_hz2id_leafed_tree(hz2tree, tree2is_derived_component, tree2identifier__dict, /):
    '-> (hz2id_leafed_tree, leaf_identifier2tree, leaf_identifier2derived_hz_set)'
    leaf_identifier2tree = {}
    leaf_identifier2derived_hz_set = defaultdict(set)
    tmay_hz = []
    def recur_fmap_tree(tree, /):
        '-> id_leafed_tree'
        if tree2is_derived_component[tree]:
            op, children = tree
            id_leafed_tree = (op, *map(recur_fmap_tree, children))
        else:
            identifier4tree = tree2identifier__dict[tree]
            leaf_identifier = identifier4tree
            leaf_identifier2tree.setdefault(leaf_identifier, tree)
            leaf_identifier2derived_hz_set[leaf_identifier].add(*tmay_hz)
            id_leafed_tree = leaf_identifier
        return id_leafed_tree
    def main():
        #hz2id_leafed_tree = fmapT__dict(recur_fmap_tree, hz2tree)
        hz2id_leafed_tree = {}
        for hz, tree in hz2tree.items():
            tmay_hz.append(hz)
            id_leafed_tree = recur_fmap_tree(tree)
            tmay_hz.pop()
            hz2id_leafed_tree[hz] = id_leafed_tree
        _leaf_identifier2derived_hz_set = {**leaf_identifier2derived_hz_set}
        return (hz2id_leafed_tree, leaf_identifier2tree, _leaf_identifier2derived_hz_set)
    return main()



def _main_汉字分解成字根囗字根反向索引汉字(args, /, *, fout):
    result_of_start_4 = _result_of_start_n.result_of_start_4__(
        user_explict_specified_non_derived_components
        = args.non_derived_components
        ,threshold4ref_count
        = args.threshold4ref_count
        ,user_explict_specified_non_float_components
        = args.non_float_components
        ,single_stroke_ref_names
        = args.single_stroke_ref_names
        ,single_stroke_hzs
        = args.single_stroke_hzs
        )

    (result_of_start_3, input4_start_4__, output4_start_4__) = result_of_start_4
    (tree2is_derived_component, hz2id_leafed_tree, leaf_identifier2tree, leaf_identifier2derived_hz_set, total_sz_id4leaf_node_hzs_5ples, sz_id4tree4hz_hzhex_idtree_5ples) = output4_start_4__

    print("(('汉字分解成字根',", file=fout)
    pprint(sz_id4tree4hz_hzhex_idtree_5ples, stream=fout)

    print("),('字根反向索引汉字',", file=fout)
    pprint(total_sz_id4leaf_node_hzs_5ples, stream=fout)
    print('))', file=fout)


def _main_预处理囗深入替换类型为汉字的树叶(args, /, *, fout):
    result_of_start_0 = _result_of_start_n.result_of_start_0

    (deprecated_by_start_0, fixed__hz2tree___BMP_only, outside_refs___BMP_only, outside_hzs___BMP_only, bypassed_hzs___BMP_only, replaced_hzs___BMP_only) = result_of_start_0
    d = {**locals()}
    nms = 'outside_refs___BMP_only outside_hzs___BMP_only bypassed_hzs___BMP_only replaced_hzs___BMP_only'.split()
    _show_vars_lens(nms, d, fout=fout)

def _show_vars_lens(nms, locals_, /, fout):
    nms = [*nms]
    for nm in nms:
        var = locals_[nm]
        print(f'{nm!s} = {var!r}', file=fout)
    for nm in nms:
        var = locals_[nm]
        print(f'len({nm!s}) = {len(var)!r}', file=fout)

def _main_预处理囗深入替换类型为汉字的树叶囗一致使用统一区汉字(args, /, *, fout):
    s = args.non_UNIFIED_hz2UNIFIED_hz
    if not len(s)%2 == 0: raise TypeError(repr(s))
    non_UNIFIED_hz2UNIFIED_hz = dict(zip(s[0::2], s[1::2]))
    result_of_start_0_1 = _result_of_start_n.result_of_start_0_1__(non_UNIFIED_hz2UNIFIED_hz)
    (result_of_start_0, input4_start_0_1__, output4_start_0_1__) = result_of_start_0_1
    (fixed_UNIFIED__hz2tree___BMP_only, missed_non_UNIFIED_hz_set, replaced_non_UNIFIED_hz_set) = output4_start_0_1__
    d = {**locals()}
    nms = 'missed_non_UNIFIED_hz_set replaced_non_UNIFIED_hz_set'.split()
    _show_vars_lens(nms, d, fout=fout)


def _main_辅助人工定义哪些部件是字根(args, /, *, fout):
    result_of_start_1_2 = _result_of_start_n.result_of_start_1_2__(args.imay_max_sz4hzs)
    (result_of_start_1_1, output4_start_1_2__) = result_of_start_1_2
    (total_sz_id4node_node_hzsL_5ples,) = output4_start_1_2__


    #pprint(tree2ref_count, stream=fout)
    pprint(total_sz_id4node_node_hzsL_5ples, stream=fout)

def _main_辅助估算被引用次数的阈值(args, /, *, fout):
    result_of_start_1 = _result_of_start_n.result_of_start_1
    (result_of_start_0, output4_start_1) = result_of_start_1
    (tree2parents, tree2ref_count, sorted_ref_count_repeat_pairs) = output4_start_1


    pprint(sorted_ref_count_repeat_pairs, stream=fout)
def _main_估算被引用次数的阈值(args, /, *, fout):
    result_of_start_2 = _result_of_start_n.result_of_start_2__(args.max_num_components_can_be_handled)
    (result_of_start_1, input4_start_2__, output4_start_2__) = result_of_start_2
    (max_num_components_can_be_handled,) = input4_start_2__
    (threshold4ref_count,) = output4_start_2__


    #return threshold4ref_count
    print(threshold4ref_count, file=fout)



r'''[[[
=====now:using fixed__hz2tree___BMP_only
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 300
28
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 200
34
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 1
1013
    #correct! [..., (1012, 1), (1031, 1)]


py script/collect_hz_components.py  辅助估算被引用次数的阈值
[(1, 19092),
 (2, 939),
 (3, 392),
 (4, 228),
 (5, 136),
 (6, 90),
 (7, 81),
 (8, 78),
 (9, 84),
 (10, 56),
 (11, 51),
 (12, 47),
 (13, 49),
 (14, 62),
 (15, 33),
 (16, 29),
 (17, 28),
 (18, 33),
 (19, 29),
 (20, 25),
 (21, 23),
 (22, 27),
 (23, 26),
 (24, 17),
 (25, 22),
 (26, 26),
 (27, 19),
 (28, 21),
 (29, 21),
 (30, 12),
 (31, 13),
 (32, 10),
 (33, 13),
 (34, 9),
 (35, 6),
 (36, 8),
 (37, 6),
 (38, 8),
 (39, 10),
 (40, 4),
 (41, 8),
 (42, 2),
 (43, 3),
 (44, 5),
 (45, 3),
 (46, 2),
 (47, 6),
 (48, 3),
 (49, 4),
 (50, 2),
 (51, 3),
 (52, 3),
 (53, 4),
 (54, 2),
 (55, 4),
 (56, 3),
 (57, 1),
 (58, 2),
 (59, 1),
 (60, 2),
 (62, 4),
 (63, 1),
 (64, 1),
 (65, 1),
 (67, 2),
 (68, 1),
 (69, 2),
 (70, 1),
 (71, 2),
 (74, 1),
 (76, 1),
 (79, 1),
 (80, 2),
 (81, 1),
 (88, 2),
 (90, 1),
 (91, 2),
 (92, 2),
 (98, 1),
 (99, 1),
 (103, 1),
 (105, 1),
 (106, 1),
 (107, 1),
 (110, 1),
 (112, 1),
 (113, 1),
 (115, 1),
 (122, 1),
 (129, 1),
 (131, 1),
 (136, 1),
 (140, 1),
 (146, 1),
 (147, 1),
 (153, 1),
 (154, 1),
 (156, 1),
 (157, 1),
 (169, 1),
 (177, 1),
 (184, 1),
 (197, 1),
 (200, 1),
 (201, 1),
 (212, 1),
 (226, 1),
 (227, 1),
 (232, 1),
 (236, 1),
 (244, 1),
 (296, 1),
 (298, 1),
 (302, 1),
 (319, 1),
 (323, 1),
 (353, 1),
 (368, 1),
 (399, 1),
 (404, 1),
 (415, 1),
 (420, 1),
 (426, 1),
 (454, 1),
 (490, 1),
 (493, 1),
 (602, 1),
 (698, 1),
 (707, 1),
 (735, 1),
 (966, 1),
 (1012, 1),
 (1031, 1)]
=====old:using hz2tree___BMP_only
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 300
27
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 200
33
py script/collect_hz_components.py  估算被引用次数的阈值 --max_num_components_can_be_handled 1
1013
    #correct! [..., (1012, 1), (1031, 1)]


py script/collect_hz_components.py  辅助估算被引用次数的阈值
[(1, 22034),
 (2, 478),
 (3, 260),
 (4, 160),
 (5, 93),
 (6, 95),
 (7, 69),
 (8, 83),
 (9, 70),
 (10, 42),
 (11, 54),
 (12, 43),
 (13, 62),
 (14, 40),
 (15, 33),
 (16, 22),
 (17, 34),
 (18, 27),
 (19, 30),
 (20, 27),
 (21, 19),
 (22, 24),
 (23, 28),
 (24, 16),
 (25, 23),
 (26, 22),
 (27, 21),
 (28, 21),
 (29, 13),
 (30, 11),
 (31, 13),
 (32, 15),
 (33, 9),
 (34, 9),
 (35, 5),
 (36, 6),
 (37, 10),
 (38, 8),
 (39, 5),
 (40, 8),
 (41, 2),
 (42, 2),
 (43, 5),
 (44, 5),
 (45, 1),
 (46, 5),
 (47, 4),
 (48, 4),
 (49, 2),
 (50, 2),
 (51, 4),
 (52, 2),
 (53, 4),
 (54, 4),
 (55, 3),
 (56, 2),
 (57, 1),
 (58, 2),
 (59, 1),
 (60, 2),
 (61, 1),
 (62, 3),
 (63, 1),
 (64, 1),
 (65, 1),
 (67, 2),
 (68, 1),
 (69, 2),
 (70, 2),
 (71, 1),
 (74, 1),
 (76, 1),
 (79, 1),
 (80, 2),
 (81, 1),
 (88, 2),
 (90, 1),
 (91, 2),
 (92, 2),
 (98, 1),
 (99, 1),
 (103, 1),
 (105, 1),
 (106, 1),
 (107, 1),
 (109, 1),
 (112, 1),
 (113, 1),
 (115, 1),
 (122, 1),
 (129, 1),
 (131, 1),
 (136, 1),
 (140, 1),
 (146, 1),
 (147, 1),
 (153, 1),
 (154, 1),
 (156, 1),
 (157, 1),
 (169, 1),
 (177, 1),
 (184, 1),
 (197, 1),
 (200, 1),
 (201, 1),
 (212, 1),
 (226, 1),
 (227, 1),
 (232, 1),
 (236, 1),
 (244, 1),
 (296, 1),
 (298, 1),
 (302, 1),
 (319, 1),
 (323, 1),
 (353, 1),
 (368, 1),
 (399, 1),
 (404, 1),
 (415, 1),
 (420, 1),
 (426, 1),
 (454, 1),
 (490, 1),
 (493, 1),
 (602, 1),
 (698, 1),
 (707, 1),
 (735, 1),
 (966, 1),
 (1012, 1),
 (1031, 1)]

#]]]'''


def is_UNIFIED_hz(ch, /):
    '注：有12个在 兼容区@Unicode_13_0'
    nm = U.name(ch)
    return nm.startswith('CJK UNIFIED IDEOGRAPH-')

def findout_and_replace_non_UNIFIED_hz(hz2tree, non_UNIFIED_hz2UNIFIED_hz, /):
    '-> (fixed_UNIFIED__hz2tree, missed_non_UNIFIED_hz_set, replaced_non_UNIFIED_hz_set)'
    missed_non_UNIFIED_hz_set = set()
    replaced_non_UNIFIED_hz_set = set()
    def recur_fmap_tree(tree, /):
        '-> fixed tree'
        case, payload = tree
        children = tree2children(tree)
        if children:
            children = tuple(map(recur_fmap_tree, children))
            tree = case, children
        elif case == 'hz':
            hz = payload
            if not is_UNIFIED_hz(hz):
                non_UNIFIED_hz = hz
                if non_UNIFIED_hz in non_UNIFIED_hz2UNIFIED_hz:
                    replaced_non_UNIFIED_hz_set.add(non_UNIFIED_hz)
                    UNIFIED_hz = non_UNIFIED_hz2UNIFIED_hz[non_UNIFIED_hz]
                    payload = UNIFIED_hz
                    tree = case, payload
                else:
                    missed_non_UNIFIED_hz_set.add(non_UNIFIED_hz)
                    tree;pass
            else:
                UNIFIED_hz = hz
                tree;pass

        elif case == 'ref':
            tree;pass
        else:
            raise logic-err
        return tree
    def main():
        assert all(map(is_UNIFIED_hz, hz2tree))
        if not all(map(is_UNIFIED_hz, non_UNIFIED_hz2UNIFIED_hz.values())): raise TypeError
        if any(map(is_UNIFIED_hz, non_UNIFIED_hz2UNIFIED_hz.keys())): raise TypeError

        fixed_UNIFIED__hz2tree = fmapT__dict(recur_fmap_tree)(hz2tree)
        return (fixed_UNIFIED__hz2tree, missed_non_UNIFIED_hz_set, replaced_non_UNIFIED_hz_set)
    return main()

def try_to_replace_hz_node_by_hz_decomp_tree(hz2tree, /):
    r'find out leaf.hz in hz2tree then replace the leaf by hz2tree[leaf.hz]'
    assert all(len(hz)==1 for hz in hz2tree)
    d = {}
    outside_refs = set()
    outside_hzs = set()
    bypassed_hzs = set()
    try_replaced_hzs = set()
    def recur_get(hz_node, /):
        '-> tree'
        case, payload = hz_node
        if not case=='hz': raise logic-err
        if not len(payload)==1: raise logic-err
        hz = payload

        if hz not in hz2tree:
            outside_hzs.add(hz)
            return hz_node
        if hz in d:
            return d[hz]
        recur_put(hz)
        return recur_get(hz_node)
    def recur_put(hz, /):
        '-> None'
        if hz in d:
            return

        tree = hz2tree[hz]
        if tree == ('hz', hz):
            bypassed_hzs.add(hz)
            pass
        else:
            tree = recur_fmap_tree(tree)
        d[hz] = tree
        recur_put(hz)
        return
    def recur_fmap_tree(tree, /):
        '-> tree'
        case, payload = tree
        if case == 'ref':
            ref_name = payload
            outside_refs.add(ref_name)
            return tree
        elif case == 'hz':
            hz_node = tree
            hz = payload
            try_replaced_hzs.add(hz)
            return recur_get(hz_node)
        else:
            op = case
            children = payload
            children = tuple(map(recur_fmap_tree, children))
            return (op, children)
        raise logic-err
        return
    def main():
        for hz in hz2tree:
            recur_put(hz)
        fixed__hz2tree = d
        assert fixed__hz2tree.keys() == hz2tree.keys()
        assert outside_hzs == try_replaced_hzs - set(hz2tree.keys())
        replaced_hzs = try_replaced_hzs - outside_hzs - bypassed_hzs
        if 0:
            #why not 『==』?
            #   since main() call recur_put
            #       ==>> not [bypassed_hzs <= try_replaced_hzs]
            assert len(outside_hzs) + len(bypassed_hzs) + len(replaced_hzs) >= len(try_replaced_hzs)
            assert outside_hzs | bypassed_hzs | replaced_hzs >= try_replaced_hzs
        return fixed__hz2tree, outside_refs, outside_hzs, bypassed_hzs, replaced_hzs
    return main()

def 拓扑排序囗囗孤例化囗深入添加子部件囗囗不稳定排序(trees, /):
    'trees = hz2tree.values() 数量增加[有点奇怪] or tree2parents.keys() 数量不变[更佳]'
    ls = []
    s = set()
    def recur_put(tree, /):
        if tree in s:
            return

        children = tree2children(tree)
        for child in children:
            recur_put(child)
        s.add(tree)
        ls.append(tree)
        assert len(ls) == len(s)
        return
    def main():
        for tree in trees:
            recur_put(tree)
        topo_sorted_trees = ls
        topo_sorted_trees = tuple(topo_sorted_trees)
        return topo_sorted_trees
    return main()
def 拓扑排序囗囗通过部件标识名实现稳定排序(trees, /):
    '既不『孤例化』也不『深入添加子部件』'
    def f(tree, /):
        identifier4tree = tree2identifier(tree)
        sz = len(identifier4tree)
        return (sz, identifier4tree)
    topo_sorted_trees = sorted(trees, key=f)
    topo_sorted_trees = tuple(topo_sorted_trees)
    return topo_sorted_trees
def 拓扑排序囗囗孤例化囗深入添加子部件囗囗通过部件标识名实现稳定排序(iter_unordered_trees, /):
    iter_unordered_trees = iter(iter_unordered_trees)
    topo_sorted_trees__unique_tree__subtrees__unstable = 拓扑排序囗囗孤例化囗深入添加子部件囗囗不稳定排序(iter_unordered_trees)
    topo_sorted_trees__unique_tree__subtrees__stable = 拓扑排序囗囗通过部件标识名实现稳定排序(topo_sorted_trees__unique_tree__subtrees__unstable)
    topo_sorted_trees = (topo_sorted_trees__unique_tree__subtrees__stable)

    check_type_is(tuple, topo_sorted_trees)
    return topo_sorted_trees

class 囗缓存拓扑排序(ABC):
    def get_or_calc_topo_sorted_trees(sf, /):
        '-> topo_sorted_trees'
        while 1:
            may_topo_sorted_trees = sf._get_may_topo_sorted_trees()
            if may_topo_sorted_trees is None:
                unordered_trees = sf._get_unordered_trees()
                topo_sorted_trees = 拓扑排序囗囗孤例化囗深入添加子部件囗囗通过部件标识名实现稳定排序(unordered_trees)
                check_type_is(tuple, topo_sorted_trees)
                sf._set_topo_sorted_trees(topo_sorted_trees)
                continue
            else:
                topo_sorted_trees = may_topo_sorted_trees
                break
        #end-while
        topo_sorted_trees
        return topo_sorted_trees
    @abstractmethod
    def _get_unordered_trees(sf, /):
        '-> unordered_trees'
    @abstractmethod
    def _get_may_topo_sorted_trees(sf, /):
        '-> may_topo_sorted_trees'
    @abstractmethod
    def _set_topo_sorted_trees(sf, topo_sorted_trees, /):
        'topo_sorted_trees -> None'

class 囗判别可拆出部件(囗缓存拓扑排序):
    r'''
    定义 可拆出部件(float_component)
        = 『被引用次数超过阈值』并且不是『单笔部件』并且不是『用户显式指定的不可拆出部件』的部件
        | 所有直接子部件都是『可拆出部件』的部件

    #'''
    def view__tree2is_float_component(sf, /):
        '-> tree2is_float_component'
        tree2is_float_component = sf._get__tree2is_float_component()
        tree2is_float_component = MapView(tree2is_float_component)
        return tree2is_float_component
    def _fill__tree2is_float_component(sf, /):
        tree2is_float_component = sf._get__tree2is_float_component()
        if tree2is_float_component: raise logic-err
        #tree2ref_count = sf._get_tree2ref_count()
        topo_sorted_trees = sf.get_or_calc_topo_sorted_trees()
        f = sf._is_float_component__after_all_children_solved
        for tree in topo_sorted_trees:
            b = f(tree)
            check_type_is(bool, b)
            tree2is_float_component[tree] = b
        return
    def get_ref_count_of_component(sf, tree, /):
        tree2ref_count = sf._get_tree2ref_count()
        return tree2ref_count[tree]

    def _is_float_component__already_cached(sf, tree, /):
        tree2is_float_component = sf._get__tree2is_float_component()
        return tree2is_float_component[tree]
    def _is_float_component__after_all_children_solved(sf, tree, /):
        if sf.is_user_explict_specified_non_float_component(tree) or sf.is_single_stroke_component(tree):
            return False
        if sf.is_ok__ref_count_of_component(tree):
            return True
        children = tree2children(tree)
        if not children:
            return False
        f = sf._is_float_component__already_cached
        return all(map(f, children))
    def is_ok__ref_count_of_component(sf, tree, /):
        ref_count = sf.get_ref_count_of_component(tree)
        threshold4ref_count = sf._get_threshold4ref_count()
        return is_okT__ref_count(threshold4ref_count)(ref_count)
    def is_single_stroke_component(sf, tree, /):
        case, payload = tree
        if case == 'hz':
            hz = payload
            return sf.is_single_stroke_hz(hz)
        elif case == 'ref':
            ref_name = payload
            return sf.is_single_stroke_ref_name(ref_name)
        else:
            assert len(case) == 1
            return False
    def on_init(sf, /):
        sf._fill__tree2is_float_component()

    @override
    def _get_unordered_trees(sf, /):
        '-> unordered_trees'
        tree2ref_count = sf._get_tree2ref_count()
        return tree2ref_count.keys()


    @abstractmethod
    def is_single_stroke_ref_name(sf, ref_name, /):
        '-> bool'
    @abstractmethod
    def is_single_stroke_hz(sf, hz, /):
        '-> bool'
    @abstractmethod
    def is_user_explict_specified_non_float_component(sf, tree, /):
        '-> bool'
    @abstractmethod
    def _get_threshold4ref_count(sf, /):
        '-> threshold4ref_count'
    @abstractmethod
    def _get__tree2is_float_component(sf, /):
        '-> tree2is_float_component'
    @abstractmethod
    def _get_tree2ref_count(sf, /):
        '-> tree2ref_count'
class 囗判别可拆开部件(囗判别可拆出部件):
    r'''
    定义 可拆开部件(derived_component)
        = [op不为 交叠 的 拆分序列tree] 并且 所有直接子部件都是『可拆出部件』并且不是『用户显式指定的不可拆开部件』的部件

    #'''
    def view__tree2is_derived_component(sf, /):
        '-> tree2is_derived_component'
        tree2is_derived_component = sf._get__tree2is_derived_component()
        tree2is_derived_component = MapView(tree2is_derived_component)
        return tree2is_derived_component
    def _fill__tree2is_derived_component(sf, /):
        tree2is_derived_component = sf._get__tree2is_derived_component()
        if tree2is_derived_component: raise logic-err
        topo_sorted_trees = sf.get_or_calc_topo_sorted_trees()
        f = sf._is_derived_component
        for tree in topo_sorted_trees:
            b = f(tree)
            check_type_is(bool, b)
            tree2is_derived_component[tree] = b
        return

    def _is_derived_component(sf, tree, /):
        case, payload = tree
        if not len(case) == 1:
            return False
        op = case
        if op == '⿻':
            return False
        if sf.is_user_explict_specified_non_derived_component(tree):
            return False

        f = sf._is_float_component__already_cached
        children = tree2children(tree)
        if not children: raise logic-err
        return all(map(f, children))

    @override
    def on_init(sf, /):
        super().on_init()
            #sf._fill__tree2is_float_component()
        sf._fill__tree2is_derived_component()

    @abstractmethod
    def _get__tree2is_derived_component(sf, /):
        '-> tree2is_derived_component'
    @abstractmethod
    def is_user_explict_specified_non_derived_component(sf, tree, /):
        '-> bool'
class 判别可拆出部件(囗判别可拆出部件):
    def __init__(sf, /, *, threshold4ref_count, tree2ref_count, user_explict_specified_non_float_components, single_stroke_ref_names, single_stroke_hzs):
        sf._threshold4ref_count = threshold4ref_count
        sf._tree2ref_count = tree2ref_count
        sf._tree2is_float_component = {}
        sf._user_explict_specified_non_float_components = {*user_explict_specified_non_float_components}
        sf._single_stroke_ref_names = {*single_stroke_ref_names}
        sf._single_stroke_hzs = {*single_stroke_hzs}
        sf._may_topo_sorted_trees = None
        sf.on_init()

    @override
    def _get_may_topo_sorted_trees(sf, /):
        '-> may_topo_sorted_trees'
        return sf._may_topo_sorted_trees
    @override
    def _set_topo_sorted_trees(sf, topo_sorted_trees, /):
        'topo_sorted_trees -> None'
        check_type_is(tuple, topo_sorted_trees)
        if not sf._may_topo_sorted_trees is None: raise logic-err
        sf._may_topo_sorted_trees = topo_sorted_trees

    @override
    def is_single_stroke_ref_name(sf, ref_name, /):
        '-> bool'
        return ref_name in sf._single_stroke_ref_names
    @override
    def is_single_stroke_hz(sf, hz, /):
        '-> bool'
        return hz in sf._single_stroke_hzs
    @override
    def is_user_explict_specified_non_float_component(sf, tree, /):
        '-> bool'
        return tree in sf._user_explict_specified_non_float_components
    @override
    def _get_threshold4ref_count(sf, /):
        '-> threshold4ref_count'
        return sf._threshold4ref_count
    @override
    def _get__tree2is_float_component(sf, /):
        '-> tree2is_float_component'
        return sf._tree2is_float_component
    @override
    def _get_tree2ref_count(sf, /):
        '-> tree2ref_count'
        return sf._tree2ref_count

class 判别可拆开部件(判别可拆出部件, 囗判别可拆开部件):
    def __init__(sf, /, *, user_explict_specified_non_derived_components, threshold4ref_count, tree2ref_count, user_explict_specified_non_float_components, single_stroke_ref_names, single_stroke_hzs):
        sf._user_explict_specified_non_derived_components = {*user_explict_specified_non_derived_components}
        sf._tree2is_derived_component = {}
        super().__init__(
    threshold4ref_count
    = threshold4ref_count
    , tree2ref_count
    = tree2ref_count
    , user_explict_specified_non_float_components
    = user_explict_specified_non_float_components
    , single_stroke_ref_names
    = single_stroke_ref_names
    , single_stroke_hzs
    = single_stroke_hzs
    )

    @override
    def _get__tree2is_derived_component(sf, /):
        '-> tree2is_derived_component'
        return sf._tree2is_derived_component
    @override
    def is_user_explict_specified_non_derived_component(sf, tree, /):
        '-> bool'
        return tree in sf._user_explict_specified_non_derived_components

class Globals:
    first_op = '⿰'
    last_op = '⿻'
    ops = ''.join(map(chr, range(ord(first_op), ord(last_op)+1)))
    op2num_args__str = r'⿰2⿱2⿲3⿳3⿴2⿵2⿶2⿷2⿸2⿹2⿺2⿻2'
    ####################        ^^^^^
    op2num_args = dict(zip(op2num_args__str[::2], map(int, op2num_args__str[1::2])))
    assert ops == op2num_args__str[::2]
    assert set(ops) == op2num_args.keys()

    op2nm__str = r'⿰h2⿱v2⿲h3⿳v3⿴oo⿵ss⿶nn⿷ee⿸se⿹sw⿺ne⿻xx'
    op2nm = {op:a+b for op, a, b in zip(op2nm__str[0::3], op2nm__str[1::3], op2nm__str[2::3])}
    nm2op = inv__bijection__immutable(op2nm)
    if 0b00:
        print(op2nm)
        print(nm2op)
    assert ops == op2nm__str[::3]
    assert set(ops) == op2nm.keys()
    assert len(ops) == len(nm2op)
    if 0:
        assert all(op == nm2op[op2nm[op]] for op in ops)
        #NameError: name 'nm2op' is not defined
    assert all(op == nm2op[op2nm[op]] for ops, nm2op, op2nm in [(ops, nm2op, op2nm)] for op in ops)
str.isidentifier
def ref_name2identifier(ref_name, /):
    if not (ref_name.startswith('&') and ref_name.endswith(';')): raise TypeError
    if '_' in ref_name: raise logic-err
    s = ref_name[1:-1]
    s = s.replace('zIz', 'zIz0')
    s = s.replace('-', 'zIz1')
    s = s.replace('+', 'zIz2')
    identifier4ref = s
    if '_' in identifier4ref: raise logic-err
    if not identifier4ref.isidentifier(): raise Exception(f'logic-err: {identifier4ref!r}')
    if not identifier4ref.isidentifier(): raise logic-err
    return identifier4ref
def ref_name5identifier(identifier4ref, /):
    if '_' in identifier4ref: raise logic-err
    if not identifier4ref.isidentifier(): raise logic-err
    s = identifier4ref
    s = s.replace('zIz2', '+')
    s = s.replace('zIz1', '-')
    s = s.replace('zIz0', 'zIz')
    ref_name = f'&{s!s};'
    return ref_name
def hz2identifier(hz, /):
    if not len(hz) == 1: raise TypeError
    i = ord(hz)
    identifier4hz = hex(i)
    return identifier4hz
def hz5identifier(identifier4hz, /):
    i = int(identifier4hz, 16)
    hz = chr(i)
    return hz

def tree2identifier(tree, /):
    op2nm = Globals.op2nm
    def recur(tree, /):
        '-> Iter identifier without "_"'
        case, payload = tree
        children = tree2children(tree)
        if children:
            op = case
            nm = op2nm[op]
            yield nm
            for child in children:
                yield from recur(child)
        elif case == 'hz':
            hz = payload
            yield case
            yield hz2identifier(hz)
        elif case == 'ref':
            ref_name = payload
            yield case
            yield ref_name2identifier(ref_name)
        else:
            raise TypeError
    identifier4tree = '_'.join(recur(tree))
    if not len(identifier4tree) >= 5: raise logic-err
        # ref_w
        # hz_xxxx
        # nm_...
    return identifier4tree

def tree5identifier(identifier4tree, /):
    if not len(identifier4tree) >= 5: raise TypeError
    nm2op = Globals.nm2op
    op2num_args = Globals.op2num_args
    ls = identifier4tree.split('_')
    ls = (*ls,)
    def recur(begin, /):
        '-> (tree, begin, end)'
        xcase = ls[begin]
        if xcase == 'hz':
            identifier4hz = ls[begin+1]
            hz = hz5identifier(identifier4hz)
            payload = hz
            case = xcase
            end = begin + 2
        elif xcase == 'ref':
            identifier4ref = ls[begin+1]
            ref_name = ref_name5identifier(identifier4ref)
            payload = ref_name
            case = xcase
            end = begin + 2
        else:
            nm = xcase
            op = nm2op[nm]
            num_args = op2num_args[op]
            end = begin + 1
            children = []
            for _ in range(num_args):
                (child, _begin, end) = recur(end)
                children.append(child)
            payload = tuple(children)
            case = op
            end
        tree = (case, payload)
        return (tree, begin, end)
    def main():
        (tree, begin, end) = recur(0)
        if not begin == 0: raise logic-err
        if not end == len(ls): raise ValueError(identifier4tree)
        return tree
    return main()

r'''
判别可拆出部件(
    threshold4ref_count
    , tree2ref_count
    , user_explict_specified_non_float_components
    , single_stroke_ref_names
    , single_stroke_hzs
    ).view__tree2is_float_component
判别可拆开部件(
    user_explict_specified_non_derived_components
    , threshold4ref_count
    , tree2ref_count
    , user_explict_specified_non_float_components
    , single_stroke_ref_names
    , single_stroke_hzs
    ).view__tree2is_float_component/view__tree2is_derived_component/get_or_calc_topo_sorted_trees
#'''

def _main_拓扑排序(args, /, *, fout):
    result_of_start_3 = _result_of_start_n.result_of_start_3
    (result_of_start_1, output4_start_3) = result_of_start_3
    (tree2identifier__dict, tree5identifier__dict, topo_sorted_trees, topo_sorted_sz_id_tree_triples) = output4_start_3


    pprint(topo_sorted_sz_id_tree_triples, stream=fout)




def main(args=None, /):
    import argparse
    from seed.io.may_open import may_open_stdin, may_open_stdout

    prefix = '_main_'
    main_names = sorted(nm[len(prefix):] for nm in globals().keys() if nm.startswith(prefix))
    parser = argparse.ArgumentParser(
        description='collect_hz_components 收集汉字部件/人工辅助确认哪些部件再不拆分'
        , epilog=''
        , formatter_class=argparse.RawDescriptionHelpFormatter
        )
    parser.add_argument('main_name', type=str, choices=main_names
                        , help='choose the main function')
    parser.add_argument('--max_num_components_can_be_handled', type=int, default=300
                        , help='how many components user want to play with? [default=300] ==>> aid to compute threshold4ref_count(阈值)')

    parser.add_argument('--threshold4ref_count', type=int, default=28
                        , help='阈值: parameter to define float_component(可拆出部件) [default=28]')

    parser.add_argument('--non_derived_components', type=str, default=[], nargs='*'
                        , help='显式指定不可拆开部件')
    parser.add_argument('--non_float_components', type=str, default=[], nargs='*'
                        , help='显式指定不可拆出部件')
    parser.add_argument('--single_stroke_ref_names', type=str, default=[], nargs='*'
                        , help='所有单笔部件的引用名')
    parser.add_argument('--single_stroke_hzs', type=str, default=''
                        , help='所有单笔汉字')

    parser.add_argument('--imay_max_sz4hzs', type=int, default=-1
                        , help='用于『辅助人工定义哪些部件是字根』中，用以裁剪输出汉字列表。[default=-1]')
    parser.add_argument('--non_UNIFIED_hz2UNIFIED_hz', type=str, default=''
                        , help='用于『预处理囗深入替换类型为汉字的树叶囗一致使用统一区汉字』，将 汉字笔划、汉字部首 等 替换成 统一区汉字字符 [default=""]；格式:例『⻤鬼⻌辶』'
                    '#("CJK RADICAL GHOST", "CJK UNIFIED IDEOGRAPH-9B3C", "CJK RADICAL SIMPLIFIED WALK", "CJK UNIFIED IDEOGRAPH-8FB6")')
    parser.add_argument('-i', '--input', type=str, default=None
                        , help='input file path')
    parser.add_argument('-o', '--output', type=str, default=None
                        , help='output file path')
    parser.add_argument('-e', '--encoding', type=str
                        , default='utf8'
                        , help='input/output file encoding')
    parser.add_argument('-f', '--force', action='store_true'
                        , default = False
                        , help='open mode for output file')

    args = parser.parse_args(args)
    encoding = args.encoding
    omode = 'wt' if args.force else 'xt'

    if 0:
        may_ifname = args.input
        with may_open_stdin(may_ifname, 'rt', encoding=encoding) as fin:
            pass

    def f4components(strs, /):
        return {*map(literal_eval, strs)}
    update_attr(args, 'non_derived_components', f4components)
    update_attr(args, 'non_float_components', f4components)
    update_attr(args, 'single_stroke_ref_names', set)
    update_attr(args, 'single_stroke_hzs', set)

    _main_ = globals()[prefix+args.main_name]
    may_ofname = args.output
    with may_open_stdout(may_ofname, omode, encoding=encoding) as fout:
        _main_(args, fout=fout)
if __name__ == "__main__":
    main()


