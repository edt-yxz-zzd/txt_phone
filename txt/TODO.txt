

for backup cmd:
  view ../../python3_src/nn_ns/filedir/backup_tools/main.py
  view ../../python3_src/my_convention/backup_cmds.txt


to explain:
  novel 新奇的
  refrain from 避免
  horror 恐怖
  hierarchy 阶层 分层结构
    hi/er/ar/chy
      hai er ra: ki
  preclude 阻止
  reject 拒绝
  panic 恐慌
  nickname 略称/简称/绰号
  controlled 受控的 vs open
  conceptual 概念上的
  opaque 不透明的
    o/pe/k
  automatic 自动的
  互斥 mutual exclusion ==>> mutex
    并联 parallel
    串联 series
    优先
      priority
        优先处理 priority processing
        优先电路 priority scheme
        优先调度 priority scheduling

      precedence
      preferential 有优先权的
        preference 偏好
      fallback 退路，应急办法
      preemption 优先购买权
    前瞻 提前 短路 bypass
      prospective 预期的，未来的，有希望的，前瞻性
        prospect [名词] 前景，希望
      advanced 提前的，高深的，先进的
        advance 预先的 [动词] 提前，推进
      短路 short pass, short out
      bypassing 忽略，分流，分路
      bypass 支路，旁路 [动词]忽视，省略，规避，绕道
      预言 predict[动词]
        predicted 预计的/提前预测的
        predictable 可预知的，平庸的/无创意的
      预见 foresee
        foreseeable 可预见的，不远的
      远见/预见性 foresight
        foresighted 前瞻性，深谋远虑的
      预知
        precognition[名词]
        foreknowledge[名词]
        foreknow[动词]
        unforeknowable 无法预知的
          ==>>?? foreknowable 可预知的？
    mutual exclusion parallel
    priority choice/switch
    plain series
    predictable series

  cased 包装，装入
  contiguous 邻接的，无中断的，连续的
  chrono-  [前缀]用于组词表示计时相关的词
        /data/data/com.termux/files/home/../usr/include/c++/v1/chrono
  取消，回退，后悔，调头，回溯
    rollback 卷回
    后悔
      regret
      repent
    取消
      cancel 取消（预定）
      abort 流产，夭折，终止
      draw back
      annul/disannul 废止
      repeal 撤销，废除
      revoke 吊销，撤回
      discharge
      withdraw 提取，撤销
    回退
      backspace 退格键
    后退
      fallback
      give away
      step back
      draw back
        drawback 缺点，弊端，故障，障碍
      backstep
      recession 退却，退离，（占领地的）交还
      regression 倒退，退行
        regress后退 <--> progress前进
    调头 回溯
      turnaround 回转
      back tracking 回溯法
      backtracking 沿原路返回
  预定 预订
    reserve 保留
      booking/reservation 预约 预订
    preset 预置，初调 #类似 default
      ?preplace
    preliminary 初步的
    predefine 预定义
      predefined
    prearrange 预先安排
    preplan [动词] 预先计划
      preplanned
      preplanning 预先计划，前规划
  中途 预告 预感 宣布claim 占领 独占 识别，锁（禁止回退），不归路，单行道，不能调头，不能回溯
    intermediate 居间的，中间的，中等的
    halfway [adj/adv] 不彻底的/不彻底地
    midway [adj/adv] 在中间
    stage 阶段，舞台
      staging 分期，上演
        staging station 中途站
      staged 分期的，分段的，阶梯式
    预感
      forefeel
      premonition
      presage
      presentiment
    提前
      beforehand 预先
      preact 提前
      延期
        postpone/delay 延迟
        defer 推迟
      提早
        early
        advance
        premature 早产的，草率的
    加速，加快
      boost 助推，哄抬，增产，力捧，鼓吹，推荐
      speed-up 加速
      acceleration加速，促进<--> deceleration减速
        accelerate加速，促进[动词] <--> decelerate减速
        accelerated 加速的，早熟的
      hasten 催促，匆匆
      expedite 速办
      stepped-up 加速的
        step up 提升，逐步增加，升压；登上
      quicken 加快

    one-way 单行的，单向的，单程的，自私任性的
      <--> two-way 双向的，两用的
      one way entrance 单行入口
      one way traffic 单行交通
      one way street 单行道
  独占，垄断，排他，独霸，霸占，所有权，主权，私有，拥有，占有，占据，修剪
    monopoly 专有，专卖，专利，独占权
    monopolize 取得垄断
    monopolization 独占化
    排他
      exclusive
      exclusion
      sole 独家的，单身的
        sole licence contract 排他性许可证合同
        sole and unconditional ownership clause 所有权独有条款
    独霸
      dominate 占优势，威压，操纵，支配
    occupy 霸占，占有，占据
    主权
      sovereign 自治的
      supreme 最优的，最高的，最权威的，极端的，终极的
        supreme power 统治权
      supremacy 霸权
    所有权
      ownership
    私有
      private
    修剪
      prune 修剪，简洁
        pruning
      shave 剃
      trim
      clip

  assist 帮助
  mission vs task
  request 申请
    response 应答，响应，灵敏度，反应，回答
  acquire 获得，捕获
    <--> release 释放，发表
      #publish 发行，发布
      #distribution 散布，销售，流通
    resource managerment
    RAII ===‘‘Resource Acquisition Is Initialization’’
  claim 断言，主张，要求
  parallel vs switch vs choice vs alternative
  staged premature accelerated/early failure/success detection conditional pruning exclusive series(backtracking two_way series, exclusive monopoly one_way supreme series)
  ===
  decide 决定
  frame 框架，帧
    stack frame of func to hold automatic object
    automatic vs static vs thread_local vs free-store vs temporary
  operation 效能，作用，业务，工事，操作，运算，实施，运转
  合作
    coordination 协调，对等关系
      coordinate 坐标，坐标系，配位，配价的
    cooperation 合作，协作，互助
      cooperative 非常常用
      cooperate[动词]
      我觉得 强调 协调运转，环环相扣，过程性，并行
    collaboration 合著
      collaborate[动词]一起工作
      我觉得 强调 共同努力以得到一个结果，结果性，可能串行
  serial 串行的，串联的
    serialization 串行化
    series
  并行，并发
    parallel 并联的，并列的，平行的，并行的，并发的
      parallelism[名词]并行性
      时间点上有重合
    concurrent 并行的，并发的
      concurrency[名词] 并行性，并发性
      时间段上有重合
    coincide[动词]同时发生
      coincidence[名词]
    同步 异步
      #chrono- 计时
      #syn chrono us
      synchronous 同步的，同期的，同时的
      asynchronous 异步的，不同期的，不同时的
    simultaneity 同时性
      simultaneous 同时的，联立
      simultaneously 同时地
      ===
      vs simulate[动词]模拟，伪装，仿真
        simulator 仿真器，伪装者，模拟程序
        simulation 赝品
    collateral 旁系的，附属的，次要的，侧的
      lineal 直系的，正统的
      branch分支 vs trunk主干 #stem 茎，干线
      次要
        secondary 次要的，第二位的，衍生的，从属的，辅助性的
        subordinate 下位的，下级的，附属的
        accessory 补助性的，附带的
        auxiliary 辅助的，协助的，补充的，备用的
        minor
        side effect 副作用
        collateral
        non-dominate
        non-essential
      主要
        main 主要的
          mainstream 主流
        chief 最高的，最重要的，最大的
          ?supreme
        major 多数的 <--> minor 少数的
        principal 首要的
          prime 第一流的，原始的，根本的
          primary 初等的，初步的，初期的，原始的，第一位的，根本的
        ruling 支配性的，占优势
          ?dominate
        key 关键的，基本的，重要的
          key link 主要环节
        leading 卓越的，领衔的
          leading role 主角
        essential 必需的，本质的
        basis/base 基础，基准
        mass 主要部分，质量
        master 主要的，支配性的
        prevailing 流行的，优势的
        cardinal 极重要的
  efficient 有效率的
    coefficient 系数
  category 范畴，种类
    ?class
  material原料，资料 vs resource资源
  product产品
  parameter 参数
  contradiction 矛盾
  碰撞
    collision[名词]
      collide[动词]
        vs conflict 对立，争执，斗争，冲突
      collision-free
    crash 垮台
    impact 冲击
    knock 敲击
    bump 冲撞
    impinge 碰到，侵犯，影响
  -free
    smogfree 无烟的
    carefree 不关心的，不负责的
    taxfree 免税的
    collision-free


  promise + future
    promise 承诺（做某事）指望，可能性
    compromise 妥协
    future 未来，远景
  无限制
    unlimited 无边际的，无限的，极大的，过度的
    unrestricted 不受约束的
    unrestraint[名词] 放纵
    unbridled 不羁的，无束缚的，放纵的，蛮横的
    unconfined 松散的，自由的，无拘束的
    unbounded 无边际的，无止境的
    open-end 开放的，可广泛解释的
      open end licence 开放式许可证
      open-ended 有无限多的，可扩充的，可扩展的，开口的
  超长
    * 超过额定长度，超过允许长度 extra-
    * 超级长的，非常长的 ultra-
    overlength
      over-length
    superlong
      super long
    extra long
    ultra-long
    lengthy 长久的，漫长的，冗长的
  extra- 额外的，临时的，特别的，格外的，另外的，超出的
  ultra- 极端的，偏激的，过度的
  flow 流动
    data flow diagram

  qualified 合格的，适任的，通过检查的，有资格的；有限度的，受限制的，受限定的
    ##qname-受限定的标识名，被限定词修饰的标识名
  受控的，受管理的，受管制的
    受控
      controlled
      influence[名词] 有影响力
    管理
      administer[动词] 统治
        administrative operator 管理操作员
      rule [动词] 统治
      control 管制
      manager 经营
      direct 指导
      superintend 监督
      supervision [名词] 监督
        supervisor 监督者
        supervisory [err:受监督的？]还是[yes:作为监督者的/用作监督目的的/监督用的？]
          #类似 monitor
          supervisory operating system
          supervisory program 管理程序
    控制
      control
      master 驯服
      bridle 抑制
      curb 限制
      dominate 支配
      govern 治理
      manipulate 操作，窜改  #篡改？窜改？
      cybernation[名词] 电脑控制
        cybernate[动词] 使受电脑控制
        cyber- 网络/数码/电脑
        cyberpunk 网络朋克

    管制
      restrain 克制，羁押
      surveillance 看守，监视
    监控
      monitor 监控器
      supervisor
        supervisory
      watch dog
    维护
      maintain[动词] 维修
        maintenance[名词]保养
          upkeep
      conserve 节约，保存
      preserve 保持
      safeguard [动词]防护 [名词]保护装置
      uphold 支持
      defend 保卫，辩护
      assert 坚持，断言
      service 服务
      working 实用的，现职的
      attendance 看护
    被占领的，被占用的，被分配的，被瓜分的，有主的（无主之物）
      ownerless 无主的
      荒地
        wild 野生的
          <--> tame 驯服的
          <--> cultivated 被 耕作/栽培/养殖 的
        barren 不毛的
        wasteland
      lord 领主
        lordless 无君主的，无丈夫的
      host （待客的）东道主，寄主
      ruled 直纹的，带方格的
        unruled 未统御的，不带方格的
      圈地
        enclosure 圈地，围场
          <--> common 共有地
          enclosed 闭式
            enclosed area 封闭区
  中继
    relay 继电器，接班人，转播
    retransmission
    repeater 中继器
      repeating
      trunking #trunk- 长途
  篡改？窜改？
    窜改 原文/账目
      改易（文字）:窜改旧史
    篡改 历史/经典/政策/理论
      用作伪的手段对经典﹑理论﹑政策等进行改动或曲解。

  union
    anonymous union #匿名
    tagged union === discriminated union
      #mine:cased
    new(&s) string{ss};//placement new: explicitly construct string (§11.2.4)
  lollipop==lollypop 棒棒糖



to read:
  book:C++
    '/sdcard/0my_files/book/lang/C++/The C++ Programming Language(4ed)(2013).pdf'
      e others/book/The\ C++\ Programming\ Language(4ed)(2013).txt

    download: cppreference.com
      termux
      update clang c++20
TODO:
  def:[并联串联]
    语法+数据结构，指令，偏序（有向无环图，类继承关系）
    语法+数据结构:
      并联-空间上的重叠-union 并集
      串联-空间上的先后顺序-direct_product tuple
    指令:
      并联-时间上的重叠-并行
      串联-时间上的先后顺序-串行
    偏序:
      并联-偏序无关
      串联-偏序大小

  class grammar:#parser/recognizor
    @input_filter(f...)
    @plain_token_name #rsymbol
    def token_name(sf, /)-> None#not callable after @plain_token_name
      #或 istream -> position -> tmay token
    @output_filter(f...)
    @plain_rule_name #lsymbol
    def rule_name(sf, /)-> rhs

    @switch_rule_name
    class rule_name:
      def branch_rule_name

    #arg = data_arg | symbol(lsymbol/rsymbol, plain/arged)
    @input_filter(f...)
    @template_token_name #rtemplate
    def token_name(sf, /, *args)-> arged_token_name
    @output_filter(f...)
    @template_rule_name #ltemplate
    def rule_name(sf, /, *args)-> rhs #after @template_rule_name become: (*args) -> (arged_rule_name :: () -> rhs) #lazy call && hashable <<== recur ref

    obj used in grammar:
      look_ahead(post_rule_seq) <: ignore
        ignore: match and discard output, as-if output not in init seq output
      try_enter(pre_rule_seq, post_rule_seq)
        pre_rule_seq success ==>> forward decl I match!
      token_tester #acceptor, set, required for arged_token
      filter for data flow
      field-name@series ##idx?
      branch-name@parallel
      ===
      istream<token> .tell/seek/truncate_before/read_le/peek_le
        token.rsymbol #token is not rsymbol!!
        cache symbol match result at posotion until pruning backtracking
      ===
      left-recur ?? recursive-recognizor?
        left-recur detect for grammar&&runtime-parsing/recognizing
          NOTE:look_ahead create a branch
      ===
      mutual exclusion parallel     __or__ |
      priority choice/switch        __true_div__ / #__rshift__ >>
      plain series                  __mul__ *
      predictable series            __mxmul__ @  #__xor__ ^
        parallel vs switch vs choice vs alternative
        staged premature accelerated/early failure/success detection conditional pruning exclusive series(backtracking two_way series, exclusive monopoly one_way supreme series)
          no plain series
          early-success-detection-series(backtracking-subseq, err_msg, exclusive-subseq)
            premature-series
            early-pruning-series
              zero-consume match can decl pruning-or-not
              look_ahead 模式 标志位:完全匹配、直到修剪信号、非零消耗
          parallel(alternatives, err_msg, *, ordered:bool)

    is_symbol
    is_lsymbol
    is_rsymbol
    is_template
    is_arged_template
    is_partial_arged_template

TODO:
  path naming: dir vs file
    if dirname ends with "/":
      ${dirname}/{relative_path}
        ==>> sep = "//"
      path_sep = dir_end + join_sep + relative_begin

  lang:
    ====
    def:[约束的产生]
      约束 可以 很容易的 声明，并用于 推导
      但它如何产生？
      显然是有 具体的实现细节 逐步构建而成
      这并不容易，只能 假定 一些虚拟属性，冻结 某个时刻的对象的值，然后 忽略 非局部性的作用，进行一些粗略推导，以得到 约束
        而是否停机（无死循环/无限递归）更难，通用编程领域里通常不予考虑
          但在特殊领域，如 编译期计算（constexpr, type construction, type pattern match）必须停机！
          归纳法？收敛？发散？
    ====
    def:[API_ABI]
      什么是API？有别于ABI，关注的是用户代码的不变性，即与API的实现无关
        如:声明 类公开数据成员，但它的实际定义是类似C++的数据成员 还是 类似python的property，对API并无影响
        C++头文件 保护 ABI信息 甚至更多，并不完全合理
        可以 分离出 API 用于 维护 用户代码不变性 / compiler
          __api_decl__
        可以 分离出 ABI 用于 维护 用户可执行文件不变性 / linker&loader
                __abi_decl__
        API 描述 高层关系、约束，逻辑上的必然关系的定义体，公开规范的人为定义
        ABI [type_erase][physic_sort] 即使是 底层接口 弱类型 仍是 有类型 即 physic_sort
          physic_sort: 如: 对象指针，函数指针，数据成员指针，它们分属不同的 physic_sort，在弱类型的ABI接口中，physic_sort扮演重要角色（即 作为 更大颗粒的数据类型）
          如：python 的 object-reference 如何 取出 object.__class__.__getattribute__ 以便 进行 完全受用户定义的__class__控制 的操作。
            如何 取出 就是 physic_sort，它是一个协议:
              reference 如何 解引用 得到 object 地址
              object layout 如何 存取 __class__
              __class__ 如何 取出 __getattribute__
                显然 不能 无限 循环
                至少 py::type 要有 明确 取出 __getattribute__ 的 方法
                实际上，python 明确将 特殊属性 直接 保存在 __class__ 里。即 均明确 取出 __getattribute__ 的方法，所以 无需 先取出 object.__class__.__class__
        physic_sort 作为 协议/约束，显然也是有 偏序的
          比如 上面的 python::reference 很可能 细化 shared_ptr的physic_sort
            shared_ptr的physic_sort
              描述了 占用内存的大小+对齐，如何 复制/移动/赋值/析构

        # 前瞻接口声明
        # 类公开成员
        # 类关系: 继承关系
        # 约束:
        #     如:static_assert(std::is_pod<T>::value, ...)
        #     由于 T 定义 并不完整，ABI不全，故此 约束 只能用于推导。只有 最后 配置 实现 时 才能 用作 对 T 的检查。
        # 必然性定义体
          #see:[必然偶然]
        # 某些 ABI 声明:
        #     如: 声明 X 是 physic_sort
        #         声明 S,T 符合 X
        #         这样一来，S 与 T 之间 就有了 某种 逻辑上的必然联系
      idea 4 c++?
        def:[big_ptr]
        big_ptr = {.data_ptr, .ops_ptr}
          ops_ptr -> ops:: physic_sort s.t. decltype(big_ptr)
            ops is static
            ops for subobj/baseclass is a subobj of bigger ops
            e.g. ops = {.decl_type_info, .ops_offset_at_derived_most_obj_ops, .?ops_offset_at_whole_obj_ops?(not required), data_offset_at_derived_most_obj, data_offset_at_whole_obj?, pvtb(ptr_to_virtual_function_table of decltype(big_ptr))}

    ====
    常量/资源
      def:[必然偶然]
      真常量:
        #必然性相同
        公开协议参数
        数学公式参数
        文件格式参数
        ...
        枚举类型~头文件~API~程序员之间的协议
      可配置的常量:
        #偶然性相同 #named-obj/value 之间的 is/== 关系，也有 必然/偶然 的区分
        #这些实现相关的细节信息 不该出现在 头文件 里，可用 编译期函数提供（该函数必须显式表明自己的返回值 并非真常量）
        机器字长~移植性变化
        字符串字面常量的地址
        可翻译的文本/日期/带单位数据~地域性变化
        默认值~可重置，除非是API的一部分（公开规范）
        测试数据
          测试用 的 数据 的 集合 有很多，只是偶然选中当前 样本
        样例数据 #提供几个有效参数做示例
        版本号
        ....
        历史数据
        物理公式系数
      什么是『必然』？
        其实 只有 两样:
          * 定义
            各种 数学对象，它们的 定义 也就是 公设
            各种 规范标准、协议、API、文件格式...
            高层对象 之间的关系: 如 类继承、有哪些公开成员...
          * 从定义出发推导出的逻辑结果
      历史 与 物理:
        历史记录 以后 可能订正
          历史文本 古代书籍 可能更新/或有 很多版本/底本/变体
        物理 皆是 测量值，有误差
      C++ 赋值两个相同 字符串常量，它们的地址是否相等？依赖于实现
        当进行 == 测试时，可 返回 不确定值//并行态（既真且假），见下面xbool
        其实 C++ 头文件 并不只 包括 API，还包括 ABI，甚至更多。这显然是『实现依赖』的，并非出于逻辑上的必要。当用 类型 定义变量、声明成员 时，其实 并不需要 完整定义，只需 前瞻性声明 即可。如果 使用 公开成员，那也只需 公开部分的API，私有部分是实现细节 并不需要 出现在 头文件 里。
      『保证』
        所谓『保证』，有其前提。
        比如，这个 版本 的 语言标准 保证
        比如，这个 版本 的 编译器 保证
        比如，这个 版本 的 平台/操作系统/虚拟机 保证
        除非 前提 成立，否则 不必然
        检查 前提 其实 就是 分支版 的 『实现依赖』
      forwarding_reexport:[转发式重新输出]===转发引入名作为输出名
        这种情况 如何 区分 必然偶然？
        分情况:
          * 必然性 API 声明 一般都是 必然性转发
            但 注意到 声明 也是 有 层次的，某些声明 就像 不完全定义体
          * 必然性ABI声明、必然性定义体 的 转发 可能是 偶然的

    ====
    tag everywhere: require pseudo-import to decl the meaning of tag
      syntax: {[}tag{]}
    vs inline comment: {-[}inline comment{]-}
    ====
    alias pattern && reversable alias pattern
      we can easily go from left to right by alias-def given alias constructor+args(pattern match args on lhs of alias-def)
      but how can we go from right to left?
        reversable ==>> alias is injection/互斥
    using alias, we can simplify construction that use original constructor
    using reversable alias, we can simplify pattern-match that use original constructor
    ====collision-visibility of identifier
    成员名 防碰撞（多继承）
    函数 命名参数 防碰撞（多转发）
      变量名 肯定是 不够用的
      至少 也得是 路径名/qname=qual_name
        可用 symbol/object 'is'
    私有/可见性控制
      无论是 class/pkg/namespace 都很重要
      对外 要完全 不可见，如同不存在，而非 只是 禁止 使用。禁止 使用 意味着 可见，意味着 碰撞。
    ====collision-公开的成员名 防碰撞
      * using qname，qual_name, qualified-name
        见下面 包名 防碰撞
      * using parameterized identifier
      parameterized identifier
        def:[参数化标识名]
        参数化 标识名: 参数 可以是 任何 编译期的值，相等+读写（<->文本），包括:类型、参数化标识名。重点在于 标识名 并非 字面 值，允许 参数 实例化 时 使用 引用 变量名/别名，甚至 参数化标识名 本身 也可 alias
      ===参数化标识名 vs 参数化模版名
      ===参数化标识名 只命名 唯一一个 标识 vs 参数化模版名 命名 所有潜在组合（导致 不能 作为 虚函数 名）
      encoding identifier/complex identifier
        embedding type-name:
          f[T]<S>()
          S~template arg
          T is part of whole identifier "f[T]"
          why?
            #err: virtual g<T>()=0;
            virtual g[T]()=0; //ok!
      ====
      标识-参数-自定义 .xxx.xxx
        分解 标识:
          py.unittest test_xxx
          listener.on_xxx
          set_xxx/get_xxx
        自定义 静态 __getattr__
          如: x..f(...) = {x.f(...); return x;}
            ==>> x..f(...)..f(...)
          __getattr__ 通常 需要 分解 标识
        可用于 metaprogramming，复制 整个类 的 公开成员函数，用于 实现 ref
      ===
      参数化模版名 可用于 命名 私有标识，只要 某些 参数 是 私有类
        私有标识 可用于 框架宏 在 展开处 就地 定义 私有变量，以防 与 用户变量名 碰撞

    ====collision-unbounded-ultra-lengthy-identifier
      无限制超长标识名
      unlimited, unrestricted, unbounded
    包名 防碰撞:
      当前 包名 这么短，必有 独立提出 并发生碰撞的。随着时间的推移，代码数量剧增，顶级包名 必然 越来越长
        问题 只出现 在 完全 开放空间，不特定 人员/团队 不特定 时期 不受控地 自由使用/占有 包名，相当于 并行编程-数据竞争
        问题:如何优雅地使用 长度极长的包名？包 安装？包 引用？
      hname = huge_name ~ 几无可能 碰撞 ~ 防碰撞机制的唯一根源
        唯一的 目的是 有别他人，不需要 明显的 含义(如:库用途，与 库内容 无关！，库相关 命名 当在 非开放空间之下)
          #？第一行 是 nname？
          作者团体标识，库创建时间，地点，随机数
        #xxx #under __subspaces__/.../.../.../
        #xxx #under __open_space__/.../.../.../
        under __ospace__/.../.../.../
      nname = nickname/agname/byname 略称/简称/绰号 ~ 极大可能碰撞
      msuffix = manually-choosen-collision-free-suffix
        路径名 里的 nname[msuffix] 只能是 以使用它的 库 的位置为基准 向上搜索 先辈，不能搜索其他！也即 向下 公开，对外 私有，非API。但 alias 是以 路径名 前缀 为 基准，属于 API 的 一部分，也区分为 必然、偶然，必然 则 连同 定义体 都是 API 的一部分，偶然 则 只有 alias 存在性声明 是API的一部分，定义体 可能 更改/可配置/可替换。
          see:[必然偶然]
      rsuffix = auto-choosen-collision-free-random-suffix
      cname = controlled-name
        #xxx #under __subpackages__/
        #xxx #under __controlled_space__/
        under __cspace__/
        under __pspace__/
      pspace = private controlled-space #__private_controlled_space__
        enclosed space + invisibility
        有主受控秘藏空间
        路径名？ 必须 与 公开 空间 区分开（受控私有空间，受控公开空间，开放公开空间）
      cspace = controlled-space #__controlled_space__
        enclosed space + visibility
        有主受控公开空间
      ospace = open-space #__open_space__
        common/wild space + visibility
        无主众竞公开空间
        ### xxx ### e.g. for others to fork and ...impl his variant to same API
        e.g. 大地域/大团体 分配 空间 给 子团体
      nsroot = namespace root
        #xxx #__root__
        #__nsroot__

      包自动管理:
        即:下载，安装
        依 本包 前缀 寻路，本包 既然 使用 hname，则 父空间 是 开放的 无限制注册空间
        安装于: 父空间-根目录/__ospace__/{nname}/{digest}/{随机名-同目录区别而已}/
          #本包 根目录
          #hname_pkg
          ===
          __hname__ #文件，保存 hname # 声明/输出 export hname #../*/__hname__ 的 值 作为 键值 必须 唯一
          __nname__ #文件，保存 nname，冗余 检查 __hname__ 第一行
          __digest__ #文件，for __hname__, 方法名+摘要<方法名>(hname) #用于避免 依赖庞大无限制更新的 只增不减 摘要库 或 只能 使用 固定有限的几个 古董摘要库 # 直接用做 {digest}/ 目录名 #受文件系统规范，只取最大前缀，其长不超过系统限制
          __encoding__ #文件，for __nname__,__hname__,__digest__
          __cspace__/ #含 本包 所有 子包根目录 及 子模块文件
            #cname_pkg
            {子模块名-module-name} #文件，模块
            {子包名}/ #{子包 根目录}
              #无 __hname__, __imports__, ...
              __cspace__/
              __ospace__/
          __ospace__/ #含 本包 所有 子空间 的 根目录
            {子空间-nname}/{digest}/{随机名}/...recur def...
          __imports__/
            {他包-nname}/{本包 作者 手动 选的 防碰撞 后缀-msuffix}  #文件，保存 输入包/他包 的 hname
        定义目录类型:
          ==举例:
          开放空间:
            #xxx #如：源代码根目录/
            #如：__ospace__/
          受控空间
            #如：__cspace__/
          长名包
            #如：__ospace__/{nname}/{digest}/{rsuffix}/
          短名包
            #如：__cspace__/{cname}/
            #xxx #如：__cspace__/{cname}.{ext}
          ==定义:
          源代码根目录/ #xxx <: 开放空间
            #禁止出现 __hname__,__nname__,__imports__/
            #禁止出现 __cname__
            #禁止出现 __cspace__/,__alias__/
            __nsroot__ :: 空文件
            __ospace__/ :: 开放空间

          开放空间/
            #xxx #禁止出现 __nsroot__
            {nname}/{digest}/{rsuffix}/ :: 长名包
          受控空间/
            {cname}.{ext}
            {cname}/ :: 短名包
          长名包/ <: 短名包
            #禁止出现 __nsroot__
            #禁止出现 __cname__
            __hname__ := hname
            __nname__ := nname
            __encoding__
            __imports__/
              {nname}/{msuffix} :: hname
            #以下 与 短名包 相同
            ...包文件夹共同内容...
          短名包/
            #禁止出现 __nsroot__
            #禁止出现 __hname__,__nname__,__imports__/
            __cname__ := cname
            #以下 与 长名包 相同
            ...包文件夹共同内容...

          ...包文件夹共同内容.../
            __version__/
              {version}/
                __后顾性兼容__
                  #声明 兼容哪些旧版本
                  #声明 哪些部分 应该 废除
                  #     新用户 使用 新版本 时，可有 两种引入模式: 完全兼容旧版，不完全兼容旧版
                  #为保证 引入 文件 未被窜改，各处引入语句需添加 ((路径名+版本+其间{nname[msuffix]:hname} 或 完全展开后的路径+版本)+被引用的文件的内容)临时变换后的 散列值
                    #完全展开后的路径 是 模块的隐含输入，它绝对如何解释nname[msuffix]
                  #为保证 本文件 的 位置 未被移动，需声明 本文件 完全展开后的路径+版本 临时变换后的 散列值
                __export__
                  #声明 输出哪些 包/模块 及 版本，只有 选中的，才是 可见的
                __fork__
                    # fork-branch #声明 继承 别的包 的 哪些版本的实现
                __abi_decl__
                    # see:[API_ABI]
                __api_decl__
                  #re-impl-API #声明 实现了 哪些 别的包+版本 的 哪些 API

                  #声明 本包 API #输出 本包/本模块 的 哪些 对象
                    # see:[API_ABI]
                __module__.{ext} # 本包作为 模块
                __main__.{ext} # 本包作为 主模块
            __pspace__/ :: 受控空间
            __cspace__/ :: 受控空间
            __ospace__/ :: 开放空间
            __alias__/
              {alias} := {路径名}
                #set curr pkg, then rhs to 绝对路径名（且是标准的:不含alias/向上后续路径）
                  #acyclic 防循环

      引用 他包 的 本包内的 代码/本地命名:
        {他包 前缀}/{他包-nname}[{msuffix}]
          #开放空间 搜索 __ospace__/
        {他包 路径}/{他包 子包名/子模块名}
          #非开放空间 搜索 __cspace__/
        #不存在 全局命名，如果有，那 只能 直接嵌入 hname，只能是 机器 理解，对于 人 来说 可读性 差
        路径名 格式:
          # qname，qual_name, qualified-name
          # regex".*:" ==>> 开放空间 #__ospace__/
          # regex".*[.]" ==>> 受控空间 #__cspace__/
          # regex".*\]" ==>> 长名包
          # regex".*\w\>(?![\[\]])" ==>> 短名包
          #
          路径名 = 绝对路径名 | 相对路径名
            绝对路径名 = ///:{开放空间后续路径}

            许空相对路径名 #许空
              = 相对路径名
              | "" #空
            相对路径名 #非空
              # 独立 或 在 长名包/短名包 之后
              = .{受控空间后续路径} #『.』当下的最近先辈__cspace__
              | :{开放空间后续路径} #『:』当下的最近先辈__ospace__

            受控空间后续路径 #许空
              # 不独立 且 在 受控空间 之后，而 受控空间 必然 从属于 包（长名包/短名包）
              = 向上后续路径
              #受控 向下
              | {cname}{许空相对路径名} #『cname』当下的短名子包
              ##特殊:结束，解释别名
              | "" #空
              | ${alias}{许空相对路径名}
                #在指定位置的别名
              | $?{alias}{许空相对路径名}
                #在指定位置的向上搜索别名

            开放空间后续路径 #非空
              # 不独立 且 在 开放空间 之后
              = 向上后续路径
              #开放 向下
              | [{nname}[{msuffix}]]{许空相对路径名}
              | [[[{hname}]]]{许空相对路径名} # 上面的展开式 # 机器交换用 全局极长唯一命名
                #hname 与 cname 在不同 命名空间，哪怕 值相等 也不 发生 碰撞
                #但 {cname}/ pkg(__module__.{ext}, __main__.{ext}) 和 {cname}.{ext} module 发生 碰撞？

            向上后续路径 #非空
              #向上
              = {相对路径名}
              | ?{cname}{许空相对路径名} #『?cname』按名搜索当下的最近先辈__cspace__
              | ?[{nname}[{msuffix}]]{许空相对路径名} #『?[nname[msuffix]]』代码所在包 向上搜索 先辈__imports__/，以得到 最近 符合 该 略称 的 hname，在于 目标路径上 向上搜索 该hname
                ###bug!!! 中途跳过的先辈 再版可能 提前 截胡 nname[msuffix]!
                ### 所有 nname[msuffix] 只能在 最近的 开放空间/受控空间 里 搜索！不能fallback到更上的先辈 # 或 显式指出 具体向上跳过几个 开放空间/受控空间
              | ?[[["{hname}"]]]{许空相对路径名} # 上面的展开式



    ====
    初始化函数 分割:
      + 检查输入是否符合 前置条件 （可能 异常）
      + 构建数据成员的临时副本（不该 出错，或者 异常 作为 前置条件 的一部分？）
        # 分割的意义何在？在于减少 动态检查，这里的初始化 跳过前置条件检查，而将它们的这些前置条件 添加到 上面的 本类的前置条件，合并精简
      + 检查 类类型不变量（不该 出错，或者 异常 作为 前置条件 的一部分？）
      + 移动赋值给数据成员（无错）
    =====
    xbool = true|false|wait|err
      xbool-推导
        * 有限步
          不相容-既真且假
          无关-不真不假
        * 不停机
          计算未结束-可能真可能假
      wait={true,false}0b11/待确定/计算中/并行态/偏序相等{<=,>=}
        整数素性判定-快速测试 未成功
        连分数比较/带误差浮点数比较
          无穷长连分数 相等时 无法判定
          浮点数 误差范围重叠，也无法比较
        实现依赖 的 结果: 见上面 两相等字符串常量地址是否相等？sizeof(int)==sizeof(long)？既真且假，并行态
      true={true}0b10/偏序大于{>=,!<=}
      false={false}0b01/偏序小于{!>=,<=}
      err={}0b00/出错/未定义/输入在定义域外/前置条件不成立/算法逻辑出错/偏序无关{!>=,!<=}
        除零
        整数素性判定-输入 非整数 或 0,+1,-1
    ====vs class/data invariants
    #conceptual property/attr
    #decl/build-up opaque-condition using opaque-condition-constructor via postcondition/class-invariants #check-func/class-constructor
    pre-post-condition:
      [precondition] -> [postcondition]
      ==
      [common-AND-precondition][...] -> [common-AND-postcondition][...]
        * [branch-precondition] -> [branch-postcondition]
        * [branch-precondition] -> [branch-postcondition]
        * [branch-precondition][...] -> [branch-postcondition][...]
          * [branch-precondition] -> [branch-postcondition]
          * [branch-precondition] -> [branch-postcondition]
    ====
    外挂接口的C++实现:
      // not good below, I shift to use data-member instead of iherit
      template<template m> class Monad : Functor<m>{
        template<typename i, typename o> m<o> operator >>=(m<i>&, std::function<o, i>&);
        template<typename o> m<o> return_(o&);
        private:
          virtual ...impl<m,i,o>...
      };




    [type_erase][physic_sort]
    type erase: reduce to physic_sort: ABI: aligment/size_of/copy/move/del are all the same
      java ref/builtin-types are have diff physic_sort, so type-erase-generic not support unbox type，i.e. the param for generic (typename) has type constraints too, that is physic_sort
    type param role: label-only, data(view, immutable, uninit, init, init_or_uninit_并行（禁止读写/构造/析构）..., impl whole alias)
      how role to cooperate with tag?
        tag: e.g. const in C++
        template: e.g. char* <==> ptr<char>
        what role of char for ptr<char>?
          <<== what relationship about ptr<char> and ptr<const char>?
            单向隐式就地转换(仅静态类型声明更改，无任何动态动作)
            physic_sort are the same
      Functor newtype : fmap <==> static_cast
    IO <: MemberAssign <: MemoryWasted/Consume <: Monad
    IO <: DateTime/Abs-Clock <: TimeSpan <: TimeWasted/Consume <: Monad
    IO <: GlobalVarsAccess <: GlobalImmutableVarsAccess <: Monad
    ===
    lazy_ref = ???
    top_ref = shared_ptr4top_owener
      shared_ptr -> block{.shared_count, .weak_count, raw_ptr, destruct_free_mem_func}
    sub_ref = {shared_ptr4top_owener, raw_ptr4this_data}
      sub_ref.x ==>> shared_ptr4top_owener not change, raw_ptr4this_data change

    shared_ref = top_ref | sub_ref
    inner subdata impl type = boxed-top_ref | boxed-sub_ref | unboxed-local_member_room | unboxed-raw_ptr (as-if unboxed what the raw_ptr ref to)

    data cycle prevent?
      immutable nonlazy data property := any ...
        #part construction before whole construction
      mutable or lazy data property :=
        #part construction may not before whole construction
        | weak_ref
        | in_use_ref  #可配合 shared_ref/unique_ptr，但这里unique_ptr的实现 更复杂，类似shared_ptr，只是共享计数的值只能为1，故可省略，不能支持weak_ref？但可支持更弱版的weak_weak_ref，不能取出shared_ptr/in_use_ref，但能检测是否还存在，比较是否相等，散列，甚至大小？，需要weak_weak_count?（两版本，有/无）, in_use_count (无需shared_count，weak_count)
          #like weak_ref, use count, not share ownership
          #but weak_ref can point to nullptr
          #     in_use_ref assume 'data in use' like usage of raw_ptr to local/stack/call-frame var
          # in_use_ref neednot detect nullptr when dereference
          # when shared_ptr decide to delete data, and found in_use_ref exist, abort()
          # save src location(shared_ptr->mk in_use_ref) info to show at abort()
          #     how to generalize this src info access idea?
        | raw_ptr to static-obj
          #到底是 变量的类型 本身 只能用于 定义 静态变量
          #还是 raw_ptr 的约束，只能 指向 静态变量？
          #泛化: 仅本线程可用的类型，raw_ptr to thread_locals
          #泛化: 同时定义帧？线性定义栈？生存期覆盖？
        | change only to spec-branch (e g. nullptr ==>> FIFO-doubly-list(backward using weak_ref, head in, tail out)) ... type-dec-tree-disjoint-branch but can init with anything???
          #init always ok
          #cycle occur only at member/field/property/attr [any-depth] assigment
          #
        | ???constraints on lazy
          #global-data-flow-check?
          #     every func: input, output, nonlocals/globals, which var (whole or part?) put into which var tree?
        | type-strictly-decrease-for-same-type-constructor-in-tree{edge=non-weak_ref}
          ==>> all datatype complete, not only forward decl # or using forbidden set? 外部约束-针对 不透明/未声明 的那部分数据成员
            ==>> no open-inherit #开放式继承 成员数据无限可能
            ==>> no func/lambda #函数的实现 引用静态变量 绑定局部变量，无限可能
              #函数 都是静态变量，只是绑定的数据变量 不同，函数允许 循环引用（用于 递归）（反正 所有 函数 只有 在程序结束时 才析构）
              ==>> 仅用于定义静态变量的类型 不需要 计数共享，允许 循环引用，直接用 raw_ptr（也不用负责其析构）
                init order: using var member or only as-if-uninit-var-ref
                静态类型 分两个阶段: 全局变量初始化 完毕 与 未完毕 #甚至 具体到 某个 静态变量的某个变量 初始化 完成
                  析构则是反转这些阶段
            ==>> no sub_ref #owner is untyped
            ==>> if lazy: global? binding? forbidden set as template param ...


    call-frame, yield-stmt-position, func-impl-friend(known goto/yield-label, yield-output-type(cased by yield-position))
      "yield from" ==>> frames
    局部约束增强 vs 输出约束更改 vs 独占约束更改（如:inplace-new）
      声明于各个分支各自初始化
    约束 vs 模版参数:
      mx_mul(lhs, rhs)
      mx_mul<R, M, C>(lhs<R,M>, rhs<M,C>) -> mx<R,C>
        许多函数，虽然 可以 调用 free 以避免 代码爆炸，但 很难 用作 脚本/C-API/虚函数
      mx_mul(lhs, rhs){lhs.num_cols==rhs.num_rows} -> mx{mx.num_rows==lhs.num_rows, mx.num_cols==rhs.num_cols}
    hs::
      datatype 的 类型 与 值: 值构造器 是 有限的，受控
      Type 的 类构造器 是 无限的，开放
      受控:则 穷举遍历 case ... of
      开放:则 单独 实例化 + 类型推导 自动匹配: 接口与实现: class ~ instance
        vs C++动态多态: 各子类 实现 虚函数
        vs C++静态多态: 各特化模版 匹配不同 类构造器
        ===回想起来:我的Earlay?解析器 的 实现: 定义 接口，添加 新数据 到 接口 名下，监听器 将其 监听的接口名下的 新数据引起的 新组合 发送到 执行器（先送到 检查器，以确定 与 已存在的数据是否相容）
          其实 开放式 定义 也可 以此，先添加 前瞻性声明（用于 循环定义），再添加 定义体；后面 是 依赖之前 定义 的 定义。
          组合性接口:成员数据 正交 直积空间，全部有效 存在，并不需要另行声明
          关联性接口: 接口+实现（多种可能，所以需要人为干预，命名区分防碰撞）
            = 开放性接口 | 受控性接口
          开放性接口 关联一个 只增 序列/集合 以包含 不断添加的 实现
            如何处理这些 实现？什么时候处理？
              注册 监听器 检查器 执行器
          受控性接口 关联一个 固定 序列/集合
            ？一次性 完成 初始化？
              或 要求 在 结束处理（编译）前 必须 有 一个 封装 信号 表示 完成 初始化
            别的执行器 可判断 是否 已声明 该接口（存在性）？是否 完成 定义/初始化？如果 完整，则 启用 执行器 遍历/穷举/归纳处理。
          开放性接口 的 实现 在哪存取？
            很多关系 都指望用户 添加
            如: hs-class-instance
            这里 牵涉到 很多实体:
              实现者/用户/作者
              关系实例名=关系类名+关系实例参数
            这里 还牵涉到 模糊搜索:
              #用户 为避免 重新发明轮子，必然 需要 遍历搜索
              #在哪找？怎么用 程序 快速找？tag 特性 过滤？
              #数据库？
          提供多个 可替换的 配置文件（夹） 作为 代码的一部分，这样 编译器 指令 更有 含义（全都 指向 代码树，加上 编译命令 本身，再无其他不可见的额外信息）。
              see:[必然偶然]:[配置偶然信息]

  obj vs val
    obj ~ 析构/资源管理/IO
      decl has swap? copy-constructor? ==>> auto has assigment
      #move-constructor always auto
      iterater #st mutable/IO
    val ~ immutable
      StateMonad
      builtin data type #unboxed immutable value, no address
  decl-qual-kwarg + packed-args-kwargs to support foward call
    外挂接口 也是 kw:
      sort :: Ord a => [a] -> [a]
      <==> sort<a>(vector<a>&, *(Ord<a>)=...)
  decl-qual-member to avoid multi-inherit collision
  反转实现依赖:
    Functor a => Monad a
    Functor a <<== Monad a
      在缺少 Functor 的情形下，定义 Monad，则反过来 自动定义 Functor，但这样一来，Functor a 可能就有多个实现！
      其实若非自动生成，则 2 kw 参数 各自取 数据成员（相当于 取出依赖），也可能 不一致

  named value
    type is compile time value
    type-constructor is qual-named value
    when no address, qname is identity

  idea?
    unque impl
      e.g.
        forward decl
        hs::infix
        parameterized

    multi-impl
      e.g.
        abstract class / interface ~ derived classes
        type ~ objs
        template ~ specializations
        hs::class ~ instance
      naming?
        named
        parameterized
        ...
  idea 4 c++?
    another inherit hierarchy: just used as tag to classify subclass and offer default-value and requirements(abstract api/interface)
    the only problem of c++ inherit hierarchy is that multi-inherit require virtual baseclass, since there is a subobject has exactly type of the baseclass.
    the new hierarchy has no such subobject
  idea 4 c++?
    框架宏
      其命名 必需 依序包含 未匹配括号
    语句组/透明语句组（stmt_group vs scope） 只是一个 透明的组，并非 真正的 作用域
      可用作 框架宏 的 参数
      ？？？可用作 解包用 左值 声明:
        {int x, int y} = z
        {auto x, int y} = z
        auto {x, y} = z
      用作 被注释的 代码片段
        注释领头 解释目的，代码片段 随后缩进
        //反过来的情形也有
        //单行语句/语句组 领头，多行注释 随后缩进
  idea 4 c++?
    break 退出最近作用域，而非仅是loop/switch
    break + for/while/do/loop/switch/label...
  idea 4 c++?
    hs::newtype
    C++::class 添加 __this_type__
    这样，当用newtype定义新类型时，operator/成员函数 __this_type__ 自动 转向 新类型
    ？？？但还有很多问题：
      类继承关系？
      模版特化-类型参数角色问题#role

  idea 4 c++?
    all static (global/thread_local/static-member/static-local/...) as non-static-member in a virtual class
    we can inherit this class then overload some member, and pass its instance into func-call as implicit-param

  idea from c++.cin<< ?
    见上面 自定义 静态 __getattr__
    设计 新语法:
      x..f(...) ..g(..)
        #as-if return x
        <==>
          x.f(...);
          x.g(...);
      or:
        with x:
          .f(...);
          .g(...);

  idea 4 c++?
    约束: [logical-const] vs [physic-const] vs both vs recur-both
      * [logical-const]
        允许(私有)实际成员修改，但(深度)公开概念成员 不变
        c++::mutable
        synchronous/parallelism obj .lock()
        std::string::c_string()
          #在必要时，需附加NUL字符#不允许&s[0]
          #与vector::data()不同#允许&v[0]
      * [physic-const]
        不允许(任何)实际成员修改，但(任何)概念成员 可变（本身vs深度引用）
        只读存储器
      * both
      * recur-both
        ...
      强联系（拥有） vs 弱联系（索引）
        强联系（拥有）vs 直接成员
        弱联系（索引）vs 间接成员
      key@mapping
        绑定与否
        key 不变，但 mapping 本身可变
        ptr作为key，默认绑定内存空间，故指向的对象 有默认定义
        其他key基本 无法绑定特定mapping，所以 并无明确的 指向对象
  idea 4 c++?
    约束: [non-freeable/deletable-ptr]
      #like "const"
      not allow "free(p)"/"delete p"/"delete[] p"
      deletable_ptr can implictly convert to nondeletable_ptr
      get address "&x" always return nondeletable_ptr
      deletable_ptr of derived_class cannot convert to deletable_ptr of baseclass without virtual destructor
    idea 4 c++?
      member alias with diff tag
        distinguish use ?purperse?
    idea 4 c++?
      tag droppable/addable
      some kinds of tagged type can convert to non-tagged version
      some kinds of tagged type can convert from non-tagged version

  idea 4 c++?
    allow only loop/tail-recur/tail-mutual-recur
      to avoid call-stackoverflow
  idea 4 hs?
    datatype ==>> subdatatype
    比如：减少并联分支，成员类型 改成 子类型
    用途:
      nonempty_list
        datatype list a = empty_list | cons a (list a)
        subdatatype nonempty_list a <: list a = cons a (list a)

      partial_ordering
        datatype partial_ordering = LT | EQ | GT | NA
        subdatatype total_ordering <: partial_ordering = LT | EQ | GT

      datatype bit = O | I
      subdatatype bitO <: bit = O
      datatype integer = zero | nonzero_integer {sign :: bit, little_endian_tail_bits :: list bit}
      subdatatype natural_integer <: integer = zero | nonzero_integer {sign :: bitO, little_endian_tail_bits :: list bit}

  idea from c++.__file__/__lineno__ ?
    how to access src info?
  idea from py?
    混合使用，统一使用协议
    +=
      就地修改？mutable
      构建新值？immutable
    统一:
      返回 带新值的对象 #不确定是 新对象 还是 旧对象
      不再使用旧对象 #因为 不确定是 带新值 还是 带旧值


  构造器-匹配-区别-私有
    公开构造器
      检查约束，抛出异常
      变换参数，调用 私有构造器
    私有构造器===在线构造器
      ==>> 公开匹配器
      ==>> 别名匹配器
    标准构造器
      用于 == 测试: 每个等价类 产生 结构相同的 标准构造器树
    读写构造器
      即可对 参数进行相当程度的 标准化
      也必须 调用 公开构造器 以 检查约束
  静态多态/模版匹配 vs 动态多态/hs-class-instance:
    静态多态/模版匹配:
      可用 静态约束 区分 特化模版
    动态多态/hs-class-instance:
      要么 不使用 约束，仅靠 类型构造器
      要么 约束区分 也要 作为 参数 输入，静态 或 动态




  my argparser
    see:
      e ../../python3_src/seed/recognize/CmdlinePrefixParser.py



=====
钢琴 邮箱
  from 煎蛋:无聊图 from 网络
  钢琴住了几个妖，邮箱住了几个魔，魑魅魍魉怎么它就这么多




===============
层层压迫的稳定性
  在层层压迫的社会里，虽然大部分人都是受害者，却难以团结反抗，只因大部分人也是施害者。人们不去痛恨社会结构，而是痛恨自己没能站得更高。不论是追求自己现世更上一层楼、子孙更上一层楼，还是寄希望于来世投个好胎，这份压迫都无疑地在激发人们的积极性，社会整体而言反而是健康的。
法治亦人治
  法律规章，终究是人在执行。
  人们不愿做-大明诰？此一时彼一时，与时俱进。说一套做一套，潜规则黑社会。扔一本法典给猴子，猴群会怎样？
  人们做不到-规定选出一个人来完成所有生产劳动、开疆拓土保证每个人自由活动有无限资源空间，不与他人发生矛盾，其他人负责玩耍。这样一个完美社会如何？

私有
  团体私有知识
  法不可轻传
  保障自身安全-防止他人利用这些知识反过来危害自身（了解能力局限、发现漏洞破绽、军备竞赛）
  满足自身发展的需求-每一份投资都期待收获，从这里得到知识，理应为这些知识的增加做出贡献。
  私有 到底 好不好？合不合理？
  大多数情况下，外部环境是弱肉强食，私有合理。
  但少数人为的强力组织显式地屏蔽掉弱肉强食法则，公有 才有其生存空间。

量变到质变
  单纯数量的堆积，加上漫长岁月的演化，甚至能够自成天地，诞生生灵，乃至仙神
  何必为了炼制法宝而穷搜天地？天地这个无尽藏就在眼前。
  要是能掌控天地似操控法宝般如臂使指，也算得道。这是神道。
育种
  灵根可遗传，高阶修士生育率低
  大量圈养有灵根的凡人
青出于蓝
  这份传承十分凶险，原主极其骄傲，既然留下传承，必然要求传人青出于蓝，功法修炼过程绝不会四平八稳，因为初创他自己肯定没练过。
既受其利则受其弊
  既然依靠家族得了好处，自然也要牺牲自己去维护家族利益。不遵守规矩的人，便要受到所有家族的讨伐，因为这些家族正是靠着这规矩才能长存。
  --凭什么要帮理不帮亲？真到了生死存亡的时候，会与家族共存的人是谁？是这些讲道理的人吗？错！只有我们！不计利益不计生死。--你说得对。那我们是否要自绝于正道，合家举族充作杀人越货的强盗？我们是否已做好举世皆敌的准备？
  压力平衡
    扩张-稳定时边界必定压力平衡
      1. 外对内压力-外部环境险恶
      2. 内对外压力-兵力物资密度
      3. 向心力-个人发展资源的政策倾斜造成的梯度

市恩
  物资充裕时怎么搞都无所谓，但却需顾及大灾大难。在灾难面前，是携手共抗，还是互相鱼肉？互助者人，相煎者亦人。囤积有形易腐之物，使人生不均之愤，不值。

凭什么让我独自承受灾难？
  雪灾，南侵/内战/剥夺老弱病残的口粮，死够人抢够粮
  人道法则 公平 患不均
  一方有难八方支援
    同一件事，可以有不同说法做法，不管好听难听，本质不改

开宗明义
  --（野路子蛊师）突破炼蛊瓶颈:不能繁殖只能靠斗蛊来产生强蛊？效率太低！寿命短？在正常的外部环境中存活时间短？太折腾！改！
  --伤人伤己，作为威慑性的战略武器和大量低成本制造的临时性战术武器，最重要的禁忌是:避免反噬。事实是这些所谓的缺点一点都不自然，明显是人为的。你一生的成就其实只是在突破前人布下的禁制。聪明却未及根本。

奢侈品
  --闪闪发光的珠宝？艳丽多彩的皮毛？哼，女人！
  --削铁如泥的宝刀？耐用顺手的工具？哼，男人！

剑
  棍-兵器之祖
  刀-应用最广泛
  矛-低成本战阵用兵器
  弓-远程
    石
  剑-人文底蕴深厚-正直，忠诚，复仇
天
  这天乃是人道这片天！
    天听自我民听，天视自我民视 vs 天地不仁，以万物为刍狗
      天外有天，有好多重天，说的不是同一重天
      官府/朝廷/政府 - 这是一重天
      人道 - 一重天
      天道 - 一重天
      声张正义，当然只能靠人。天理昭昭，终究是要我们自己维护。
    出世-脱离人道
      说得轻巧，其实哪有那么简单！传承 即是 人道 的 一大特征。记忆-交流-语言文字-记录-命名-定义-自己与自己交流-听听过去自己怎么说跟将来的自己说说当下的想法-当下不同念头之间的交流-众念国-可以将整个族群当作一个生物也可反过来将一个人看作一个生物聚落
      人道 以人命名，但 与人并无什么特别关系。只是因为是人在命名，并且认为人乃万物灵长，故有此称。
      人类远未将人道推衍至极，而众生也皆在人道上蹒跚前行。
      将所有生命视为一个整体也无不可。旨在不断磨砺壮大自己。
    逆天改命
    人道。 要你按时老死，你偏要长生久视？
    人道圣人，将道果融入人道之中？这也是外道法门，与器修差别不大。丹修用药，由外而内，打了个擦边球，亦算不得正统（内道法门）。
      别家传法，我宗传道，传的便是行侠仗义的道！--剑宗
      如果认为个人并非独立的存在，只是人道者大江大河的一个小小浪头，那修人道也不能算是外道法门。--逝者如斯夫，不舍昼夜
    神通不及天数-以人为本
      科技发达若不关注民生
        医疗系统天下第一，但穷人病死用不起
        物资丰沛，狗豕食人食不知俭，路有饿殍不知发
        武器流通，民众生命却得不到保障
        律法繁浩，贼盗多起
    雷霆雨露俱是天恩
      龙生九子，子子不同。因为 龙不是生出来的，是磨砺中造就的。信仰认知 难以承传，父子乖离，愚公移山 的 想法太简单。子孙不会理所当然地接受祖先的控制，这既是灾难也是生机。--山与海之间
      天行健君子以自强不息。消灭了敌人还有远方更强的敌人，消灭了外部的敌人自己内部将来也会分裂，度过天灾还有未来更大的天灾，度过外加的灾劫自己的体量膨胀对资源不竭的索取将成为内生性的灾劫。人的最大敌人是自己，是自己无穷无尽的欲求，这是进步的动力，这是自毁的根源。理智告诉你，以阶级斗争为纲；感性告诉你，『人民日益增长的物质文化需求』是主要矛盾。理性 理所当然地 败退，因为 一切智慧 围绕 终极目标 运动。

    三魂:爽灵、胎光、幽精
      天魂-不灭真灵，终极目标，命。命者名也，所谓 真名，即使人生的终极目标。人一生一世的活动、思考 就如同滚落的石子，『轨迹虽然复杂，但大势是趋向更低处』一般，是围绕着 自身的终极目标 的。
      人魂-记忆，人生历程，社会关系，国功民劳，恩怨情仇，缘。
      地魂-人之德，即 遗传信息。联系 三魂七魄，人之所以有人样的模版--人之德。#性格习惯，时光刻痕
    人道惑人: 寿，智，志
      寿:活物求生
      智:灵物因智
      志:志为智纲
        老:僵化，不接受新事物，不学习新知识，只因志向（人生终极目标/欲求）早定。
  面相-嫌丑爱美
    脸上长瘤/恶眼之相 面相不好命格不好 妨害至亲？
    这贼老天也忒嫌丑爱美
  树叶-寿命限制的根源
    人的生死如同树叶的茂凋，乃是人道意志的体现，什么文治武功都是臆想，该死的时候就会死，与奴隶贼寇无异。
    天地不仁，圣人不仁
青
  徒有人形罪
巨蚌
  这边界防御实是多余，浪费人力物力，最好磨灭。边界自在人心，并不因为我说磨灭便磨灭，也不因你说永存便永存。只能说同心同德是个长期目标，慢慢来不急。
功劳体系-缺陷
  战争 应该摆在哪里？
  要么不得一统，战乱不断，要么和平之后用进废退，纷乱再起，治乱循环
    巨兽启蒙，记史不宣，传承不灭，补足战乱缺陷
  为什么要接受挑战？他有什么资格挑战？凭啥要按战力评高低定权位？为什么不同要求偏要捆绑在一起？过去的传统就让它过去，我们现在分工看专长。
    你不正是靠战争胜利才地位巩固？勇武、智慧、名声、权势、财富，本来就是高度统一的，你这么强行拆分，全靠政策律法维护，毫无稳定性可言，混乱自此始。
世间无尽藏就在眼前，却还需去哪里争夺天材地宝？
剑修像邪修
  不贪生，夭折死于非命，无法想象躺在床上寿终正寝的样子:生死本是寻常事-邪教口号
  重杀不重养生，不畏因果业力:一剑斩之-天劫加重？那就炼更强的邪器
所有老师都希望学生聪明有天赋，面对愚顽没有进步的学生会暴躁崩溃。但是假如能自学成才无师自通，还要老师干嘛？
既然连遍知遍识都做不到，人自然便有亲疏远近，对不认识乃至于不知道存在与否的人，其死活又有何影响？自有亲近的人在乎。
合理
  合不合理，是人道范畴的概念，是人们对于耳闻目睹的事件与过往的经验心中确认的理论进行比较嵌入得出的结论。道就是道，无所谓合不合理。
  如果某理论与事实不符，该理论便不合理。哪个理？即是不合『实践是检验真理的唯一标准』这个理。但这个理本身合不合理呢？又该合什么理？人类目前恐怕还未探索到这一层次，或者说无此需求。
怎么高个子都躺下了？哦，原来现在我才是
五毒
  与其说火毒有生命，不如说一切生命尽属火毒
多少
  作一选择，自己得利一，众人各得利万。众人虽心知肚明，却不仅不分利，还要笑你蠢笑你穷，欺你辱你，如此抉择你作是不作？
  用进废退，和平时期，军备废弛，人才流失，军人地位卑下。
弱小
  被压迫剥削，仍不肯脱离，因为无法独自生存，只能抱团取暖，被迫害也只能忍受。

若不辜负你的信任，却是要辜负属下高升一步的期冀。信任？一文不值。帝王术又如何？凡事还是要讲规矩。
绝地？难道不是这些孑遗的最后家园吗？
祭祀
  香火成神？不，人人可为尧舜，祭祀有功之人其实祭祀的是心中愿为之洒血的正道，是表达效仿先贤自力更生的呼喊，是团结同志的宣传。若是变成祈求施舍的磕头虫，这祭祀不要也罢。
  人助，助人。又何必认脸？
重因不重果
  有罪无罪当依源头看

功德无量
  彩票主任 领奖，教 希冀不劳而获的穷鬼 做人，肃清歪风邪气，功德无量
  不怨天不尤人，只做该做的事，不计成败。
开挂反杀
  我看出来了，这故事是说，如果没金手指还不了刮没有贵人抬举不是大能转世背景深厚，就只能认命当咸鱼。
  青帝不是某个人，不是成功登顶的某些人，而是不因失败而退却、前赴后继的所有反抗者
  功成何必在我？
  为什么要按别人制订的规矩玩？不爽就直接掀桌子
  什么公子大少，什么宝物权柄，想不到你竟然还痴迷敌方的名利圈。人所定义，我若不认，屁都不是。什么你的我的，我若不认，连你的命都不属于你自己。
  小人-法天相地#idea from 蛊真人-幽魂分身小人族紫-仙蛊『大』
    --你为何不用法天相地？--为何用不了？[......我怎么变小了？...原来已经用了]
  公道自在人心，就算你能所有人闭嘴，难道众人心中就不鄙视你了？
  钱是我的钱，天灾是别人的天灾，别人才该出钱出力，我有众人无数年血汗铸就的堡垒，要死肯定是最后一个死。
  人口数量+人群密度==智慧基石
  和谈？是要把我的血肉论斤卖么？我不需要赔礼道歉。你砍我一刀，我还上十刀就行。
  抹杀人道功德-抛弃点歪的科技树，断绝传承，摧毁一切成果/造物/传奇/经典/技术/艺术-人贱物鄙，恨屋及乌-再造人间
      --何至于此！何至于此啊？！--一而再再而三，卑鄙无耻偏偏还得意洋洋，留下的也只是恶名污名，与其污染世间，不如断绝你们的一切
      另起炉灶才能正真超越。毕竟别人的技艺流传在外的只是皮毛，甚至有缺陷。
  青帝赐劫
    隳名屠圣
      抹杀 过去种种 及 未来无数可能
      唯有 超脱时间海 的 圣人 才有资格参战，为自己的生存甚至是诞生的可能性而战
        过去明王拳/未来明王拳
小惩大诫
  你以为别人会在乎，其实没人在乎，你以为后人会记得，但后人根本不了解。被害人，凶徒，皆无足轻重，所有人皆无足轻重。不过小小惩罚以示警告，严厉的惩罚对维护稳定的社会关系有害。奴隶、贱民，你所压迫的人，无论正义与否，不论是否弱小愚顽，终至暴动反抗。
私了
  民不举官不告？
  私了？
  若禁止私了，可具有可操作性？
  私了，无非威逼利诱。利诱，则钓鱼，虚假的受害者。威逼，则被自愿私了，不了了之，罪犯逍遥法外。无论何种情况，罪行得不到惩戒，依旧在继续，至于更甚。
  解决方案:消除过大的物质精神双重差距
痕印宗
  痕迹-不可能完全消除，不可能得不出有效信息，但，轻易的破坏可极大的提高得到特定有效信息的难度
  印象-由外而内制造赝品，以假乱真；窜改消息渠道，幻境迷人，乱人耳目；直接窜改性格/情绪/记忆/历史/推演结果
逼迫
  约定轮值戍守，拒绝加盟的人会被视为占别人便宜，会遭到围攻。这就是人道压迫。现在别人就在逼迫我。
    关我屁事？当然有关。恩将仇报，有违人道，惩奸除恶，路人有责
  行政上的欺骗是怎么产生的？
    明明我们抱团取暖，理应以诚相待
    指标层层加码，截止日期/产量/
    伤亡人数/损失财货...
    回扣/层层外包/...
    职位只升不降
投降
  不接受投降。你的加盟可以增加我们的实力？别开玩笑了。我们的力量才不是靠投机分子支撑。
修道非修心
  念头通达，意志坚定，修的是己道
    己道、神道 隶属 人道
    证据
      一服己，二服众
      由于技术手段不同、层次有高低，证据并不通用，过于简单容易伪造，过于高级无法理解

  了悟天道，天人合一
教你说人话
  --孽障（坐骑），会不会说人话？明明是除魔卫道，怎么说得我倒像是逐利蝇营之人？（鞭！）组织言辞再给我说一遍！--...--教你说人话真不容易。
压力-内卷
  孤儿寡母 被同族迫害？不是应该帮衬么？
  人口众多，社会生存压力大，弱小无力者自然是先崩塌。
  可早些动乱年代众志成城难道压力小了？
  那是压力太大不得不抱团取暖，现在压力不大不小...好吧，生存压力大但惩罚力度小...
  行了，别压力大压力小，
商
  垄断 生产
  垄断 渠道 # 武装二道贩子
  攫取利益 甩锅灾责
    通货膨胀
    污染转移+剪刀差

以战养战
  法宝炮弹
邪不胜正？不过是主流定义了『正』，是以左道旁门『邪』成了小众非主流的大口袋。而人数加长期稳定意味着力量。至于主流是啥，这可没有一定之规。
有用无用
  在有用无用之间...概率分布，个人随机应变？群体各异自由选择？
    分而治之，拉一批打一批
  人只有作为整体才有意义，个人只是树叶。
竞争-弱肉强食
  团体里面又有小团体抱团取暖，内部竞争烈度更弱，形成凝聚力。
  推恩令
    赢者通吃，富有是真，但只是个别人，因为担心均分后力量分散被淹没
    这又形成离心力
  小团体『对外一致』原则+『少数服从多数』原则+优势民主小团体序列==实现少数人控制多数人的民主反向控制
    2人小团体 决定 3人团体的对外策略
    2 -> 3 -> 5 -> 8 ....
    实现2人在民主制度下对8人的奴役
  补有余
    世家，窃据高位，票多资源倾斜，强推更多庸才，打压异己，窃据高位，死循环。

众念国
  幽冥界-众念国 外显
  神器 有灵无性 - 地域博大，难以一统
  小物件 反而容易诞生器灵，但提升质材，器灵有泯灭之危 - 扩张加速崩溃
外力
  我要的不是胜利，而是靠自己赢得的胜利。战争及其他一切形式的争斗，不过是仪式，判断德行的人道仪式。

斩红尘
  党争，站队，纠葛已深，如何断？与其让我对得起你，不如让你对不起我。得罪本派系太子党...，不容于各派系，自此脱身。

第一机缘体质-拉仇恨体质
  随便喜欢上一头母猪，该母猪也会立即成为炙手可热的大众情人。
  出门在外，必有肥羊打劫送人头


杠杆原理
  越长越软越容易弯曲，因为杠杆原理
官僚系统 设计
  各级部门/整个官僚系统 分成两部:
    世间部
      来源:任何人
      来源广，思路广，避免本本主义，接地气实践性高，满足大众权欲
    世外部
      来源:从婴儿选取，公开培养，无隐私无私财，没有移民外国的权利。
      执政知识更系统规范，避免世俗人情权财纠葛，有利于矫正歪风邪气
  共同:
    执政起，人生再无隐私
    从底层历练晋升
    #禁止按比例分配

明日黄花
  什么九纹金丹，不过渡河的舟筏，巨舰也罢牛皮也罢，纵使徒手凭河，只要过得河去皆是一样。既过河便是垃圾。

裹尸布
  炼尸的裹尸布 秒变 母猪赛貂蝉-香喷喷的 绫带类法宝

生死本是寻常事
  --这一路千里追杀，无数百姓皆因你而死！你算什么正道人士！
  --生死本是寻常事，看破自己的生死，更看破他人的生死。竟然企图用无辜路人的生死来拖延我的步伐？我只为除恶而来，岂能由你摆布！


说聪明也未必，只是尽心尽力考虑众人的难处缓和矛盾罢了。

正道嘛，肯定占道理，就是没理也得掰成有理；邪道占便宜就是道理。


你吃我，我吃你，自己吃自己

为难
  端午节前，同事派粽子，也不问我要不要，直接放下。
  若是问了，我便顺势拒绝。
  退回去？会得罪人
  吃下去？会被毒死
  悄悄扔？老来饿死-还是做个人渣，浪费粮食算了


档口
  晚上出门，无人留守，关风扇？要不要关灯？若关灯，必须要关门。不如假装有人在里面或附近或很快回来。
歌
  情歌，只有孤男寡女时，还功放情歌，听的人不尴尬，尴尬的是放的人。
二维码 打印 截屏放大移动 避开屏幕缺陷点防止屏幕太小 结果:只有打印的才行，放大移动无效




资格性测试，选拔性测试，自检性测试
  面向自己:
    自检性测试
  面向公众:
    证明能力达标，不限出线人数:
      资格性测试
    证明比别人强，限制出线人数:
      选拔性测试

===
存储文件分类
  书/标准=稳定+找回
  软件=稳定+更新+找回
  他人代码/网页=变动+找回
  我的代码/文档=变动+不可找回
  配置=稳定+更新+不可找回


核酸检测
  必须微信？
  没微信不是人？没手机不是人？


酵母的保存


面粉
  1.734 kg * 4.76 元/kg = 8.3 元
  20210523 蒸作 20 个馒头（1个留作酵头）
    ==>> 馒头 1.7两面粉/4毛/个


嘉5月
  擀面杖 4.5元
  红辣椒粉 4.5元/罐
  玉米粉 3元/斤
  豆皮 6.8元/斤
  面粉 2.8元/斤



