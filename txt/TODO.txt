彖tuan4
起讫 qi3 qi4 开始+终结
篆隶楷 草行 科斗
  隶li4
    古隶#秦汉
    今隶=楷书#三国
  篆zhuan4
    虫鱼篆=鸟虫书
    大篆=籀书#周宣王时史籀zhou4
    小篆=秦篆#李斯
    蝌斗篆文=蝌蚪书
鱼鲁帝虎:指将鱼误写作鲁，帝误写作虎。泛指文字错讹。
忘帝力:1.相传帝尧时，一老者边击壤，边唱道:"日出而作，日入而息，凿井而饮，耕田而食，帝力于我何有哉？"后用为歌颂太平的典故。
三皇五帝:五帝：少昊、颛顼、帝喾[高辛]、尧、舜；三皇：伏羲、神农、黄帝。原为传说中我国远古的部落酋长。后借指远古时代的帝王。
  三皇:传说中的远古帝王。说法很多，其中一说指伏羲、女娲、神农，又一说指燧人、伏羲、神农。
    欧路词典:
      伏羲 神农 黄帝
      伏羲 神农 女娲
      伏羲 神农 燧人
      伏羲 神农 祝融
      天皇 地皇 泰皇
      天皇 地皇 人皇
  五帝:传说中的上古五位帝王。有四种说法：
    (1)指黄帝[轩辕]、颛顼[高阳]、帝喾[高辛]、唐尧、虞舜。见《史记·五帝本纪》。
    (2)指太昊(伏羲)、炎帝(神农)、黄帝、少昊(挚)、颛顼。见《礼记·月令》。
    (3)指少昊、颛顼、高辛、唐尧、虞舜。见《书序》。
    (4)指伏羲、神农、黄帝、唐尧、虞舜。见《易·系辞下》。
    --五方天帝:郑玄:
    青/苍-灵威仰-太昊
    赤-赤熛怒-炎帝
    黄-含枢纽-黄帝
    白-白招拒/白昭矩-少昊
    黑-汁光纪/协光纪-颛顼
    ---
人亡政息:亡：失去，死亡；息：废，灭。旧指一个掌握政权的人死了，他的政治措施也跟着停顿下来。
六十四卦:《易》中的八经卦﹐两两重复排列为六十四卦。卦名是:乾/干﹑坤﹑屯﹑蒙﹑需﹑讼﹑师﹑比﹑小畜﹑履﹑泰﹑否﹑同人﹑大有﹑谦﹑豫﹑随﹑蛊﹑临﹑观﹑噬嗑﹑贲﹑剥﹑复﹑无妄﹑大畜﹑颐﹑大过﹑坎﹑离﹑咸﹑恒﹑遁﹑大壮﹑晋﹑明夷﹑家人﹑睽﹑蹇﹑解﹑损﹑益﹑夬﹑姤﹑萃﹑升﹑困﹑井﹑革﹑鼎﹑震﹑艮﹑渐﹑归妹﹑丰﹑旅﹑巽﹑兑﹑涣﹑节﹑中孚﹑小过﹑既济﹑未济。
寿夭 修短 促久
我武惟扬#奋发向上
我生不辰#生不逢时
汉-杨雄-《琴清英》：『祝牧与妻偕隐，作《琴歌》云：「天下有道，我黼子佩；天下无道，我负子戴。」』
  我黼子佩#黼fu3#有福同享
  我负子戴#患难与共
《诗经*小雅*北山》普天之下莫非王土，率土之滨莫非王臣
人之相敬，敬于德；人之相交，交于情；人之相随，随于义；人之相信，信于诚
战战兢兢，如临深渊，如履薄冰
上天难欺，下民易虐，民脂民膏，尔俸尔禄。
初风头水:喻首次，初次。
义正辞严:regex"[义意理]正[词辞][严约]"
木秀于林:欧路词典:三国:魏:李康《运命论》:『故木秀于林，风必摧之；堆出于岸，流必湍之；行高于人，众必非之。前鉴不远，覆车继轨。』
  湍:tuan1

天工人代:天的职责由人替代#？替天行道？
诟龟呼天:原意为占卜不吉，对占卜器具及天辱骂呼叫。引申为对不幸命运的呼号。
欲报之德，昊天罔极--《诗经*小雅*蓼莪》
含章天挺:指内怀美质而挺秀。同“含章挺生”。
盗天:1.窃取自然生长之物。
虫天:1.《庄子．庚桑楚》:"唯虫能虫﹐唯虫能天。"成玄英疏:"鸟飞兽走﹐能虫也;蛛网蜣丸﹐能天也﹐皆禀之造物﹐岂仿效之所致哉！"陆德明释文:"一本唯作虽……言虫自能为虫者﹐天也。"谓虽微小如虫豸﹐都有适应自然的天性。后以"虫天"指万类竞存的大自然。
九天:
  《吕氏春秋*有始》谓天有九野:
      幽 玄 变
      颢 钧 苍 东
      朱 炎 阳
         南
         颢hao4
    汉-杨雄-《太玄-太玄数》九天:#1~9:中羡从，更睟廓，减沈成
九仙:欧路词典《雲笈七籤》卷三:太清境有九仙:1-9:1上仙，2高仙，3火仙，4玄仙，5天仙，6真仙，7神仙，8灵仙，9至仙#上高火，玄天真，神灵至
谪仙 zhe2xian1 1.亦作"谪仙"。 2.谪居世间的仙人。常用以称誉才学优异的人。 3.专指李白。 4.借指被谪降的官吏。
坠落 坠zhui4 堕落 堕duo4
侧身:1.倾侧其身，表示戒惧不安。 2.向侧面转体。 3.厕身，置身。
  厕身:置身。
  厕身其间:指某件事自己参与在内。
仓廪实而知礼节#廪lin3
灭此朝食#朝zhao1
  朝食：吃早饭。让我先把敌人消灭掉再吃早饭。形容急于消灭敌人的心情和必胜的信心。
  语出《左传·成公二年》：“余姑翦灭此而朝食。”原指消灭了敌人后再吃早饭。后形容斗志高昂，要立即消灭敌人。
卮zhi1卮zhī巵
  古代盛酒的器皿：卮言（卮不灌酒就空仰着，灌满酒就倾斜，没有一成不变的常态，如同说话没有主见或定见。后常用为对自己著作的谦辞，如《诸子卮卮》）
  古同“栀”，栀子。
  ---
  漏卮==漏巵
    1.亦作"漏卮"。 2.底上有孔的酒器。 3.比喻利权外溢。 4.比喻饮量极大。
    ---
    堵塞漏卮
    漏卮难满
  江河不实漏卮
    卮：古代盛酒的器具。江河的水，漏处太多，也会像有漏洞的酒器那样迟早要干涸。比喻不能忽视事物的细微之处。
  玉卮无当
    卮：古代盛酒的器皿；当：底。玉杯没有底。后比喻事物华丽而不合实用。
  卮言
    1.亦作"巵言"。 2.自然随意之言。一说为支离破碎之言。语出《庄子．寓言》:"巵言日出，和以天倪。"成玄英疏:"巵，酒器也。日出，犹日新也。天倪，自然之分也。和，合也……无心之言，即卮言也。是以不言，言而无系倾仰，乃合于自然之分也。又解:巵，支也。支离其言，言无的当，故谓之卮言耳。"后人亦常用为对自己著作的谦词，如《艺苑卮言》﹑《经学卮言》。
  卮辞
    1.亦作"卮词"。 2.谓随和人意，无主见之辞。
  鲁卮
    1.即欹器。

罟gu3:鱼罟，罪罟
婕妤jie2yu2
思辨，辩证
取次
道次
句芒:古代传说中的主木之官。又为木神名。
鱼烂取亡:鱼烂自内而发。比喻因内部腐败而自取灭亡。
猿猴取月:？水中捞月？
酒次青衣:据《晋书．孝怀帝纪》载:孝怀帝为前赵刘聪所俘。刘聪举行盛大宴会，令孝怀帝穿青衣，给宾客斟酒。后用"酒次青衣"指受人摆布﹑侮辱。
屦及剑及jv4ji2jian4ji2屦及剑及:形容行动坚决迅速:欧路词典::中华成语大辞典--左传::宣公十四年::投袂而起，屦及于窒皇，剑及于寝门之外，车及于蒲胥之市。秋九月，楚子围宋。#楚庄王为申舟报仇#及:赶上


子绝四：毋意，毋必，毋固，毋我。
  ---我:
  毋意:臆测，胡乱揣测，凭空捏造，无端歧视偏见，随意注解前贤言行，造神膜拜#才子#理中客
  毋必:以妄作真，要求现实现状发展符合自己的理念，怨天尤人#愤青#思辨
  毋固:给自己定下原则性底线，画地为牢固守不让，故步自封不思进取。#僵尸#井蛙
  毋我:有我不知有人，有人不知有天，强施与人，强加于天。#巨婴
  ---辞典:
  毋意:不主观臆断。
  毋必:1.不持绝对的态度。谓能因时变通。 2.不必。
  毋固:1.谓不可鄙野而不知礼。 2.谓不固执拘泥。
  毋我:谓无私见，不自以为是。
毋寱毋喘:谓实事求是，理直气壮。寱，胡言呓语;喘，细气小声。
吉光片羽：吉光：古代神话中的神兽名；片羽：一片毛。比喻残存的珍贵文物。
习非胜是:习：习惯；非：错误的；是：正确的。对某些错误事情习惯了，反以为本来就是正确的。
蛙蟆胜负:青蛙与蛤蟆斗争的胜负。比喻不足介意的荣哀得失。#蜗角之战？
自我作古/自我作故:不沿袭前人，自我创造。
遐暨:及于远方
  无暨:不已，无限
裕后光前/光前裕后:为后人造福，给前辈增光。常用以歌颂人们的不世功勋。
鸟媒-用以引诱他鸟而拴系的活鸟。
  笼媒-被人用来诱捕鸟类的鸟。捕鸟者把关着鸟的笼子放在野外﹐利用其鸣声来引诱其同类的鸟。
  风媒花，虫媒花-依靠风力传粉的花、依靠昆虫传粉的花
    ？？无此词:风媒虫介？？
年该月值 指命中注定的时辰。
掣肘 che4 zhou3
旻 min2 青旻=青天 ？冥ming？
天真
  《庄子:渔父》『礼者，世俗之所为也；真者，所以受于天也，自然不可易也。故圣人法天贵真，不拘于俗。』
拘挛补衲
  拘挛：互相牵扯；补衲：缝补连缀。形容诗文勉强拼凑而不自然。
  南朝:梁:钟嵘《诗品:总论》:『遂乃句无虚语，语无虚字，拘挛补衲，蠹文已甚。』
  蠹 du4 流水不腐，户枢不蠹
水浒hu3
株连蔓引/株连九族 而非 诛连
捧哏 peng3 gen2 相声艺术谓配角用话或表情动作来配合主角，逗人发笑。
揣而锐之vs揣而棁之
  揣zhui1
  棁zhuō/zhuo1梁上的短柱。
  ----
  揣chuǎi
  估量，忖度：揣测。揣摩。揣度。揣想。揣情（忖度情理）。不揣冒昧。
  姓。
  hide or carry in one*s clothes
  揣
  chuài
  〔挣（
  〔囊（
  hide or carry in one*s clotheszh坣g ）揣〕见“挣1”。n乶g ）揣〕见“囊1”。
  hide or carry in one*s clothes
  揣
  chuāi
  放在衣服里：揣着手。揣在怀里。
  hide or carry in one*s clothes
  揣
  tuán
  古同“团”，聚集的样子。
  hide or carry in one*s clothes
  揣
  zhuī
  捶击：“揣而锐之，不可长保”。
  hide or carry in one*s clothes
  笔顺：一丨一丨乛丨一丿丨乛丨丨

  笔顺：一丨丿丶丶丿丨乛一丿乛
薅，耨，搙
  薅耨 hao1 nou4 除草
  薅草 除草
  搙nù/nu4捻。搙nuò/nuo4拭。搙nòu/nou4拄。笔顺：一丨一一丿一一乛丿丶一丨丶
  耨nòu/nou4古代锄草的农具。锄草：深耕易耨。笔顺：一一一丨丿丶一丿一一乛丿丶一丨丶
  薅hāo/hao1拔除：薅草。薅锄。揪。笔顺：一丨丨乛丿一一丿一一乛丿丶一丨丶

白衣苍狗/白云苍狗
  1.青狗，天狗。古代以为不祥之物。 2.唐杜甫《可叹》诗:"天上浮云似白衣，斯须改变如苍狗。"后因以比喻世事变幻无常。
《可歎》'杜甫著'#天上浮雲如白衣，斯須改變如蒼狗。


椿庭萱堂
  椿庭：指父亲；萱堂：指母亲。指父母双亲。
椿萱并茂
  椿：多年生落叶乔木；萱：古人以为可以使人忘忧的萱草。椿萱：喻父母，古称父为“椿庭”，母为“萱堂”。比喻父母健在。
无萱
  萱草一名忘忧草。"无萱"谓不能忘忧。语本《诗．卫风．伯兮》:"焉得谖(萱)草？言树之背。"毛传:"谖草令人忘忧。"
萱草
  单子叶植物，百合科。多年生草本。肉质根肥厚，呈纺锤形。叶狭长。夏秋开花，漏斗形，橘红或橘黄色，晨开晚谢。原产欧洲，中国各地都有栽培。可供观赏。根可入药。

？暄软？萱软？松软，选软
  暄腾
    [方]∶暄而有弹性。如：这屉馒头蒸得很暄腾。
负暄之献
  暄：温暖。原指冬天晒太阳取暖当成一种好方法献给国君。后用来谦称自己的贡献很微小。也比喻所献出的东西并不贵重难得。
负暄
  1.《列子．杨朱》:"昔者宋国有田夫，常衣缊黂，仅以过冬。暨春东作，自曝于日，不知天下之有广厦隩室，绵纩狐貉。顾谓其妻曰:'负日之暄，人莫知者。以献吾君，将有重赏。'"后遂以"负暄"为向君王敬献忠心的典实。 2.冬天受日光曝晒取暖。

for backup cmd:
  view ../../python3_src/nn_ns/filedir/backup_tools/main.py
  view ../../python3_src/my_convention/backup_cmds.txt

grep '堆出于岸\|行高于人\|木秀于林' -r /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/重命名/ -l
  grep: /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-2/《剑侠奇中奇全传》.txt: I/O error
  view ++enc=utf8 /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-2/《剑侠奇中奇全传》.txt


文武之道，未坠于地，在人。
    卫公孙朝问于子贡曰：“仲尼焉学？”子贡曰：“文武之道，未坠于地，在人。贤者识其大者，不贤者识其小者，莫不有文武之道焉。夫子焉不学？而亦何常师之有？”《论语*子张第十九》
view /sdcard/0my_files/unzip/e_book/e_book_经典_collect/國語[ctext.org].txt
view ++enc=gb18030 /sdcard/0my_files/unzip/e_book/e_book_经典_collect/《国语》原文,注释,全译.txt
  国语*楚成王以周礼享重耳
    #冀州之土其无令君乎
    #十室之邑必有忠信#子曰：“十室之邑，必有忠信如丘者焉，不如丘之好学也。”《论语*公冶长第五》
    #令尹子玉曰：「請殺晉公子。弗殺，而反晉國，必懼楚師。」
    #王曰：「不可。楚師之懼，我不修也。我之不德，殺之何為！天之祚楚，誰能懼之？楚不可祚，冀州之土，其無令君乎？且晉公子敏而有文，約而不諂，三材侍之，天祚之矣。天之所興，誰能廢之？」
    令尹子玉曰⑧：“请杀晋公子。弗杀，而反晋国，必惧楚师。”
    王曰：“不可。楚师之惧，我不修也。我之不德，杀之何为！天之祚楚，谁能惧之？楚不可祚，冀州之土⑨，其无令君乎？且晋公子敏而有文，约而不谄，三材待之，天祚之矣。天之所兴，谁能废之？”

  国语*灵公使麑杀赵宣子
    #兢兢业业，夙兴夜寐，也可能是国贼
    #靈公虐，趙宣子驟諫，公患之，使鉏麑賊之，晨往，則寢門辟矣，盛服將朝，早而假寐。麑退，嘆而言曰：「趙孟敬哉！夫不忘恭敬，社稷之鎮也。賊國之鎮不忠，受命而廢之不信，享一名于此，不如死。」觸庭之槐而死。靈公將殺趙盾，不克。趙穿攻公于桃園，逆公子黑臀而立之，實為成公。
    灵公虐①，赵宣子骤谏，公患之，使麑贼之②，晨往，则寝门辟矣，盛服将朝，早而假寐。麑退，叹而言曰：“赵孟敬哉③！夫不忘恭敬，社稷之镇也。贼国之镇不忠，受命而废之不信，享一名于此，不如死。”触庭之槐而死。灵公将杀赵盾，不克。赵穿攻公于桃园④，逆公子黑臀而立之⑤，实为成公。
  /^[^ 0-9〔〕，。]\{1,20}$
  view others/app/gvim/filter--example.txt
  view others/app/gvim/filter.txt
    :redir @v>
    :filter /^[^ 0-9〔〕，。]\{1,20}$/ :%l
    "vp
    :redir END

view ++enc=gbk xxx.txt
view ++enc=big5 xxx.txt
%s/<F\d\+>//g
%s/ \+$//g

curl https://www.hko.gov.hk/tc/gts/time/calendar/text/files/T[1901-2100]c.txt   --create-dirs -o 'T#1c.txt'

=============[[[[[begin:explain
to explain:
  using:
    view /sdcard/0my_files/unzip/e_book/字词典/\[Chinese-English\ dictionary]cedict_1_0_ts.u8
    欧路词典
  =======
  www待查 无印subtitle? 毕竟空 胜义有，外挂/外接/内嵌/内接/内联
  账户vs帐户
    帐户account 但 账户 似乎也行
  起讫 qi3 qi4 开始+终结
  =======
  外挂/外接/内嵌/内接/内联
    attach 附加
    embed 嵌入
  查询
    query n 疑问，质问，问号 v 问
  terminology 用辞，术语
    jargon 专门术语/行话/黑话
    instance 实例
    occurrence 具体值，发生的事件
  terminate v 结束/终止/满期 adj 有结尾的/有限的
    terminate a contract 解除合同
    terminator n 端子
    termination n 终止/终结
      termination allowance 解雇津贴
      termination of risk 保险责任终止
      termination of term 满期
    terminable 可终止的
    terminal n 终点，终端机，末端 adj 终点的，按期的，致死的
      terminally adv 晚期地，致命地
      terminal account 终结帐户 #??动词？
      terminal building 候机大厅
      terminal station 终点站
        terminus 终点站
      terminal years 起讫年度 #？
  singleton 独身，单身 #独例？孤例？
  guard n 警卫/看守 vt 守卫，护卫 == protect
    guard A against/from B 保护A以防/免于B
    监视(囚犯)，看守(入口)
    抑制(言辞/愤怒)
  introduce
    introduce vt 介绍，引入，推出，引进，推广，初次输入/传入，插入，提出，开始，引导
      introduce disease 染病
    introductory adj. 入门级别的，初步的
    elimination 分解式，[数]消去，消除/排除/删除/除去，[生理]排泄/排出
    introduction 合成式，引言/前言/导论/绪论/序言/序文，入门/概论/序论，介绍，前奏曲
      introduction of A to B 介绍
      introduction of A into/to B 创始，引进/初次输入
      introduction to 入门
  归纳vs演绎
    induce v [逻辑]归纳，[电学]感应，劝诱/说服，引发/导致，人工引起
      [逻辑]v.  induce归纳 <-> deduce演绎
      induction n 归纳法
      inductive [逻]归纳的，[电]诱导的/感应的 <-> deductive 演绎的，推论的
      归纳法
        inductive approach
        inductive method
        method of induction
        induction
      归纳推理
        inductive reasoning
        inductive inference
      归纳原理 induction principle
      归纳证明 proof by induction
      归纳证明法 inductive proof method
    generalization n. 综合，概括，泛化，推广，归纳
    extrapolation n. [统计]外推法/外插法
    summary n 概要，摘要，概略 adj 概括的//简略的，即决的/简易的
    conclude 总结，推断
    infer 推断
      = conclude = deduce = gather
    collect=gather 聚 <-> scatter 散播，挥霍，驱散，吹散 vi 散开
  resp.
    respect
        vt 重视/顾虑，尊敬，自重/有自尊心，
        n (respect for/to) 敬意，重视，关心/注意，(respects)问候/致意/请安 <-> disrespect
        n (in all/many/some/no/every/this/... respect) 方面/细节/点
        n 关系/关联
        ######
        in respect of
          关于...，至于...，就...而言 = as reguards
          [商]作为...的代价报酬
        with respect to
          关于...，至于... = concerning
        without respect to
          不拘，不论，不管，不顾虑
  problem 毛病  n 疑难/问题  adj 有问题的
    solve problems
    solve vt 解决/解释/解答 #？清偿债务？
    solver n
  complete v 完成，使完整 adj. 彻底的，完整的，已完成的，完善的，圆满的，齐全的，完备的，完结的
    incomplete 不完整的，未完成的，残缺的，不完全的，不充分的，不完备的，不足的，不完善的

  rebuild v 重建，改造，再建，改建，重新组装
  lattice 点阵，栅格，网格，格子
  ladder n 梯子
    rope ladder 绳梯
  rope n 绳索 v 绑，栓
  bind 捆绑 bound
    bounded adj. 有限制的，有界限的，[数]有界的
    bound
      ---
      adj bind 的 过去式，过去分词
        (无:比较级，最高级)
        -bound 被束缚的，被封锁的
          dutybound 有义务的
          fog-bound 被浓雾所困的
          snow-bound 被大雪所困的
        be bound to do
          有义务去做的
          必然会发生的
          决意要做的
        已封装的，装订好的
      ---
      vi 跳跃 ~leap
      ---
      n 界限，(允许的/可能的)范围
        out of all bounds 过分的/过分地
        out of bounds 越界
      vt
        X bounds Y on Z. # X形成Y的Z方面的界限。
        USA is bounded on the west by the Pacific. 美国之西以太平洋为界。/美国西临太平洋。
      vi
        X bounds on Y. # X接壤Y
        Canada bounds on USA.
      ---
      adj. 准备前往...的
        (无:比较级，最高级)
        -bound
          northbound adj 往北的，北行的
        a streamer bound east 往东行驶的轮船
        a train bound for China/the east 开往中国/东部的列车
        a plane bound from USA to China
        He is homeward bound. == He is bound for home. 回国/回家
      ---
      ---
  tower n 塔，高楼 v 高耸，超越
    towering adj. 高耸的，杰出的，激烈的，远大的
  进制，几元几次，几阶几价
    -ary
    unary 一元的
    binary 二元的，二进制
    ternary 三元的，三进制
        trinary 三元的
    quaternary 四元的，四进制
        quadruple ？四元组？
        quaternion 四元数，四个一组
    quinary 五元的，五进制
        quintuple ？五元组？
    senary 六进制
        sixtuple
    septinary 七进制
    octonary 八进制
        octal
    novenary 九进制
    denary 十进制
        decimal
        decade
    undecimal 十一进制
    duodecimal 十二进制
    quaterdenary 十四进制
    quindenary 十五进制
    hexadecimal 十六进制
        sexadecimal
    septendecimal 十七进制
    octodenary 十八进制
    novendenary 十九进制

    monad [哲]单子，单孢体，单细胞生物，[化]一价元素/根/原子
    monoid 类群，[数]独异点


  simplified 精简了的 vs traditional 传统的
    简体字vs繁体字
  括号，括弧 bracket
    parenthesis (pl. parentheses) 小括号，圆括号 []
    bracket 中括号，方括号 []
    brace   大括号，花括号 {}
    角括号 <>
  identical adj 同一的
    identification
    identifier
  controller 控制器，调节器，管理员，管制员，(会计)财务主管/查账员/主计员
  impure adj (气/液)污秽不洁的/脏的，混有杂物/杂色，不道德的猥亵的，(动机)不纯的，
    <-> pure 纯粹的(<->mixed)，清洁的，纯种的，贞洁的，纯理论的(<->applied #理论数学vs应用数学)，完全的仅仅的(pure and simple 地道纯粹的(仅仅是某种事物/人))
  separate vt 分隔 vi 离开，脱离 adj 不同的，独自的，各自的，分开的，独立的
    separator 分隔符
    separate 切开连接一起的东西 vs divide 分成几部分 vs part 分离 vs sever 切断，切去，割断

  process 进程，程序，工序，手续
    process identification (PID) 进程标识
    schedule 进程表 plan
  burn n. 烧伤 v. 烧，烧毁
    be burning to do 急于
    burner 灯头，煤气头
    burnt (过去式) adj 烧焦的

  getter,setter
  transition 转换
  converter 转换器
    convert 转换
    covert adj 隐蔽的(<-> over) n. 隐藏处
    cover vt. 遮蔽，覆盖
  违反
    violate
  多余
    redundant 冗余的
      redundancy n
    unnecessary 不必要的
    superfluous 不必要的
    surplus n/adj 剩余，过剩，盈余
    spare adj 候补备用多余的，贫乏稀疏不丰盛的
    uncalled-for 未经请求的
    nuisance 妨碍的棘手的噪扰的
  超过 超出
    exceed v
      excess n 超量，超出量 adj
      excessive adj 过度的极端的
    supernumerary 额外的
    odd 奇怪的偏僻的奇数的额外的
    go beyond
      above and beyond
      over and above
    surpass v 凌驾
    outstrip v 追过
    overtake v 赶上
    forereach 追及赶上逼近
    dominate v 占优
      dominance n 优越优势
    outward vs inward
    overstep 越界过分
    outrun 胜过，超越
    overage 超龄的，附加物，超额
    overrun 跑过头
    overtop 高过
    overflow n/v 溢出
    overrange 超出额定界限
    overrating 定额过高
    overshoot 过头，过冲，超调量
  意义
    sense n 感觉，直觉，意识，观念，认识，理智/合理性/判别礼，清醒，意义，意见，意向，旨趣 v 感应，察觉，了解
    meaning
    purpose 意图用途
      vs purport n 主旨大意 v 声称主张 #搬运到前面
    significance
    value (实用重要性上的)价值
    worth (知识精神道德上的)价值
    effect 效果/效应

  further (far比较级) adj&adv (时空/程度)更远/更多/更进一步，再者说/此外/附带补充
  安装
    setup n 机构，装置，[计算机]设置，调整/调定/设定，装配/安装，准备工作，预先准备调校设定，set up 调试，建立
      set-up error 安全误差，调定误差
      set-up instrument 调定仪表
      set-up diagram 准备工作框图
      set-up sheet 装配图表
      set-up spring 预压弹簧
      set-up time 准备时间，展开时间
      --
    assemble 聚集/召集，收集整理，汇编/装配
    adjustment n 调整/修整
      adjust v 校准/调准/调整 = adapt 适配/使-适应
    erect v 树立/建造
    mount v 登上/攀爬/骑乘/跨坐，架设安装，上升/增高/增大
      mounter 安装工
      mountain 山脉
    rig v 装配
    install 安装，就职任命/就任，入席坐下就位，
      installation accuracy 安装精度
      installation and debugging 安装与调试
      installation and checkout 安装与测试
        checkout 结账(退房)，查验/检查/测试
      installation and trial run 安装与试行
        trial
          adj. 试验中的(试飞/试车)，预选的(预赛/选拔赛/初审)
          n (try名词) 试用/试验/尝试，考验，审判
            criminal trial 刑事审判
            preliminary trial 初审
            public trial 公审
            on trial 审讯中，试验中
            learn by "trial and error" 在 不断摸索反复试验 中学习
      installation and maintenance 安装与维护
    fulfil=fulfill 履行/实行/完成/实现
      fulfillment of a claim 结偿债务
  扇 fan
    fan out 扇出，扇形展开
    fan out branch 扇出转移
    fan outlet 扇风机出风道
    另:fan~fanatic之略  狂热支持者，迷/粉
  不对称
    asymmetry 反对称性
    dissymmetry 不对称现象
    asymmetric 非对称的
    dissymmetric 左右对称的，不匀称的
    irregular 无规律的/不规则的，违法的/违规的/法律上无效的，不整齐的/凹凸不平的，非正规的，散漫不端不道德的
    ---
    symmetric 对称的
    symmetry 对称性
  determined 果断的，决然的，下定决心做的
    determinate 确定的，已知数的
    indeterminate 不确定的，未知数的
  lattice 点阵，栅格，网格
  schema
    schema 图解，略图；概要，纲要；模式
      模式?pattern
      pl. schemata
    scheme 电路；图解；大纲；计划方案；计谋阴谋；组织机构体系结构；配合构成；一览表，分类表
      体系?hierarchy
      pl. schemes
  incompatible 不兼容的，不相容的，不两立的
  主题/题目/话题
    subject 学科，主语，主体，主观自我，臣民/被统治者
    theme
    topic
  对象
    object 物体/对象/目标/目的，客体/受词(vs subject 主体/主语)
    target 靶，标的，目标
    instance 实例
    entity 实体
    entry 条目，入口
    item 项目
    catalog 目录，一览表
    cell 单元，细胞
      单元 unit/cell/element
    组织
      packet 包裹，信息包
      texture 肌理，纹理
      organization
      system
      hierarchy
      scheme
      structure
        record 记录
      club 俱乐部
    集体/团体/集团
      body 团体组织
      mass 团/群集团
      community 社区，群落
      team 队/组
      group 小组
        herd 牧群
        swarm 蚁群/蜂群/群众
        school 鱼群
      clan 门阀，党派
      bloc 阵营
      fellowship 互助会，公会
  定位
    anchor 锚定器，精神支柱，靠山
    locator 定位器，雷达，探测器，定位程序
      an echo locator 回声勘定器
    localizer 使地方化者，信标
    steady 稳固的
    locating
    indication 标示
    indicator 指示器，显示器，指示剂，指示牌
    access 访问，入口，通路，门路，存取
    positional 位置上的
    positioner 定位器，位置控制器，远程位置调节器，反馈放大器
    retainer 制动器，止动器，抵住物，保持架，限位器，顾问律师家臣侍从
    beacon 烽火狼烟，指向标，灯台，信标
    起始
      beginning
      inception
      onset 开端
      start
      initialize 初始化
      initiative 初步
      initial 最初的
      primary 初等的，第一阶的，初期的
      home
  intend v 意欲做，打算做
    intent n. 意图，目的，意旨，意向(intention) #源intend
    intent adj. 专注的 #源intension #n. intentness
    intended adj 故意的，预期的，有计划的，有企图的，拟议中的
      intended effect 预期效果
      intended purpose 预期目标
      intended target 指定目标
      intended size 额定尺寸
      intended stress 预计应力
  permanent 永久的，耐久的，持久的；常设的，终身的；固定标准的 vs temporary 临时的，暂时性的，权宜的temporary vs momentary 一时的，片刻的，短暂的，瞬间的 vs transient 瞬变的，过渡的，短期的，瞬息即逝的
    perennial 常年的/长年的/长期持续的/多年生的(植物)/永久的，终年的/一年到头的/四季不断的，反复的/不断发生的
    permanent residence 永久住处
    permanent tooth 恒齿
    permanent committee 常务委员会
    permanent agreement 永久性协定
    permanent appointment 正式任命
    permanent assets 固定资产
    permanent basis 平时编制
    permanent calendar 万年历
    permanent magnet 永久磁铁
    permanence n. 永久性，安定度
    permanency n. U=permanence; C:不变的人/物/地位(终身官职)
  updatable 可更新的 nonupdatable 不可更新
    nonrenewable resources 不可更新的资源
    non-renewable energy resources 不可更新的能源资源
    non-regeneratability 不可更新性
    updatable 可覆写的
    renewable 可再生的
    replaceable 可更换的
      replaceable cutter tooth 可更换刀齿
    exchangeable disk storage
    interchangeable type bar
    convertible
    writable
  detect 探测，检测，侦察
  alter == change 变更
  权限拒绝
    limits of authority 权限，权力
    authority credentials 权限-凭据/凭证/证书/印信，权限值
    permission
      ask for permission 请求许可
      without permission 未经许可，擅自
      permissible 容许的，不碍事的
      permissive 宽容的，纵容的，随意的，(规则)默许的
  浅
    superficial 表面的，肤浅的
    shadow 影
    shallow
      (水/容器)浅的 <-> deep
      肤浅的，皮相的
  protocol 协议
  prototype 原型，模范/母模/样板，设计原型/试验模型
    mold 模子/板模；果冻，人像；性格
  receive 接收 vs send 发送
    admit 容许，承认，通向
    accept 答允，甘心忍受
      an accepted meaning 众所公认的意义
  reason n. 理由，动机 vi. 推论，劝服
    == cause n.
    reason for理由
    reason out 推论出
    reasons
    reasonable adj. 合理的，正当的
      reasonably 合理地，适度地
    reasoning n. 论据，推理过程 adj. 推理性的
    reasoned adj. 有依据的，理由充分的
    reasonless adj. 不理智的
  trait 特征，特性，性状
  treat 对待
  placeholder 占位符
    place holder
    holder 持有人，夹持器，夹具/座，容器
      stockholder 股东
      officeholder 公务员
  毕竟有界限域:毕竟-有界限-域 region of ultimate boundedness
  calculus 计算，演算，微积分(学)
    calculus of proposition 命题演算
    calculus of residues 留数计算
  route n 路线，途径 vt 安排路线，发送
    routine n 日常工作，例行公事，惯例，程序 adj 日常的，例行的，定期的，死板的
    routing 路由选择
    router 路由器
  permutation n 排列 vs combination n 组合 adj 混合的
    v permute, combine
    arrangement 安排，布置，搭配，约定，筹备，改编
  schedule n 日程表，调度表 vt 调度，安排
      batch 批/分批/批量
  throughout
  idea 观念，概念，思想，主意，构想，理念，表象，念头，见解，推测，直觉，预感，空想，幻想，想像
  周延 [zhou1 yan2] /exhaustive/distributed (logic: applies to every instance)/
  intension n 内涵 vs extension n 外延
    HoTT 同伦类型理论 使用 内涵性的等同 而非 如同 集合论 使用 外延性的等同
    intension n 内涵，紧张，努力，专注，强度，强化，密集经营
    extension n 外延，扩大，伸展，扩张，延长，延长期间，扩建部分 adj 可伸缩的，可折叠的，扩展的，分机的，对外公开的
    tension n 张力，电压，紧迫，紧张，张拉，张紧，拉紧
    extensional adj 外延[引申/外在]的
      extensionality n 外延，外延性
    intensional adj 内涵性的
  逻辑
    ===
    现实世界是时变的，一切对象都在改变，命题的真值也在改变。刻舟求剑，削足适履，与时俱进，因地制宜。特别是用排中律来框套人的心理，结论就比较牵强。现实中的人，时而记起时而忘记，时而重视时而忽视，时而理性时而感性，时而精明时而糊涂，方醒方醉。精神病人可否脱罪？即使推理出有罪，定什么罪名也是个问题，即并行管道目的地一致，但实构中具体使用哪条线路却量刑的依据，逻辑可以不管，实践却必须强行区分，这时非实构的凭空出现的排中律就成了问题根源。『知道』是纵容，『不知道』是玩忽职守，正常人都会避重就轻。
      #同一律？
      #虚拟假设忽略太多具体情形的特殊性或者说混合了太多情形过于宽泛以至于结论无用。特殊前提『不对称』，将论题由一般性的『人与人的对抗』转移到特定情形，『没有必胜法』这个结论也就不再自证其明。
    真理无需实践检验，真理必是纯虚的，真理必是废话。
    需要实践检验的命题必是教条，大量实践验证过的命题是实用的教条。实用的教条不是废话，实用的教条必不是真理，实用教条必有瑕疵。
      前面这句话也无需实践检验，同样是废话。虚拟的永远不会是现实，永远不能干预现实。思维实验:双球落地:自由落体定律-双球同时落地的推理：若重球先落地，则可用轻绳将两球联系起来，两球变一物更重，应更先落地，但由于小球落地晚必会拖累重球，导致重球落地更晚，矛盾。然而现实中并非如此，跳伞后，降落伞打没打开大不一样。落地快慢的需要考察的影响因素绝不止重量。
      因地制宜与时俱进，是真理也是废话。它指导不了人去做什么有意义的事，这跟打官腔云里雾里绕来绕去不知所云并无区别，说了等于没说，实乃最高等级的无为法，神棍们也不外如是。
    tautology 逻辑学就是这么幼稚，这么小儿科，不能拿到幼儿园吹牛装逼。觉得难，理解不了，是因为人已不再单纯幼稚，内心戏太多。
    函数-实构-推导步骤
    数据-原料
    函数-加工厂-管道
    函数合取-并行管道
    数据合取-一盘菜
    数据析取
    ===
    同一律 『a===a』
      在同一思维过程中，每一个 『思想』(?概念/判断)a都必须保持自我的同一性和确定性。
        #   #idea？ 构想，理念,概念
        有条件的、相对的确定性，并不否认思维对象的发展变化。不是 形而上学
      偷换/混淆 概念 = 没有保持 概念 的 内涵 外延 的 同一
        intension n 内涵 vs extension n 外延
      偷换/混淆/转移 论题/判断
    不矛盾律 『a =!= 非a』
      在同一思维过程中，反对关系的两个『思想』不能同真，保持思维前后的一贯性。
          逻辑矛盾 不是 辩证矛盾
      自相矛盾
        * 概念自毁:用相互反对的概念组合成实质上不成立的概念
        * 判断逻辑矛盾
    排中律 『a \/ 非a』
      在同一思维过程中，下反对关系的两个『思想』不能同假，保持思维的明确性。
        非此即彼 是 有条件的：只在同一时间、同一关系、针对同一对象的思维过程中起作用
      两不可
    ===
    类比推理
      A有属性a,b,c,d
      B有属性a,b,c
      类比得: B有属性d
    回溯推理
      [q]
      [p1->q]
      [p2->q]
      [p3->q]
      ...
      ...
      回溯得:[p1/\p2/\p3...]
    ===
    归纳推理vs演绎推理
    归纳推理=完全归纳推理 | 不完全归纳推理
    不完全归纳推理 = 简单枚举归纳推理 | 科学归纳推理 | 概率归纳推理
    不完全归纳推理 <: 或然性推理
    完全归纳推理 <: 必然性推理
    归纳方法：
        先行情况 ~~~>> 现象
        ~~~>> 表示 观察结果
        --~~> 表示有 因果联系
      * 求同法=契合法
        AB ~~~>> ab
        CAD ~~~>> a
        EA ~~~>> ast
        ...
        ...
        ...
        归纳: A --~~> a
        隐藏的共同情况？
      * 求异法=差异法
        AB ~~~>> ca
        -B ~~~>> c-
        归纳: A --~~> a
        只是部分必要原因？
      * 求同求异并用法=契合差异并用法
        AB ~~~>> ca
        -B ~~~>> st-
        CAD ~~~>> a
        C-D ~~~>> -xy
        EA ~~~>> ast
        E- ~~~>> -d
        ...
        ...
        归纳: A --~~> a
        只是部分必要原因？
      * 共变法
        #变化 引起 变化 - 共变
        #   余者不变
        A1BD ~~~>> ca1
        A2BD ~~~>> ca2
        A3BD ~~~>> ca3
        ...
        ...
        归纳: A --~~> a
        相关不一定是因果？
        互为因果？
      * 剩余法
        观察: ABCD ~~~>> bdca
        已知: B --~~> b
        已知: C --~~> C
        已知: D --~~> D
        归纳: A --~~> a
        B影响a？
        A只是部分原因？


    ===
    以下是 演绎推理
    ===
    规范模态判断 = 规范模态词++基础判断
    规范模态词 = 必须 | 允许 | 禁止
      ==>> 规范模态判断 = 必须判断 | 允许判断 | 禁止判断
      ---我猜：
      必须p = 禁止非p = not 允许非p
      必须非p = 禁止p = not 允许p
      必须=禁止非=?=必然
      必须非=禁止=?=必然非
      允许=?=可能
      允许非=?=可能非
    ===
    真值模态判断 = 真值模态词++基础判断
    真值模态词 = 必然 | 可能
      ==>> 真值模态判断 = 必然判断 | 可能判断
    必然p = not 可能非p #矛盾关系
    必然非p = not 可能p #矛盾关系
    not (必然p & 必然非p) #反对关系
    可能非p | 可能p #下反对关系
    必然p -> 可能p #差等关系
    必然非p -> 可能非p #差等关系
      ---我的理解：
      公设 [事况空间 非空]
      命题 = 事况->真值
      必然p = 凡事况x皆p(x)
      必然非p = 凡事况x皆非p(x)
      可能非p = 某事况x有非p(x)
      可能p = 某事况x有p(x)
        ---
        not (必然p & 必然非p) #反对关系<==>[事况空间 非空]
        可能非p | 可能p #下反对关系<==>[事况空间 非空]
        同理 上面的 差等关系<==>[事况空间 非空]
    ===
    负判断 = 否定联结项(肢判断)
    否定联结项 = 并非
    ===
    假言判断 = 假言联结项(前件,后件)
    假言联结项 = 蕴涵 | ...
    充分条件假言判断 = 蕴涵/若是则是/若有则有(前件,后件)
    充分必要条件假言判断 = ???等价于/当且仅当(前件,后件)
    必要条件假言判断 = ???蕴涵于/若非则非/若无则无/只有才有(前件,后件)
    ===
    形式系统 列出 步骤 即 证明 存在 步骤 导出 某命题
    但 永不能 证明 自己 不能 导出 某命题
    #但能证明 别的形式系统 能否 导出 某命题？或 反转角色？
    必不能:
      [证明 不能 导出 命题甲]
      [证明 不能 导出 命题甲的否命题]
    有可能:
      [证明 能 导出 命题甲]
      [证明 能 导出 命题甲的否命题]
      四种可能
    ======
  universal quantifier ALL 凡 vs existential quantifier SOME 某
    dependent function type
      #avoid: dependent product type
      II-type
      II P x {x::A}
      \[x -> ...] : @\[x:A] -> P x
    dependent pair type
      #avoid: dependent sum type
      Sigma-type
      Sigma P x {x::A}
        subtype/subset:{x<-A | P x}
      (x, y) : ?\[x:A] * P x
    ?,@ 相当于 一个将 函数 当作 参数的操作符
    Polymorphism: Quantifying over TYPE
      #not? P :: A -> TYPE :: TYPE+1
      #not? P :: @[a:A] -> TYPE :: TYPE+1
      #not? g :: @[a:A] -> P a :: TYPE
      f :: TYPE -> ??? :: TYPE+1
      f :: @[A:TYPE] -> ??? :: TYPE+1
    ===
    conjunction A/\B A&B #intersection A/-\B
    vs ordered pair "product/pair type" A*B
      联言判断 = 联言联结项(联言肢...)
      联言联结项 = 合取
      ---
      projector
      prA=projection-fst=fst :: A*B -> A
      prB=projection-snd=snd :: A*B -> B
    ===
    disjunction A\/B A|B #union A\-/B
      相容选言判断
        选言判断 = 选言联结项(选言肢...)
        选言联结项 = 析取 = 相容析取 | 不相容析取
          相容析取 = Any = 至少一个真 = 或
          不相容析取 = OneAndOnlyOne = 有且只有一个真 = 要么
          ==>> 相容选言判断 | 不相容选言判断
      vs disjoint union "coproduct type" A+B (cased/tagged Either)
        ---
        injector
        inl=left-injection=Left :: A -> A+B
        inr=right-injection=Right :: B -> A+B
        ---
        case analysis # case...of
    ===
    negation
      contradictory premises may produce insensible mathematics and unmeaningful names.
      (intended to be)
      the ‘Zero Type’ #empty/false/error
        not A === A -> ZeroType
      Truth and Falsity
        * A inhabited
        * (not A) inhabited
        * YET
      the Law of Excluded Middle(LEM):
        @[T:Type] -> (T + not T)
      the rule of Double Negation Elimination
        @[T:Type] -> not (not T) -> T
      the Law of Explosion:
        ZeroType -> (@[T:Type] -> T)
      Disjunctive Syllogism
        A+B -> not A -> B
    ===
    UnitType vs ZeroType
      Singleton UnitType
        AtMostOne UnitType
          (Inhabited UnitType)
        AtMostOne ZeroType
          not (Inhabited ZeroType)
      Hence, they are compatible with what we might call a ‘trivial interpretation’ in which there are (almost) no inhabited types.
        #"almost": id-identity :: ZeroType->ZeroType
      To avoid this trivial interpretation we introduce one additional type that is inhabited by definition.
    ===
    tautology
      In particular, if the theorem is a tautology involving no premises we write 『⊢ P』. #『[]⊢ P』
    ===
    (zzz-introduction-rules) vs (zzz-elimination-rules)
      where zzz is logical connectives
      introduction 合成式
      elimination 分解式
      connective 联结项
    ===
    『|-』===『==>>』
    『-|』===『<<==』
    『-||-』===『<==>』
    Theorem (Absorption):
      [A+(A&B)] -||- [A]
      [A&(A+B)] -||- [A]
    Theorem (Distributivity of \/ over /\)
      [A+(B*C)] -||- [(A+B)*(A+C)]
    Theorem (Distributivity of /\ over \/)
      [A*(B+C)] -||- [(A*B)+(A*C)]
    Theorem (Modus ponens):
      [a:A][f:A->B] |- [f a:B]
    Theorem (Non-Contradiction):
      [] |- [not (A*not A)]
    Theorem (Modus Tollens):
      [A->B][not B] |- [not A]
    Theorem (‘Positive’ Contraposition of =>):
      [A->B] |- [not B -> not A]
    Theorem (‘Negative’ Contraposition of =>):
      [A->not B] |- [B -> not A]
    constructive_logic vs classical_logic
      has no the Law of Excluded Middle(LEM):
      Equivalence of DNE and LEM
        Neither Double Negation Elimination (DNE) nor the Law of Excluded Middle (LEM) hold as rules in constructive logic.

    Theorem (Double Negation of LEM):
      [] |- [not (not (A+not A))]
      proof:
      [(A+not A)->0]:
        [A->0]
        !![(A+not A)->0]
        [not A->0]
        [(A->0)->0]
        !![A->0]
        [0]
      [((A+not A)->0)->0]
      [not (not (A+not A))]
      #Equivalence of DNE and LEM
      Double Negation Elimination (DNE)
        [not (not A) -> A]
        [not_not A -> A] #双重否定消除
      the Law of Excluded Middle (LEM)
        [A+not A]
      * DNE => LEM
        [DNE][(Double Negation of LEM)] => LEM
      * LEM => DNE:
        [LEM][(Left (A -> (_->A)/DNE), Right (not A -> not (not A) -> 0/A)] => [DNE]
    Theorem (Explosion):
      [A*not A] |- [B]
    Theorem (Disjunctive Syllogism):
      [A+B][not A] |- [B]
    ---
    [A->B] vs [not A+B] vs [not (A*not B)]
    [not A+B] |- [A->B]
    [A->B] |- [not (A*not B)]
    [[A->B] -> [not A+B]] |- [[B->B] -> [not B+B]] #LEM
    [[not (A*not B)] -> [A->B]] |- [[not (1*not B)] -> [1->B]] #DNE
    ---
    ???[not A -> B] |- [A+B]
      no!!!
      [[not A -> B] -> [A+B]] |- [[not A -> 0] -> [A+0]] #DNE
    [A+B] |- [not A -> B]
      yes
      no <<==
    ??? [] |- [not A+not_not A] #虚排中律？
      no!!!
      ???[not A+not_not A] |- LEM/DNE
        no!!!
      LEM/DNE |- [not A+not_not A]
        yes
        所以 虚排中律 比 排中律 更易实构
    ---
    Double Negation Introduction (DNI)
      [A] |- [not_not A]
      proof:
        [a:A][f:A->0]:
          [f a: 0]
    Triple Negation
      [not_not_not A] |- [not A]
      proof:
        [f:not_not A->0][a:A]:
          [f (DNI a): 0]
    ---
    de Morgan Law
      [A*B] |- [not (not A+not B)]
        [A*B] |- [not_not A][not_not B]
        no <<==
        [[not_not A][not_not B] -> [A*B]] |- [[not_not A][not_not 1] -> [A*1]] #DNE
      [not A*not B] -||- [not (A+B)]
        [not A*not B] -||- [not A][not B]
      [not (A*B)] -| [not A+not B]
        [A->B->0] -| [not A+not B]
        no ==>>
        [[A->B->0] -> [not A+not B]]@not_all2any_not |- ???
          既不能证明命题本身，也不能证明命题推导出LEM/DNE，比它们更低层/更易实构？
            双重否定 应该是可以证明的
            相比 虚排中律，哪个 更易实构？
              * not_all2any_not ==>> 虚排中律
                [[A->B->0] -> [not A+not B]] |- [[A->(not A)->0] -> [not A+not_not AB]] #虚排中律
              * not_all2any_not ??<<==?? 虚排中律
              ???[not_not A][not_not B][A->B->0] |- [0]
              [[not_not A][not_not B][A->B->0] -> 0] |- ???
          结论：
            LEM<==>DNE==>>not_all2any_not==>>虚排中律
      [not (not A*not B)] -| [A+B]
        [not A->not B->0] -| [A+B]
        no ==>>
        [[not A->not B->0] -> [A+B]]@not_all_not2any |- [[not A->not_not A->0] -> [A+not A]] #LEM
        [[not A->not B->0] -> [A+B]]@not_all_not2any |- [[not A->not 0->0] -> [A+0]] #DNE
          结论：
            LEM<==>DNE<==>not_all_not2any==>>not_all2any_not==>>虚排中律
      我们可选用一个 最容易实构的不可无条件实构的经典逻辑中的定理 作为测试条件，使用场景如下：
        * [] |- [经典逻辑中的定理]
            #证明可实构
        * [经典逻辑中的定理] |- [最容易实构的不可无条件实构的经典逻辑中的定理]
            #证明不可实构
            not_all2any_not:To demonstrate that this is not constructively valid we need the more powerful technique of Heyting algebra models, which are beyond the scope of this Primer.


  problematic=problematical 有疑问的
    problem 问题，题目
    problem solving 问题解决
    problem defining language 问题定义用语言/用于定义问题的语言
    problem definition/description 题目说明
    problem diagnosis 问题诊断
  diagnosis [医]诊断 vs prognosis [医]预后(预测)
      预后:对于某种疾病发展过程和最后结果的预测。例如『流行性感冒的预后，视并发症的有无和并发症的性质而定，单纯的流行性感冒预后很好，并发支气管炎的预后较差﹐并发肺炎的预后最坏，能引起死亡。』
  proof irrelevance
    proof, certificate, witness, evidence
  raw_string 原始/原生/原貌/纸面/蛮区/...字符串
      view others/数学/编程/术语/raw_string原始字符串_原生字符串.txt
  cf. confer 参照，比较
    i.e. ie=(that is) 即，换言之就是
    e.g. eg=(for example) 例如
    imho 恕我直言
  未婚妻，准女婿，准岳父，预备役，准将，预产期，副手
    预备
      预备队 reserve force
      预备军官 reserve officer
      preparatory 预备的，准备上需要的
        预备期 preparatory period
        预备室 preparatory room
        大学预科 preparatory course
      预备考试，事先试验 pretest
      备胎 stepney
      预备时间 readiness time
      preliminary 初步的
        预备设计 preliminary design
        预备数据 preliminary data
    准博士 ABD(All But Dissertation)
      dissertation 长篇的学位论文
    准父母 parents-to-be
    准决赛 semi-finals
    预产期
      estimated 估计的，预计推测的 #estimated date of ...
      expected date of ...
  quasi- 准-，半- # 准标准，半仙
    pseudo- 如-，拟-，似-，仿-，伪-，假-，假性- #如夫人，拟人，仿古，伪政权/伪君子/伪军/伪随机，赝？
    mimic adj. 模仿的，仿造的，伪造的，模拟的，拟态的
      a mimic battle 模拟战
      mimic tears 假哭
      the mimic stage 表演模仿别人动作的滑稽剧
      vt. 模仿 ~ imitate
        mimicked, mimicking # 多了个k
      mimic coloring (动物)拟色，保护色
    quasi corporation 准法人
    quasi contract 准契约
  neighborhood n adj 邻居，邻近
    neighbor n adj
  pairwise adj 成对的 adv 成对地
    pairwise correlation 两两相关
    pairwise uncorrelated 两两不相关
    pairwise orthogonal 两两正交的
    pairwise independent events 两两独立事件
    pairwise independence 两两独立
    pairwise disjoint set 两两不相交集

  phase 阶段，时期，相位
    aspect 角度，观点
    facet 切面，方面
  shortcut 捷径
  命题 proposition
    propositional variable/constant 命题变量/常数
    propositional algebra 命题代数
    propositional logic 命题逻辑
  代表
    represent v 代表，表示
    representative adj 典型的，有代表性的 n 典型，样本，议员，代表人
    delegate n 代表，使节，特派员 v 委托
    agent n 委托人，代理商
    proxy n 代理人
      proxy attribute 间接属性
      proxy measure 间接测定
  first order logic 一阶逻辑
  同或
    view others/数学/编程/术语/同或XNOR.txt
  异或 exclusive or
    inclusive adj 包含在内的 vs exclusive adj 排他的，独占的
  undefined_behavior 未定义行为
  user_defined
  ground n 场地，土地，战场 adj 地面上的
  snapshot 快照，瞬像，抽点打印
    snapshot debug 抽点查错
    snapshot debugging 抽点打印调试
    snapshot dump 抽点转贮，抽样转储
  dump 卸下，倾倒，倾销，抛售，打印出，转储
  ancestor/forefather 祖先/前人 vs descendant 后代/后裔/子孙
  程序 routine, program
  严格
    rigid 刚性的，僵直的，严格的，严厉的，精密的，死板的，顽固的 #SPQR_tree
    strict 严格的，严厉的，精密的，完全的绝对的
    severe 苛刻的，严重的，严密的，严格的，严厉的，凶猛的，猛烈的，剧烈的，艰难的，简朴的
    stern 严苛的，坚决的，严肃的，冷酷的，险峻的
    stringent [规则等]严格的，[学说等]具有说服力的，[金融]银根紧缩的
    exacting 苛刻的，严厉的；辛苦的，吃力的
  只增，递增，增函数，单调函数
    单调函数 monotone/monotonic function
    递增 increasing
    单调递减 monotone decreasing
    单调递增 monotone increasing
    单调递增函数 monotone increasing function
    单调非减函数
      increasing function
      monotone nondecreasing function
      monotonically nondecreasing function
  configuration n 配置
  valid adj 有效
  besides adv except
  约束 constraint n
  满足
    satisfy
      satisfies her/equations/doubts/conditions/requirements/curiosity
      satisfied
      satisfy the prescriptive period 满足有效期
        有效期
          the term/period of validity
          effective period/duration
          life span
          valid period
        exhaustion of effect 有效期满
        effective dead-line

    meet the specification 满足技术条件
    满足需要
      satisfy wants
      meet the needs/challenge

  punctuation 标点
    冒号 colon。逗号 comma。分号 semicolon。
    句号 period, full-stop
    井号？sharp升半音
  profit 利润
  description 描述
    descriptor 描述符
    describe v
    descriptive bill 附说明的账单
  classification/grouping/naming 分类？
  long_term
    long term 长期，长寿
    long term interest-free loan 长期无息贷款
    long term manuring 长期施肥
    long term memory 长期记忆，长期存储器
    long term running test 长期运转试验
    long term sustained loading 长期持续载荷
  缺失，缺漏，脱漏
    hiatus n 脱漏，漏字
    lacuna n 脱漏部分，阙文
    omission n 遗漏，省略的东西
    deficit n 短缺，赤字
    deficiency n 短缺，缺乏
    deletion n 删除的部分
    missed 脱漏
    流失，外流
      drain
      leaky 易泄露的，多嘴的
      leak 漏洞
  解释，说明，注解，注释
    illustration n 图解，例证
    explain v 说明
      explicate 详细说明，引申
      expound 专家有系统地解说，阐述，论述
        exposition n
      explain v 说明
        explanation n
          explanatory adj 解释性的
        comment n 评论，评语，批评，解说，闲谈
          remark n 判断，意见，留意注意
          observation n 观察后得出的结论，报告观测结果
    interpret v 翻译，解释
      interpretation n #??translation
      interpretative=interpretive adj 解释用的
        interpretive code 解释用代码
    elucidate v 阐释
    construction n !!!
      put a good/bad/false construction on a person's action

  所在，所在地，所处，处所，当前，当下
    designation n 指定，指名，任命，选派，称号，标识
    当下
      the moment
        at the moment 此刻
        for the moment 目前，暂且
      on the instant
      at once
      off hand
    当前
      current 现行的，现今的
      present 现存的，在场的 <-> absent 缺席的
      immediate 直接的 <-> mediate 间接的
        邻接的，当前的
  潜在，候选
    potential 潜在的
      potential demand 潜在需求
      the potential uses for metaclasses
    latent 潜伏的，隐伏的
    candidate 候选人，候补人员
    alternate 交互的，交替的
      alternate member 候补人员
    possible 可能的，可行的，适当的预备候补役
    legal 合法的，正当的，法定的
      illegal 非法的
  开启，置位，接通，启动/起动，启用/弃用，激活的
    set-reset 置位复位
    turn-on 接通开启，启动/起动
    enable 启动，许可，允许，使能
      enabled 激活的
      disabled 残废的
      disable 禁止
    loaded 加载的，客满的 vs unloaded 空载的/dumped 废弃的 #load vs dump
    alive[表语？]/living[定语？] 在世的 <--> dead 已死的
    active 活跃的 <--> passive 不活跃的，消极的
      inactive 不活跃的，非现役的，停用的
    present 现存的，在场的 <-> absent 缺席的
    ？？在职的，离职的，休假的，工作中的？？
    显
      manifest n 清单，名单 adj 明显的 v 证明，显露
          inventory 库存清单/目录
          directory?
          catalog 目录，一览表
          scheme 电路；图解；大纲；计划方案；计谋阴谋；组织机构体系结构；配合构成；一览表，分类表
          schema 图解，略图；概要，纲要；模式
      evident 明显的
        apparent 显然的，表观的
        obvious
        clear
        plain
        noticeable 显眼的
      illustrious 著名的，显赫的，杰出的
        eminent
        dostinguished
      explicit
      exposure n 暴露
        expose vt 暴露
          exposed(‘‘leak out’’)
        exhibit v 展示 n 展品
        encapsulation n 封装，密封，包装
        encapsulate 封装，包胶，概括，压缩
          compress 压缩
          condense 浓缩，(气体)凝聚
          reduce 减缩，削减，降低
          squeeze 压榨，压挤，紧握，挤进，挤出，扣动，勒索，压迫
          constrict 收缩，收紧，抑制，限制
          contract n 契约 v (肌肉)紧缩，皱(眉)，缩短(语句)
      distinct 独特的 <-> vague 含糊的
  survey 测量
    exploration 探勘
  全:
    whole
    gross 毛重
    total
    all
  补:
    complement 补充物，补足物，互补物；补码；补语；[数学]余数，余角，余弧
    tonic 补药，滋补品
    patch 补丁
      mend 修补
      repair 修理
    compensation 补偿金，赔偿金，抵偿物
    inventory 库存清单/目录
    supplementary reading matter 补充读物
    补充说明:supplementary/additional remarks/specification
    component 环节/构件/零件/成员/成分/分量/组份/元件/要素/[物理]分力
      detail n 细节/详述/零件/元件/琐事 v 详述/选派
        detailed adj 详尽的，详细的
    填充物:
      padding 填充物
      filling/filler/gapfiller 填料
      packing n 填料压盖/填充包装
      stuffing 配料，填充剂
      plugging 堵塞
      pad n 衬垫 v 填塞
      plug 插头，塞子
        plugin 插件
      stuff 原料，要素
      pack 包裹
      inflation 通货膨胀，充气
      charge v 充
      infill v 填入
    stray parameter 补充参数
      stray 迷失的，散开的，偶尔的，稀疏的
    post selection 补充拨号

  补:
    supplementary angle 补角#和为平角
    complementary angle 余角#和为直角
    complementary set 补集
      補角 补角 [bu3 jiao3] /supplementary angle/
      餘角 余角 [yu2 jiao3] /complementary angle (additional angle adding to 90 degrees)/
      補集 补集 [bu3 ji2] /complement of a set/
  discrete adj 离散的
    <-> indiscrete adj 浑然一体的
    统一
      unification n 通用化，单一化，...的统一
        unified 联合
      unity n 单一体，统一体
        united 合并的，联合的
      uniform 同型的，均匀的
      consolidated 合并的
      integrate v 合并，整合
        integrated adj 完整的，整合的，综合的，无歧视的
        integration n 集成化，累计，平等化（待遇），整体化，统合，完成，调整，融合，积分
        integral adj 完整的，整体不可缺的，整数的，积分的 n 整体，整数，积分
      single adj 唯一的，单一的，单身的，团结一致的，一心一意诚心诚意的
  fine 细 <-> coarse 粗
  混合
    hybrid n 混合物，杂种 adj 混合的，杂种的
    admixture n 附加剂，混合剂
      admix v
      mix v 混合，搅拌
      mixture n 配料，对策，合成品
      mixer n 混合器，搅拌器，混频器
      intermix=intermingle n
    commixture n 混合物
    compound  n 合成物，合成字，围场 v 混合，调和，调教 adj 复合的(<->simple)
    blend v n 混杂，融入
    composite n 合成物 adj 合成的
      composite number/quantity 合数 <-> prime number 素数/质数 simple quantity
  附加
    v.
      add
      attach
      append
      tag to
      annex n. 附件，附加物 vt. 附加，增建，吞并，兼并
    n.
      addition
      attachment
      fork 叉，分岔，支流
      annexation n. 合并之物，附加物
      accessory n. 配件 adj. 附带的，补助性的
    adj.
      additional 追加的，额外的
      additive 附加的
      attached 附属的，附加上的
      extra 额外的，临时的，另外的 adv. 特别地，格外地
      supplementary 辅助的，补足的，副的
  副
    副标题subtitle #??无印??
    副产品 coproduct, sideproduct,side-product
    副作用 sideeffect#side-effect
  standalone 单机，独立
    stand-alone
    isolated 孤立的，被隔离的，[电学]绝缘的，[化学]分离的
  iterator 迭代器 #err:iterater____is_error_name_should_be_iterator
      detect#err:dectect____is_err__should_be_detect
  dispatch 分派，调度
    dispatcher 调度器，分配器
  transparent 透明的 <-> opaque
  scope 范围，视野  #作用域
  verify v 证实，确认
  必需
    necessary
    required
    essential
    indispensable 不可缺的 （义务，职责）
      dispensable 可有可无
  #env
    environ vt 环绕，包围
    environment n 环境
    envelope 信封
    封装
      capsulation
      encapsulation vs decapsulation
      encapsulate
      packaging
      potting
      packaged
      housed
  bottomup/topdown
  wildcard 通配符
  channel
    channels/rows/columns
  separator 分隔符
  enduser 终端用户
    user-defined 用户定义
  integer
    decrease
    increase
  weird
  piece
  query
  lifted
  intra- vs inter-
    intra- 在内部的
    inter- 在一起，交互
    internal
    external
  指示
    indicate vt 指示，指出，暗示，简述，必需要
    indication n 指示，症候，标示，刻度
    indicator n 指示物
    instruct vt 指导，通知
    instruction n 教导，指令
    directive n 指令，命令 adj 定向的，指示性的，支配的
    pilot n 驾驶员，舵手，向导 adj 试验性的 vt 驾驶，引导，引领
    marking 印记，记号
  novel 新奇的
  refrain from 避免
  horror 恐怖
  hierarchy 阶层 分层结构
    hi/er/ar/chy
      hai er ra: ki
  preclude 阻止
  reject 拒绝
  panic 恐慌
  nickname 略称/简称/绰号
  controlled 受控的 vs open
  conceptual 概念上的
  opaque 不透明的
    o/pe/k
    non-transparent
  automatic 自动的
  互斥 mutual exclusion ==>> mutex
    并联 parallel
    串联 series
    优先
      priority
        优先处理 priority processing
        优先电路 priority scheme
        优先调度 priority scheduling

      precedence:infix-operator
      preferential 有优先权的
        preference 偏好
      fallback 退路，应急办法
      preemption 优先购买权
    前瞻 提前 短路 bypass
      prospective 预期的，未来的，有希望的，前瞻性
        prospect [名词] 前景，希望
      advanced 提前的，高深的，先进的
        advance 预先的 [动词] 提前，推进
      短路 short pass, short out
      bypassing 忽略，分流，分路
      bypass 支路，旁路 [动词]忽视，省略，规避，绕道
      预言 predict[动词]
        predicted 预计的/提前预测的
        predictable 可预知的，平庸的/无创意的
      预见 foresee
        foreseeable 可预见的，不远的
      远见/预见性 foresight
        foresighted 前瞻性，深谋远虑的
      预知
        precognition[名词]
        foreknowledge[名词]
        foreknow[动词]
        unforeknowable 无法预知的
          ==>>?? foreknowable 可预知的？
    mutual exclusion parallel
    priority choice/switch
    plain series
    predictable series

  cased 包装，装入
  contiguous 邻接的，无中断的，连续的
  chrono-  [前缀]用于组词表示计时相关的词
        /data/data/com.termux/files/home/../usr/include/c++/v1/chrono
  取消，回退，后悔，调头，回溯
    rollback 卷回
    后悔
      regret
      repent
    取消
      cancel 取消（预定）
      abort 流产，夭折，终止
      draw back
      annul/disannul 废止
      repeal 撤销，废除
      revoke 吊销，撤回
      discharge
      withdraw 提取，撤销
    回退
      backspace 退格键
    后退
      fallback
      give away
      step back
      draw back
        drawback 缺点，弊端，故障，障碍
      backstep
      recession 退却，退离，（占领地的）交还
      regression 倒退，退行
        regress后退 <--> progress前进
    调头 回溯
      turnaround 回转
      back tracking 回溯法
      backtracking 沿原路返回
  预定 预订
    reserve 保留
      booking/reservation 预约 预订
    preset 预置，初调 #类似 default
      ?preplace
    preliminary 初步的
    predefine 预定义
      predefined
    prearrange 预先安排
    preplan [动词] 预先计划
      preplanned
      preplanning 预先计划，前规划
  中途 预告 预感 宣布claim 占领 独占 识别，锁（禁止回退），不归路，单行道，不能调头，不能回溯
    intermediate 居间的，中间的，中等的
    halfway [adj/adv] 不彻底的/不彻底地
    midway [adj/adv] 在中间
    stage 阶段，舞台
      staging 分期，上演
        staging station 中途站
      staged 分期的，分段的，阶梯式
    预感
      forefeel
      premonition
      presage
      presentiment
    提前
      beforehand 预先
      preact 提前
      延期
        postpone/delay 延迟
        defer 推迟
      提早
        early
        advance
        premature 早产的，草率的
          premature optimization is the root of all evil.
    加速，加快
      boost 助推，哄抬，增产，力捧，鼓吹，推荐
      speed-up 加速
      acceleration加速，促进<--> deceleration减速
        accelerate加速，促进[动词] <--> decelerate减速
        accelerated 加速的，早熟的
      hasten 催促，匆匆
      expedite 速办
      stepped-up 加速的
        step up 提升，逐步增加，升压；登上
      quicken 加快

    one-way 单行的，单向的，单程的，自私任性的
      <--> two-way 双向的，两用的
      one way entrance 单行入口
      one way traffic 单行交通
      one way street 单行道
  独占，垄断，排他，独霸，霸占，所有权，主权，私有，拥有，占有，占据，修剪
    monopoly 专有，专卖，专利，独占权
    monopolize 取得垄断
    monopolization 独占化
    排他
      exclusive
      exclusion
      sole 独家的，单身的
        sole licence contract 排他性许可证合同
        sole and unconditional ownership clause 所有权独有条款
    独霸
      dominate 占优势，威压，操纵，支配
    occupy 霸占，占有，占据
    主权
      sovereign 自治的
      supreme 最优的，最高的，最权威的，极端的，终极的
        supreme power 统治权
      supremacy 霸权
    所有权
      ownership
    私有
      private
    修剪
      prune 修剪，简洁
        pruning
      shave 剃
      trim
      clip

  assist 帮助
  mission vs task
  request 申请
    response 应答，响应，灵敏度，反应，回答
  acquire 获得，捕获
    <--> release 释放，发表
      #publish 发行，发布
      #distribution 散布，销售，流通
    resource managerment
    RAII ===‘‘Resource Acquisition Is Initialization’’
  claim 断言，主张，要求
  parallel vs switch vs choice vs alternative
  staged premature accelerated/early failure/success detection conditional pruning exclusive series(backtracking two_way series, exclusive monopoly one_way supreme series)
  ===
  decide 决定
  frame 框架，帧
    [stack_frame]
    stack frame of func to hold automatic object
    automatic vs static vs thread_local vs free-store vs temporary
  operation 效能，作用，业务，工事，操作，运算，实施，运转
  合作
    coordination 协调，对等关系
      coordinate 坐标，坐标系，配位，配价的
    cooperation 合作，协作，互助
      cooperative 非常常用
      cooperate[动词]
      我觉得 强调 协调运转，环环相扣，过程性，并行
    collaboration 合著
      collaborate[动词]一起工作
      我觉得 强调 共同努力以得到一个结果，结果性，可能串行
  serial 串行的，串联的
    serialization 串行化
    series
  并行，并发
    parallel 并联的，并列的，平行的，并行的，并发的
      parallelism[名词]并行性
      时间点上有重合
    concurrent 并行的，并发的
      concurrency[名词] 并行性，并发性
      时间段上有重合
    coincide[动词]同时发生
      coincidence[名词]
    同步 异步
      #chrono- 计时
      #syn chrono us
      synchronous 同步的，同期的，同时的
        synchro- 同步的
        synchronize[动词]同时发生，并发
        synchronized
      asynchronous 异步的，不同期的，不同时的
    simultaneity 同时性
      simultaneous 同时的，联立
      simultaneously 同时地
      ===
      vs simulate[动词]模拟，伪装，仿真
        simulator 仿真器，伪装者，模拟程序
        simulation 赝品
    collateral 旁系的，附属的，次要的，侧的
      lineal 直系的，正统的
      branch分支 vs trunk主干 #stem 茎，干线
      次要
        secondary 次要的，第二位的，衍生的，从属的，辅助性的
        subordinate 下位的，下级的，附属的
        accessory 补助性的，附带的
        auxiliary 辅助的，协助的，补充的，备用的
        minor
        side effect 副作用
        collateral
        non-dominate
        non-essential
      主要
        main 主要的
          mainstream 主流
        chief 最高的，最重要的，最大的
          ?supreme
        major 多数的 <--> minor 少数的
        principal 首要的
          prime 第一流的，原始的，根本的
          primary 初等的，初步的，初期的，原始的，第一位的，根本的
        ruling 支配性的，占优势
          ?dominate
        key 关键的，基本的，重要的
          key link 主要环节
        leading 卓越的，领衔的
          leading role 主角
        essential 必需的，本质的
        basis/base 基础，基准
        mass 主要部分，质量
        master 主要的，支配性的
        prevailing 流行的，优势的
        cardinal 极重要的
  efficient 有效率的
    coefficient 系数
  category 范畴，种类
    ?class
  material原料，资料 vs resource资源
  product产品
  parameter 参数
  碰撞
    avoid collisions
      The procedure of consistent non-colliding renaming is called α-conversion.
        #[pg29/85]
        # [HTT]A Primer on Homotopy Type Theory-Part 1-The Formal Type Theory.pdf
        #       HTT_Primer-PART-1.pdf
    collision[名词]
      collide[动词]
        vs conflict 对立，争执，斗争，冲突
          such a conflict is resolved by adding an overriding function to the most derived class.
      collision-free
    contradiction 矛盾
    坍塌
      collapse倒塌，瓦解，折叠，下陷，[价值体力健康]暴跌，衰退，病倒，虚脱，颓丧
      slump 掉落陷入，暴跌骤降，萧条不景气
      缩
        contract 契约，负(债)，缩，皱，沾染，收缩，感染 <-> expand 展开
        shrink 缩短，缩水，蜷缩，退避，畏缩
        shrinkage
    clash 冲突，碰撞
      name clash
    crash 垮台
    impact 冲击
    knock 敲击
    bump 冲撞
    impinge 碰到，侵犯，影响
  -free
    smogfree 无烟的
    carefree 不关心的，不负责的
    taxfree 免税的
    collision-free


  promise + future
    promise 承诺（做某事）指望，可能性
    compromise 妥协
    future 未来，远景
  无限制
    unlimited 无边际的，无限的，极大的，过度的
    unrestricted 不受约束的
    unrestraint[名词] 放纵
    unbridled 不羁的，无束缚的，放纵的，蛮横的
    unconfined 松散的，自由的，无拘束的
    unbounded 无边际的，无止境的
    open-end 开放的，可广泛解释的
      open end licence 开放式许可证
      open-ended 有无限多的，可扩充的，可扩展的，开口的
  超长
    * 超过额定长度，超过允许长度 extra-
    * 超级长的，非常长的 ultra-
    overlength
      over-length
    superlong
      super long
    extra long
    ultra-long
    lengthy 长久的，漫长的，冗长的
  extra- 额外的，临时的，特别的，格外的，另外的，超出的
  ultra- 极端的，偏激的，过度的
  flow 流动
    data flow diagram

  qualified 合格的，适任的，通过检查的，有资格的；有限度的，受限制的，受限定的
    ##qname-受限定的标识名，被限定词修饰的标识名
  受控的，受管理的，受管制的
    受控
      controlled
      influence[名词] 有影响力
    管理
      administer[动词] 统治
        administrative operator 管理操作员
      rule [动词] 统治
      control 管制
      manager 经营
      direct 指导
      superintend 监督
      supervision [名词] 监督
        supervisor 监督者
        supervisory [err:受监督的？]还是[yes:作为监督者的/用作监督目的的/监督用的？]
          #类似 monitor
          supervisory operating system
          supervisory program 管理程序
    控制
      control
      master 驯服
      bridle 抑制
      curb 限制
      dominate 支配
      govern 治理
      manipulate 操作，窜改  #篡改？窜改？
      cybernation[名词] 电脑控制
        cybernate[动词] 使受电脑控制
        cyber- 网络/数码/电脑
        cyberpunk 网络朋克

    管制
      restrain 克制，羁押
      surveillance 看守，监视
    监控
      monitor 监控器
      supervisor
        supervisory
      watch dog
    维护
      maintain[动词] 维修
        maintenance[名词]保养
          upkeep
      conserve 节约，保存
      preserve 保持
      safeguard [动词]防护 [名词]保护装置
      uphold 支持
      defend 保卫，辩护
      assert 坚持，断言
      service 服务
      working 实用的，现职的
      attendance 看护
    被占领的，被占用的，被分配的，被瓜分的，有主的（无主之物）
      ownerless 无主的
      荒地
        wild 野生的
          <--> tame 驯服的
          <--> cultivated 被 耕作/栽培/养殖 的
        barren 不毛的
        wasteland
      lord 领主
        lordless 无君主的，无丈夫的
      host （待客的）东道主，寄主
      ruled 直纹的，带方格的
        unruled 未统御的，不带方格的
      圈地
        enclosure 圈地，围场
          <--> common 共有地
          enclosed 闭式
            enclosed area 封闭区
        closure 闭包
        包络 envelope 信封，封套，封皮，气囊
          profile 轮廓，外形，简介，概貌
          包络失真 envelope distortion
  中继
    relay 继电器，接班人，转播
    retransmission
    repeater 中继器
      repeating
      trunking #trunk- 长途
    接力 relay
    过渡
      transitional 过渡的，过渡时期的
        transition 变迁期，过渡时期
      transient 瞬变的，过渡的，短期的，瞬息即逝的
      passage 通道
      buffer 过渡层，缓冲器/缓冲区
      middle
      intermediate 居间的，中间的，中等的
      halfway [adj/adv] 不彻底的/不彻底地
      midway [adj/adv] 在中间
      stage 阶段，舞台
        staging 分期，上演
          staging station 中途站
        staged 分期的，分段的，阶梯式

  篡改？窜改？
    窜改 原文/账目
      改易（文字）:窜改旧史
    篡改 历史/经典/政策/理论
      用作伪的手段对经典﹑理论﹑政策等进行改动或曲解。

  union
    anonymous union #匿名
    tagged union === discriminated union
      #mine:cased
    new(&s) string{ss};//placement new: explicitly construct string (§11.2.4)
  lollipop==lollypop 棒棒糖

  目的
    purpose
    destination
    goal
    aim
    target
    objective
    intention
  消耗
    consume[动词]
      consumption[名词]
  ？朴素，天然，质朴？
    severe 严重的，苛刻的，简朴的
    austere 节俭的
    sober 不鲜艳的
    unadorned 未加修饰的
    modest 谦逊的，有分寸的
    rustic 老土的，粗糙的
    stark 写实的，纯粹的，无装饰的
    naked 裸露的
    raw/rude/crude 未加工的
    natural
      innate 天生的，先天性的 <--> acquired 后天性的，获得性的
    plain 清楚明白的
    simple 单纯的
    easy 容易的
    innocent 无罪的，无辜的 <--> guilty
    naive 天真幼稚的
    childlike 童真的
    pure
    天真 《庄子:渔父》『礼者，世俗之所为也；真者，所以受于天也，自然不可易也。故圣人法天贵真，不拘于俗。』
  使用中/工作中/在线/线上/活的/存活的
    use 使用
      usable 可用的
      usage 用法 abusage 误用
    exploit 利用
    apply 运用
    active 活跃的 <--> passive 不活跃的，消极的
      inactive 不活跃的，非现役的，停用的
    working 在职的
    loaded 加载的，客满的 vs unloaded 空载的/dumped 废弃的 #load vs dump
    on-line 线上，在线，联线，联机
      <--> off-line 脱机，离线
      on-line operation(OLO) 在线操作
      on-line data processing
    in-line 在线，同轴的，内联，直列的
    demountable 可拆卸的
    alive[表语？]/living[定语？] 在世的 <--> dead 已死的
    survival 残存的
    dangled 悬挂着的
      ?undangled
    ??scoped??
    lifetime 终身的
    duration 存续期间
    life span 生存期间
    嵌入
      inlet 入口 outlet 出口
      embed
      inbuilt
      builtin
      buried
      telescope
  嵌套
    nest
      nesting
      nested procedure
      nested recursion
      nested structure
      nested loop
    escape 脱逃
      escapable cost 可节省的成本
    imprison 监禁
    detain/jail/intern 拘留
    arrest/apprehend/capture 逮捕
    captive 被俘的，被监禁的，被系住的


  chunk vs block vs piece
    chunk 厚块，厚片，大块
    block 木块；阻塞
    part 部分（构成全体的一部分）
    portion 从全体中划出的一部分
    piece 碎片，零件（脱离全体的一部分）
      piecework 计件工作

  error-prone
    prone 倾向于，有...倾向的
  specific
    unspecified
    specification
  indicate
  formal argument === parameter
    vs actual argument
  facility 设备；容易<-->difficulty
    facilities and equipment
  variadic template
  arbitrary
  ellipsis =?= ...
  logical criteria = precondition | postcondition | ...

  illustrate 举例说明
  demonstrate 示范，论证
    undemonstrated 未证实的
  fault-tolerant
    failure[名词]失败 <--> success
    fault 缺陷，故障，过失
      faultless 完美无暇的，无失误的
  plausible 貌似真实的
    implausible 难以置信的，不似真实的
  decent 得体的
  deprecated
    deprecate 非难，藐视
    outdated 过时的
    duplicate 重复的
  syntactic sugar
  name clash
    accidental name clash
    potential
  explicit qualification
    qualifier
  synonym
  confusion
  orthogonal adj 直角的，正交的
  iterator
    iterator
  marginal
  section
  examine
  technical
  aspect
  compose
  convenience
  safety
  accessible
  using-declaration
  using-directive

  intrusive
  backward compatibility
  consequently
  particular
  circumvented
  realistic
  circumstances
  guarantors of invariants
  access specifiers
  obey rules
  intricacies of our code
  fortunately
  implicit conversion
  explicit
  be optimized away (elided)
  mundane sophisticated complicated
    the simple and mundane is statistically far more significant than the complicated and sophisticated.
  contrived
  opportunity
  refinement
  eliminate
  denote
  typical
  immensely
  overelaboration
  leads to inconvenience
  deliberately being a bit paranoid
  sloppy
  firmly entrenched
  mandatory
  concrete classes(value types) vs abstract classes vs class hierarchies
    value-oriented programming
    object-oriented programming
  distinguish
  emphasize
  similarity
  intent vs purpose
  incurs no hidden overhead
  indirection through pointers
  housekeeping
  gross
  establish the invariant
  inevitably
  homogeneous
    how to define constructors to accept arbitrarily sized homogeneous initializer lists (such as {1,2,3}and{1,2,3,4,5,6}).
  delegating constructor
  shallow copy vs deep copy vs move operation vs copy-on-write
    shared state vs independence
      entangled when the requirement of independence have been violated
        garbage collection
    praised for ‘‘efficiency’’
  obvious
  alternative
  caveat
  ancillary function
  no compelling reason
  directed acyclic graph
  unsurpassed
  homogeneous containers
  heterogeneous lists
  conceived
  brand-new
  contextual keyword
  indulge
  interface inheritance vs implementation inheritance
    abstract class + pure virtual function
    using baseclass::f;
  in contrast to
  multiple-inheritance lattice
  inquires
  turning a knob
  ?frontend
    sibling
    ambiguous
  replicated
  nuisance
  consistent
  terminology
  mixin
  class hierarchy navigation
    class lattice === class hierarchy
  be unduly concerned about
  virtual call mechanism
  RTTI vs RAII
    RAII ===‘‘Resource Acquisition Is Initialization’’
    RTTI === ‘‘run-time type information’’
  downcast vs upcast vs crosscast
    Casting from a base class to a derived class is often called a downcast because of the convention of drawing inheritance trees growing from the root down.
    Similarly, a cast from a derived class to a base is called an upcast.
    A cast that goes from a base to a sibling class is called a crosscast.
  abbreviated to
  dynamic dispatch
    double dispatch
  a region of memory
  generic
  subscripting, concatenation, and comparison
  instantiation, specialization
  parameterized
    A version of a template for a specific template argument list is called a specialization.
    The process of generating a class or a function from a template plus a template argument list is often called template instantiation.
    特化 - 特化版本的模版声明+定义体
    实例化 - 模版绑定实际参数后生成的实际代码+对象
    point of instantiation 第一次使用模版产生实例代码+参数相关的错误检查
  code bloat, code shrinkage
  early detection
  granted
    I made all members of Link private and granted List access.
  acronym, synonymous
  nonsensical
  exposure
  encapsulate, encapsulation
  concept, constraint
    Concepts and Constraints
  weave
    This implies opportunities to weave together information from different contexts.
  manifest
  endeavor
  accomplishment
  craft, reflect
    I see a concept as a carefully crafted entity that reflects fundamental properties of an application domain.
  hesitate
  semantic specification
  emphasize
  lexicographical ordering
  archetype #仅止于刚好满足概念约束最小需求的类型，用于 检查模版的实现 有无 超出声明的需求
  sufficient
  backbone
  performance-critical areas
  mature examples
  paramount
    run-time efficiency and compactness are paramount.
  policies#policy
    parameterize classes and functions with ‘‘policies.’’
      comparison criterion for a map
      actions for algorithms (§4.5.4, §32.4)
        sort()
      allocators for containers (§31.4, §34.4)
      deleters for unique_ptr(§34.3.1)
  comparison criterion
  elaborate
  crucial
  tedious
  refrain
  deliberate, tradeoff, flexibility, opportunity, obscure
    Not allowing an ‘‘empty’’ argument to mean ‘‘use the default’’ was a deliberate tradeoff between flexibility and the opportunity for obscure errors.
  traits#trait
    The technique of supplying a policy through a template argument and then defaulting that argument to supply the most common policy is almost universal in the standard library (e.g., §32.4).
      Curiously enough, it is not used for basic_string(§23.2, Chapter 36) comparisons. Instead, the standard-library string relies on char_traits(§36.2.2). Similarly, the standard algorithms rely on iterator_traits(§33.1.3) and the standard-library containers rely on allocators(§34.4). The use of traits is presented in §28.2.4.
  primary template vs partial specialization vs complete specialization
    template<typename T> class Vector {...}; //general vector type #primary template
    template<typename T> class Vector<T∗> : private Vector<void∗> {...}; //partial specialization
    template<> class Vector<void∗> {...}; //complete specialization

  code bloat~type erasure
    'The C++ Programming Language(4ed)(2013).pdf' :: pg731[746/1366]pg733[748/1366] #code bloat代码爆炸~type erasure类型擦除
  consistent
  customization point #e.g. overload std::swap
  distinction, razor thin, irrelevant
    With this last version the distinction between specialization and overloading has become razor thin and largely irrelevant, so we can simply write:
  irregularity, irregular
    irregularity of an argument type
    ‘‘irregular types’’
  provide, flexible, efficient
    provide flexible and efficient parameterization of types
  notation
  mechanism
  manual, eliminate, redundant, replicated, instantiation
      eliminating redundant replicated instantiations
      26.2.2 Manual Control of Instantiation
  innocent-looking
  coincidence, incidence
  mysterious
  overaggressive
  verbosity
  manipulator
    the endl manipulator
  exploit, various, commonality
    exploits various forms of commonality

  deceptive, duality, rough, approach, individual, accommodate, appropriate, optimal
  polymorphism
    * run-time polymorphism
    * compile-time polymorphism === parametric polymorphism
    ---
    The rough duality of the generic and object-oriented approaches can be deceptive.
        Object-oriented programmers tend to focus on the design of hierarchies of classes (types) with an interface being an individual class (Chapter 21).
        Generic programmers tend to focus on the design of algorithms with the concepts for template arguments providing an interface that can accommodate many types (Chapter 24).
    The ideal for a programmer should be mastery of both techniques to the point where either can be used where most appropriate.
        In many cases, the optimal design contains elements of both.

  undesirable
  premium
  essential
  inhibit vs forbid vs prohibit
    inhibit 阻止，抑制
    forbid/prohibit 禁止 #prohibit 法律 正式用语
    允许
      permit vs allow vs let vs make
      permit 积极地给予许可
      allow 默许 或 不禁止
      let 不反对对方做
      make 强制对方执行
  be a struggle
  disaster
  instantly vs immediately
  compensate
  constitute
  hypothetical
  devise
  expert territory
  trepidation
  compiler intrinsic
  departure, conventional, shine
    departure from conventional notation that lets implementation details shine through
  indispensable
  compelling
  divergence
  encapsulation
    exposed(‘‘leak out’’)
  exotic
  scaffolding/boilerplate
  repetitive
  potentially, possibility, violation
    potentially differing types
    possibility of type system violations
  plus vs add vs subtract vs minus
  erroneous
  parameter pack
    args...
    ‘‘peel off’’
  hypothetical
  quantity, unit, dimensionless #？不带单位？
    unknown quantity 未知量
    known quantity 已知量
      quantity数量 vs quality品质
    if (speed == 20)//error : 20 is dimensionless
    A Quantity is a numeric value with a Unit.
    A Quantity is a value with an associated Unit:
  physical measurement
  dictated
  magnitudes
  tensors ？张量？
  irregular vs jagged
    check_non_jagged
  utter nonsense
  designate, unknowns, equations, diagonal coefficients, ‘‘back substitution’’, pivot
    the x_s designate the n unknowns;a_s and b_s are given constants.
    The goal is to find values for the unknowns that simultaneously satisfy the n equations.
    the square n-by-n matrix defined by the coefficients
    Gaussian elimination [Freeman,1992], [Stewart,1998], [Wood,1999]
      we transform A and b so that A is an upper-triangular matrix.
      If we can get all the diagonal coefficients to be nonzero, then the system has a unique solution, which can be found by ‘‘back substitution.’’
      Vec classical_gaussian_elimination(Mat2d A, Vec b)
      {
        classical_elimination(A, b);
        return back_substitution(A, b);
      }
  fused operations #融合？
  conscious
    to satisfy performance-conscious users
  accommodate
  stringent
  moderate fluency
  try not to reinvent the wheel.
  cult of orthogonality
  obscure or dangerous
  mnemonic
  commentary distinguishes
  associative containers multimap and multiset
  diagnostics vs debug
  container adaptors
  consistent
  contexts vs categorys
  permitted
  retrieved
    future_already_retrieved
    promise_already_satisfied
    broken_promise
  ultimately originate
    ultimately vs finally
    optionally
    error-message
  potentially portable
    system-specific
    category-specific
    multiple platforms
  convenience
  tedious
  deem, roughly, devise
    This roughly means that any test for equality that you can devise on the value of the objects must deem the copy equal to the original.
  amortized linear time
  dwarf a small cost proportional to
    dwarf adj 矮小的 <-> giant 巨大的
      dwarf n 侏儒
      dwarf v 矮化，妨碍发育生长/使-发育不良变小/使-相形见绌
    proportional 成比例的，均衡的，相称的
  logarithm
  quadratic
  asymptotic 渐近的，渐近线的
    asymptotic approximation 渐近逼近法，渐近性近似
    asymptotic behaviour/characteristic 渐近特性，渐近状态
    asymptotic cone 渐近锥面
    asymptotic convergence 渐近收敛
    asymptotic curve 主切曲线
    asymptotic direction of arrival 到达的渐近方向
    asymptotic distribution of eigenvalue 渐近分布
    asymptotic error constant 渐近误差常数
    asymptotic convergence 渐近收敛
  perennial 常年的/长年的/长期持续的/多年生的(植物)/永久的，终年的/一年到头的/四季不断的，反复的/不断发生的
    see:permanent
  emphasis
  relationship between A and B
  capacity, increased, exceeded, reserve, surprised, measurably affect performance, essentially, growth strategy, estimates, invalidation, predictability, prevent, delay
  chars.push_back()
  caused a relocation, ‘‘invalidated’’
  design, minor, stylistic, binary, framework
    this design is with minor stylistic differences that of a real binary tree framework [Austern,2003].
  benefit, optimization
    I benefit from the empty-base optimization.
  traversal
    indirect through a pointer
    consecutive access through a vector-like structure
    optimal
    efficient random access
    underestimate these benefits
    incur
    an order of magnitude more expensive than
    equivalent data
    spectacular
    surprising
    suggest
    compactness and efficiency
    unintentionally compromised
    two-dimensional matrix
    two obvious alternatives
    subscripting
    stores elements contiguously
  tendency
  semantics, occasionally, disadvantage
    enables efficient move semantics
    that occasionally puts it at a disadvantage
  pessimization
  minimizing
  worthwhile
  massive
  empirical
  splice
  comparison criterion
  bewildering
  convenient
  realistic, scenarios, typically
    load factor of an unordered associative container = .size()/.capacity()
    (worst caseO(n∗n)) how unordered_map::rehash()?
    in realistic scenarios typically do
  experimentation
  adaptor, provide, restricted
    A container adaptor provides a different (typically restricted) interface to a container.
  lexcographical
    lexcographical_compare()
  eliminate, duplicate
    unique() does not eliminate duplicates
  a half-open range [begin:end)
  end points to the one-beyond-the-last element of the sequence.
  Currying or partial evaluation
  deprecated predecessors
  curious
  individual, deem, overhead
  concatenation
  homogeneous vs heterogeneous
  significant, cascade, triggered, garbage collection delay, detrimental, response
      the cascade of destructor calls triggered by its deletion can cause a significant ‘‘garbage collection delay.’’ That can be detrimental to real-time response.
  allocator
  typically, verbosity, alleviated, aliases
    Typically, the verbosity would be alleviated by the use of aliases.
  disguised
    safely-derived pointers vs disguised pointers

  mortal, nasty, scatter, legitimate
    ordinary mortals
    nastier tricks
    scattering the bits of a pointer around in different words
    legitimate reasons
  consecutive vs contiguous
  archetypical
  ======
  appending
  ======
  ???!!!
  重命名

    串===序列/流
    规范串===数组
      #变长|定长
      #变长（变短）？易长（异常）？动长？
    链串===链表
    单端改动串===栈/后进先出队列
    单向移行串===队列/先进先出队列
    双向移行串/双端改动串===双向队列

    阵===矩阵/二维矩阵
    点
    有序正交点===元组/向量/位移/一维矩阵
    有序命名正交点===命名元组
    无序索引正交点===记录/结构体

    #associative containers multimap and multiset
    关联表===映射/词典
      #单主键|多主键 / 单索引|多索引
      #单一等价代表|复数等价代表
    无序散列关联表
    有序散列关联表
    全序平衡树关联表

    集===集合
      #单一等价代表|复数等价代表
    无序散列集
    有序散列集
    全序平衡树集
=============]]]]]end:explain


===
to read:
  book:C++
    '/sdcard/0my_files/book/lang/C++/The C++ Programming Language(4ed)(2013).pdf'
      e others/book/The\ C++\ Programming\ Language(4ed)(2013).txt

    download: cppreference.com
      termux
      update clang c++20
===clang
$ view ../../../usr/include/c++/v1/list
  TODO:how both .size() and .insert() O(1)?
  ls.insert(at_before, begin, end)
    ==>> ls => this.sz
    ==>> copy => this.sz ++ repeat n times
    ==>> NOTE: insert() copy not emplace-move/snap from another list!!!
  lst.splice(p,lst2)
    Insert the elements of lst2 before p;lst2 becomes empty
    O(1)
  lst.splice(p,lst2,p2)
    Insert the element pointed to by p2 in lst2 before p; the element pointed to by p2 is removed from lst2
    O(1)
  lst.splice(p,lst2,b,e) Insert the elements [b:e) from lst2 before p; the elements [b:e) are removed from lst2
    I think must be O(n)
      yes! clang::list::splice using distance() to count!!!

$ ls ../../../usr/include/clang -1
  ARCMigrate
  AST
  ASTMatchers
  Analysis
  Basic
  CodeGen
  Config
  CrossTU
  DirectoryWatcher
  Driver
  Edit
  Format
  Frontend
  FrontendTool
  Index
  Lex
  Parse
  Rewrite
  Sema
  Serialization
  StaticAnalyzer
  Tooling
$ ls ../../../usr/include/clang-c/ -1
  BuildSystem.h
  CXCompilationDatabase.h
  CXErrorCode.h
  CXString.h
  Documentation.h
  Index.h
  Platform.h
$ ls ../../../usr/include/c++ -1
  v1
$ ls ../../../usr/include/c++/v1/ -1
  CMakeLists.txt
  __bit_reference
  __bsd_locale_defaults.h
  __bsd_locale_fallbacks.h
  __config
  __config_site.in
  __cxxabi_config.h
  __debug
  __errc
  __functional_03
  __functional_base
  __functional_base_03
  __hash_table
  __libcpp_version
  __locale
  __mutex_base
  __node_handle
  __nullptr
  __split_buffer
  __sso_allocator
  __std_stream
  __string
  __threading_support
  __tree
  __tuple
  __undef_macros
  algorithm
  any
  array
  atomic
  bit
  bitset
  cassert
  ccomplex
  cctype
  cerrno
  cfenv
  cfloat
  charconv
  chrono
  cinttypes
  ciso646
  climits
  clocale
  cmath
  codecvt
  compare
  complex
  complex.h
  condition_variable
  csetjmp
  csignal
  cstdarg
  cstdbool
  cstddef
  cstdint
  cstdio
  cstdlib
  cstring
  ctgmath
  ctime
  ctype.h
  cwchar
  cwctype
  cxxabi.h
  deque
  errno.h
  exception
  experimental
  ext
  filesystem
  float.h
  forward_list
  fstream
  functional
  future
  initializer_list
  inttypes.h
  iomanip
  ios
  iosfwd
  iostream
  istream
  iterator
  limits
  limits.h
  list
  locale
  locale.h
  map
  math.h
  memory
  module.modulemap
  mutex
  new
  numeric
  optional
  ostream
  queue
  random
  ratio
  regex
  scoped_allocator
  set
  setjmp.h
  shared_mutex
  span
  sstream
  stack
  stdbool.h
  stddef.h
  stdexcept
  stdint.h
  stdio.h
  stdlib.h
  streambuf
  string
  string.h
  string_view
  strstream
  support
  system_error
  tgmath.h
  thread
  tuple
  type_traits
  typeindex
  typeinfo
  unordered_map
  unordered_set
  utility
  valarray
  variant
  vector
  version
  wchar.h
  wctype.h

$ ls ../../../usr/include/c++/v1/*/ -1
  ../../../usr/include/c++/v1/experimental/:
    __config
    __memory
    algorithm
    any
    chrono
    coroutine
    deque
    filesystem
    forward_list
    functional
    iterator
    list
    map
    memory_resource
    numeric
    optional
    propagate_const
    ratio
    regex
    set
    simd
    string
    string_view
    system_error
    tuple
    type_traits
    unordered_map
    unordered_set
    utility
    vector

  ../../../usr/include/c++/v1/ext/:
    __hash
    hash_map
    hash_set

  ../../../usr/include/c++/v1/support/:
    android
    fuchsia
    ibm
    musl
    newlib
    solaris
    win32
    xlocale
$
===
TODO:
  非确定型有限状态机:
    输入符号的集合操作:
      空？
      补
        全集+空集
      交
        批量交集 :: @[input<-[symbol_set]] -> ([symbol_set{nonempty}], [{idx}]{len==len(input)})
    由巨量集合转化为 互斥集 再变成 内部符号
    输入文本:tell/seek
    捕获capture如何实现？
    贪婪+拒绝？回溯？
      大范围划定 之后 小范围细分
    着色
      只有 终态 才着色？还是 中间态 也着色？
      单色？色集？
TODO:
  c++头文件 新建自动化
    #escape include guard
    #len{ddd}_{name}
    #len{ddd}esc_{escaped_name}
    #len{ddd}ext_{extension_suffix_name}
    项目根目录+头文件相对路径
    ==>>
    //{xxx}.hpp
    #ifndef INCLUDED__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{xxx}_hpp
    #define INCLUDED__len{ddd}_{dir0}__len{ddd}_{dir1}__len{ddd}_{dir2}__len{ddd}_{xxx}_hpp
    //#include "dir0/dir1/dir2/xxx.hpp"
    #include "xxx.hpp" //this header
    namespace dir0{ namespace dir1{ namespace dir2{
    ... ...
    } } }
    #endif//INCLUDED__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{xxx}_hpp

TODO:
  vector with fixed capacity
  deque with fixed capacity
TODO:
  矩阵高斯消元 携带 rhs向量/矩阵

TODO:
  ops
    e script/IOps.py
  计件薪时
    单位运算模块 unit system
      metric vs unit vs dimension
      可度量概念=时间|距离|钱|质量|...
        我觉得 量纲 应该 对应 metric
        量纲dimension维 维度
        量纲关系 dimension relation
        量纲常量 dimensional constant
        无量纲dimensionless
        无量纲系数dimensionless factor/coefficient
      量纲=mul~ measurable_concept**n {(measurable_concept,n)<- 可度量概念*整数}
          <<==量纲的乘除法
      基本单位=未知量*可度量概念
        unit
        unknown quantity 未知量
        known quantity 已知量
          quantity数量 vs quality品质
      复合单位=未知量*量纲
      由于 部分同量纲单位 之间的比例关系 未知 或 待求(如：每月的工作日数，每工作日的工作小时数)，故 带量纲值 = 多项式分式<未知量...> * 量纲(<<==加法的量纲一致性原则)
        ==>> 需要 带多个变量的 多项式分式
        ==>> 需要 代数ops
        ==>> 需要 IOps!!!

    每月的工作日数、每工作日的工作小时数、每大件的小件数、每小件几分钱、每月收入、每日大件数、每大件起步耗时、每小件几秒
    每月收入=每大件的小件数*每小件几分钱 * 每月的工作日数*每日工作小时数*每小时大件数
      每大件耗时=(每大件起步耗时+每大件的小件数*每小件几秒)
      每小时大件数*每大件耗时=1
      ==>>
      每大件耗时=
        =1/每小时大件数
        =每大件的小件数*每小件几分钱 * 每月的工作日数*每日工作小时数/每月收入
      每小件几秒
        =(每大件耗时-每大件起步耗时)/每大件的小件数
        =(每大件的小件数*每小件几分钱 * 每月的工作日数*每日工作小时数/每月收入-每大件起步耗时)/每大件的小件数
        =每小件几分钱 * 每月的工作日数*每日工作小时数/每月收入-每大件起步耗时/每大件的小件数

TODO:
  make_makefile
    独立式辅助文件 vs 注入式描述
      集中控制文件 指明 哪些文件 拥有 注入式描述，字符编码 及 如何 注入/抽取 的 格式(格式=开始行 结束行 行前缀(以注释的方式存在))
    描述:
      文件类型(==>>处理方式):
        *用户预先提供的
          真实文件名
          前置依赖扩散 抽象目标名...
            要不要 预处理 预编译？
              指明 预处理的 抽象目标名
              这样一来，所有 依赖本文件的目标 将也依赖 本文件的预处理目标
          前置需要 哪些项目内部文件 真实文件名 用于 编译期
          后置需要 哪些项目内部文件 抽象目标名(本头文件的实现文件)、哪些项目外部库 抽象外部库名 用于 链接期
        *make自动生成的
          #由 文件类型 决定如何生成
          抽象目标名+构造器参数-依赖类型(见下面)
            (+文件类型+最终配置(后缀名+项目输出根目录<文件类型>(.gch预编译头文件 最好与头文件 放在一起，否则 源文件 依赖的 就要从 头文件 改成 .gch预编译头文件 最好与头文件 放在一起，否则 源文件 依赖的 就要从 头文件 改成 .gch，而且 编译器 还不知道 在哪找到它)))==>>真实文件名)
            #含 相对路径(相对于 本文件所在目录) 不能是 绝对路径(相对于 项目源代码所在根目录，不行 是因为 可能移动))
          前置依赖扩散 抽象目标名...
          前置需要 哪些项目内部文件 真实文件名/抽象目标名 用于 编译期
            //<==>构造需要 哪些项目内部文件 真实文件名/抽象目标名 用于 编译期
      依赖统一表达:
        [依赖类型][依赖跳转类型]:对象名...
        ---
        依赖类型:
          如:
            +前置依赖/编译期依赖
            +后置依赖/链接期依赖
        ---
        依赖跳转类型:
          如:
            +吾之所需
              (本文件我依赖哪些对象？)
              头文件 编译期依赖 其他头文件
              头文件 链接期依赖 自身的实现文件/源文件的目标文件+外部库
              源文件的目标文件 编译期依赖 该源文件
                  直接依赖 用作 构造参数
                  直接依赖+间接依赖+捆绑依赖 仅用于 决定 是否需要 更新/构造
              可执行文件/库 链接期依赖 目标文件
                  直接依赖+间接依赖+捆绑依赖 用作 构造参数
                      但 如何 区分 目标文件 与 外部库？
                          命名规则，一为 抽象目标名，一为 抽象外部库名
            +吾之捆绑
              (若依赖我，则捆绑依赖其他对象，虽然这些对象 并非 吾之所需)
              xxx.hpp 捆绑 xxx.gch
              xxx.cpp 依赖 xxx.hpp 并自动捆绑依赖 xxx.gch
                  先 预编译 xxx.gch 再 编译 xxx.cpp
              xxx.gch 依赖 xxx.hpp 但 并不捆绑依赖 自己！！
                多个 捆绑对象 之间的依赖关系？？
                  如果 它们都依赖xxx.hpp，那么 必须 解开 依赖循环！
                  必须 显式 声明 有无依赖关系？若有，谁依赖谁？

TODO:
  矩阵乘法 与 单位乘法
  假设 行i的单位 叫 r[i], 列 c[j]
    则 mx[i,j] * (r[i]/c[j]) 每个元素 都拥有与众不同的单位
    输入输出 两个面 箭头arr a->b . b->c === a->c
    乘法 将lhs的输出cL[j]与rhs的输入rR[j] 匹配
      匹配的 均作乘法
      最后 出现 多个 元素 带相同单位 rL[i]/cR[k],求和简并为一个， a->c+++a->c === a->c
TODO:
  def:[并联串联]
    语法+数据结构，指令，偏序（有向无环图，类继承关系）
    语法+数据结构:
      并联-空间上的重叠-union 并集
      串联-空间上的先后顺序-direct_product tuple
    指令:
      并联-时间上的重叠-并行
      串联-时间上的先后顺序-串行
    偏序:
      并联-偏序无关
      串联-偏序大小

    // C++ class 有问题: 数据成员的次序: 逻辑次序/概念次序，内存布局次序，初始化次序，大小/相等比较次序(+部分数据成员无关)

  class tokenizer/lexer:
    noise<state>
      eg.
        skip/ignore space whether [contains newline?]:
          [logical-line not complete] <==> [noise-space contains newline]
  class grammar:#parser/recognizor
    @input_filter(f...)
    @plain_token_name #rsymbol
    def token_name(sf, /)-> None#not callable after @plain_token_name
      #或 istream -> position -> tmay token
    @output_filter(f...)
    @plain_rule_name #lsymbol
    def rule_name(sf, /)-> rhs

    @switch_rule_name
    class rule_name:
      def branch_rule_name

    #arg = data_arg | symbol(lsymbol/rsymbol, plain/arged)
    @input_filter(f...)
    @template_token_name #rtemplate
    def token_name(sf, /, *args)-> arged_token_name
    @output_filter(f...)
    @template_rule_name #ltemplate
    def rule_name(sf, /, *args)-> rhs #after @template_rule_name become: (*args) -> (arged_rule_name :: () -> rhs) #lazy call && hashable <<== recur ref

    obj used in grammar:
      look_ahead(post_rule_seq) <=: ignore
        ignore: match and discard output, as-if output not in init seq output
        failure-look_ahead vs fullmatch-look_ahead vs premature-look_ahead vs nonzero-consumption-premature-look_ahead

      try_enter(pre_rule_seq, post_rule_seq)
        pre_rule_seq success ==>> forward decl I match!
      token_tester #acceptor, set, required for arged_token
      filter for data flow
      field-name@series ##idx?
      branch-name@parallel
      ===
      istream<token> .tell/seek/truncate_before/read_le/peek_le
        token.rsymbol #token is not rsymbol!!
        cache symbol match result at posotion until pruning backtracking
      ===
      left-recur ?? recursive-recognizor?
        left-recur detect for grammar&&runtime-parsing/recognizing
          NOTE:look_ahead create a branch
      ===
      前后约束:xml tag，C++ raw-string-literal
      ===
      错误信息 在哪提供？
        根/主左符/不能返回:
          每个 左符/右符 都可能成为 根，均提供一个零消耗匹配失败信息
          最长匹配？
        非根/非主左符/允许返回:
          并联:
            平行:冲突性歧义错误
            平行/优先:无匹配，返回 上层
          串联:
            早产后失败:早产之后，成为唯一路径，后续 左符/右符 变 根，必须 成功 不能 返回
            早产前失败: 返回上层
      ===
      乱序？
        比如: int const === const int
        比如: f()... override final;
        比如: rf'' === fr''
        乱序+重复？
        乱序+分散式重复？
          具象语法树 依 字面 次序排列
          抽象语法树 有序+归组
      ===
      mutual exclusion parallel     __or__ |
      priority choice/switch        __true_div__ / #__rshift__ >>
      plain series                  __mul__ *
      predictable series            __mxmul__ @  #__xor__ ^
        parallel vs switch vs choice vs alternative
        staged premature accelerated/early failure/success detection conditional pruning exclusive series(backtracking two_way series, exclusive monopoly one_way supreme series)
          no plain series
          early-success-detection-series(backtracking-subseq, err_msg, exclusive-subseq)
            premature-series
            early-pruning-series
              zero-consume match can decl pruning-or-not
              look_ahead 模式 标志位:完全匹配、直到修剪信号、非零消耗
          parallel(alternatives, err_msg, *, ordered:bool)

    is_symbol
    is_lsymbol
    is_rsymbol
    is_template
    is_arged_template
    is_partial_arged_template

TODO:
  path naming: dir vs file
    if dirname ends with "/":
      ${dirname}/{relative_path}
        ==>> sep = "//"
      path_sep = dir_end + join_sep + relative_begin

TODO:
  整数<->string
    builtin/literal_type <-> [begin, end)
    <symbol_classify, digit2output_uint, is_sign, is_sep, allow_sign<true>, allow_multi_sign, allow_sep, allow_leading_sep, allow_tailing_sep, allow_contiguous_sep, must_have_digits, must_have_sign, allow_empty, max_output_uint, allow_leading_0s, allow_leading_0_radix_prefix, read_radix>
    digit::value #literal_type constexpr
      instead of digit<builtin_integral>
    digit2output_uint::call(digit::value)
      'A' / 'a' -> output_uint{10}
        output_uint is literal_type
TODO:
  整数表达:

    ##is_same_type
    template<typename S, typename T>
    struct IsSameType{
      static inline constexpr bool is_same_type(){return false;}
    };
    template<typename S, typename T>
    constexpr inline bool is_same_type(){return false;}
    template<typename T>
    struct IsSameType<T,T>{
      static inline constexpr bool is_same_type(){return true;}
    };
    template<typename S, typename T>
    constexpr inline bool is_same_type(){return IsSameType<S,T>::is_same_type();}

    template<typename T>
    struct StdFormOf{
      using type = typename T::StdForm;
      using StdForm = StdFormOf<type>;
    };
    template<typename T>
    using std_form_of = typename StdFormOf<T>::type;
    template<typename S, typename T>
    constexpr inline bool is_eqv_type(){return is_same_type<std_form_of<S>,std_form_of<T> >();}
    /////
    using MaxWord = unsigned_max_t;
    static_assert is_unsigned<MaxWord> # is_integral<T>()
    template Word<MaxWord>;
    template CheckMax<MaxWord radix_minus_1, MaxWord...>;
      radix_minus_1 >= 1
      radix_minus_1 >= args...
    template Natural__0isM__little_endian<MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm
      StdIntegerType
          #Integer__0isM__little_endian
          #Integer__0is0__little_endian
      StdNaturalType
          #Natural__0isM__little_endian
          #Natural__0is0__little_endian
          #for mix use cooperation in continued fraction
    template Integer__0isM__little_endian<bool is_neg, MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm #is_neg ==>> nonempty
      StdIntegerType
      ?StdNaturalType

    template Natural__0is0__little_endian<MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm #to_drop_tailing_0s
      StdIntegerType
      StdNaturalType
    template Integer__0is0__little_endian<bool is_neg, MaxWord radix_minus_1, MaxWord...>;
    template Integer<bool T4_0isRADIX_F4_0is0, bool T4_big_endian_F4l_ittle_endian, bool T4_neg_F4_natural, MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm #to_drop_tailing_0s #is_neg ==>> nonempty
      StdIntegerType
      ?StdNaturalType
    template Rational<typename Integer, typename Integer__ge1>;
        template Fraction<typename Integer, typename Integer__ne0>;
    template FiniteContinuedFraction__gt0le1<typename Integer__ge1...>;
    template FiniteContinuedFraction__ge1<typename Integer__ge1...>;
    template FiniteContinuedFraction__ge0<typename Integer__ge0, typename Integer__ge1...>;
    template IterContinuedFraction__ge1<typename calc, typename args...>;
      call::next(args::value...) -> <result_pint, next_args...>
    calc_lazy_value<CalcWithArgs>()->R;
    iter_next<IteratorWithArgs>()->(void|BoxWithLabel<typename R, NextIteratorWithArgs>)

    # __0isM little_endian
    mul1__0is0 :: uint%M -> uint%M -> (low__0is0::uint%M, high__0is0::uint%M)
      # 3*5 % 9 == 6 > 5 > 3
      # 3*5 % 10 == 5 == 5 > 3
      # 3*5 % 11 == 4 (< 5)(> 3)
      # 3*5 % 12 == 3 == 3 < 5
      # 3*5 % 13 == 2 < 3 < 5
    mul1__0is0 u v | u>v = mul1__0is0 v u
    #[u<=v]
    mul1__0is0 u v | u<=1 = (u*v, 0)
    mul1__0is0 u v | v <= floor_sqrt (M-1) = (u*v, 0)
    mul1__0is0 u v | u <= floor (sqrt(M-1)/x) && v <= floor (sqrt(M-1)*x) = (u*v, 0)
        where x=continued_fraction[1; 1...]
          #[1<x<2] #1<x=1+1/x<2 #(-1/x)=1+1/(-1/x) #1/x=x-1
    mul1__0is0 u v | v <= (M-1)//u = (u*v, 0)
    mul1__0is0 u v = (l0+d*l1_h0, l2_h1+d*acc3_h2)
        where
            d = 1+floor_sqrt(M-1)
              # [(d-1)^2 <= M-1 < M <= d^2]
              #[M>=2][d>=2]
              #[(M-1)^2 < d^4]
            (qu, ru) = divmod u d
            (qv, rv) = divmod v d
              #[d<=v<=M-1<d^2]
              #[1<=qv=v//d<=(M-1)//d<=d-1]
              #[u<=v][0<=qu<=qv<=d-1][u*v<=v^2<=(M-1)^2<d^4]
              #[0<=qu,qv,ru,rv<=d-1]
              #[max ru qu * v <= (d-1)*(M-1) < (d-1)*d^2 < d^3]
              #[u*v < d^4]
            (l0,l1,l2) = mul_h_hh ru (rv, qv)
            (h0,h1,h2) = mul_h_hh qu (rv, qv)
            (l1_h0, acc2) = add_h_h l1 h0
            (l2_h1, acc3) = full_add_h_h acc2 l2 h1
            acc3_h2 = acc3+h2
              # (l0, l1_h0, l2_h1, acc3_h2)
              # output here

            add_h_h :: uint%d -> uint%d -> (uint%d, acc::uint%2)
            add_h_h x y = if d-x <= y then (y-(d-x), 1) else (x+y, 0)
              #[half+half<=2*(d-1)==2*d-2==d+(d-2)<2*d]
            full_add_h_h :: uint%2 -> uint%d -> uint%d -> (uint%d, acc::uint%2)
            full_add_h_h acc x y =
              #[acc+half+half<=1+2*(d-1)==2*d-1==d+(d-1)<2*d]
              let (z0, acc0) = add_h_h x y
                  (z1, acc1) = add_h_h z acc
              in  (z1, acc0+acc1)
            mul_h_hh :: uint%d -> (uint%d,uint%d) -> (uint%d, uint%d, uint%d)#little_endian
            mul_h_hh x (y,z) =
              #[x <= d-1][y+z*d<=M-1]
              #[x*(y+z*d)<=(d-1)*(M-1) < (d-1)*d^2 < d^3]
              let (qxy, rxy) = divmod (x*y) d
                  (qxz, rxz) = divmod (x*z) d
                  #bug:add overflow@[M=2] (acc, qxy_rxz) = divmod (qxy+rxz) d
                  (qxy_rxz, acc) = add_h_h qxy rxz
              in  (rxy, qxy_rxz, acc+qxz)
                  #[0<=acc<=1]
                  #[acc+qxz<=d-1]
                  #if[M:=4][x,y,z:=1]:[d=2][acc=1][qxz=0]
                  #if[M:=2][x,y,z:=1]:[d=2][acc=1][qxz=0]

    mul1__0isM :: uint%M -> uint%M -> (low__0isM::uint%M, high__0is0::uint%M)
    mul1__0isM 0 0 = (0, M-1) #==M*M==M+M*(M-1)
    mul1__0isM 0 v = (0, v-1) #(0,0)<==>M+0*M==M==M*1
    mul1__0isM u 0 = mul1__0isM 0 u
    mul1__0isM u v =
      let (low__0is0, high__0is0) = mul1__0is0 u v
          #[1<=u,v<=M-1]
          #[1<=u*v<=(M-1)^2<M^2]
          #[M^2>low__0is0+high__0is0*M == u*v >= 1]
          #[0<=low__0is0,high__0is0<M]
          #[(low__0is0, high__0is0) != (0,0)]
          #[low__0is0==0] ==>> [high__0is0!=0][high__0is0>=1]
          #[high__0is0 != M][high__0is0<=M-1]
          (low__0isM, high__0is0_) = if low__0is0==0 then (0, high__0is0-1) else (low__0is0, high__0is0)
      in  (low__0isM, high__0is0_)

    us__0isM :: [uint%M]
    us__0is0 :: [uint%M]
    us2int__0isM us__0isM = sum((u if u else M)*M**i for i,u in enumerate(us__0isM))
    us2int__0is0 us__0is0 = sum(u*M**i for i,u in enumerate(us__0is0))
    us2us__0is0__0isM us__0is0 = ???
    us2us__0isM__0is0 us__0isM = ???

    us2us__0is0__0isM [] = []
    us2us__0is0__0isM (0:us) = dec__0isM__ge1 1 (us2us__0is0__0isM us)
    us2us__0is0__0isM (u:us) = u:us2us__0is0__0isM us
    dec__0isM__ge1 :: uint%M -> [uint%M] -> [uint%M]
    dec__0isM__ge1 1 [] = []
    dec__0isM__ge1 1 (u:us) = 0:dec__0isM__ge1 u us
    dec__0isM__ge1 0 us = (M-1):us
    dec__0isM__ge1 u us = (u-1):us


    us2us__0isM__0is0 [] = []
    us2us__0isM__0is0 (0:us) = 0:us2us__0isM__0is0 (inc__0isM us)
    us2us__0isM__0is0 (u:us) = u:us2us__0isM__0is0 us
    inc__0isM [] = [1]
    inc__0isM (0:us) = 1:inc__0isM us
    inc__0isM ((M-1):us) = 0:us
    inc__0isM (u:us) = (u+1):us

    u2p__0isM__0is0 :: uint%M -> uint{1..M}
    u2p__0isM__0is0 0 = M
    u2p__0isM__0is0 u = u
    p2u__0is0__0isM :: uint{1..M} -> uint%M
    p2u__0is0__0isM M = 0
    p2u__0is0__0isM p = p
    func_pow :: uint -> (a->a) -> (a->a)
    func_pow 0 f x = x
    func_pow exp f x = func_pow (exp-1) f (f x)

    half_add1__0isM :: uint%M -> uint%M -> (low::uint%M, acc__0is0::uint%2)
    half_add1__0isM 0 v = (v, 1)
    half_add1__0isM u 0 = half_add1__0isM 0 u
    half_add1__0isM u v =
      let x = (M-1) - u
            #[1<=u,v<=M-1]
            #[2<=u+v<=2*M-2]
            #[2-M<=u+v-M<=M-2]
            #[u+v<=M] ==>> [2<=u+v<=M]
            #[u+v>M] ==>> [1<=u+v-M<=M-2]
            #
            #[0<=x=(M-1)-u<=M-2]
            #[v<=x] ==>> [v<=M-1-u][2<=u+v<=M-1]
            #[v>x] ==>> [v>M-1-u][1<=v-x==u+v-(M-1)<=M-1]
            #[v>x] ==>> [0<=v-x-1==u+v-M<=M-2]
            #[v>x][v==x+1] ==>> [0==v-x-1==u+v-M<=M-2]
            #[v>x][v!=x+1] ==>> [1<=v-x-1==u+v-M<=M-2]
      in  if v <= x then (u+v,0) else if v==x+1 then (0, 0) else (v-x-1, 1)
    full_add1__0isM :: uint%3 -> uint%M -> uint%M -> (low::uint%M, acc__0is0::uint%3)
    full_add1__0isM acc__0is0 u v =
      let (s0, acc0) = if acc__0is0==0 then (u, 0) else half_add1__0isM (p2u__0is0__0isM acc__0is0) u
          (s1, acc1) = half_add1__0isM s0 v
      in  (s1, acc0+acc1)

    add__0isM :: [uint%M] -> [uint%M] -> [uint%M]
    add__0isM = full_add__0isM 0
    full_add__0isM :: uint%3 -> [uint%M] -> [uint%M] -> [uint%M]
      #full_add__0isM acc__0is0 lhs rhs
      #full_add__0isM acc__0is0 [] [] = if acc__0is0==0 then [] else [p2u__0is0__0isM acc__0is0]
    full_add__0isM acc__0is0 [] rhs = func_pow acc__0is0 inc__0isM rhs
    full_add__0isM acc__0is0 lhs [] = full_add__0isM acc__0is0 [] lhs
    full_add__0isM acc__0is0 (u:us) (v:vs) =
      let (s, acc_) = full_add1__0isM acc__0is0 u v
      in  s:full_add__0isM acc_ us vs
      ----
    #full_add__0isM acc__0is0 (u:us) (v:vs) =
      let s = (acc__0is0 + u2p__0isM__0is0 u + u2p__0isM__0is0 v)
          (q,r) = divmod s M
            #[0 <= acc__0is0 <= 2 <= M]
            #[q*M+r == s <= acc__0is0+M+M <= 3*M]
            #[0<=q<=3][0<=r<=M-1]
            #[q==3] ==>> [r==0][acc__0is0==2==M][u==0][v==0]
            #[r!=0] ==>> [q!=3][0<=q<=2]
            #
            #[q*M+r == s >= acc__0is0+1+1 >= 2 > 0]
            #[(q,r) != (0,0)]
            #[r==0] ==>> [q!=0][1<=q<=3]
          (q_, r_) = if r==0 then (q-1, M) else (q,r)
            #[0<=q_<=2][1<=r_<=M]
      in  p2u__0is0__0isM r_ : full_add__0isM q_ us vs
    subtract__0isM :: [uint%M] -> [uint%M] -> (is_neg::bool, [uint%M])
      #subtract__0isM lhs rhs
      # [1,1,2] - [0,0,1] == [1]
      #full_subtract__0isM :: uint%3 -> [uint%M] -> [uint%M] -> (is_neg::bool, to_drop_tailing_0s::bool, [uint%M])
        #full_subtract__0isM borrow lhs rhs
    subtract__0isM lhs [] = (False, lhs)
    subtract__0isM [] rhs = (True, rhs)
    subtract__0isM (u:us) (v:vs) =
      let (is_neg, abs) = subtract__0isM us vs
            #[is_neg] ==>> [abs != []]
          (a, b) = (u2p__0isM__0is0 u, u2p__0isM__0is0 v)
            #[1<=a,b<=M]
          is_neg_ = is_neg || (abs==[] && a < b)
            #[is_neg_] <==> [is_neg]or[abs == []][a<b]
            #[is_neg_] ==>> [abs != []]or[abs == []][a<b]
            #[! is_neg_] ==>> [! is_neg]([abs != []]or[a>=b])
            #[! is_neg_] ==>> [abs != []]or[a>=b]
          (a_, b_) = if is_neg_ then (b,a) else (a,b)
            #[is_neg_] ==>> [abs != []]or[abs == []][a_>b_]
                #flip
            #[! is_neg_] ==>> [abs != []]or[a_>=b_]
                #not flip
            #[abs != []]or[a_>=b_]
            #[a_ < b_] ==>> [abs != []]
            #[1<=a_,b_<=M]
            #[a_ < b_] ==>> [a_+M-b_==a_+(M-b_)>=a_+0>=1]
            #[a_ < b_] ==>> [a_+M-b_==M-(b_-a_)<=M-1]
            #[a_ < b_] ==>> [1<=a_+M-b_<=M-1][abs != []]
            #[a_ > b_] ==>> [1 <= a_-b_ <= M-1]
          abs_ = if a_ < b_ then let (h:ts)=abs in (a_+M-b_):(dec__0isM__ge1 h ts) else if a_ > b_ then (a_-b_):abs else case abs of
              [] -> []
              (h:ts) -> 0:dec__0isM__ge1 h ts
            #[abs_==[]] <==> [abs==[]][a_==b_] ==>> [! is_neg_]
            #[is_neg_] ==>> [abs_ != []]
      in  (is_neg_, abs_)
    mul1s__0isM :: uint%M -> [uint%M] -> [uint%M]
    mul1s__0isM u vs =
      let (lows__0isM, highs__0is0) = mul1s__0isM__lows_highs u vs
      in  add__0isM lows__0isM $ us2us__0is0__0isM (0:highs__0is0)
    mul1s__0isM__lows_highs :: uint%M -> [uint%M] -> (lows__0isM::[uint%M], highs__0is0::[uint%M])
    mul1s__0isM__lows_highs u [] = ([], [])
    mul1s__0isM__lows_highs 0 (v:vs) = (0:dec__0isM__ge1 v vs, [])
    mul1s__0isM__lows_highs u (v:vs) =
      let (lows__0isM, highs__0is0) = mul1s__0isM__lows_highs u vs
          (low__0isM, high__0is0) = mul1__0isM u v
      in  (low__0isM:lows__0isM, high__0is0:highs__0is0)

    mul__0isM :: [uint%M] -> [uint%M] -> [uint%M]
    mul__0isM [] vs = []
    mul__0isM us [] = mul__0isM [] us
    #mul__0isM (u:[]) vs = mul1s__0isM u vs
    mul__0isM (u:us) vs =
      let highs = mul__0isM us vs
          lows = mul1s__0isM u vs
      in  add__0isM lows $ mul1s__0isM 0 highs

TODO:
  真名屏蔽，虚拟注册名需要真名支持
    三方:
      个人，服务器，政府
      个人+政府 共享 真名+真名密码
      个人+服务器 共享 虚名+虚名密码
      服务器 可要求 政府 鉴定 真名存在性/真名签名有效性 得到 hash(服务器+真名) 避免 重复注册 或 控制 个人小号上限。
        虚名密码 找回？不行！
        政府 不得与闻 虚名密码
        服务器 不得与闻 真名密码
      政府 可由(服务器+虚名)得到 真名

TODO:
  农历公历对照表 农历节日 公历节日
    e others/数学/编程/农历/py农历.txt
    e others/数学/编程/农历/java农历.txt
    e others/数学/编程/农历/js农历-1.html
    e others/数学/编程/农历/js农历-2.html
    e others/数学/编程/农历/0农历在线www.txt
    others/数学/编程/农历/0农历在线[四个网站两个有用].zip
    ls $my_tmp/wget_/0农历在线/
      bieyu.com
      ks3-cn-beijing.ksyun.com
      supfree.cn
      www.nongli.net
    e script/农历/农历.py
        from seed.int_tools.digits.ConvertBoundedIntSeqToUIntWithLen import ConvertBoundedIntSeqToUIntWithLen
        e ../../python3_src/seed/int_tools/digits/ConvertBoundedIntSeqToUIntWithLen.py
    /sdcard/0my_files/git_repos/txt_phone/txt/script/农历/香港天文台农历对照表（文字版）.zip
    view ++enc=big5 /sdcard/0my_files/tmp/curl_/香港天文台农历对照表（文字版）/T2021c.txt
    /sdcard/0my_files/zip/万年历github/
      view /sdcard/0my_files/zip/万年历github/www.txt


TODO:
  lang:
  lang_design:
    ====
    ====
    ====
    ====
    阶段 重现
      比如：mapping-setitem, 只需on_new, on_overwrite 两种情况的处理函数，但实际应用中的defaultdict却是on_new_then_overwrite, on_overwrite，处理完一个阶段后，进入下一个阶段，类似C++ switch-case-break 与switch-case-no_break。
    ====
    ***
      通常 默认允许功能不断增加，但不允许减少。其实，禁止某些功能的增加，也很重要。
        del d[ALL_KEYS] # "ALL_KEYS" is not hashable to distinguish normal hashable key. that is the way to create special keys.
          # slice is unhashable
            >>> {}[:]
            Traceback (most recent call last):
                ...
            TypeError: unhashable type: 'slice'
    ====
    片段程序 与 静态分支（代码爆炸）
      如：radix_repr2uint__merge/uint2radix_repr__merge:little_endian/big_endian
        大部分代码相同，仅少数不同
      判断静态条件 是否 相容/互斥，或 由用户提供证明 或 由用户显式保证而在实例化时实时检查
    ====
    标识名带阶段时期
      functional,声明式语言
      分散定义，全局约束
      变量、约束 最好分 阶段
      不同阶段的变量 对应 不同的值/定义来源收集，受到相应阶段的约束
      变量名
      定量名=变量名+阶段
    ====
    文本与带外文本
      *手写-强调文本清爽易识
      *面向程序读写:格式简练标准唯一
      *人机版相互嵌套
    ====
    可选命名参数
      缺省值/默认值:
        *无
        *静态
        *半自动
          *动态调用前，全局唯一？竞争？
          *动态调用时，值一致
          *动态调用时，值依赖其他参数
          *动态调用时，值依赖其他参数及全局变量IO操作
        *全自动，不允许用户赋值，可无名
          如用于 模版匹配出错从而拒绝成为候选，函数前置条件
      如何 调用？转发？取出 默认值？
        两种赋值:
          * 简化赋值，a,v::T
            f()
            f(a = v)
            f(**kw)
          * 完整赋值，a?, mv :: Maybe T
            f(a? = mv)
            #无需:f(**?kw)
          a,a? 是 互斥兼容的命名参数
            兼容 是指最终会构造出一致的参数统一调用唯一接口
            语法糖-伪函数重载，内联展开

    ====
    通用格式
      关键字
        表达式
          类型 之类 静态信息 提取
        IO语句
          源文件 信息 路径 行列...
          二进制文件-编译信息 编译时间 参数...
        库函数
          运行信息 平台 动态状况 统计信息 调试信息
      标识
        定义引入新标识
          标识范围控制#存在性，区间作用域
          权限管理#谁能使用标识
        使用已有标识
        标识名 的 字符串 是否 重要？
          作为 API 输出，脚本语言调用 库函数/公开成员函数，函数命名参数，有些 标识名不可修改
        那个标识？
          引入的标识
          声明的标识（参数）
          定义的标识
          依赖的标识（对象成员，空间限定，类型依赖的特化选择）
          依赖型关键字
        同层空间 拒绝 同名标识/再定义
        里层空间 允许覆盖 外层空间的标识
        隐参数 的 赋值时机？
          调用时完全收集:
            f x
          调用时部分收集:
            f!{x, ?a=1,?b}
          显式完全收集:
            f!
          显式部分收集:
            f!{?a=1,?b}
              # ?a 手动收集
              # ?b 自动收集
      切割文本，组织成:列表、树、串并图、有向无环图、多维矩阵、命名元组/有序记录、映射/多复合主键记录表
        #集合:{,a,b}
        #映射:{:,a:1,b:2}
        表达式 如何 变成 树？
          f a
          f` a
            f{ a }
          a `f
            { a }f
          a `f` b
          f{ a }g` b
            f{ a }g{ b }
            f-g(a, b)
          a .f b
            f a b
    ====
    flag vs state
      相容 vs 互斥
      中间类型:部分相容 部分互斥
      部分互斥标志位:
        每一个 合法状态 都有相应的 未必合法状态 用于代表 所有相容标志位 或 所有不相容标志位，未必合法 是因为 所谓 相容/不相容 仅限于 向 原状态 添加 一个 标志位
      依赖标志位: 类似子类，只有 所有/部分？ 父标志位 置位时，子标志位 才能 置位
      多标志位 之间的 相容关系:之前 考虑的 都是 单标志位 之间
      优先级:正向判断相容合法的规则 与 反向判断互斥非法的规则 谁的优先级 更高？具体到 任意两个规则 之间的优先级 比较。一旦 无法比较优先级 或 同优先级 的 两规则（最高优先级） 发生冲突，则是 设计性错误
    ====
    批量操作原子化
      外部解释语言
        使用 内部提供的 脚本语言，只含 原子操作序列？
      内部编译语言
        使用 锁？
    ====
    我的protected 虚函数 分类:
      #主语 子类
      *可调用但不可覆盖/final
      *可覆盖但不可调用/类似C++ private
      *可调用可覆盖/类似C++ protected
      #可调用~应为 受控可调用:调用处 的 所在方法 的 定义函数体的所在类 必须是 被调用对象 的 基类
    我的private 函数 分类(只有一类):
      *子类 不可调用不可覆盖不可见（不挤占命名空间）
        ==>>private无虚函数
    声明方法的所在类+定义函数体的所在类+最外层派生类+
    ====
    protected的作用:
      禁止 绕过子类 对基类直接修改+读取
        用于 完全覆盖基类操作，如:移动（移动构造、移动赋值、交换）
        即使用户得到 静态类型声明为基类引用的数据，也无法使用被覆盖的操作
        不同子类不会混杂，各管各的。
      分享权限给还未存在的对象/类型，仅凭 关系 来识别
        这很有意思
        view others/book/The\ C++\ Programming\ Language(4ed)(2013).txt
        ===
        pg604[619/1366]
          A derived class can access a base class’s protected members only for objects of its own type:
            class Buffer {
            protected:
              char a[128];
              //...
            };
            class Linked_buffer : public Buffer {
              //...
            };
            class Circular_buffer : public Buffer {
              //...
              void f(Linked_buffer∗ p)
              {
                a[0] = 0;//OK: access to Circular_buffer’s own protected member
                p−>a[0] = 0;//error : access to protected member of different type
              }
            };
          This prevents subtle errors that would otherwise occur when one derived class corrupts data belonging to other derived classes.


          ///
          Members declared protected are far more open to abuse than members declared private. In particular, declaring data members protected is usually a design error. Placing significant amounts of data in a common class for all derived classes to use leaves that data open to corruption. Worse, protected data, like public data, cannot easily be restructured because there is no good way of finding every use. Thus, protected data becomes a software maintenance problem.


    ====
    staticmethod 不能被覆盖/派生类 不能重定义之
      若要覆盖，必须使用 classmethod
      否则，obj.f 究竟是否是派生类覆盖后的staticmethod？
      要么 不能通过 对象调用staticmethod，必须 静态指明 究竟是 那个类，也就是说，staticmethod不可继承
      ==>>
      staticmethod 不可继承&静态显式指明所属类 或 可继承&不可覆盖
      既要 可继承 又要 可覆盖，则 改用classmethod
      * explicitly qualified staticmethod
      * final staticmethod
      * classmethod
    ====
    分离参数:按输入输出:
      s,t = {x,a,b}.f(c,d)
        输出 s,t
        修改 x,a,b
        输入 c,d
        .f ~ x.f
    ====
    垃圾回收-有效的无用垃圾
      不可遍历的映射表（或 实际使用中 未遍历的映射表） 一旦 某个键值 被遗忘且无法重新构造（如：JavaScript的Symbol）则 该键值的对应映射值 不可能再通过 映射表+键值 访问，很可能 成为 活着的垃圾
        应使用WeakKeyDictionary
      底层系统的内存分配+垃圾回收，但 用户可以自定义（高层语言/脚本/虚拟对象之间的循环引用）内存分配，这时垃圾回收又当如何实现？
        ??doubly-linked-list using ‘‘xor trick’’+double-pointers-iterator
            node_base<T>{ptr_as_uint xor prev_next}
            tail_head_node<T>:node_base<T>{ptr_as_uint xor prev_next, ptr head_node}
            node<T>:node_base<T>{ptr_as_uint xor prev_next, T val}
            iter<T>{ptr prev_node, ptr curr_node}
            begin_iter = {&tail_head_node, &head_node}
            end_iter = {&last_node, &tail_head_node}
            双向链表 节点循环 中间插入一个无值的节点，迭代器 含 两个指针
      如何 系统性地排查 有无再次访问的可能性（在整个程序编译链接后）？析构动作 的 发生 是否 产生副作用（是否允许提前析构）？
    ====
    def:[允许抢先析构的强引用+不可被抢的强引用]
      目的：保证 在某处之前 析构，而不被 某个旮瘩里 残留/暂时残留 的 强引用 拖累 而延缓析构
      使用时 类似 弱引用 需先检查 是否 存在
      与 弱引用 不同的是，如果 其他引用 不强行析构，则 保证 存在性。
      问题:
        弱引用 解引用 之前 必须 构造 强引用，以保证指针使用过程中 的 有效性
          weak_ptr.lock()->shared_ptr
        允许抢先析构的强引用 的 情形，解引用 之前 同样 需要 构造 不可被抢的强引用
          应该 尽量 局限 不可被抢的强引用 的使用，尽量 局部临时性存在。
          所有 允许抢先析构的强引用 的 权限 加起来 仅等同于 一个 不可被抢的强引用
            或许以此类推 可定义 抢先析构组？组与组之间 并不相互影响（如果 还有其他组存在，不能 真的进行析构）。而 不可被抢的强引用 相当于 自成一组！
              上面是 同层划分，也许 可以 树状组织起来？

    ====
    对输入的反应
      比如：模块 对于 宏 multithread的开启与否 是否有不同定义
      对输入的是否反应 也可用作 声明的一部分
        这对于控制版本变体的实际数量有帮助
          #注意:声明 有多种层次，必然偶然
        makefile:分离编译:可节省编译，控制 自动生成的输出路径（排除不被反应的输入参数）
    ====
    语言支持-语法糖
      数据成员 是否 静态？自动生成不同版本
      比如：unique_ptr<> 的 deleter
        静态版 unique_ptr<element_type, deleter_type>
        vs 动态版 unique_ptr<element_type>(element_type*, deleter_type_base)
      比如：sort() 的 less_than
      比如：vector<> 的allocator
      比如：矩阵 的 维度...
        #vector.size()
    ====
    C++ 与 Haskell/Python 的直观感受上的不同是？
      Haskell 有Show+Read
      Python 有repr+eval/ast.literal_eval
      C/C++ 并无！
      是否可注重数据的读写/存储，对于使用者而言十分重要！（调试？）
      强类型语言: 必须在读之前明确数据的精确类型
      弱类型语言: 只需划定可能使用到的数据类型，并设置求值环境/解析环境，可能需要使用类似xml那样的schama来约束容器成员的类型。
    ====
    标签 控制 计算流程
      比如: 证明用对象 不必实际构造
      比如: 有时 要求 函数 返回 这个类型 有时 那个类型 有时 void 有时 通过 INOUT输入引用来输出
    ====
    可移植性 要求 标准库 既不能包含更少，也不能包含更多！！
    ====
    惰性函数标识名 必须 与 勤性~ 区分开
      到底 是 精细控制 函数的每一个 实际参数表达式 惰性与否 还是 直接冻结 函数的所有 实际参数表达式？
    ====
    防碰撞-局部可见声明
      声明 本标识 对 哪些 实体 可见
      重复声明定义 无所谓，只要 可见到它们的实体不重叠就行
      实体:函数、类、域/空间、文件、包、实体组（多个实体）...
    ====
    区间表达与使用:
      半开区间 的 毛病:
        * 反向迭代器 不对称，解引用 计算量大（多次反转浪费更多，不过）: *(--p)
        * 双向迭代器 的 尾迭代器 需指向 与区间关联的完整无效节点#随机访问迭代器 无此毛病
      闭区间 的 毛病:
        * 无法合理 表达 空区间
          空容器 空区间: [无效..无效]
          非空容器 空区间: [无效..有效] #含位置信息
          Range iter
            = NoIterAtAll
            | EmptyRangeAt iter
            | ClosedNonemptyRange iter iter
        * 循环 流程 复杂（除非 语言提供 语法糖）:
          if 非空区间:
            while (1){
              ...do-job...
              if (front_iter == last_iter) break;
              else ++front_iter;
            }
            ==>>
            do if 非空区间
            {...}
            until(front_iter==last_iter; ++front_iter)
    ====
    值 与 含义
      坐标系生成向量集 至于 坐标点 如同 量纲单位 至于 量纲值
      数组索引~数组
      文件位置~文件
      键值~映射表
      点/边~图
      ---
      语言 最好 能提供 静态类型 绑定 动态值 与 关联对象，以防误用！
    ====
    lazy value 要求 不论何时计算，结果不变。
      ==>>要求 所有参数（隐参数、引用到的全局变量）皆本质不变immutable 而不仅view-readonly
      不能使用弱引用，可用in_use_ref代替，in_use_ref只能抛出 不可捕获异常
    ====
    数组下标/序列索引
      从零开始
      但！区间表达？反方向索引？
      hs:
        不支持 反方向索引
        闭区间
        [0..n-1]
        [0..n-2]
      py:
        None=last-pass-one, -1=last
        半闭半开区间
        [0:]
        [0:-1]
      mine:
        -1=last-pass-one, -2=last
        半闭半开区间
        [0:-1]
        [0:-2]
    ====
    具象值 的 内部表达 外部表达 默认定义
      问题1? 具象值的类型ADT 是否 该如 Haskell那样 引入时 完全展示给 用户，以后 不可变更？
      问题2? 如果 分离出 定义体，则恐出现循环引用定义，难以提前控制，甚至 可能 没有一种可能的实现-配置-套装 能满足所有约束
      ---
      1: 其实 用户需要知道的仅止是 具象值 含有 那些数据成员，它们是什么概念的值？
          这些 数据成员 是否 真实存在，并不重要
          是否 还有 隐藏的辅助数据成员 也不重要
          这些 数据成员 所属概念 是用何 具象类型 来实现 也不重要
      2: 为了保证 至少有一套实现 能满足 所有约束，需要 提供一个 默认定义体
      ---
      内部表达 被隐藏起来，但 外部表达 呢？
        序列化为外部数据存储，各种 不同定义体 必须 统一 输出格式
    ====
    ？
      ？empty base optimization: 外挂接口+无用参数(参数化标识名)+虚基类？或 重复 空基类(带虚析构函数) 这种情形 究竟如何？
        see:[[无用参数]]
        empty-base optimization
        The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8).
        完全可行！
          https://en.cppreference.com/w/cpp/language/ebo
          Empty base optimization

          Allows the size of an empty base subobject to be zero.
          Explanation

          The size of any object or member subobject (unless [[no_unique_address]] -- see below) (since C++20) is required to be at least 1 even if the type is an empty class type (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.

          However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:
              Empty base optimization is prohibited if one of the empty base classes is also the type or the base of the type of the first non-static data member, since the two base subobjects of the same type are required to have different addresses within the object representation of the most derived type.


    ====
    ops:
      immutable ops
      emplace ops / inplace ops
      注意:expression_template 可能需要 临时变量 可就地修改，以节省构建多余的临时变量
      本操作:
        是否就地修改 输入的目标对象？
        是否新建 结果的目标对象？#输入的目标对象 也可。直接用作 结果的目标对象
        返回是否包含 结果的目标对象？如何 抽取？如何 分离 期望结果 与 结果的目标对象？
        返回的 结果的目标对象 是否可修改？
        ---有效组合:
        不就地修改 输入的目标对象+不新建 结果的目标对象+不返回 结果的目标对象
        不就地修改 输入的目标对象+不新建 结果的目标对象+返回 结果的目标对象(即 输入的目标对象)
        不就地修改 输入的目标对象+新建 结果的目标对象+返回 结果的目标对象
        ...TODO
      ---
      immutable obj
      readonly view
        template parameter role:tag forwarding
      mutable obj
      ---
      #e script/IOps.py
      子对象 重复: 相等/相同 约束
        opsA, objA
        opsB, objB {..., .opsA, .objA}
          .opsA of_objB at_objB
        opsB {..., .opsA}, objB {..., .objA}
          .opsA of_objB at_opsB
          #静态 无实例 操作
        opsB, objB {..., .objA {..., .opsA=clsA}}
          .opsA of_objB at_objB
          #A 以 cls 本身 作为 ops，绑定，不可拆解
        opsB {..., .opsA}, objB {..., .objA {..., .opsA=clsA}}
          .opsA of_objB at_objB/at_opsB
          #上述2种情形 共存，导致 opsA 重复
          #必须 确认 等同！！！
      ===>>> ops 分割成 3个: 无实例操作，带实例读操作，带实例修改操作
            ？？？无实例构造，带实例构造(复制、替换某些属性值)
            ？？？带实例析构

        替换某些属性值 构造器（带实例）
          of_obj at_ops 是否 允许 at_obj 覆盖？（vs 只允许 等同值 覆盖 vs 不允许 覆盖 vs 满足 值变化趋势约束 覆盖），
          也许 该在名称上体现出不同的要求...
      ---
      #e script/IOps.py
      命名空间 既 区分 private/public/protected，又 区分 of_obj/of_obj_ops/of_obj_ops_cls,
      #as_obj,as_obj_ops,as_obj_ops_cls
        ops[xxx:protected:as_obj_ops, arg...., :, kw:arg...]
        ops[xxx:protected:as_obj_ops, kw:arg..., :, arg....]
        ops[xxx:protected:as_obj_ops](arg...., kwargs={kw:arg...})
        ops[xxx:protected:as_obj_ops](arg...., **mk_kwargs[kw:arg...])
        ops[xxx:protected:as_obj_ops][kw:arg...](arg....)
      property:
        @obj
          ops.get_xxx__of_obj_at_obj(obj)
        @obj_ops
          ops.get_xxx__of_obj_at_obj_ops()
          ops.get_yyy__of_obj_ops_at_obj_ops()
        @obj_ops_cls
          type(ops).get_xxx__of_obj_at_obj_ops_cls()
          ops.get_yyy__of_obj_ops_at_obj_ops_cls()
          ops.get_zzz__of_obj_ops_cls_at_obj_ops_cls()
        []:
            ops.of_obj_at_obj["xxx"](obj)
            ops.of_obj_at_obj_ops["xxx"]
            ops.of_obj_at_obj_ops_cls["xxx"]
            ops.of_obj_ops_at_obj_ops["yyy"]
            ops.of_obj_ops_at_obj_ops_cls["yyy"]
            ops.of_obj_ops_cls_at_obj_ops_cls["zzz"]
      ---
      method/property
        覆盖控制:
          abstractmethod/virtual=0: 必须 被 override
          final: 不得覆盖
          协同工作:___kwargs___={?:?}
            @协同工作
            def f(self, ___kwargs___, /, ...):...
          正在新建vs正在覆盖override
        get bound_method/unbound_method
        access control section:
          public/private/protected
          因为 部分成员函数 对外不可见（命名空间 也 错开）
            基类 定义 f --> ___f___
            派生类 覆盖 ___f___
            外部 调用 f 而非 ___f___
          @using_private_section
          def f(self, self_private_section, /, ...):...
      ---
      协作构造
        协作构造:数据成员、协作函数的返回值+输入命名参数
        约束:
          +独立约束::一元约束
          +拓扑偏序约束::二元约束
          +其他参数参与的复杂约束
        协作构造的初始化方式:
          *无需初始值
          *某个共同基类提供
          *最外层派生类提供
          *作为参数由用户直接输入
        协作构造方式:
          必须提供 融合操作
          *或顺或逆的任意一种拓扑序
            需要 初始值
          *独立产生增量，无序融合
            *有初始值
            *无初始值
          有无初始值:
            必须提供 融合操作+概念上的偏序小于等于
            *有初始值
              必须提供 增量操作+[可选]偏序小于等于
              v[n+1]:=v[n] op x<ops.f>
              要求: x op y op z === x op z op y
                即：后续操作可交换，支持无序？
                (op z) . (op y) $ x === (op y) . (op z) $ x
            *无初始值
              必须提供 融合操作+偏序小于等于
              融合操作 是 可交换的二元运算
              融合输入 偏序小于等于 融合结果
              正整数:
                乘法
              自然数:
                加法
                比特位操作:与、或
                排除:异或
              集合:
                集合交
                集合并
                排除: 对称差
              映射:
                xxx 键值集合交/并？
                可选映射值的融合操作+偏序
                  #Map K V --> Maybe V
              元组|定键记录:
                分解成 各元素
              变键记录(映射作记录):
                各键 独立的 可选映射值的融合操作+偏序
                  #Map K V<K> --> Maybe V<K>
              数组:
                数组长度:增|缩+元素相关操作
              互斥并联:
                ？
            .
    ====
    def:[[无用参数]]
      #never_use/unused/abandon/useless
      #useless_parameter, runtime_discardable_argument

      void g([[无用参数]] Xxx x, ...);
      g :: [[无用参数]] Xxx -> ...
      仅用作 编译期函数重载，其输入值无用，只能静态计算constexpr，不得动态计算，(一类一值？其实，多值也可以，只是 类似 模版参数，每值实例化一个函数)，运行期不得构造不得传入，如同不存在。
      * 部分支持 enable_if（无返回值的构析函数）
          但 类模版 的enable_if？
            template<..., [[绑定默认值_禁止用户提供]]typename=Enable_if<b,void> > class Xxx;
      * 通过 函数重载 部分实现 参数化标识名
          虚函数 不能是 模版函数，但 可以是 重载函数
            #xxx 外挂接口 总需要 一些辅助实现函数，它们 ？？？不，不是
            外挂接口 独立开发声明 一个新的成员函数(虚函数)，必须 避免覆盖基类接口：避免被子类接口覆盖，则 必须 采用 统一命名方式-参数化标识名: class [[外挂接口]] Xxx<A,B>{[[新接口]] void g([[无用参数]] UseLess_RunTimeDiscardable<Xxx<A,B> >, ...)=0;};
        see:[参数化标识名]
          参数化标识名 可用作 私有标识
            私有类+参数化标识名==>>私有标识


    ====
    异常基类/抛出所在地基类--用作标签的空基类
      各包 必须定义 一个 包异常基类
      各库 必须 定义 一个 库异常基类
        任何 直接 从此库中 抛出的 异常 必须 基于 本库的 库异常基类
        库异常基类 是 所在包的 包异常基类 的 派生类
        细节实现库 的 库异常基类 是 其所要补充的库的 库异常基类 的 派生类
      由于 十分 规整+繁琐，可自动化 由 语言 默认支持，并行异常=普通用户定义的异常+语言提供的抛出所在地基类
        catch(用户异常基类&&抛出所在地基类)
    ====
    特化 依 概念/约束 enable_if
      概念偏序:
        [is_X<T>()] ==>> [is_Y<T>()]
        [is_X T] ==>> [is_Y T]
        is_X <=: is_Y
        X <=: Y
      多元约束偏序:
        //is_same<X,Y> Is X the same type as Y?
        //is_base_of<X,Y> Is X a base of Y?
        //is_convertible<X,Y> Can an X be implicitly converted to a Y?
        is_same <=: is_base_of <=: flip is_convertible
      声明式定义 比 计算式定义 更好 推导 处理
        比如：特化
        当 多个定义 存在时，解决方案 就是 约束之间的偏序
        约束 必须 是 可分解的

    ====
    可修改容器 异常保证 与 元素 的 操作异常
      容器的最低异常保证 应作为 模版参数
        如果 发现 元素操作 相对 安全，则 提升 异常保证 的 规格
      赋值？移动？交换？
      容器的某个 多个元素就地修改的操作 的 『强异常保证』版实现:
        可基于 元素相关的就地修改操作 的异常保证 来选择实现
          *『无异常保证』:
            容器直接修改元素
          *『强异常保证』:
            ...竟然无用！只能降级使用，仅相当于『基本异常保证』...
            //可见『强异常保证』可最后 再考虑实现，可不实现，外部能够自动实现
          *『基本异常保证』:
            *1:
              +容器的deep_copy/deep_clone
              +容器此修改操作的『基本异常保证』版实现
              +容器的『无异常保证』swap/move
            *2:
              +元素的deep_copy/deep_clone
              //+另外保存新元素+最后一次性批量更新
              +元素的『无异常保证』swap/move
    ====
    多元运算符vs迭代器
      命名输入参数vs多元运算符（正则表达式 形式）
      歧义/竞争/优先级？开头？结尾？调用态？完全调用态？
      短路？惰性？语句组？
      语法糖宏
      框架宏
        局部 输入输出 + 环境敏感 隐参数
        与外部的流程协同
          就地调用 非匿名函数
        对外部环境静态状态更新
      迭代器（静态状态 正则表达式 形式）
      ---
      多元运算符
        前缀:
          #『`』or『,』
          开头词:
            <`xxx arg0
          中间词:
            ...argI `xxx argJ...
          结尾词
            ... argN `>xxx
          半开头词:
            arg0 `<xxx arg1...
              当无歧义时
            <` arg0 `xxx arg1...
              当有歧义时
          半结尾词
            ... >`xxx argN
              当无歧义时
            ... `xxx argN `>
              当有歧义时
          开头词/半开头词 && 结尾词/半结尾词
            开头词&&结尾词
              <`>xxx
                独立运算符
                惰性值 变现运算符？
                处理 隐参数？
                IO 语句？
            开头词&&半结尾词
              <>`xxx
                前缀运算符
            半开头词&&结尾词
              `<>xxx
                后缀运算符
            半开头词&&半结尾词
              `<>`xxx
                二元运算符
      多元运算符 正则表达式/LL1
        #不得递归，下面是 大分类，但 值 不能 递归！严格 变小！
        #必须 符合 LL1 编译器语法要求，不得冲突
        #输入参数的结构类型:选择=并联Either，串行先后=串联 元组Pair，重复=串联 数组Array
        含头尾 =
          | 选择<含头尾>
          | 开头词/半开头词 && 结尾词/半结尾词
                独立运算符
                前缀运算符
                后缀运算符
                二元运算符
          | 含头 不含头尾* 含尾
        含头 =
          | 选择<含头>
          | 开头词/半开头词
          | 含头 不含头尾+
        含尾 =
          | 选择<含尾>
          | 结尾词/半结尾词
          | 不含头尾+ 含尾
        不含头尾 =
          | 选择<不含头尾>
          | 中间词
          | 不含头尾+
      其实 头尾 皆可重复，只是 中间的不是头尾
      重定义:
        含头尾 =
          | 选择<含头尾>
          | 含头 不含头尾* 含尾
        含头 =
          | 选择<含头>
          | 含头 不含头尾+
          | < 不含头尾+
            #开头词 在后
          | <` 类型 不含头尾+
            #半开头词 在后
        含尾 =
          | 选择<含尾>
          | 不含头尾+ 含尾
          | `>结尾词
          | >
            #半结尾词 在前
        不含头尾 =
          | 选择<不含头尾>
          | 不含头尾+
          | `中间词
            #可能是 中间词/开头词/半开头词/结尾词/半结尾词
            #可能是 独立运算符/前缀运算符/后缀运算符/二元运算符


    ====
    收敛 数据 函数
      函数分类:（收敛，异常（可捕获，不可捕获），发散/不返回/不退出/不停机）
      保证递归/循环 终结:关键输入参数 的 数据等价类 的 全序 + 循环引用函数组 的 等价类 全序
      所谓 数据类型偏序 究竟是 哪个层面上的声明？
      约束 引入它的源代码的使用？==>>抽象概念声明
      约束 最终用户的配置/配置协调相容？==>>配置约束声明


    ====
    区分 带量纲的值 与 无量纲的值
      量纲
          量纲的乘除法
          加法的量纲一致性原则
      无量纲的值 由区分为：真无量纲、量纲幂指数为零的值

    ====
    区分 可移植的值 与 不可移植的值
      见下面:
        字符全序 可称为『临时性局域性不可交流型全序』 类似 对象地址 有效性 并非 全局性永恒不变
      low level system error_code
        各系统 有各自的编码、逻辑概念，与实现绑定
      所有参数都是 可移植的值 的 表达式 产生 可移植的值
        一旦 含有 不可移植的值，则 产生 不可移植的值
    ====
    内存值表达 与 等价
      表达结构等同 vs 抽象概念值相等
        即使 存在 抽象概念值，表达结构的规范标准型 却
          * 未必 存在(有限表达)？
            #lambda-expr，外延等价（作为映射的等价）
            #实数的有限表达 不可能，部分 可用 函数 表达，但 难以比较是否相等
          * 未必 可计算（不能保证运算收敛/停机）
            #knot 结的规范标准型
            #group 群的归一化关系表达型的规范标准型 #群同构#<a,b,c | a*b==1, a/c/b/a==1, b*c/b/c==1>
            #命题的真性
            #定理证明的规范标准型（即 标准化 已存在的某份证明）
          * 未必 可移植？
            #字符全序 依赖于 字符集内码，不同的字符集 或 不同的内码方案 都将 导致 排序结果 不同 #gb18030 vs unicode
            #       可称为『临时性局域性不可交流型全序』 类似 对象地址 有效性 并非 全局性永恒不变
          * 未必 可在合理空间内存储(即存储 该规范标准型)
            #零阶逻辑命题的规范标准型
            #带集合运算的正则表达式（集合减、集合交），指数爆炸
          * 未必 可在合理空间内计算
            #IDFSM非确定型有限状态机的规范标准型（MDFSM最小确定型有限状态机）
          * 未必 可在合理时间内计算
            #group 简单无向图的规范标准型 #图同构
            #魔方魔数 保证/证明/检查
        同理，等价 判断:
          * 未必 可计算（不能保证运算收敛/停机）
            #knot 结的等价
            #group 群同构
            #实数的有限表达 不可能，部分 可用 函数 表达，但 难以比较是否相等
          * 未必 可在合理空间内计算
            #IDFSM非确定型有限状态机的等价
          * 未必 可在合理时间内计算
            #graph 图同构
            #零阶逻辑命题的真值表等价
            #
      自然数:
        #M>=2, little_endian
        us__0isM :: [uint%M]
          无冗余，但运算慢/不自然
        us__0is0 :: [uint%M]
          有冗余/有重复，但运算自然
          最高位无效0
      平衡树:
        树高度 对于 等价关系 无效
          <<==树高度 必须 满足 o(logN)
      正则表达式/有限状态机:
        标准化/规范化 难#时空占用o(expN)
    ====
    宏
      宏==>>环境敏感的表达式==>>使用地点 自动填充 隐参数==>>接口文件声明隐参数==>>实现文件 显式配置隐参数 或 隐参数是局部作用域的输入参数
      带限定前缀/全路径
      主要问题还是 有碍 词法分析，外部工具 直接搜索，标准化问题（其实 第三方库与标准库 也存在同样问题，自由vs通用）
    ====
    切面继承/切面偏序
      某个类的某个切面 是 另一个类的某个切面 的 子接口/子切面
      反转:[类A的I切面 <=: 类B的J切面][类B的W切面 <=: 类A的W切面]
        读操作切面 vs 写操作切面
      禁止 crosscast dynamic_cast
        允许 upcast 隐式
        ??允许 downcast dynamic_cast
    ====
    声明
      声明 的 目的 在于强调 如何使用（源代码语言层面上） 而非 实际定义 或 实现细节
        但 可以有 对实现的约束 以确保 能够 实现...
      更严格的更强约束的更多需求的输入方面声明==>>更自由的更多选择余地的更大设计实现空间的输出方面定义体
    ====
    物理性状#虚拟物理声明#physic_sort
      声明类型时 可附带 虚拟物理声明，用于 强调 某些类型的某些物理约束是相同的，这个 物理约束 无需 用户提供定义/配置，可能 由 编译器 推导出来，甚至 仅止于 作为一个 虚拟约束 完全无需定义
      代码爆炸+类型擦除==>>声明模版时，参数的物理性状 的 哪些方面 应用于 实现中 而无法 擦除？哪些 参数 影响 模版的物理性状(可细化到各性状方面)？本模版与其他模版，特别是 本模版带不同参数 之间的 物理性状 关系（相同？特别强调必须不同？细化到方面）？
    ====
    逆推收敛
      类型匹配逆推 是在 编译期 进行，不得 死机/发散/死循环/无穷递归
      ==>> 终究还是要有一个 所有函数收敛的子语言
    ====
    def:[循环引用与泛强引用的伪强连通分量]
      #C++因为使用 基类引用、函数对象，不可能避免 肿瘤，必然存在 内存泄漏！
      #bug:弱引用 可生成 强引用！函数状态 的 弱引用 不简单！重点 注意！！
      泛强引用 指 强引用数据成员 或 内嵌式数据成员(unboxed)
        核心:（分享析构权）
      以 泛强引用 作为 有向边，以 内存实际对象 作为 节点，形成 的 有向图 可能有环形路径，即 不平凡的强连通分量（以下 简称 肿瘤）。
      以下 循环引用 专指 肿瘤(泛强引用 的 循环)。
      数据成员 可随意修改，则 难以 作出任何 约束、检测、发现 肿瘤...
      但 假设 所有 强引用成员 不得修改 或 绑定 惰性表达式
        （当然，表达式 本身作为一个对象，也服从 本假设的约束，即 表达式 的 自带 状态 的 强引用数据成员...）
        （所谓 绑定，指 该成员可从引用 表达式 更改成 引用 表达式 的 计算结果（如果 表达式 是 生成器，甚至 允许 不断 修改该成员 以 引用 最新结果））
      全局变量 与 局部变量 一样 不得无条件 循环引用
      但凡 涉及到 循环引用的对象 必须集中在一起，同批次定义
        特例1:函数
          函数递归相互调用 很常见
          这意味着 一个函数 能否 直接调用 另一个函数，不能只看 函数签名/声明，还要 确立 包/模块偏序 以此 进一步 确立 函数偏序，最终用户的配置方案 也必须 满足 函数偏序 约束
            外挂接口 ~ 函数签名
            外挂实例 ~ 函数定义体
            静态的 外挂实例 之间的依赖 ==>> 模块偏序
            动态生成的 外挂对象，作为参数而被 函数 接受，似无不可
          ？？无状态函数 只是 代码块，是 实心数据，循环引用 仅止于 保证 存在性，又是 平凡构造/平凡析构，连构析次序都不要紧，只需注意 同批次构析，静态无状态函数（常见）甚至都无需管理！！静态只读数据！！
        特例2:数据 自引用
          即 数据 的 构造表达式 使用 未来的输出的计算结果 作为 输入参数
            def:[未来强引用] 注意 避免 死循环
          此 表达式 及其 内部状态成员 也算作 同批次成员
      同批次对象 会绑定 一个 同批次的计数管理节点(以下 简称为 肿瘤窗口)（当然 如果 输入的参数 蕴含 更早更更外层的 未来强引用，则 无需 新建 新的 肿瘤窗口，直接 使用 该 未来强引用 绑定 的  肿瘤窗口）
      肿瘤窗口 就是 整个 肿瘤 的 外部共享计数器
        肿瘤内部的对象 无需 独立的 外部共享计数器
      循环引用的析构:
        乱序==>>不得假设成员存在==>>先将可能的构成肿瘤的强引用置空(nullptr)
    ====
    不使用 垃圾回收 的 数据结构
      #! def:[强引用下游固化数据类型]:（即 所有 强引用、内嵌（unboxed） 延伸的 所有下游数据的 强引用成员 皆不可修改）
      #     接近 functional datatype，只是更宽松
      #! 浅层不重叠数据类型 #doubly/singly-linked-list
      #! 动态变化的循环引用固然难以检测、处理，但 固化的或惰性的循环引用 可预先安排一个 伪强连通分量计数节点，所有 指向 该伪强连通分量 中的对象的引用的中转计数节点 需要 指向 该伪强连通分量
          [循环引用与泛强引用的伪强连通分量]

      #任何 折叠起来的类型 都必须 固化: Haskell::GADT 比如: base_ops<physic_sort> = forall T<-physic_sort. pair<ops<T>, T> ；forall即意味着 折叠，T 既然可以是 任何 类型，当然 只能 固化 以阻止 循环引用
      首先 排除 函数、基类引用，除非是 强引用下游固化数据类型(完全固化的ops外挂接口对象，十分实用:代码 与 数据 分离，代码 可自带状态 但必须固化)
        它们的 共同点 是 函数体、子类/派生类 十分自由
        可冻结函数(yield)、带状态函数(lambda) 状态数据 类似 派生类，函数帧 甚至是 成员数目类型动态变化的 状态数据
      ==>> hs::datatype  | 完全实心结构体（不含任何引用，可树状化表达（无重复引用、无共享引用）） |  完全显式依赖偏序数据类型（类型构造器 a『小于』b 表示 a可被b直接或间接使用，反之则不行；；小于 而非 小于等于，保证 没有 循环引用『完全』指 无遗漏，这保证 即使在使用引用的情况下 与 完全实心结构体 等价） | 强引用下游固化数据类型
      其次 声明时 必须 指出 定义体 允许使用的直接使用了哪些数据类型(类型构造器->直接许可类型构造器->延伸许可类型构造器，不需要 声明 完全实心结构体 及类似类型；『小于等于』而非仅仅只是『小于』)，怎么用（引用本身可修改，引用本身不可修改，unboxed，weak_ref，in_use_ref，同批次循环引用，全对象引用）
        #这里 可区分 类型构造器 参数 的 角色:
        #   有些参数 最终后 成为 数据成员，有的 不会
        #   datatype T a = T (A B a)
        #   这里 直接用到两个类型构造器 A,B
        #       A 已然用于构成 数据成员，B 则要看 A 对于 自身参数的归类
        什么关系重要？
          分享承担析构任务的引用（强引用）
          构造后、修改后 不得出现循环
        def:[构造后修改后]
        构造时，新对象还不存在，不可能 有它的 强引用（但可能有 全对象引用 不得在 全对象构析过程中解引用），是故 不可能出现循环引用。
          <<== 构造成功后，才可以 出现 强引用
          ==>> 强引用下游固化数据类型
        修改 强引用 时，必须要求 可以静态判断出 替换的新对象 无法产生循环引用
          * 被强引用的类型 的 延伸许可类型构造器 中 并无 全对象的类型构造器，则 不可能 出现循环
          * 被强引用的类型 可区分为 两种，构造后 与 修改后，修改后的类型 可以是 构造后类型的 删减变体，即 减少 某些 可能 导致出现循环引用的 并联分支(允空引用->nullptr肯定没毛病)
            see:[类型增删变体]
          * 更复杂的推导证明
            singly-linked-list
            doubly-linked-list
            list-op:
              list-slice(remove)
              list-insert(remove)
        weak_ref，in_use_ref，全对象引用，同批次循环引用 类似，皆非 强引用(最多 也只是 伪强引用)，无需考虑
        引用本身不可修改，unboxed 两者类似，构成 有向无环图 的一部分，不可无视，直接许可类型构造器
        引用本身可修改，见上面:see:[构造后修改后]

    ====
    状态空间:
      * 多维正交
        标志位
      * 拓扑偏序
        类继承:
          迭代器:输入(不可重复的单向)迭代器、可重复的单向迭代器、双向迭代器、随机迭代器
          内存并发次序:relax, ..., 一致
    ====
    检查 与 报错
      约束检查 作为 声明 的 一部分，是 状态分流的构成部分，不能通过检查，只是 匹配失败，相当于 缩小匹配空间
      约束检查 作为 定义体 的 一部分，由于是在 状态分流 之后，不能通过检查，意味着 参数 不符合 前置条件（可能是 隐含的，与 实现紧密相关的，如：部分复杂情况待定义，当下只实现最简单的基础功能），出错，停止编译。
    ====
    原则:追加 声明/定义 不得 破坏/更改 之前的 代码 含义/实现/编译/和谐/稳定
      #追加: 纵向 新版本；横向 不同模块集成协作
      除非 封闭式，状态分流 不得 兜底/重叠
      局部性检查 必须 隐含 全局性约束
        否则 两个大系统 在独立工作情况下 各自和谐，但 一旦集成一起，可能 违反 全局性约束，这是不能接受的

    ====
    自动维护的辅助性数据成员
      概念性的声明 vs 带实现细节的声明
        概念性的声明 用于 匹配分流、证明推导
          #using/let...in 再自定义内部使用的 参数
        带实现细节的声明 用于 声明 私有功能性成员、辅助性成员（公开/私有）、内存布局次序、构造次序、对齐方式、对象的字节大小、physic_sort(物理访问声明)
      cache
      lock
      举例:
        datatype SizedList a = Empty | Con1 Size a (SizedList a) | Cons Size (SizedList a) (SizedList a)
        Size 无需用户维护
      函数的默认参数，特别是 模版的默认参数 某些很可能不希望用户提供，因为 它只是 cache(let...in)或 enable_if 之类的实现细节
    ====
    声明 多个对象 之间 不存在 共享的可修改状态
      容器里所有对象？
      经过 映射表 解释 索引 之后 也无重叠？

    ====
    异常
      不可捕获异常:
        未定义行为异常 #因为 不保证能检测到 未定义行为（当在虚拟机上仿真运行时 由于不考虑效率，不少 未定义行为 可以被检查到）
        待明确声明异常 #某些 情景分支 未有实现，更谈不上 声明。将来 可能 抛出指定异常，也可能 正常 返回，故而 当前抛出的异常 并非稳定接口，不可依赖，故不可捕获。
        in_use_ref 异常 #in_use_ref 与 weak_ref 的区别在于 in_use_ref 逻辑上 假设 被引用对象 生存期 长于 in_use_ref本身，故而 不必、不可、也可能做不到 检测 存在性，不能生成 强引用，一旦出错，将是 全局性错误 而非 局部性错误，用户 不能忽略它 也不能成功处理它
        未来强引用 异常 #表达式引用自身，出现死循环，严重的逻辑错误
        若 抛出的异常 不在 函数的异常声明列表中，则 该异常 只能是 未定义异常，该 抛出行为 只能是 未定义行为，不可捕获。函数的异常声明列表 可用 类似 C++ metaprogramming 的 方式 构建（抓取 输入参数 的 异常列表 进行 填充，而 静态已知子调用的异常依赖 需手动填充）
        调试用断言异常 #因为 该异常 仅存在于 调试版 不存在于 发布版，所以 并非 稳定接口，用户 不可依赖它。
        重大灾难防备中止异常#破坏外部数据完整性安全性的代码逻辑异常#在 发布版中仍存留，只因 错误影响到的不仅仅只是应用软件本次运行，而是 有更深远的影响，责任重大，比如:读写不匹配-影响持久性存储/网络流通
          读写不对称性
            同一个值 对应 多个表达
            比如:python字符串 是使用 单引号 还是 双引号，是否 raw？multi-line？是否只允许ascii？（比如 中文字符 是直接输出 还是 \Uxxxx_xxxx 还是 \N?{...unicode名称...}）
            写-不同格式<参数> 但 要求 格式相容无歧义
            读-统一#版本？
            ==>>
              写操作 返回前 必须 使用 读操作 对 输出结果 进行 检测，抛出 读写不匹配 的 代码逻辑异常

      可捕获异常:
        逻辑无关的不可控制的异常:
          算法 所需资源不足:
            timeout
            调用栈溢出(递归太深、自动栈帧变量太大（巨大数组）)
            动态内存分配失败
        逻辑无关的依赖底层的不可移植的可控制的异常:
          整数机器字长溢出
        逻辑相关的可以控制的异常:
          内部逻辑异常
            难以提前检查的前置条件:
              文件格式/字符编码 的 正确性
              累积误差约束
              带误差矩阵求逆 的 满秩要求
            算法实现 出错 的 断言异常 #debug
              如：矩阵乘法 要求 行列匹配，代码作者 粗心大意 可能造成不匹配。也可能使用脚本，而脚本解释器 作简单映射转发参数，并不负责检查 前置条件 因为 工作量太大
            继承性的底层异常: 算法 使用 外挂接口，则 除了 算法 框架 自己 抛出的异常，还继承了 外挂接口 抛出的异常
          外部协议异常:
            协议异常
            io异常
    ====
    等价
      同一对象 #object
      同一结构树 #datatype ADT
      复制 赋值 等价 #即赋值时，如果等价，可直接跳过赋值操作，当作已经赋值 #复制构造 时，若 两方 均是 不可修改，则 可跳过复制，直接使用引用？生存期？
    ====
    需求/约束/概念
        最小需求 <<== 某一具体算法
        联合需求 <<== 同一算法目标下的多种可选的合理算法
        通用概念 <<== 多种算法目标下的多种可选的合理算法的共同需求
        可选需求 <<== 有则开启更多功能声明
        需求 一般 出现在 声明 中，为了 实现的多样性，需求 应当 更多
        到底是 逻辑与 还是 逻辑或？
        逻辑与: 需求 更严格，算法可自由挑选
        逻辑或: 需求 更宽松，但 算法 只能在 具体参数 已知后 在 匹配的需求分支 下挑选
          其实 逻辑或 可能更合理
          因为 满足 逻辑与 的具体参数，意味着 满足 逻辑或 的 所有分支需求，挑选其实是 自由的。
          只是 逻辑与 只需 提供一个实现，但 逻辑或 必须 给 每个分支 提供一个实现
          不只是 实现/试验用原型 难度大增，有时候 某些需求分支 可能需要 底层系统支持，而这并不具有可移植性，亦即 无法实现。
          逻辑与 的 严格需求 提供 可移植性，在 底层系统支持缺失的情况下 提供 替代方案
      ==>> 存在 可移植性 毛病的 分支 必需 与 可移植性 分支 逻辑与
      ==>> 混合 逻辑与 逻辑或:
        ((逻辑或(可空所有 偶然可行需求分支) `逻辑或` 逻辑真) `逻辑与` 逻辑或(非空所有 必然可行需求分支))
    ====
    ...
      字符 相等 全序 关键字 有毛病: 跨字符集 难以 自动 判断相等。全序 在不同字符集间 不能兼容。关键字 如何 映射到 各字符集（最小字符集？）？
      外挂接口~同态
        随便指定某个类型的两个值，完全可以替代Bool，无需对最终结果使用类似fmap进行转换（从Bool转换成指定值）
        甚至无需是两个值，可以是两个等价类
      隐参数自动构造 ~ 环境感知 直接获取|依赖子对象|构造匹配逆推 唯一途经 不能冲突
        依赖子对象:
          共性: class S a => R a
          特化: instance T x => R [x]
          依赖子对象 冗余 与 兼容/同一/等价
        隐参数 举例:
          Java: this.this 类的内嵌类
          Haskell: Ord a
          全局变量？
          浮点数 误差 管理
          logging 配置
        显式的隐参数自动填充:
          {f} -- 将f所需 隐参数 从当前环境中 构造并填充
          {f} {g} -- 先填充f,g，再应用f于g
          (f {g}) -- f仍未填充
        隐参数 声明 全局性注册:
          用户 独立发挥 各自 承包 部分子空间 的 隐参数 构造 #逆推 需求+正向构造
          由 引用方用户 负责 引入的已被承包子空间（设置为 当前文件 默认构造）无冲突
              依『最终用户配置一切』的原则，引入的只能是 声明+约束，不能是实现。
              所以 隐参数自动构造声明 中 必须 含有 所承包的子空间的整体范围信息（内部如何细分，如：优先匹配，是无用的信息），在 最终配置 之前 便能够排除冲突。
      匹配~拆包~比 只能用 构造器 多一层抽象
        拆包==逆运算==解方程
          a@(b+3) ==>> b=a-3
          a@(divmod_result_of d q r) <==> [a==q*d+r][0<=r<d] <==> (q,r)=divmod a d
        def:[类型拆包]
        类型拆包 可分散后独立承包实现为 开放性外部虚函数表
          see:[外部虚函数表的开放性]
        类型拆包 应用举例:
          C++模版 类里的类型别名 无法逆推拆包
            实现 自动挑选 函数参数 传值 还是 传引用 的元编程 实际上 用途不大
            see:[自动选择传值或传引用的元编程]
      全局变量/常量~必然偶然 重定向 命名对象 代理 热刷新
        偶然:
          局部性偶然:
            编译期输入的宏常量 与 实现、底层系统相关
          临时性偶然:
            加载期初始化读入的全局性配置常量 与 用户应用 偏好 相关
          不时更新的全局变量，热刷新，不该 保存 或者说 只能 通过 路径 访问，或者说 使用 代理

    ====
    如何将 多类型变量的外挂接口 归结到 单类型变量的外挂接口？
      ??? class C a b c <<==??? class X x
      ???instance C (A a) (B b1 b2) (Y x y z w)
      class C<A,B> d
      instance C<A,B> d => C (A a) (B b1 b2) d
      instance C<A,B> (Y x y z w)
      ==>> instance C (A a) (B b1 b2) (Y x y z w)
    ====
    外挂接口特化 举例:
      class Show a where
        show :: a -> String
      class Show a => Show4List a where
        show4list :: [a] -> String
      instance Show4List a => Show [a] where
        show = show4list
      instance [a!=Char] Show a => Show4List a where
        show4list = ...
      instance Show Char => Show4List Char where
        show4list = ...
    ====
    def:[关系的匹配与定义]
      hs::class
      C++::template #type_traits?
      R 外挂接口
      E 具象实体
      D<R, [E...]> 关系定义
      关键是:
        * 这三者的作者 不同
        * 在哪找 D<R,[E...]>？如何 匹配？
      唯一性全局性封闭式模糊匹配:
        D 的 作者 必须是 R 的 作者
        D 与 R 捆绑一起，无需考虑『在哪找』
        E 的 匹配 类似 hs 函数的 优先模糊匹配+条件保护，反正是 封闭式 怎么爽 怎么玩。
        全局性 指 所谓『封闭式』包含 所有 可能的 模糊匹配
        唯一性 指 D 是 唯一的，与 R 一起出现
      命名式局部性封闭式模糊匹配:
        命名 D
        引用 D 的 标识 解决『在哪找』
        局部性 指 所谓『封闭式』仅限于 当前命名
      唯一性开放式规范匹配:
        有 很多 E，选择一个 作为 主E，成为 ME
        D 的 作者 必须是 ME 的 作者
        D 与 ME 捆绑一起，无需考虑『在哪找』
        『规范匹配』:ME 的 匹配 类似 hs::instance 匹配，ME 的 类型构造器+参数变量，不允许 更 模糊，也不允许 更 特化。但 其他 E 则 使用 局部性封闭式模糊匹配
        唯一性 指 D 是 唯一的，与 ME 一起出现
      命名式开放式规范匹配:
        D 的 作者 不是 R/E 的 作者 或 有 很多 E 而无 ME
        『在哪找』只能用 标识解决
        为什么 受 命名 约束 还要 规范匹配 而非 模糊匹配？
          方便 组合 引用，在 实现文件 引入 标识+匹配声明，在 匹配声明 无冲突的 情形下，可 无标识化/默认化
          是否 允许 规范匹配 的 内部模糊匹配？可以 考虑，不过 对于 无 隐标签 的 类型并立，其实现 必然 更复杂，甚至 可能 需要 任何 使用 它的 实体 都要 预知 模糊匹配 的 结果，或者说 模糊匹配 的 形式 成为 规范匹配 的 声明 的 一部分，但这又是不可能的，因为 通用的 规范匹配 实例化后 形形色色，难以 进一步 规范，除非 一开始就 存了 给指定 对象 开后门 的心思。
      预先式模糊匹配声明 vs 规范匹配实例化声明
        规范匹配实例化声明:
          R的实例 (E 是 (类型构造器 所需的参数变量的数目))...]
          所需的参数变量的数目 <= 类型构造器参数数目
        预先式模糊匹配声明:
          声明 会有哪些模糊匹配分支出现，以怎样的优先次序出现
          这样一来，在变量传入之前，便会 先进行模糊匹配，带着 隐形的匹配结果分支标签 进入 调用，这样一来，静态类型 就转化为 动态标签，适用于 动态外挂接口对象的构建。
          其实，这种 匹配结果/分支标签 完全可以 显化！！显化 成一种 关系/约束/匹配约束 R！
      『重点』:实现 方式:
        * C++ 代码爆炸
          无需物理兼容
          无法 使用 命名式匹配？
          或者说 命名式匹配 就是 type_traits
          type_traits 的 实现:
            唯一性全局性封闭式模糊匹配
            唯一性开放式规范匹配:
          『在哪找』是个大问题
          C++通过#include指望能够包含 够用的 兼容的 匹配，而这是无法确定的:
            * 若有默认匹配，若漏掉特化，将难以察觉。
            * 不同作者 重复定义 同一特化，发生冲突。
          共性接口 vs 特化接口
            vector<bool> reference_type value_type 的 关系 与众不同
        * Java 类型擦除
          物理兼容
          无 隐参数
        * Haskell 动态组合构造 外挂接口 对象
          物理兼容
          隐参数自动构造
          隐参数 依赖子对象 冗余 与 兼容/同一/等价
      无限空间互斥切分承包责任制:
        无限空间 切分后 一般仍是 无限空间（带参数变量）
        禁忌: 独立承包 却发生 空间重叠
          （如 :兜底的缺省实现C++模版 经常如此，一旦 遗漏有效特化版本，直接采用默认版本 而非报错，难以察觉；
          二来 将来版本追加新分支 竟然 会修改 旧版本的选择，这正是C++模版所求的，却 未必合理，特别是对于 永恒代码 而言 不合理；
          除非 封闭式优先匹配，否则 不许 兜底、特化、重叠）
          ==>> 平行匹配 vs 优先匹配
        可以 承包整个空间
        可以 承包空间后 再减去部分空间 （类似 集合操作，已达到 平行匹配 如同 优先匹配）
        承包后 允许采用 封闭式优先匹配的细分承包（如:允许 兜底匹配）

    ====
    类型并立
      //==>> [无标签+虚函数===隐标签===虚拟标签]
      //    err!!! 除了 内联式的虚函数 紧邻式的带标签，还有 分离式的外挂接口！！！
      //            分离式: ([A]|[B]) != [(A|B)]
      无标签: C++ union | polymorphic baseclass
      带标签: hs datatype
      无标签 多态:
        虚函数 转发
        但 (Show a) | (Read a) 的 自动化 实现 比较 麻烦，转发 序列化后 无标签！
        当脱离 内存中的 虚函数 体系后，标签 是 必须的！
        可给 类型 排个序，用 整数 索引号 作 标签！
          但:
          * 子类型 无法 兼容
          * 因为 无标签，所以 实际上 并不 知道 是 那个 类型。//除非 typeid()，但这样 其实是 隐标签 不是 无标签（虚函数 本来就是 隐标签）
        能否统一 各种编译器实现 各个应用软件 的 自动化生成标签？简洁 的 标签？子类型 兼容 的 标签？
          可以 让 用户 选择 一套 虚拟标签，它 并不 真实 存在，仍是 无标签/隐标签，可用于 序列化；不同套的 虚拟标签 之间 虚拟标签 与 无标签 之间 可以 相互转化，但需 显式指明

    ====
    def:[类型擦除]#java generic type
      physic_sort
        see: 'The C++ Programming Language(4ed)(2013).pdf' :: pg731[746/1366]pg733[748/1366] #code bloat代码爆炸~type erasure类型擦除
      对于 接口类体系 很重要
      因为 有多个 版本的 实现类体系
        （类体系 一组相关的类）
        （接口类体系 一组相关的抽象接口类）
        （实现类体系 一组相关的具象实现类）
      固然 可以 从 实现类体系 一对一地 映射 到 接口类体系，但 无法 强调 类体系内部  相关性，即 可能 通过 一致的 接口类体系  产生 不同的实现类体系之间的 混用
      可通过 模版参数 区分开
      但此 模版参数 并不影响 physic_sort，即可 进行 类型擦除，以防 代码爆炸，用户 代码也不必 重新编译
      模版参数 声明约束:
        * 是否 影响 physic_sort，是否 影响 模版实例化，是否 可擦除（可==>>不能靠这参数区分特化+本模版定义体内部使用的模版本参数 也是 可擦除的）
        * 类型 #typename/int/...
        * 值约束 #physic_sort/logical-concept/predicator/...
      底层系统设计 无需 考虑 高层用户自定义类型
        GUI 返回 基类引用，对于 应用程序而言 损失了 派生类的诸多有用信息
        使用 dynamic_cast 还原？
        太麻烦！
        但 底层系统 预先分离编译，不可能 实现 静态多态，只能 类型擦除+动态多态
        解决方案:
          * 底层类型擦除，高层模版参数大范围跨对象约束
            有点 外挂接口 的意思
          * see:[外部虚函数表的开放性]



    ====
    const data member:
      static const data member:
        for complicate type has no constexpr constructor
      static constexpr data member:
        enum
      non-static const data member:
        e.g. Map::Item::fst #Key
      non-static constexpr data member:
        e.g. tag as-if typeid() for dynamic_cast
    ====
    see:[类型增删变体]
    ====
    see:[覆盖源自数据成员的虚函数]
      +隐式/显式 类型转换
      +using 数据成员::成员函数
      ==>>更灵活的 基类
      [浮动数据成员]+[浮动基类]
      实现接口 无所谓 浮不浮动、共不共享、重不重复，因为 没有 可修改的数据成员
      继承实现+共享数据 一般 都是 浮动共享+保护//virtual protected @C++
      继承实现+不共享数据 一般 都是 固定重复+私有//non-virtual private @C++
    ====
    like “strict”
      声明 输入输出参数 之间 是否有 共享数据 entangled？
    ====
    see:[必然偶然]
    概念/接口->等待最终用户配置的具象类
    『任何一个』的 两种含义:
      * 每一次出现 均是 forall x<-I. [...]，即 产生一个新的待配置类型参数
      * 只有第一次声明时才产生一个新的待配置类型参数，以后均引用 同一类型
    约束（必须怎样配置） vs 优化指导（最好怎样配置）
    ====
    批量处理
      比如: 虚函数表，类继承图格导航
      比如: 同步对象 所有读写操作 默认 锁保护
        实现 同步对象 的 转发代理类型
    ====
    面向对象 的 最大问题是 只是 面向单个对象
      当需要产生 新对象、需要 处理多个对象时，还是要靠 外挂接口
    ====
    文件头部声明
      1) 语言+版本
      2) 方言/自定义语法糖+[输出为该版本抽象语法树]
      3）文件类型 // 前瞻性声明、API声明、ABI声明、内部实现私有友员声明、定义实现
    ====
    see:[外部虚函数表的开放性]
      内部虚函数 标志位:
        * 我是不是 虚函数？virtual
        * 我可不可 被覆盖？final
        * 我需不需要 被覆盖？=0
        * 我需不需要 被每个具象子类覆盖？typeid()
        * 我需不需要 被每个子类覆盖？
        * 我是不是 正在覆盖？override
        * 我 是否私有？private #不可调用，但能覆盖！！ #protected 允许子类 调用 该子类的对象的 本虚函数我
        * 我 需不需要 默认实现？
            ...单继承的包裹式...
            ...多继承的协作式...
            super 链 会触及 声明虚函数的类，所以一开始就需要 默认实现。
    ====
    永久
      关键字 的 命名空间 必须 与用户 命名空间 区分
      像C++那样，毫无节操地添加 关键字，谈何 后顾性兼容？
    ====
    显式省略:
      按个数: _, _, ...
      前瞻性预留 不确定个数（只确定 个数下限）: ... ...
    ====
    对象:强调约束vs强调表达vs强调修改vs强调接口vs强调标识
      强调标识Q:带标识，绑定一个对象/转发另一个命名对象，区分 必然偶然
      强调接口I:外部只能看到 纯接口引用，不知 具体类型，无法 赋值、比较、多元运算...，无法 显示(repr)，除非是 命名对象
        boxed
        防碰撞: ref.interface_alias::f
        see:[辅助函数与关联辅助开放空间]
        一套接口多种实现
          整数<n,endian>: (0|(sign, pint)) where pint=[word%n] #omit leading 1, little_endian/big_endian
          复数:(实数，虚数)|(0|(preal,real%2pi)) #polar coordinate
      强调修改D:正交空间直积点，自由修改，无约束，保存+加载+显示+标准化+传输（序列化/字符串化(repr))
        unboxed
          ??where is unboxed tagged/cased union??
        无继承，不允许 虚函数
        see:[辅助函数与关联辅助开放空间]
          无成员函数
        D===单标签E
      强调表达E:带标签并集，无约束，保存+加载+显示+标准化+传输（序列化/字符串化(repr))
        ???互斥并联？？？hs-datatype???
          tagged/cased union??
        E 的 负载 是 D，即 负载 可 自由修改
          但！标签难改
        所以 总的来说 不可修改
          无 默认构造器，永远 需要 显式构造
        boxed
        (E&D)===hs.newtype<D>|单标签
      强调约束V:表达不可修改的值，与 静态约束、并发访问 配合良好
        通常 V === (E|D)+静态数值约束，即 V 是 (E|D) 的 子类型，存储/表达 为(E|D)，只是 不可修改，并且 符合 声明的 约束
        #Date#年月日约束
        boxed/unboxed

    ====
    UndefinedError
      Throwable but not Catchable
      因为在以后的版本里可能细化 未定义状况，部分变成 有明确回应。任何catch UndefinedError后进行的行动都是无效的
      不是 稳定API 的一部分
      API声明 以外的 异常 不可捕获，即 所有 线程 必然 终结
      API 异常声明 分两种:
        * 声明 的 异常 属于 稳定API的一部分，含义明确，允许 其他异常出现并终结 进程
        * 声明 的 异常 属于 稳定API的一部分，含义明确，不允许 其他异常出现，是对所有 内部调用函数的 强约束。保证 进程 不死。但 是否 返回？是否 没有 死循环/发散性递归/调用栈溢出/内存不足？
          实心数据 不需要 动态内存，可提前保留 内存空间（如：std::vector 保留着一些未初始化空间），只要 构造函数 无异常 则 必无异常（除了 栈溢出）。
    ====
    package/module API 中继
      转发
      挑选？指定成员名 或 指定 版本
      合并?碰撞？ 要么 挑选  要么 分别赋予 限定 前缀
      版本？所有？包括 以后？
      必然偶然
    ====
    package/module/entry access control
      private+friend
      invisitable-as-if-not-exist #importance to inherit
      ？对于 某个类，即使是 某个库 私有的，只要 通过 合理的方式 将其 类名 暴露到 其他库，那么 其他库 就可 正常使用 该类。
        比如:
          class A{
          private: class P{};
          public:
            vector<P> ls;
              //是否允许暴露？
              //是否允许vector使用P的成员函数？
          };
      是否可接触=通过指定方式是否可接触|是否可暴露（是否不可能通过任意方式接触？）

    ====
    永久？永恒代码
      同版本 修订:
        订正:注释、文本常量
          追加补充 注释
          并不影响 编译/改变可执行文件
          仅作为文档，给人看！
          当然，最终用户 可通过 配置 显式地真正订正 可执行文件
        订正 vs 再版
          再版 只能 兼容/包含，不能更改
          必然偶然？
          可移植的值 能否 订正？
            会影响无数 存储空间中的文件及格式
      再版 巨大影响！
        比如：再版时，数据类型定义的同时 特化 某个关系/外挂接口
          包xxx 再版为 yyy
          包zzz 原来引入 xxx
          包wee 引入zzz，但希望zzz引入yyy而非xxx，即zzz<yyy>而非zzz<xxx>
          如果 引入包 自动由旧版变成新版，则 代码含义被窜改
          如果 仍维持引用旧版，则 对于 有使用新版的需求 的用户而言 将有两个麻烦:
            +再版 zzz，zzz<xxx> -> zzz<yyy>
            +必须 通知 zzz的作者
          如此一来，一包再版，所有依赖它的包被迫再版
          可见，直接引入 包 是 错误的设计
            应该 引入 包接口！
            由 最终用户 进行 配置！
            包 是 模版，引入的包接口 是 模版参数
      文件存储单元
        字节？当下的标准 存储单元，网络通信单元
        但连二进制都不是永久保证，字节 不可靠！
        先考虑 字符集，再考虑 编码，最后考虑 摘要函数
      字符 可靠 但！
        字符 的 数字化 表达 有疑问
        那个字符集(有序，对应 模剩余系)？
        字符 在不断增加，有来自过去的，有当下创造的，潜在的 字符集 无限大
        任何一个 字符集 都不可靠！unicode 不可靠！
        字符集名 必须 作为 参数
        字符集名 用那个字符集？
        文件系统路径字符集？显然，文件 本身 不能提供 自身所用的 字符集 及 编码方案，需要 额外信息，要么 编码 在 路径（如：后缀名） 里，要么，系统性设计 一一对应的 关联文件，要么，集中在 某个地方 进行 说明
        对照表？假设没有一个 字符集 能包含 所有 字符集名（无法统一标准称谓，比如:私有临时草创实验性的字符集），假设 字符集名 并不能 存在于 所有字符集 中。
        可是 字符集 不同 如何 交流？（相等比较？）
        假设 编译时 有一个 类似unicode的编码方案，能够 整合所有 字符集，...？
          用 函数实现 来代替 命名，如何？
          获取带外信息(文件路径)->(解码器<字符集名>)
          解码器<字符集名>.读文件(文件路径)->(字符集名？，整数串)
            ？？字符集名 用那个字符集？
          解码器<字符集名>.读文件(临时整合用字符集，文件路径)->(整数串)
            ？？关键字？？字符 归类？
        ???

      整数 可靠
    ====
    引入:接口、参数
      至于实现 可由 外部 配置
      当然 可声明 内部实现的 逻辑必然性: [某些 引入的接口 需要 相同实现/甚至同一对象]
        只描述关系，具体实现 仍由 最终用户 配置！
        但 可提供 缺省 具体实现 以供 最终用户 参考。
          * local constraint for global setting
          * local default for global setting
          * global setting
        上面是的 静态配置，只要求 API声明。还有 动态配置: 要求 physic_sort/ABI 兼容 才可互换(1.用函数参数控制 2.dll/plugin) #数据配置 最简单:加载/读取 初始化参数
          多层次 头文件

    ====
    假设 用户 是 机器/程序，而非人
      更一致简洁的语法+数据格式，更少的隐含参数、假设，更多更显式的输入输出参数+约束要求，更多地提供源文件信息（在各处代码），更少的人为限制（命名字符约束、缩进、（代码）长度限制深度限制）、更自由的排版风格、更灵活的代码次序排列、更少自作聪明的sugar语法(syntactic sugar)
    ====
    def:[约束的产生]
      约束 可以 很容易的 声明，并用于 推导
      但它如何产生？
      显然是有 具体的实现细节 逐步构建而成
      这并不容易，只能 假定 一些虚拟属性，冻结 某个时刻的对象的值，然后 忽略 非局部性的作用，进行一些粗略推导，以得到 约束
        而是否停机（收敛/不发散/无死循环/无限递归）更难，通用编程领域里通常不予考虑
          但在特殊领域，如 编译期计算（constexpr, type construction, type pattern match）必须停机！
          归纳法？收敛？发散？
    ====
    def:[API_ABI]
      #不同层次，不同用途(前瞻性声明，完整声明；用于输出的对外声明（进一步细分:普通级、专家级），用于实现的对内声明（更多私有实体）)
      什么是API？有别于ABI，关注的是用户代码的不变性，即与API的实现无关
        如:声明 类公开数据成员，但它的实际定义是类似C++的数据成员 还是 类似python的property，对API并无影响
        C++头文件 保护 ABI信息 甚至更多，并不完全合理
        可以 分离出 API 用于 维护 用户代码不变性 / compiler
          __api_decl__
        可以 分离出 ABI 用于 维护 用户可执行文件不变性 / linker&loader
                __abi_decl__
        API 描述 高层关系、约束，逻辑上的必然关系的定义体，公开规范的人为定义
        ABI [type_erase][physic_sort] 即使是 底层接口 弱类型 仍是 有类型 即 physic_sort
          physic_sort: 如: 对象指针，函数指针，数据成员指针，它们分属不同的 physic_sort，在弱类型的ABI接口中，physic_sort扮演重要角色（即 作为 更大颗粒的数据类型）
          如：python 的 object-reference 如何 取出 object.__class__.__getattribute__ 以便 进行 完全受用户定义的__class__控制 的操作。
            如何 取出 就是 physic_sort，它是一个协议:
              reference 如何 解引用 得到 object 地址
              object layout 如何 存取 __class__
              __class__ 如何 取出 __getattribute__
                显然 不能 无限 循环
                至少 py::type 要有 明确 取出 __getattribute__ 的 方法
                实际上，python 明确将 特殊属性 直接 保存在 __class__ 里。即 均明确 取出 __getattribute__ 的方法，所以 无需 先取出 object.__class__.__class__
        physic_sort 作为 协议/约束，显然也是有 偏序的
          比如 上面的 python::reference 很可能 细化 shared_ptr的physic_sort
            shared_ptr的physic_sort
              描述了 占用内存的大小+对齐，如何 复制/移动/赋值/析构

        # 前瞻接口声明
        # 类公开成员
        # 类关系: 继承关系
        # 约束:
        #     如:static_assert(std::is_pod<T>::value, ...)
        #     由于 T 定义 并不完整，ABI不全，故此 约束 只能用于推导。只有 最后 配置 实现 时 才能 用作 对 T 的检查。
        # 必然性定义体
          #see:[必然偶然]
        # 某些 ABI 声明:
        #     如: 声明 X 是 physic_sort
        #         声明 S,T 符合 X
        #         这样一来，S 与 T 之间 就有了 某种 逻辑上的必然联系
      idea 4 c++?
        def:[big_ptr]
        big_ptr = {.data_ptr, .ops_ptr}
          ops_ptr -> ops:: physic_sort s.t. decltype(big_ptr)
            ops is static
            ops for subobj/baseclass is a subobj of bigger ops
            e.g. ops = {.decl_type_info, .ops_offset_at_derived_most_obj_ops, .?ops_offset_at_whole_obj_ops?(not required), data_offset_at_derived_most_obj, data_offset_at_whole_obj?, pvtb(ptr_to_virtual_function_table of decltype(big_ptr))}

    ====
    常量/资源
      def:[必然偶然]
        比如：
          群乘法『一般』是 不符合交换律的
          但 对于特定的某些群，它们的乘法 是 符合交换律的
          ---
          某群 的 乘法 是 不符合交换律的
          但 该群中的某些元素之间的乘法 可以是 符合交换律的
        ~
        ;goto start0;
        :start1:
        有一个 全局皆然vs局部特例 的区分
        ---全集/子集 都不是空集
        有一个 默认非空全集(全球流通永久存储)+默认谓词+默认非空子集(本次运行临时私有配置) 作为 大前提
        必然真~全集元素皆真~[{}~<~G,P] @a<-G. P a
        必然假~全集皆假~[{}~<~G,P] @a<-G. not (P a)
        偶然真~当前子集元素皆真~[{}~<~G,P,{}~<~L~<=~G] @a<-L. P a
        偶然假~当前子集元素皆假~[{}~<~G,P,{}~<~L~<=~G] @a<-L. not (P a)
        ---
        否定必然真~全集元素不皆真~[{}~<~G,P] ?a<-G. not (P a)
        否定必然假~全集元素不皆假~[{}~<~G,P] ?a<-G. P a
        偶然否定偶然真~当前子集元素不皆真~[{}~<~G,P,{}~<~L~<=~G] ?a<-L. not (P a)
        偶然否定偶然假~当前子集元素不皆假~[{}~<~G,P,{}~<~L~<=~G] ?a<-L. P a
        ---
        必然否定偶然真~当前子集元素不皆真~[{}~<~G,P]@L. [{}~<~L~<=~G] -> ?a<-L. not (P a)
          === [必然假]
        必然否定偶然假~当前子集元素不皆假~[{}~<~G,P]@L. [{}~<~L~<=~G] -> ?a<-L. P a
          === [必然真]


        [必然真]|[必然假]|[偶然真]|[偶然假]|[否定必然真]|[否定必然假]|[偶然否定偶然真]|[偶然否定偶然假]
        #逆否命题
        [必然真]
          ==>> [偶然真]
          ==>> [偶然否定偶然假]
          ==>> [否定必然假]
          ==>> []

        [必然假]
          ==>> [偶然假]
          ==>> [偶然否定偶然真]
          ==>> [否定必然真]
          ==>> []

        --- expand above:
        [必然真]
            * ==>> [偶然真][否定必然假][偶然否定偶然假]
            * =/=>> [必然假]|[偶然假]|[否定必然真]|[偶然否定偶然真]

        [必然假]
            * ==>> [偶然假][否定必然真][偶然否定偶然真]
            * =/=>> [必然真]|[偶然真]|[否定必然假]|[偶然否定偶然假]

        [偶然真]
            * ==>> [否定必然假][偶然否定偶然假]
            * =/=>> [必然真]|[必然假]|[偶然假]|[否定必然真]|[偶然否定偶然真]

        [偶然假]
            * ==>> [否定必然真][偶然否定偶然真]
            * =/=>> [必然假]|[必然真]|[偶然真]|[否定必然假]|[偶然否定偶然假]

        [否定必然真]
            * ==>> []
            * =/=>> [必然真]|[必然假]|[偶然真]|[偶然假]|[否定必然假]|[偶然否定偶然真]|[偶然否定偶然假]

        [否定必然假]
            * ==>> []
            * =/=>> [必然假]|[必然真]|[偶然假]|[偶然真]|[否定必然真]|[偶然否定偶然假]|[偶然否定偶然真]

        [偶然否定偶然真]
            * ==>> [否定必然真]|
            * =/=>> [必然真]|[必然假]|[偶然真]|[偶然假]|[否定必然假]|[偶然否定偶然假]

        [偶然否定偶然假]
            * ==>> [否定必然假]|
            * =/=>> [必然假]|[必然真]|[偶然假]|[偶然真]|[否定必然真]|[偶然否定偶然真]

        ---全集/子集 都不是空集
        :end_start1:

      :start0:
      真常量:
        #必然性相同
        公开协议参数
        数学公式参数
        文件格式参数
        ...
        枚举类型~头文件~API~程序员之间的协议
      可配置的常量:
        #偶然性相同 #named-obj/value 之间的 is/== 关系，也有 必然/偶然 的区分
        #这些实现相关的细节信息 不该出现在 头文件 里，可用 编译期函数提供（该函数必须显式表明自己的返回值 并非真常量）
        机器字长~移植性变化
        字符串字面常量的地址
        可翻译的文本/日期/带单位数据~地域性变化
        默认值~可重置，除非是API的一部分（公开规范）
        测试数据
          测试用 的 数据 的 集合 有很多，只是偶然选中当前 样本
        样例数据 #提供几个有效参数做示例
        版本号
        ....
        历史数据
        物理公式系数
      什么是『必然』？
        其实 只有 两样:
          * 定义
            各种 数学对象，它们的 定义 也就是 公设
            各种 规范标准、协议、API、文件格式...
            高层对象 之间的关系: 如 类继承、有哪些公开成员...
          * 从定义出发推导出的逻辑结果
      历史 与 物理:
        历史记录 以后 可能订正
          历史文本 古代书籍 可能更新/或有 很多版本/底本/变体
        物理 皆是 测量值，有误差
      C++ 赋值两个相同 字符串常量，它们的地址是否相等？依赖于实现
        当进行 == 测试时，可 返回 不确定值//并行态（既真且假），见下面xbool
        其实 C++ 头文件 并不只 包括 API，还包括 ABI，甚至更多。这显然是『实现依赖』的，并非出于逻辑上的必要。当用 类型 定义变量、声明成员 时，其实 并不需要 完整定义，只需 前瞻性声明 即可。如果 使用 公开成员，那也只需 公开部分的API，私有部分是实现细节 并不需要 出现在 头文件 里。
      『保证』
        所谓『保证』，有其前提。
        比如，这个 版本 的 语言标准 保证
        比如，这个 版本 的 编译器 保证
        比如，这个 版本 的 平台/操作系统/虚拟机 保证
        除非 前提 成立，否则 不必然
        检查 前提 其实 就是 分支版 的 『实现依赖』
      forwarding_reexport:[转发式重新输出]===转发引入名作为输出名
        这种情况 如何 区分 必然偶然？
        分情况:
          * 必然性 API 声明 一般都是 必然性转发
            但 注意到 声明 也是 有 层次的，某些声明 就像 不完全定义体
          * 必然性ABI声明、必然性定义体 的 转发 可能是 偶然的

    ====
    tag everywhere: require pseudo-import to decl the meaning of tag
      syntax: {[}tag{]}
      syntax: {<[}tag{]>}
      syntax: {(<[}tag{]>}...???...{<[}tag{]>)}
    vs inline comment: {-[}inline comment{]-}
    ====
    alias pattern && reversable alias pattern
      we can easily go from left to right by alias-def given alias constructor+args(pattern match args on lhs of alias-def)
      but how can we go from right to left?
        reversable ==>> alias is injection/互斥
    using alias, we can simplify construction that use original constructor
    using reversable alias, we can simplify pattern-match that use original constructor
    ====collision-visibility of identifier
    成员名 防碰撞（多继承）
    函数 命名参数 防碰撞（多转发）
      变量名 肯定是 不够用的
      至少 也得是 路径名/qname=qual_name
        可用 symbol/object 'is'
    私有/可见性控制
      无论是 class/pkg/namespace 都很重要
      对外 要完全 不可见，如同不存在，而非 只是 禁止 使用。禁止 使用 意味着 可见，意味着 碰撞。
    ====collision-公开的成员名 防碰撞
      * using qname，qual_name, qualified-name
        见下面 包名 防碰撞
      * using parameterized identifier
      parameterized identifier
        def:[参数化标识名]
        参数化 标识名: 参数 可以是 任何 编译期的值，相等+读写（<->文本），包括:类型、参数化标识名。重点在于 标识名 并非 字面 值，允许 参数 实例化 时 使用 引用 变量名/别名，甚至 参数化标识名 本身 也可 alias
      ===参数化标识名 vs 参数化模版名
      ===参数化标识名 只命名 唯一一个 标识 vs 参数化模版名 命名 所有潜在组合（导致 不能 作为 虚函数 名）
      encoding identifier/complex identifier
        embedding type-name:
          f[T]<S>()
          S~template arg
          T is part of whole identifier "f[T]"
          why?
            #err: virtual g<T>()=0;
            virtual g[T]()=0; //ok!
            但！可添加无用参数重载函数 而非 特化:
              see:[[无用参数]]
              virtual g_who(Tag<T>)=0; //ok!
      ====
      标识-参数-自定义 .xxx.xxx
        分解 标识:
          py.unittest test_xxx
          listener.on_xxx
          set_xxx/get_xxx
        自定义 静态 __getattr__
          如: x..f(...) = {x.f(...); return x;}
            ==>> x..f(...)..f(...)
          __getattr__ 通常 需要 分解 标识
        可用于 metaprogramming，复制 整个类 的 公开成员函数，用于 实现 ref
      ===
      参数化模版名 可用于 命名 私有标识，只要 某些 参数 是 私有类
        私有标识 可用于 框架宏 在 展开处 就地 定义 私有变量，以防 与 用户变量名 碰撞

    ====collision-unbounded-ultra-lengthy-identifier
      无限制超长标识名
      unlimited, unrestricted, unbounded
    包名 防碰撞:
      当前 包名 这么短，必有 独立提出 并发生碰撞的。随着时间的推移，代码数量剧增，顶级包名 必然 越来越长
        问题 只出现 在 完全 开放空间，不特定 人员/团队 不特定 时期 不受控地 自由使用/占有 包名，相当于 并行编程-数据竞争
        问题:如何优雅地使用 长度极长的包名？包 安装？包 引用？
      hname = huge_name ~ 几无可能 碰撞 ~ 防碰撞机制的唯一根源
        唯一的 目的是 有别他人，不需要 明显的 含义(如:库用途，与 库内容 无关！，库相关 命名 当在 非开放空间之下)
          #？第一行 是 nname？
          作者团体标识，库创建时间，地点，随机数
        #xxx #under __subspaces__/.../.../.../
        #xxx #under __open_space__/.../.../.../
        under __ospace__/.../.../.../
      nname = nickname/agname/byname 略称/简称/绰号 ~ 极大可能碰撞
      msuffix = manually-choosen-collision-free-suffix
        路径名 里的 nname[msuffix] 只能是 以使用它的 库 的位置为基准 向上搜索 先辈，不能搜索其他！也即 向下 公开，对外 私有，非API。但 alias 是以 路径名 前缀 为 基准，属于 API 的 一部分，也区分为 必然、偶然，必然 则 连同 定义体 都是 API 的一部分，偶然 则 只有 alias 存在性声明 是API的一部分，定义体 可能 更改/可配置/可替换。
          see:[必然偶然]
      rsuffix = auto-choosen-collision-free-random-suffix
      cname = controlled-name
        #xxx #under __subpackages__/
        #xxx #under __controlled_space__/
        under __cspace__/
        under __pspace__/
      pspace = private controlled-space #__private_controlled_space__
        enclosed space + invisibility
        有主受控秘藏空间
        路径名？ 必须 与 公开 空间 区分开（受控私有空间，受控公开空间，开放公开空间）
      cspace = controlled-space #__controlled_space__
        enclosed space + visibility
        有主受控公开空间
      ospace = open-space #__open_space__
        common/wild space + visibility
        无主众竞公开空间
        ### xxx ### e.g. for others to fork and ...impl his variant to same API
        e.g. 大地域/大团体 分配 空间 给 子团体
      nsroot = namespace root
        #xxx #__root__
        #__nsroot__

      包自动管理:
        即:下载，安装
        依 本包 前缀 寻路，本包 既然 使用 hname，则 父空间 是 开放的 无限制注册空间
        安装于: 父空间-根目录/__ospace__/{nname}/{digest}/{随机名-同目录区别而已}/
          #本包 根目录
          #hname_pkg
          ===
          __hname__ #文件，保存 hname # 声明/输出 export hname #../*/__hname__ 的 值 作为 键值 必须 唯一
          __nname__ #文件，保存 nname，冗余 检查 __hname__ 第一行
          __digest__ #文件，for __hname__, 方法名+摘要<方法名>(hname) #用于避免 依赖庞大无限制更新的 只增不减 摘要库 或 只能 使用 固定有限的几个 古董摘要库 # 直接用做 {digest}/ 目录名 #受文件系统规范，只取最大前缀，其长不超过系统限制
          __encoding__ #文件，for __nname__,__hname__,__digest__
          __cspace__/ #含 本包 所有 子包根目录 及 子模块文件
            #cname_pkg
            {子模块名-module-name} #文件，模块
            {子包名}/ #{子包 根目录}
              #无 __hname__, __imports__, ...
              __cspace__/
              __ospace__/
          __ospace__/ #含 本包 所有 子空间 的 根目录
            {子空间-nname}/{digest}/{随机名}/...recur def...
          __imports__/
            {他包-nname}/{本包 作者 手动 选的 防碰撞 后缀-msuffix}  #文件，保存 输入包/他包 的 hname
        定义目录类型:
          ==举例:
          开放空间:
            #xxx #如：源代码根目录/
            #如：__ospace__/
          受控空间
            #如：__cspace__/
          长名包
            #如：__ospace__/{nname}/{digest}/{rsuffix}/
          短名包
            #如：__cspace__/{cname}/
            #xxx #如：__cspace__/{cname}.{ext}
          ==定义:
          源代码根目录/ #xxx <=: 开放空间
            #禁止出现 __hname__,__nname__,__imports__/
            #禁止出现 __cname__
            #禁止出现 __cspace__/,__alias__/
            __nsroot__ :: 空文件
            __ospace__/ :: 开放空间

          开放空间/
            #xxx #禁止出现 __nsroot__
            {nname}/{digest}/{rsuffix}/ :: 长名包
          受控空间/
            {cname}.{ext}
            {cname}/ :: 短名包
          长名包/ <=: 短名包
            #禁止出现 __nsroot__
            #禁止出现 __cname__
            __hname__ := hname
            __nname__ := nname
            __encoding__
            __imports__/
              {nname}/{msuffix} :: hname
            #以下 与 短名包 相同
            ...包文件夹共同内容...
          短名包/
            #禁止出现 __nsroot__
            #禁止出现 __hname__,__nname__,__imports__/
            __cname__ := cname
            #以下 与 长名包 相同
            ...包文件夹共同内容...

          ...包文件夹共同内容.../
            __version__/
              {version}/
                __后顾性兼容__
                  #声明 兼容哪些旧版本
                  #声明 哪些部分 应该 废除
                  #     新用户 使用 新版本 时，可有 两种引入模式: 完全兼容旧版，不完全兼容旧版
                  #为保证 引入 文件 未被窜改，各处引入语句需添加 ((路径名+版本+其间{nname[msuffix]:hname} 或 完全展开后的路径+版本)+被引用的文件的内容)临时变换后的 散列值
                    #完全展开后的路径 是 模块的隐含输入，它绝对如何解释nname[msuffix]
                  #为保证 本文件 的 位置 未被移动，需声明 本文件 完全展开后的路径+版本 临时变换后的 散列值
                __export__
                  #声明 输出哪些 包/模块 及 版本，只有 选中的，才是 可见的
                __fork__
                    # fork-branch #声明 继承 别的包 的 哪些版本的实现
                __abi_decl__
                    # see:[API_ABI]
                __api_decl__
                  #re-impl-API #声明 实现了 哪些 别的包+版本 的 哪些 API

                  #声明 本包 API #输出 本包/本模块 的 哪些 对象
                    # see:[API_ABI]
                __module__.{ext} # 本包作为 模块
                __main__.{ext} # 本包作为 主模块
            __pspace__/ :: 受控空间
            __cspace__/ :: 受控空间
            __ospace__/ :: 开放空间
            __alias__/
              {alias} := {路径名}
                #set curr pkg, then rhs to 绝对路径名（且是标准的:不含alias/向上后续路径）
                  #acyclic 防循环

      引用 他包 的 本包内的 代码/本地命名:
        {他包 前缀}/{他包-nname}[{msuffix}]
          #开放空间 搜索 __ospace__/
        {他包 路径}/{他包 子包名/子模块名}
          #非开放空间 搜索 __cspace__/
        #不存在 全局命名，如果有，那 只能 直接嵌入 hname，只能是 机器 理解，对于 人 来说 可读性 差
        路径名 格式:
          # qname，qual_name, qualified-name
          # regex".*:" ==>> 开放空间 #__ospace__/
          # regex".*[.]" ==>> 受控空间 #__cspace__/
          # regex".*\]" ==>> 长名包
          # regex".*\w\>(?![\[\]])" ==>> 短名包
          #
          路径名 = 绝对路径名 | 相对路径名
            绝对路径名 = ///:{开放空间后续路径}

            许空相对路径名 #许空
              = 相对路径名
              | "" #空
            相对路径名 #非空
              # 独立 或 在 长名包/短名包 之后
              = .{受控空间后续路径} #『.』当下的最近先辈__cspace__
              | :{开放空间后续路径} #『:』当下的最近先辈__ospace__

            受控空间后续路径 #许空
              # 不独立 且 在 受控空间 之后，而 受控空间 必然 从属于 包（长名包/短名包）
              = 向上后续路径
              #受控 向下
              | {cname}{许空相对路径名} #『cname』当下的短名子包
              ##特殊:结束，解释别名
              | "" #空
              | ${alias}{许空相对路径名}
                #在指定位置的别名
              | $?{alias}{许空相对路径名}
                #在指定位置的向上搜索别名

            开放空间后续路径 #非空
              # 不独立 且 在 开放空间 之后
              = 向上后续路径
              #开放 向下
              | [{nname}[{msuffix}]]{许空相对路径名}
              | [[[{hname}]]]{许空相对路径名} # 上面的展开式 # 机器交换用 全局极长唯一命名
                #hname 与 cname 在不同 命名空间，哪怕 值相等 也不 发生 碰撞
                #但 {cname}/ pkg(__module__.{ext}, __main__.{ext}) 和 {cname}.{ext} module 发生 碰撞？

            向上后续路径 #非空
              #向上
              = {相对路径名}
              | ?{cname}{许空相对路径名} #『?cname』按名搜索当下的最近先辈__cspace__
              | ?[{nname}[{msuffix}]]{许空相对路径名} #『?[nname[msuffix]]』代码所在包 向上搜索 先辈__imports__/，以得到 最近 符合 该 略称 的 hname，在于 目标路径上 向上搜索 该hname
                ###bug!!! 中途跳过的先辈 再版可能 提前 截胡 nname[msuffix]!
                ### 所有 nname[msuffix] 只能在 最近的 长名包(短名包 没有 __imports__/) 里 搜索！不能fallback到更上的先辈 # 或 显式指出 具体向上跳过几个 开放空间/受控空间
              | ?[[["{hname}"]]]{许空相对路径名} # 上面的展开式



    ====
    初始化函数 分割:
      + 检查输入是否符合 前置条件 （可能 异常）
      + 构建数据成员的临时副本（不该 出错，或者 异常 作为 前置条件 的一部分？）
        # 分割的意义何在？在于减少 动态检查，这里的初始化 跳过前置条件检查，而将它们的这些前置条件 添加到 上面的 本类的前置条件，合并精简
      + 检查 类类型不变量（不该 出错，或者 异常 作为 前置条件 的一部分？）
      + 移动赋值给数据成员（无错）
    =====
    xbool = true|false|wait|err
      xbool-推导
        * 有限步
          不相容-既真且假
          无关-不真不假
        * 不停机/不收敛/发散
          计算未结束-可能真可能假
      wait={true,false}0b11/待确定/计算中/并行态/偏序相等{<=,>=}
        整数素性判定-快速测试 未成功
        连分数比较/带误差浮点数比较
          无穷长连分数 相等时 无法判定
          浮点数 误差范围重叠，也无法比较
        实现依赖 的 结果: 见上面 两相等字符串常量地址是否相等？sizeof(int)==sizeof(long)？既真且假，并行态
      true={true}0b10/偏序大于{>=,!<=}
      false={false}0b01/偏序小于{!>=,<=}
      err={}0b00/出错/未定义/输入在定义域外/前置条件不成立/算法逻辑出错/偏序无关{!>=,!<=}
        除零
        整数素性判定-输入 非整数 或 0,+1,-1

    ====
    多对象约束:
      see:[concept_const__storage_const__recur_const]
        obj-concept-value = obj-name + stmt-label = value-of-the-named-obj-just-before-the-stmt-label
      其实可想象有一个虚拟对象，以这些对象为成员
      我们使用 构造函数 建立 不变式
        我们使用 检查函数 建立 约束
      我们使用 成员函数 进行修改 维持 不变式
        我们使用 相关修改函数 维持 约束
      局部破坏性修改 是 允许的，只是在 返回 之前 必需 重建约束
        而且 不允许 递归调用 外部函数（那些仍以为 约束 成立的函数/闭包/引用）
          或 采用 一次性全体批量更新策略，避免 非全体的就地修改。可简单实现 不改动or成功，避免 不确定的中间状态。
            但还是有毛病: 一个对象 可存在与 多个约束中
            上面 只考虑 维持当前的输入约束，却未考虑到 其他 不可见的外部约束
            内存空间存储的值===内存地址+时刻点===概念上的值===约束中的值
            所以 不是 多对象约束，而是 多对象的值的约束
    ====vs class/data invariants
    #conceptual property/attr
    #decl/build-up opaque-condition using opaque-condition-constructor via postcondition/class-invariants #check-func/class-constructor
    每一个函数 都该有 几个版本:
      调用者 静态证明 前置条件(比如 动态检查建立静态证明)
      调用者 不想静态证明 前置条件（特别是 混合调用 接口相同仅前置条件不同的 函数（template内部））(实现==动态检查以建立前置条件静态证明或抛出异常+转发 调用 前一版本)
      被调用函数 静态证明 后置条件
      被调用函数 不想静态证明 后置条件(抽象类的虚函数 需要 用户提供 实现，某些情形下，为了 减少用户负担，可免除 用户 后置条件 的 静态证明，而统一集中在 公开的包装函数。公开的包装函数=转发调用私有的虚函数+动态检查以建立后置条件静态证明或抛出异常)
    前置条件 分层: 基本的带明确异常的，保证无异常的；产生不同后置条件的（比如 增强后置条件）
      后置条件 反推 前置条件: 等价于 逆否命题，但 正向表达 更自然（相比于 开头not）
        [后置条件]->[前置条件]
        [前置条件]<<--[后置条件]
        [not 前置条件]->[not 后置条件]
    pre-post-condition:
      [precondition] -> [postcondition]
      ==
      [common-AND-precondition][...] -> [common-AND-postcondition][...]
        * [branch-precondition] -> [branch-postcondition]
        * [branch-precondition] -> [branch-postcondition]
        * [branch-precondition][...] -> [branch-postcondition][...]
          * [branch-precondition] -> [branch-postcondition]
          * [branch-precondition] -> [branch-postcondition]
    ====
    外挂接口的C++实现:
      // not good below, I shift to use data-member instead of iherit
      template<template m> class Monad : Functor<m>{
        template<typename i, typename o> m<o> operator >>=(m<i>&, std::function<o, i>&);
        template<typename o> m<o> return_(o&);
        private:
          virtual ...impl<m,i,o>...
      };




    [type_erase][physic_sort]
    type erase: reduce to physic_sort: ABI: aligment/size_of/copy/move/del are all the same
      java ref/builtin-types are have diff physic_sort, so type-erase-generic not support unbox type，i.e. the param for generic (typename) has type constraints too, that is physic_sort
    type param role: label-only, data(view, immutable, uninit, init, init_or_uninit_并行（禁止读写/构造/析构）..., impl whole alias)
      how role to cooperate with tag?
        tag: e.g. const in C++
        template: e.g. char* <==> ptr<char>
        what role of char for ptr<char>?
          <<== what relationship about ptr<char> and ptr<const char>?
            单向隐式就地转换(仅静态类型声明更改，无任何动态动作)
            physic_sort are the same
      Functor newtype : fmap <==> static_cast
    IO <=: MemberAssign <=: MemoryWasted/Consume <=: Monad
    IO <=: DateTime/Abs-Clock <=: TimeSpan <=: TimeWasted/Consume <=: Monad
    IO <=: GlobalVarsAccess <=: GlobalImmutableVarsAccess <=: Monad
    ===
    ref+DAG-proof
      a.x := b
      require proof: [acycle a b] =[def]= [b != a][not b-*->a]
      比如: DLL = doubly-linked-list
        建立 类不变式:
          prev -[shared_ref]-> next
          prev <-[weak_ref]- next
          [acycle prev next]
          [[DLL.head a][DLL.head b][a != b] -->> [acycle a b]]
            注意: 此处 引用 所有其他已存在的 链表 共同参与 此约束的构建
              let a=this. any b <- DLL: [[DLL.head a][DLL.head b][a != b] -->> [acycle a b][acycle b a]]
        这样一来，就可以 实现:
          链表 切割、截取、串联、插入
    ===
    lazy_ref = ???
    top_ref = shared_ptr4top_owener
      shared_ptr -> block{.shared_count, .weak_count, raw_ptr, destruct_free_mem_func}
    sub_ref = {shared_ptr4top_owener, raw_ptr4this_data}
      sub_ref.x ==>> shared_ptr4top_owener not change, raw_ptr4this_data change

    shared_ref = top_ref | sub_ref
    inner subdata impl type = boxed-top_ref | boxed-sub_ref | unboxed-local_member_room | unboxed-raw_ptr (as-if unboxed what the raw_ptr ref to)

    data cycle prevent? #-free
      #copy-on-write?
      immutable nonlazy data property := any ...
        #part construction before whole construction
      mutable or lazy data property :=
        #part construction may not before whole construction
        | weak_ref
        | in_use_ref/captive_ref/scoped_ref/local_ref/active_ref/survival_ref  #可配合 shared_ref/unique_ptr，但这里unique_ptr的实现 更复杂，类似shared_ptr，只是共享计数的值只能为1，故可省略，不能支持weak_ref？但可支持更弱版的weak_weak_ref，不能取出shared_ptr/in_use_ref，但能检测是否还存在，比较是否相等，散列，甚至大小？，需要weak_weak_count?（两版本，有/无）, in_use_count (无需shared_count，weak_count)
          #like weak_ref, use count, not share ownership
          #but weak_ref can point to nullptr
          #     in_use_ref assume 'data in use' like usage of raw_ptr to local/stack/call-frame var
          # in_use_ref neednot detect nullptr when dereference
          # when shared_ptr decide to delete data, and found in_use_ref exist, abort()
          # save src location(shared_ptr->mk in_use_ref) info to show at abort()
          #     how to generalize this src info access idea?
          #     see:[how_to_access_src_info]
          # automatic/stack_frame unboxed obj --> in_use_ref/weak_weak_ref no shared_ref hence no weak_ref
        | raw_ptr to static-obj
          #到底是 变量的类型 本身 只能用于 定义 静态变量
          #还是 raw_ptr 的约束，只能 指向 静态变量？
          #泛化: 仅本线程可用的类型，raw_ptr to thread_locals
          #泛化: 同时定义帧？线性定义栈？生存期覆盖？
        | change only to spec-branch (e g. nullptr ==>> FIFO-doubly-list(backward using weak_ref, head in, tail out)) ... type-dec-tree-disjoint-branch but can init with anything???
          #init always ok
          #cycle occur only at member/field/property/attr [any-depth] assigment
          #
        | ???constraints on lazy
          #global-data-flow-check?
          #     every func: input, output, nonlocals/globals, which var (whole or part?) put into which var tree?
        | type-strictly-decrease-for-same-type-constructor-in-tree{edge=non-weak_ref}
          ==>> all datatype complete, not only forward decl # or using forbidden set? 外部约束-针对 不透明/未声明 的那部分数据成员
            ==>> no open-inherit #开放式继承 成员数据无限可能
            ==>> no func/lambda #函数的实现 引用静态变量 绑定局部变量，无限可能
              #函数 都是静态变量，只是绑定的数据变量 不同，函数允许 循环引用（用于 递归）（反正 所有 函数 只有 在程序结束时 才析构）
              ==>> 仅用于定义静态变量的类型 不需要 计数共享，允许 循环引用，直接用 raw_ptr（也不用负责其析构）
                init order: using var member or only as-if-uninit-var-ref
                静态类型 分两个阶段: 全局变量初始化 完毕 与 未完毕 #甚至 具体到 某个 静态变量的某个变量 初始化 完成
                  析构则是反转这些阶段
                ==>> [循环引用] 同批次构析多对象循环引用
                  //同批次，同年，同时构造同时析构（类似 同一结构体的 数据成员）
                  //各对象 不负责 析构 循环引用的对象，在 构造期 及 析构期 不得 解引用。
                  //？？<==> 隐参数 批次帧引用，+lazy 数据成员 获取
                ==>> 声明 数据类型时，必须 声明 该类 如何 处理 循环引用 的。（避免~如何避免~符合 何种 协议？，允许~如何实现-符合 何种 协议？）
            ==>> no sub_ref #owner is untyped
            ==>> if lazy: global? binding? forbidden set as template param ...


    call-frame, yield-stmt-position, func-impl-friend(known goto/yield-label, yield-output-type(cased by yield-position))
      "yield from" ==>> frames
    局部约束增强 vs 输出约束更改 vs 独占约束更改（如:inplace-new）
      声明于各个分支各自初始化
    约束 vs 模版参数:
      mx_mul(lhs, rhs)
      mx_mul<R, M, C>(lhs<R,M>, rhs<M,C>) -> mx<R,C>
        许多函数，虽然 可以 调用 free 以避免 代码爆炸，但 很难 用作 脚本/C-API/虚函数
      mx_mul(lhs, rhs){lhs.num_cols==rhs.num_rows} -> mx{mx.num_rows==lhs.num_rows, mx.num_cols==rhs.num_cols}
    hs::
      datatype 的 类型 与 值: 值构造器 是 有限的，受控
      Type 的 类构造器 是 无限的，开放
      受控:则 穷举遍历 case ... of
      开放:则 单独 实例化 + 类型推导 自动匹配: 接口与实现: class ~ instance
        vs C++动态多态: 各子类 实现 虚函数
        vs C++静态多态: 各特化模版 匹配不同 类构造器
        ===回想起来:我的Earlay?解析器 的 实现: 定义 接口，添加 新数据 到 接口 名下，监听器 将其 监听的接口名下的 新数据引起的 新组合 发送到 执行器（先送到 检查器，以确定 与 已存在的数据是否相容）
          其实 开放式 定义 也可 以此，先添加 前瞻性声明（用于 循环定义），再添加 定义体；后面 是 依赖之前 定义 的 定义。
          组合性接口:成员数据 正交 直积空间，全部有效 存在，并不需要另行声明
          关联性接口: 接口+实现（多种可能，所以需要人为干预，命名区分防碰撞）
            = 开放性接口 | 受控性接口
          开放性接口 关联一个 只增 序列/集合 以包含 不断添加的 实现
            如何处理这些 实现？什么时候处理？
              注册 监听器 检查器 执行器
          受控性接口 关联一个 固定 序列/集合
            ？一次性 完成 初始化？
              或 要求 在 结束处理（编译）前 必须 有 一个 封装 信号 表示 完成 初始化
            别的执行器 可判断 是否 已声明 该接口（存在性）？是否 完成 定义/初始化？如果 完整，则 启用 执行器 遍历/穷举/归纳处理。
          开放性接口 的 实现 在哪存取？
            很多关系 都指望用户 添加
            如: hs-class-instance
            这里 牵涉到 很多实体:
              实现者/用户/作者
              关系实例名=关系类名+关系实例参数
            这里 还牵涉到 模糊搜索:
              #用户 为避免 重新发明轮子，必然 需要 遍历搜索
              #在哪找？怎么用 程序 快速找？tag 特性 过滤？
              #数据库？
          提供多个 可替换的 配置文件（夹） 作为 代码的一部分，这样 编译器 指令 更有 含义（全都 指向 代码树，加上 编译命令 本身，再无其他不可见的额外信息）。
              see:[必然偶然]:[配置偶然信息]

  obj vs val
    obj ~ 析构/资源管理/IO
      decl has swap? copy-constructor? ==>> auto has assigment
      #move-constructor always auto
      iterator #st mutable/IO
    val ~ immutable
      StateMonad
      builtin data type #unboxed immutable value, no address
  decl-qual-kwarg + packed-args-kwargs to support foward call
    外挂接口 也是 kw:
      sort :: Ord a => [a] -> [a]
      <==> sort<a>(vector<a>&, *(Ord<a>)=...)
  decl-qual-member to avoid multi-inherit collision
  反转实现依赖:
    Functor a => Monad a
    Functor a <<== Monad a
      在缺少 Functor 的情形下，定义 Monad，则反过来 自动定义 Functor，但这样一来，Functor a 可能就有多个实现！
      其实若非自动生成，则 2 kw 参数 各自取 数据成员（相当于 取出依赖），也可能 不一致

  named value
    type is compile time value
    type-constructor is qual-named value
    when no address, qname is identity

  idea?
    unque impl
      e.g.
        forward decl
        hs::infix
        parameterized

    multi-impl
      e.g.
        abstract class / interface ~ derived classes
        type ~ objs
        template ~ specializations
        hs::class ~ instance
      naming?
        named
        parameterized
        ...
  idea 4 c++?
    another inherit hierarchy: just used as tag to classify subclass and offer default-value and requirements(abstract api/interface)
    the only problem of c++ inherit hierarchy is that multi-inherit require virtual baseclass, since there is a subobject has exactly type of the baseclass.
    the new hierarchy has no such subobject
  idea 4 c++?
    tag:
      exception specialization:
        void f() throw (A,B);
        void f() throw ();
        void f() noexcept;
      ....why r() not decl I'm to rethrow?
        int r(){
            throw; //rethrow
        }
        int g(){
          try{
          }
          catch(...){
            r(); //rethrow
            throw; //rethrow
          }
        }
      decl 4 func: long-rethrow, long-return, long-break, long-continue, long-goto
        // long-goto === long_jump
        func as subroutine/macro/snippet
      decl 4 func: O(NlogN) time/space
      decl 4 func: exception guarantee
        基本:所有 对象 状态 有效，可析构
        强保证:若 异常，则 不修改参数
          无副作用？(显然 不可能没有，因为 有一个 新异常对象)
        无异常保证

  idea 4 c++?
    宏输出+宏输入#包管理？
    头文件 定义的宏/输入的宏 并不 自动输出
    只有 头文件声明输出的宏，才是 外部可输入的
    包含头文件 并不自动 输入其输出的宏，只有 显式声明 输入 才行
    头文件 保护: 避免 二次包含 理应是 默认设置
  idea 4 c++?
    框架宏
      其命名 必需 依序包含 未匹配括号
    语句组/透明语句组（stmt_group vs scope） 只是一个 透明的组，并非 真正的 作用域
      可用作 框架宏 的 参数
      ？？？可用作 解包用 左值 声明:
        {int x, int y} = z
        {auto x, int y} = z
        auto {x, y} = z
      用作 被注释的 代码片段
        注释领头 解释目的，代码片段 随后缩进
        //反过来的情形也有
        //单行语句/语句组 领头，多行注释 随后缩进
  idea 4 c++?
    break 退出最近作用域，而非仅是loop/switch
    break + for/while/do/loop/switch/label...
  idea 4 c++?
    hs::newtype
    C++::class 添加 __this_type__
    这样，当用newtype定义新类型时，operator/成员函数 __this_type__ 自动 转向 新类型
    ？？？但还有很多问题：
      类继承关系？
      模版特化-类型参数角色问题#role

  idea 4 c++?
    all static (global/thread_local/static-member/static-local/...) as non-static-member in a virtual class
    we can inherit this class then overload some member, and pass its instance into func-call as implicit-param

  idea from c++.cin<< ?
    见上面 自定义 静态 __getattr__
    设计 新语法:
      x..f(...) ..g(..)
        #as-if return x
        <==>
          x.f(...);
          x.g(...);
      or:
        with x:
          .f(...);
          .g(...);

  idea 4 c++?
    def:[concept_const__storage_const__recur_const]
      #16.2.9.2 Physical and Logical Constness
    约束: [logical-const] vs [physical-const] vs both vs recur-both
      * [logical-const]
        允许(私有)实际成员修改，但(深度)公开概念成员 不变
        c++::mutable
        synchronized/parallelism obj .lock()
        cache to save computation for queries
        std::string::c_str()
          #在必要时，需附加NUL字符#不允许&s[0]
          #与vector::data()不同#允许&v[0]
      * [physical-const]
        不允许(任何)实际成员修改，但(任何)概念成员 可变（本身vs深度引用）
        只读存储器
      * both
      * recur-both
        ...
      强联系（拥有） vs 弱联系（索引）
        强联系（拥有）vs 直接成员
        弱联系（索引）vs 间接成员
      key@mapping
        绑定与否
        key 不变，但 mapping 本身可变
        ptr作为key，默认绑定内存空间，故指向的对象 有默认定义
        其他key基本 无法绑定特定mapping，所以 并无明确的 指向对象
  idea 4 c++?
    约束: [non-freeable/deletable-ptr]
      #like "const"
      not allow "free(p)"/"delete p"/"delete[] p"
      deletable_ptr can implicitly convert to nondeletable_ptr
      get address "&x" always return nondeletable_ptr
      deletable_ptr of derived_class cannot convert to deletable_ptr of baseclass without virtual destructor
    idea 4 c++?
      标签
      member alias with diff tag
        distinguish use purpose
      比如:大小/相等比较次序(+部分数据成员无关)
        声明 某些数据成员 参与或不参与 某些活动
        比较、复制/赋值/移动/交换、垃圾回收/垃圾收集
        可见性控制:public/...
        extern/static/inline/constexpr
      比如:const/mutable //c++ keyword
      比如:override/final/virtual //c++ contextual keyword
      比如:无用参数
        see:[[无用参数]]
    idea 4 c++?
      tag droppable/addable
      some kinds of tagged type can convert to non-tagged version
        noexcept
      some kinds of tagged type can convert from non-tagged version
        const
      tag:
        mutable #for cache/lock/... impl detail, not affect conceptual value
        uninitialized #for buffer in struct, non-init after constructor


  idea 4 c++?
    allow only loop/tail-recur/tail-mutual-recur
      to avoid call-stackoverflow
  idea 4 hs?
    f :: forall a,b,c => (a -> b) -> (c -> b)
    f @[a] @[b] ...
    a, b 的 次序问题:
      用户 显式 指定，则 无端 多出许多 本该一致 的 不兼容类型
      命名kwargs，也有类似问题，而 标识名 的 选择 也是个 问题
      默认 由系统 按某个规则 排序，则 一旦 类型 改变 修改实多
      其实 可用 seq<uint> 作为 kwargs, 自动生成
    f :: forall {a,0.0},{b,0.1,1.1},{c,1.0} => (a -> b) -> (c -> b)
    f @[0.1=xxx]
  idea 4 hs?
    def:[类型增删变体]
    正体/范体->变体
    datatype ==>> subdatatype
      比如：减少并联分支，成员类型 改成 子类型
    datatype ==>> superdatatype
      比如：增加并联分支，成员类型 改成 泛类型
    def variant xxx:
      on (T a b)::constructor = delete; #删
      on (T a b) += ... | ... ...; #增
      on (T a b)::constructor@[idx/attr] = ... #成员数据类型 的 增删

    子类型 当作 约束 用途:
      nonempty_list
        datatype list a = empty_list | cons a (list a)
        subdatatype nonempty_list a <=: list a = cons a (list a)

      partial_ordering
        datatype partial_ordering = LT | EQ | GT | NA
        subdatatype total_ordering <=: partial_ordering = LT | EQ | GT

      datatype bit = O | I
      subdatatype bitO <=: bit = O
      datatype integer = zero | nonzero_integer {sign :: bit, little_endian_tail_bits :: list bit}
      subdatatype natural_integer <=: integer = zero | nonzero_integer {sign :: bitO, little_endian_tail_bits :: list bit}
    泛类型 当作 增强 用途:
      抽象语法树->具象语法树
      无糖规范官话具象语法树->加语法糖的方言具象语法树
      旧版本语法树->后顾性兼容的增强型新版本语法树

  idea from c++.__FILE__/__LINE__/__FUNC__ ?
    how to access src info?
    def:[how_to_access_src_info]
      caller env detect
      caller env forwarding
  idea from py?
    混合使用，统一使用协议
    +=
      就地修改？mutable
      构建新值？immutable
    统一:
      返回 带新值的对象 #不确定是 新对象 还是 旧对象
      不再使用旧对象 #因为 不确定是 带新值 还是 带旧值


  构造器-匹配-区别-私有
    公开构造器
      检查约束，抛出异常
      变换参数，调用 私有构造器
    私有构造器===在线构造器
      ==>> 公开匹配器
      ==>> 别名匹配器
    标准构造器
      用于 == 测试: 每个等价类 产生 结构相同的 标准构造器树
    读写构造器
      即可对 参数进行相当程度的 标准化
      也必须 调用 公开构造器 以 检查约束
  静态多态/模版匹配 vs 动态多态/hs-class-instance:
    静态多态/模版匹配:
      可用 静态约束 区分 特化模版
    动态多态/hs-class-instance:
      要么 不使用 约束，仅靠 类型构造器
      要么 约束区分 也要 作为 参数 输入，静态 或 动态

  idea 4 c++?
    from 字面常量
    近字面常量(全局静态只读 带 默认析构函数，即 什么也不做)
      特别是 指向近字面常量的指针 也可成为 近字面常量的数据成员
        支持 逻辑上的 循环引用
    像是 异常，可复制性+noexcept，通常 使用 避免 使用 动态内存
        struct My_error2 : std::runtime_error {
          const char∗ what() const noexcept { return "My_error2"; }
        };
  idea 4 c++?
    copy/move *  constructor/assigment
    copy assigment
      手写 太蠢
      可以 声明 哪些 成员不改(e.g. lock, container's allocator)，哪些直接 赋值 无异常(builtin-type, literal-type, POD)，哪些 要先 复制（有异常） 再统一批量swap（无异常）
  idea 4 c++?
    如何 将 重要数据及数据处理状态 同步更新到 持久性存储器？以便 掉电/异常 后 恢复（继续/回滚/...）？
    ?transaction? commit, continue, rollback
    ?permanent?

  idea 4 c++?
      def:[辅助函数与关联辅助开放空间]
      辅助函数 并不需要 friend 权限，没有 必要 成为 成员函数，但是 十分有用，也方便 遍历浏览，可不断添加，需要 概念上的支持，在 类空间 之外，在 命名空间 之内，一个中间层开放空间。需要 语法 支持，类似 成员函数 的 调用方式。
  idea 4 c++?
    pg395[410/1366] #Argument-Dependent Lookup(ADL)
      // 感觉不行！
      // 应该 提供一个注册用的命名空间，就像hs::class，用户 重载的函数namespace mine{f(){}} 自己用 namespace xxx_interface{using mine::f;} 注册进去
      // 模版函数 调用时: xxx_interface::f(...) 或 using namespace xxx_interface; (重载 运算符)
  idea 4 c++?
    『异常保证』
      『无异常保证』无异常 或 死（不返回）
      『强异常保证』异常 则 无修改
      『基本异常保证』异常 则 所有对象 可正常 析构
          //僵尸状态 伪合法状态
          //def:[构析不对称-僵尸状态)
          //构造函数 :: 未初始化 -> 合法状态
          //成员函数 :: 合法状态 -> 合法状态
          //移动构造/移动赋值-被动宾语 :: 合法状态 -> 僵尸状态
          //伪合法状态 = 合法状态 | 僵尸状态
          //析构函数 :: 伪合法状态 -> 未初始化
          //构造函数 析构函数 不对称
    『强-异常保证』的 修改多对象 的 实现: 临时变量+修改+批量swap
    问题在于 重复！
    事实上，修改 部分 只需要 使用『基本-异常保证』能正常析构即可。
      全用 『强-』会导致 大量 临时变量 在 多个 层次 出现，副本 浪费 空间，复制 浪费 时间
    解决方案:
      声明 某个 语句组 只需 『基本-』
      但这 需要 类似 const/non-const 成员函数 一样，区分出 两个版本，容易 出错（不一致）
  idea 4 c++?
    pass-by-value/reference
    template<typename T>
    struct PreferPassBy
    {
      constexpr static bool prefer_pass_by_reference_over_pass_by_value = true;
    };
    template<bool b, typename T, typename S>
    struct Choose;
    template<typename T, typename S>
    struct Choose<true, T, S> { using Type = T; };
    template<typename T, typename S>
    struct Choose<false, T, S> { using Type = S; };

    template<typename T>
    using PassBy = typename Choose<PreferPassBy<T>::prefer_pass_by_reference_over_pass_by_value, (const T&), T>::Type;
      def:[自动选择传值或传引用的元编程]
      see:[类型拆包]

    template<typename T>
    class X
    {
      void add(PassBy<T>);
    };

  idea 4 c++?
    def:[外部虚函数表的开放性]
    面向数据hs互斥并联 vs 面向对象c++虚函数
      面向数据:
        优:应用灵活（包括 case...of/typeid()+dynamic_cast）
          特别是 跨分支/跨子类 应用: 小于
        缺:封闭空间，分支固化
      面向对象:
        缺:应用预设（虚函数），而且 止于 自身，不能 跨子类
        优:开放空间，子类 可 自由添加
    通常 类作者 不可能 预见 将来 所有应用，虚函数 不可能 涵盖所有应用。
    如果 数据 增加 并联分支，所有 应用 都要 修改
    解决方案:
      开放 虚函数！
      某个 应用函数 可以 声明 需要 那个基类 的 哪些 外部虚函数。
      一旦 使用 此应用函数，则要求 所有 具象子类 都要 实现 这些 外部虚函数。
      但 类作者 没空，所以 由第三方来负责实现。
      外部虚函数 只有 最低权限，即 只能 接触 基类的公开成员。
        但 类 的 外部虚函数表 是开放的，直到 链接 成功 组装成 可执行文件后，外部虚函数表 才 算是 确定下来。
      外挂接口内联版？至于数据，则相当于 各个并联分支独立成为一个类型
        see:[类型增删变体]
  idea 4 c++?
    protected member: derived_class T can inly access baseclass protected member when baseclass obj is a subobj of T(or derived_class of T)
  idea 4 c++?
    operator new 为何没有 对齐 信息 输入？
    operator delete[] 为何可以有 长度 信息 输入？
      void∗ operator new(siz e_t);
      void operator delete(void∗, siz e_t);
      void∗ operator new[](siz e_t);
      void operator delete[](void∗, siz e_t);
  idea 4 c++?
    def:[覆盖源自数据成员的虚函数]
      private baseclass is just an impl detail, why can override private baseclass virtual function but cannot override data member virtual function? we extend the data member with other siblings and filling pure virtual function to make it concrete class from abstract class.
      better, we can have many non-ambiguous data members with diff override instead of at most one private baseclass.
      override ==>> this.this is the enclosing class to access extended data.
        java inner class???
            c++lambda-expr [this](){}
            引用 分类:
              引用 命名变量（或 整个 调用栈帧（含self））#py
              引用 对象#传引用:[&](){}
              引用 当前值#传值:[=](){}
        diff: the derived_class bing to the only one data member, not used another where, i.e. [exists xxx: this is this.this.xxx][this - this.this === constexpr]
          #当然，也可 模版化，数据成员名 作为 参数，该成员 的 类型 就是 正在 定义的 类。
  idea 4 c++?
    外挂构造函数===外部委托构造函数
      为何？
        type_traits 可以 解决很多 成员函数（包括 析构函数） 包装，唯独 构造函数 例外
        要使用 type_traits 作为需求说明 将受到极大限制
      实现:
        X~f(args...){
          alignas(X) buffer[sizeof(X)]; //uninitialized
          ::new(buffer) X(args...);
          X& x = *static_cast<X*>(buffer)
        }
        其实，使用 继承 也没差
        struct Y:public X{
          Y(...);
        };
        Y y;
        X& x = y;
    分支构造:
      to-def X x where
        if ...:
          X x;
        else:
          X x;
    空枚举类型:
      enum clasa uninitialized{};
      uninitialized* vs void* vs char* vs uint8_t*

  idea 4 c++?
    from others/book/The C++ Programming Language(4ed)(2013).txt
        * 模版的环境敏感型标识绑定，独立开发分离编译的两个库可能不相容，见下面 pg749[764/1366]，既然 依赖环境，那么 instantiation_point(类似goto标签，但 允许 存在于 命名空间 中)也当作为 模版参数
  idea 4 c++?
    外挂接口(重复 空基类带析构函数)+无用参数(参数化标识名)
        see:[参数化标识名]
        see:[[无用参数]]
      ？empty base optimization: 外挂接口+无用参数(参数化标识名)+虚基类？或 重复 空基类(带虚析构函数) 这种情形 究竟如何？
        empty-base optimization
        The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8).
        完全可行！
  idea 4 c++?
      外部注册:traits<category, T>:
        iterator_traits<T> = traits<Iterator, T>;
        allocator_traits<T> = traits<Allocator, T>;
        container_traits<T> = traits<Container, T>
  idea 4 c++?
    c++::std::unordered_map was bad designed!!!
      since Hash must know Pred/Eq, there are need not and should avoid the parameter Pred/Eq
      template<typename Key,
          typename T,
          typename Hash = hash<Key>,
          typename Pred = std::equal_to<Key>,
          typename Allocator = std::allocator<std::pair<const Key, T>>>
      class unordered_map;




TODO:
  my argparser
    see:
      e ../../python3_src/seed/recognize/CmdlinePrefixParser.py
    前缀:
      @选项 #后接一个参数
        @选项前缀-选项负载-选项负载... #复杂选项名 只定义前缀
      { 他命令选项转发 } #选项 需要 复杂的参数，比如 转发给 所依赖的命令
      !子命令
      ?查询
      +打开开关
      -关闭开关
      ？参数？
        #vs py::str-literal::fr''==>>引用变量？字符转义？:
        =单参数 #无需转义 raw_string
        ^=转义单参数 # ^{Uxxxx_xxxx}
        ？变量定义与引用？
          ？定义？
            ？let...in？where？
            %{xxx} =单参数
            %{xxx} %=模版单参数
          ？引用？
            %=模版单参数 vs =单参数
            %,模版单参数 vs ,单参数
            %:模版单参数 vs :单参数
          ？模版单参数？
            %% ==>> %
            %{xxx} ==>> 引用
        ？多参数？
          , <==> 1,
            由外而内
          : <==> 1:
            由内而外
          [ ,参数 ,参数 ...]
            [?][ ,参数 ,参数 ...]
            [?][ 1,参数 1,参数 ...]
            [?][ 1:参数 1:参数 ...]
            #array<?>
          [3 ,参数 :参数 :参数  ,参数 :参数 :参数 ... ]
            [?*3][ ,参数 :参数 :参数  ,参数 :参数 :参数 ... ]
            #matrix<?,3>
            [?*3][ ,参数 1:参数 1:参数  ,参数 1:参数 1:参数 ... ]
            [?*3][ 2:参数 1:参数 1:参数  2:参数 1:参数 1:参数 ... ]
          [3*2 3:参数 1:参数 2:参数 1:参数  2:参数 1:参数 3:参数 1:参数 2:参数 1:参数  2:参数 1:参数 3:参数 1:参数 2:参数 1:参数  2:参数 1:参数 ... ]
            [?*3*2][ 3:参数 1:参数 2:参数 1:参数  2:参数 1:参数 3:参数 1:参数 2:参数 1:参数  2:参数 1:参数 3:参数 1:参数 2:参数 1:参数  2:参数 1:参数 ... ]
            #tensor<?,3,2>



=====
文本编辑器 我常用到的功能:
  #为何使用vim而不用 文本框式的文本编辑器
  #     当然 集成编辑环境 能提供 类/函数 声明/定义 的 列表 与 定位，但这算是 极其特化的功能
  意外崩溃后数据恢复/自动保存
  同时打开多个文件，快速切换
  词组补全，保持缩进，缩进多行#编程 省力
  正则表达式搜索替换（*,#）
  简便的行内定位（0,$,b,e,w,f查找字符,";",","）
  重复操作，设定重复数
  方便快捷的文本操作:复制粘贴删除撤销，行编辑(新建o，合并J，行首插入I行尾附加A...)，可视文本块编辑
  命令行复用，命令行窗口编辑（q:,q/）
  选择字符编码，选择字体优先序列
  语法高亮
  配色方案，字体大小
  查找字符的unicode值，特殊字符输入
  缩进的文本块的自动折叠 #fold

钢琴 邮箱
  from 煎蛋:无聊图 from 网络
  钢琴住了几个妖，邮箱住了几个魔，魑魅魍魉怎么它就这么多


校服-蓝天白云战袍

from 大国重工::第一百五十一章 你去哪我就去哪
  --“这一间，就咱们两个人吗？”--“恐怕没这样的好事吧！”
  调戏-孤男寡女共处一室
  私人空间-人所追求的资源中 独享的时空资源 实是非同一般，大概 比 生存繁衍、交流承传、社会认可（价值/功劳/尊重/地位） 稍差一筹

蟑螂会跳！不能慢慢按，必须拍！

无法压缩的量:
  质能守恒？
  熵
  信息熵
  在 针对给定问题的算法设计 这一领域:
    复杂度
  在 编程语言设计 这一领域:
    源代码长度
    目标代码长度
    运行耗时
    动态内存消耗
    语言支持（编译器/解释器/虚拟机，标准库）
    ---
    更多抽象层 ==>> 目标代码 剧增（模版实例化，内联函数） | 运行耗时 剧增（类型擦除，函数指针/虚函数）|动态内存消耗 剧增（更多动态堆上小对象）
    解决同一问题 ==>> 复杂方案 要么 直接 代码量 大 要么 依赖的库 ...库的实现方案 循环嵌套...，简单方案 要么 耗时间 要么 耗内存

e ../lots/NOTE/novel/史记_note.txt
史记
  ?
    神农氏
    蚩尤
    炎帝
    ...
    帝鸿氏->浑沌
    少皞氏->穷奇
    颛顼(zhuan1xu1)氏->梼杌(tao2wu4)
    缙云氏->饕餮(tao1tie4)
    --
    禹[夏后] 姒氏
    契[商] 子氏
    弃[周] 姬氏
  # [国号]
  少典->1黄帝公孙轩辕[有熊]->
    +玄嚣/青阳->蟜极(蟜jiao3)->3帝喾[高辛](八元)->4帝挚xxx不善->5帝尧放勋[陶唐]->丹朱
    +昌意->2帝颛顼[高阳](八恺)->
      +穷蝉->敬康->句望->桥牛->瞽叟(瞽gu3)->6帝舜重华/虞舜[有虞](十二牧)->商均
      +梼杌
      +鯀(gun)->7帝禹文命[夏后]
        #舜，禹 的 辈分 拉开太快太大！
===============
1: 1 2 4 6 x8
2: 1 3 5 7 x9
3: 2 x4 xx6 8 10 xx12 x14
4: 1 x3 5 x7
  65=(1,8)=(7,4)=5*13=(1,2)*(3,2)=(2*2[+-]1*3,2*3[+-]1*2)
2=1^2+1^2
3=0*4+3
5=1^2+2^2
7=1*4+3
x9=3^2+0^2
11=2*4+3
13=3^2+2^2
x15
17=1^2+4^2
19=4*4+3
x21
23=5*4+3
x25=3^2+4^2=5^2+0^2
x27
29=2^2+5^2

===============
===============
2*3=2+3+1
x*y=x+y+1
x!=1
y=(x+1)/(x-1)
2%(x-1)==0
(x-1)<-{+-1,+-2}
x<-{2,3,0,-1}
{x,y}<-{{3,2},{-1,0}}
===============
50=7^2+1
8=3^2-1
360=19^2-1
x^2+-1
x:x^2:x^2-1,x^2+1
  x^2-1=(x-1)*(x+1)
1:1:0,2
2:4:3,5
3:9:8,10
4:16:15,17
5:25:24,26
6:36:35,37
7:49:48,50
8:64:63,65
9:81:80,82
10:100:99,101
11:121:120,122
12:144:143,145
===============
k个元素
  #k=5
w个j阶谓语动词，每个元素作为每一个谓语动词的每一个位置参数，均有唯一真命题
  #w=2,j=2:生/克
  ---
  再泛化: w个j阶谓语动词，每组任意z个不同元素作为每一个谓语动词的任意z个不同位置参数，均刚好有m个真命题
    #z=1,m=1
k==1+w*j*(j-1)
  ---
  再泛化: k==z+w*C<j>(z)*z!*m*(j-z)
k*w*j/j=k*w个真命题
w个谓语动词之间的关系？
===============
将我摘出(n-1)
3-1=2
5-1=4
9-1=8
50-1=49
---
11-1=10
13-1=12
17-1=16
21-1=20
25-1=24
31-1=30
37-1=36
61-1=60
361-1=360
28-1=27
===============
360=19^2-1=6*60
8=3^2-1=2^3
3^y-1=2^x
(z+2)^y-z^y=w^x
(z+2*k)^y-z^y=w^x
===============
55=sum([1..10])
6441 == sum([1..113]) == sum lcm(1..i) {i<-[1..10]}
    6441=3*19*113
e script/等差数列求和.py
561 == sum [1..33] == sum lcm(1..i) {i<-[1..7]}
21 == sum [1..6] == sum lcm(1..i) {i<-[1..4]}
3 == sum [1..2] == sum lcm(1..i) {i<-[1..2]}
1 == sum [1..1] == sum lcm(1..i) {i<-[1..1]}
===============
view /sdcard/0my_files/tmp/out4py/factor_uint.py.100000_0.out.txt
{11:1,293:1}#3223
  3+2+2+3==10
{11:2,13:1}#1573
  太阴少阳少阴太阳6789频数:{6:1,7:5,8:7,9:3}
    {3:4,11:1}#891==0o1573
    {17:2,19:1}#5491==0x1573
    {3:1,5:1,13:2}#2535==int('1573',12)
    {3:3,5:4}#16875==int('1573',24)
    {3:1,13:1,37:2}#53391==int('1573',36)
    {3:2,5:1,7:1,11:2}#38115== radix_repr2uint__big_endian(32, [1, 5, 7, 3])
    {5:2,13:2,67:1}#283075=25*11323==radix_repr2uint__big_endian(64, [1, 5, 7, 3])
      {13:2,67:1}#11323
{3:1,19:1,113:1}#6441
  6441 == sum([1..113]) == sum lcm(1..i) {i<-[1..10]}
===============
lcm(1..n)=?
lcm(1..1)=1
lcm(1..p^e) | [prime p][uint e][e>0]=lcm(1..p^e-1)*p
lcm(1..n) | otherwise =lcm(1..n-1)
===============
3000=2520+480=2520+420+60=60*(42+7+1)=60*50=60*(55-5)
  lcm(1..9)=lcm(1..10)=5*7*8*9=280*9=2520
  lcm(1..7)=3*4*5*7=420
  lcm(1..5)=lcm(1..6)=3*4*5=60
  ----
  lcm(1..11)=lcm(1..12)=5*7*8*9*11=2520*11=27720
  lcm(1..8)=3*5*7*8=280*3=840
  lcm(1..4)=3*4=12
  lcm(1..3)=2*3=6
  lcm(1..2)=2
  lcm(1..1)=1
  sum lcm(1..i) {i<-[1,3,5,7,9]}=3007
  sum lcm(1..i) {i<-[2,4,6,8,10]}=2+12+60+840+2520=3434
  sum lcm(1..i) {i<-[1..10]}=3007+3434=6441= sum([1..113])
  ----
  4阶群:
    #元素最多4阶
    {a:a^4=1}

    #元素最多2阶
    {a,b:a^2=2=b^2,b*a=a*b}
      # b*a*a*b=b*a^2*b=b*1*b=b^2=1
      # 元素最多2阶==>> (b*a)^2=1
      # ==>> b*a=a*b
  ----
  8阶群:
    #元素最多8阶
    {a:a^8=1}

    #元素最多4阶
    {a,b,c:a^2=c=b^2,c^2=1,b*a=a*b}
    {a,b,c:a^2=c=b^2,c^2=1,b*a=a*b*c}#非可交换群
      # c*a=a*c, c*b=b*c
      # a^s*b^s*c^s, s<-[0..1]
      # (a*b)^2=a*(b*a)*b=a*(a*b*c^?)*b=c^?
      # 4阶元素 有 a,a^3,b,b^3,...
    {a,b:a^4=1=b^2,b*a=a*b}
    {a,b:a^4=1=b^2,b*a=a^3*b}#非可交换群
      # b*a^2=a^2*b
      # a^t*b^s, t<-[0..3],s<-[0..1]
      # (a*b)^2=a*(b*a)*b=a*(a^3*b)*b=1
      # (a^i*b)^2=a^i*(b*a^i)*b=a^i*(a^(3*i)*b)*b=1
      # 4阶元素 只有 a,a^3

    #元素最多2阶
    {a,b,c:a^2=1=b^2=c^2,b*a=a*b,c*a=a*c,c*b=b*c}
      # b*a*a*b=b*a^2*b=b*1*b=b^2=1
      # 元素最多2阶==>> (b*a)^2=1
      # ==>> b*a=a*b
      # a^s*b^s*c^s, s<-[0..1]
  ----
  1->2->3->4->5->1
    1->3->5->2->4->1
      <==> ~ 1->4->2->5->3->1
    5元素 含2个无向大圈
      #五行双圈
      #阴阳五行
  1->2->3->4->5->6->7->1
    1->3->5->7->2->4->6->1
      <==> ~ 1->6->4->2->7->5->3->1
    1->5->2->6->3->7->4->1
      <==> ~ 1->4->7->3->6->2->5->1
    7元素 含3个无向大圈
  m元素 phi(m)个候选有向大圈
    [m>=3]:
      [2 'divs' phi(m)]
        #phi(II p[i]^e[i] {i}) = II (p[i]-1)*p[i]^(e[i]-1) {i} where [e[i]>=1][prime` p[i]][[p[i]=p[j]]-->>[i=j]]
      [gcd(i,m)=1]:
        [2 `divs` gcd(2*i,m)]
        !![m>=3]
        [2*i =/= m]
        [i!=m-i]

        [gcd(m-i,m)=1]
        [phi(m)/2个无向大圈]
          #5|10||8: phi(5|10|8)/2=4/2=2
          #7|14|9|18: phi(7|14|9|18)/2=6/2=3
          #11|22: phi(11|22)/2=10/2=5
          #?: phi(-)/2=14/2=7
          #?: phi(-)/2=22/2=11
      [phi(m)/2=p][prime p][p>=5]:
        [phi(m)=2*p]
        [i>=2]:
          [phi(p^i)=(p-1)*p^(i-1)]
        [phi(p^2)=(p-1)*p>2*p]
        [prime (2*p+1)][m<-{(2*p+1),2*(2*p+1)}]
          #p=5 ==>> m=11|22
          #以下p:尾数1/3/9，各位数之和模3为2
          #     p%10=5 非素数
          #     p%10=7,(2*p+1)%10=5 非素数
          #     p%3=0 非素数
          #     p%3=1,(2*p+1)%3=0 非素数
          #p=11 ==>> m=23|46
          #p=23 ==>> m=47|94
          #p=29 ==>> m=59|118
          #p=41 ==>> m=83|166
          #p=53 ==>> m=107|214
          #p=83 ==>> m=167|334
          #p=89 ==>> m=179|358
          #p=113 ==>> m=227|454
          47->23->11->5->2
          167->83->41
          ...13*443=5759 xxx->2879->1439->719->359->179->89
          see:
            e script/find_2p_plus1_primes.py
            script/find_2p_plus1_primes.py.out.n3.txt.rar
            view /sdcard/0my_files/tmp/out4py/find_2p_plus1_primes.py.out.n1.txt
            view /sdcard/0my_files/tmp/out4py/find_2p_plus1_primes.py.out.n3.txt
            ===
            view ../../python3_src/nn_ns/app/show_factor_uint.py
              #<<== e script/factor_uint.py
            script/factor_uint.py.10000_0.out.txt.rar
            view /sdcard/0my_files/tmp/out4py/factor_uint.py.10000_0.out.txt
      -------
      (2*p+1)型 素数链 是否 必然 终止/有限长？若是，长度 是否有上限？
        考虑 素数链 模k 的情形
      ls<k,i> =[def]= [i,i', i'', ..., i[?]==i]
        where
          i' = (2*i+1) % k
      [prime k][k>=3]:
        !![prime k][k>=3]
        [gcd(2,k)==1]
        [f<k>(i)=(2*i+1)%k 是可逆函数]
        [ls<k,i> 定义了一个等价类/等价划分]
        [ls<k,i>划分下，0的等价类 代表 素数链 有限长]
        [ls<p,2*p+1> ~ ls<p,1> ~ ls<p,0>]
        [(2*p+1)型 素数链 必然 终止/有限长]
          由于[ls<k,k-1> = [k-1, k-1]]
          故而 不存在 0的等价类 涵盖所有，因此，是否 存在 长度上限 待研究。


      ls<3,0> = [0, 1, 0]
      ls<3,2> = [2, 2]
      ls<5,0> = [0, 1, 3, 2, 0]
      ls<5,4> = [4, 4]
      ls<k,k-1> = [k-1, k-1]
      ls<7,0> = [0, 1, 3, 0]
      ls<7,2> = [2, 5, 4, 2]
      ls<7,6> = [6, 6]
      ls<11,0> = [0, 1, 3, 7, 4, 9, 8, 6, 2, 5, 0]
      ls<11,10> = [10, 10]
      ls<13,0> = [0, 1, 3, 7, 2, 5, 11, 10, 8, 4, 9, 6, 0]
      ls<13,12> = [12, 12]
      ls<17,0> = [0, 1, 3, 7, 15, 14, 12, 8, 0]
      ls<17,2> = [2, 5, 11, 6, 13, 10, 4, 9, 2]
      ls<17,16> = [16, 16]
      ls<19,0> = [0, 1, 3, 7, 15, 12, 6, 13, 8, 17, 16, 14, 10, 2, 5, 11, 4, 9, 0]
      ls<19,18> = [18, 18]
      ls<23,0> = [0, 1, 3, 7, 15, 8, 17, 12, 2, 5, 11, 0]
      ls<23,4> = [4, 9, 19, 16, 10, 21, 20, 18, 14, 6, 13, 4]
      ls<23,22> = [22, 22]
      7,17,23 有何共同点？

===============
存储列表 种类:
  #保存 初始化参数（以备重新生成数据+理解数据含义）
  #保存 暂停状态（以备继续生成数据）#只有当此状态简洁明了，数据量远小于目标数据列表时才有应用价值
      * 暂停状态 大于等于 已求得的数据列表
        平凡素数筛
      * 暂停状态 缓慢增长
        无限长连分数表达的持续运算:
          圆周率
          整系数一元多项式的根
      * 暂停状态 为 已求得的数据列表的最后几项（固定有限）
        递推运算:
          伯努利数列
          斐波那契数列
  #文件只增不删:列表vs树:只读数据树的根-保存在文件末尾，新根不覆盖旧根。（类似PDF文件格式）
  * 完全读取加载到内存，配合 简单运算解压(可以是累积型运算)（变换压缩以减少存储空间，简单以减少运算时间及解压期临时占用的内存空间）
    针对特定数据的压缩方法（如：素数表-coprime_le5-prime_coprime_le5_order_diff__minus1），不够通用，一文件一格式一专用解压加载程序，十分细琐，恐难推广
    #文件头:本文件的格式具体参数
  * 借用外部通用工具搜索，明码ascii/utf8，以行为单位，关键数据加前后缀分割成为文件中的唯一
    #文件头:本文件的格式具体参数
  * 随机读取文件，在文件内部使用某种数组（减少占用内存空间）
    #文件头:本文件的格式具体参数
    * 单文件:
        * 不含文件偏移地址的定长数据对象的数组
        * 数组长度+含文件偏移地址的定长数据对象的数组+变长数据对象的无序聚合
    * 双文件:
        + 含文件偏移地址的定长数据对象的数组
        + 变长数据对象的无序聚合
  * 随机读取文件+借用外部通用工具搜索，双文件(二合一)
    #文件头:本文件的格式具体参数

===============
load_prime_table/list
  from {primes1.txt primes2.txt primes3.txt} total=1e6*3
  my diff table/list: dynamic bytes#[0b1xxx* 0b0xxx]
  my factor table/array<word<n Bytes> >

odd_prime_diffs__half_minus1 = [0,0,1,0,1,0,1,2,0,2,...]
  3,5,7,11,13,17,19,23,29,31,37,...
    2,2,4,2,4,2,4,6,2,6,...#diff
    1,1,2,1,2,1,2,3,1,3,...#diff/2
    0,0,1,0,1,0,1,2,0,2,...#diff/2-1
prime_coprime_le5_order_diff__minus1 = []
  coprime_le5:2,3,5==>>30=lcm(1..5)
  remainders_mod30 = [1,7,11,13,17,19,23,29] # mod 30
  [@n::uint][gcd(n,30)==1]:
    order_mod30(n) =[def]= (n//30)*len(remainders_mod30) + remainders_mod30.index(n%30)
  [1],7,11,13,17,19,23,29,31,37,41,43,47,[49],53,59,61,67,...
  [0],1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,[13],14,15,16,17,...#order of coprime mod30
  [-],1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,[--], 2, 1, 1, 1,...#order diff
  [-],0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,[--], 1, 0, 0, 0,...#order diff minus1

  len(remainders_mod30)==8
  8/30=((1-1/2)*(1-1/3)*(1-1/5)=1/2*2/3*4/5=8/30=4/15
  ((1-1/2)*(1-1/3)*(1-1/5)*(1-1/7)*(1-1/11)*(1-1/13)*(1-1/17)*(1-1/19)
  = 1/2*2/3*4/5 *6/7 *10/11 *12/13*16/17*18/19
  =[1/2,1/3,4/15,8/35,16/77, ...]
  =[0.5, 0.3333333333333333, 0.26666666666666666, 0.22857142857142856, 0.2077922077922078, Ellipsis]
===============
中国哲学书电子化计划ctext.org vs 落吧书屋txt81.com vs 知轩藏书zxcs.me vs 小说天堂xstt5.com
    ---中国哲学书电子化计划ctext.org
    view /sdcard/0my_files/unzip/e_book/全唐詩\[ctext.org].txt
    view ../../python3_src/nn_ns/internet/webpage/extract_ctext_org.py
      中國哲學書電子化計劃
      中国哲学书电子化计划
    ---小说天堂xstt5.com
    view /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-1/《《道德经》全文及译文》.txt
    view /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/小说天堂书名归类-细分类成.txt
    ---知轩藏书zxcs.me
    精校小说：novel
      /sdcard/0my_files/novel/
===============
e others/book/小说下载进程.txt
  view  /sdcard/0my_files/tmp/list_book_novel_txt.txt

TODO:cache page with scores
  e script/download_zxcs_novel/collect_links_from_zxcs_sort_pages.py
  e script/download_zxcs_novel/extract_scores_from_zxcs_novel_page.py
view-source:http://www.zxcs.me/sort/37/page/1
  e /sdcard/0my_files/tmp-download/1/zxcs-37-1@20210829.html
view-source:http://www.zxcs.me/post/12842
  e /sdcard/0my_files/tmp-download/1/zxcs-37-12842.html
view-source:http://www.zxcs.me/download.php?id=12842
  e /sdcard/0my_files/tmp-download/1/zxcs-37-12842-download.html
===============
===============
小说设计
  如何 既要开挂，又要合理被迫低调，不至于情节暴走？
    金手指 有 严重限制、重大破绽
    如若 高调，必然为人试探识破 或 从多次行为可察觉弊端，会被人轻易布局灭杀
      --idea from 觅仙-只能夜间开挂，得到的好处白天又没了
===============
writing
DOING:
  e ../../python3_src/nn_ns/mimic_Haskell/Data.py
  e ../../python3_src/seed/hierarchy/README.txt

DONE:icase/iflag basecls
DONE:search triboolops class := 耗时

DONE:Property cached lazy eval into __dict__
    'see: @functools.cached_property'
    e ../../python3_src/seed/types/attr/CachedLazyProperty.py
DONE:mapping reversable update +push/pop 4 env
    from seed.types.mapping.DynamicStackedMapping import DynamicStackedMapping
    from seed.mapping_tools.mapping_reversable_update__tmay import mapping_reversable_update__tmay



e ../../python3_src/seed/hierarchy/plugin_api4register/stable_repr4export_long_term_storage.py
e ../../python3_src/seed/hierarchy/register/AttachmentDataRegister4cls.py
e ../../python3_src/seed/ops/flatten_ops_hierarchy.py

dir-cmp 选项 一次读取 整个 文件夹(除非文件太大！)！！
  backup 固定的全局设定 必须 保存在仓库里

自sort！！自举完全不需要 真实的 sort！
  e ../lots/NOTE/PTS/how to extend ECC.txt
  ====
  f :: <local_top?;  ...内外sort关系..., <=: 以及 是否-oo?三态> [...-> (v:::u)]:::local_top
    主要是 -oo 特殊对待 很麻烦！


gk-get_or_mk
  prepare-input:
    transforms:input-symbols,output-symbols
  check-input
  ops.gk(checked-prepared-input) -> (is_new, old_obj|properties4new_obj)
  xxx ops.init(raw_sf)
  check-sf:
    checks:input-symbols
  batch-update-properties
  weakable
  ordered-monotonically-transform-property @ops/@obj
    final-property
  ----
  同时覆盖群
  别名/融合
  『修改』许可-单线修改，临时修改-副本-提交
    每次批量更新，刷新『修改』许可，是之谓 单线。
    完整对象vs修改途中的不完全对象=旧基完整对象+临时副本
  公私权限许可，各动作许可
    多途访问：同一概念地址=不同(动作许可+路径)，实现 读写隔离
    ---
    obj -[get_ops_from_obj]-> ops.immutable -[get_meta_from_ops]-> interpreter.hierarchy.api-collection{.repr,.hash,.eq,.bool,.getattr,.get_or_mk}
    get_meta_from_obj=get_meta_from_ops.get_ops_from_obj
  e ../../python3_src/seed/ops/flatten_ops_hierarchy.py
  ---
  public-symbol-for-read/view/strict:
    public-symbol-for-init/repr/lazy-strict
      private-symbol-for-storage/write/lazy
  public-external-member vs private-attached-impl-detail/cached/lazy-result

derived_class-backward-compatibility-check-by-meta-defined-by-super-prototype

output-redundant-info--verify-same
  eg. x.get_xxx_ops()/x.get_yyy_ops(), common part are the same?
  ? how static/cls vs dynamic/obj

search-registered-subset
  :: Ord a => Map (Set a) b -> Set a -> Iter (Set a, b)
  # api-auto-[inject/check]-if-satisfy-subset
  search-registered-superset-for-new-registered-subset

Arrow i o 收集信息 如：权限需求/隐变量/全局变量
  name:
    constructor
    pattern-viewer
    --
    var
      <->binary.op.name
    hidden-var/kw-env
    attached-class.name,.api,.instance-template-name
    ---
    module.pkg
    ---
    open-type==universe
    close-type==datatype
    class?
  运行期可裁剪的部分:
    虚拟块-类型系统PTS构建所需，省略掉不影响输出
    f [^omittable] = ... (g ... [^omittable] ...) ... [^h ... omittable]
    该输入参数 只能用于 虚拟块表达式 中
py-仿Haskell表达式:expr1(seq, infix, seq, infix, seq-as-apps, ...);expr2(expr, infix, expr, infix, expr, ...)
  e ../../python3_src/nn_ns/mimic_Haskell/Data.py
  precedence
  weakdict<tuple.hash(x),x>
    x <: EqById&tuple
    std-the-only-one
  e ../../python3_src/seed/helper/unique_immutable_value.py
  e ../../python3_src/seed/types/mapping/OpaquePseudoMapping.py
      DONE
ops[symbol4attr:namespace_of_target_level{public/protected/private}:(my_level:[0..],target_level[0..])]
  symbol_leading_path = syntax "symbol/obj/obj..."
  obj_level==0
  ops[...,] ==>> call!!!
  value = Val value | Ref pkg attrs
  attr = Str str | Sym symbol
  symbol = Symbol pkg attrs
  get.ops4instance(type(sf))[...]
  meta, cls, ops/data
    cls = meta(ops)
    sf/ops/data = cls(...) = ops[???, ...]
  旁路参数 传递
    全局(不可修改)vs局部(影响调用子树)
    权限...
  ops = ops_wrapper4public<ops_impl>
  e ../../python3_src/seed/ops/meta.py
    TODO
    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    AddrAsHash
    <<==
    IDescriptor
    <<==
    CachedLazyProperty
    <<==
    IStorage/IStorage4Attachment/IStorage4Cache...
    <<==
    OpaqueInstanceStorage.OpaqueStorage/IProtocol4OpaqueStorage
    <<==
    OpaquePseudoMapping__weakref
    +register_external_opaque_storage4permanent_obj...
    <<==
    IMemberGettor+IMemberPatcher
    <<==
    Haskell-style (Arrow i o)

DONE split tiny
weakref.ref/WeakKeyDictionary:cmp by is_()?
  no! by hash+eq!!!
  e ../../python3_src/script/try_python/try_std_libs/try_weakref.py
e ../../python3_src/seed/abc/eq_by_id/PermanentSymbol.py
auto mk new py file via template
  e ../../python3_src/nn_ns/app/mk_py_template.py
e ../../python3_src/seed/types/mapping/OpaquePseudoMapping__weakref.py
WeakRefDictionary by id!!!
  key->[Weakable]-for-auto-del-if-any-del
    .__iter_weakables__
    or echo()
  Map<id(key), (key, weakref-set-with-callback, value)>
  WeakRefsDictionary by id!!!
    tuple<key> -> tuple<id(key)>
    frozenset<key> -> frozenset<id(key)>
    obj<key> -> ???<id(key)>
    .big_key_with_ref_to_valued_big_key_with_id
      :: big_key_with_ref -> valued_big_key_with_id
      use value of valued_big_key_with_id as actual key
        eg. valued_big_key_with_id = id(big_key_with_ref)
    .eqv_big_key_with_ref(old<big_key_with_ref>, new<big_key_with_ref>)
      :: big_key_with_ref -> big_key_with_ref -> bool
        eg. old<big_key_with_ref> is new<big_key_with_ref>
      to-verify-valued_big_key_with_id-is-impl-correctly    .iter_weakables__duplicates_ok(big_key_with_ref)
      :: big_key_with_ref -> Iter<Weakable>
      -for-auto-del-if-any-del
        eg. yield from [big_key_with_ref]
TODO
type.__dict__ : non-string key ==>> immutable
opaque_storage[public]->dict view
opaque_storage[private]->opaque_storage
mapping_as_whole_ops
  size
  clear
mapping_per_key_ops
  key4 init
  key4 set_new
  key4 overwrite
  key4 set_new_or_overwrite
  key4 delete/pop
  key4 detect
  key4 get
  key4 export #iter, popitem, keys, items
  cd ~/../usr/lib/python3.8/collections/
    /data/data/com.termux/files/usr/lib/python3.8/collections/
  view ~/../usr/lib/python3.8/collections/__init__.py
  view ~/../usr/lib/python3.8/collections/abc.py
  view ~/../usr/lib/python3.8/_collections_abc.py
  view ~/../usr/lib/python3.8/abc.py

e ../../python3_src/seed/helper/get4may.py
  add fmap4nmay
  add fmap4tmay
  add cmay2nmay
  add cmay2tmay
  add smay2nmay
  add smay2tmay
  add imay2nmay
  add imay2tmay
  add imay2smay
  add tmay2nmay -> raise if collide or (N, v)
view ../../python3_src/自己的相关数据/py_modules.txt
DONE: e ../../python3_src/seed/types/OpaqueInstanceStorage.py
TODO:e ../../python3_src/seed/abc/storage/IStorage.py
DONE: e ../../python3_src/seed/types/attr/CachedLazyProperty.py
AddrAsHash
  storage[symbol]
    symbol.[dict_path+description<is_ OpaquePseudoMapping, get/set, fdefault>]
      __weakref__
    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
    TODO
    meta-float-slots public+private, maintain-single-inheritance, ...concrete-class-instantiation_layout_or_not_using_slots
    meta-OpaquePseudoMapping-as-dict
    meta-捆绑定义 如__eq__+__hash__
      choice:default:abstractmethod/None
    view ../../python3_src/script/try_python/try_attrs/try_slots.py
        见B_a
            隐藏 attr 的方法有了！
              定义__slots__，取出descriptor，删除cls.__dict__中的descriptor

e ../../python3_src/seed/abc/eq_by_id/BaseAddrAsHash.py
    e ../../python3_src/seed/abc/abc.py
      e ../../python3_src/seed/abc/abc__ver0.py
      e ../../python3_src/seed/abc/abc__ver1.py
      e ../../python3_src/seed/abc/abc__ver2.py
    seed.lang.apply_descriptor_protocol
    seed.lang.basic_descriptors
    seed.abc.IDescriptor
      e ../../python3_src/seed/lang/apply_descriptor_protocol.py
      e ../../python3_src/seed/lang/basic_descriptors.py
      e ../../python3_src/seed/abc/IDescriptor.py
        from seed.abc.IDescriptor import NonDataDescriptor4InstanceMethod #try staticmethod but fail!!
        from seed.lang.basic_descriptors import BasicNonDataDescriptor4InstanceMethod as NonDataDescriptor4InstanceMethod
    split IXxx Xxx IDescriptor/IStorage4Attachment/OpaquePseudoMapping/AddrAsHash...
    add IStorage4Attachment, IStorage4PublicProperty, IStorage4PrivateProperty
      IStorage4Property/IStorage4Cache/IStorage4Attachment using OpaquePseudoMapping
      OpaquePseudoMapping using object.repr to avoid leak info
    mv e ../../python3_src/seed/types/AddrAsHash.py
      e ../../python3_src/seed/helper/unique_immutable_value.py
        IValueTree2AddrAsHash
          repr_sys
          symbol extension intension staroge-new repr-get()
            symbol.symbol.symbol OpaquePseudoMapping set_once
    e ../../python3_src/seed/lang/super4bypass_instance.py
      pseudo_super4bypass_instance middle_cls from_cls tmay_from_instance offset_from_middle_cls duck_type_instance_ok
    DONE: e /storage/emulated/0/0my_files/git_repos/python3_src/seed/abc/IDescriptor.py
      __func__ property+abstractmethod IWrapper4Func
      doctest: classmethod/...
      doctest: __slots__
      update __all__


类型描述系统+动作类+局部环境参数(向下传递？深度控制？)
  类型检查+局部环境参数
  repr,stable_repr,clean_repr
  构造？输入参数的类型优先次序检查(特别是 迭代器)+构造函数调用
  静态循环定义环境，动态配置运行环境
  类型 对 实例 的 控制:
    成员:必须、可选、允许、禁止
      约束<必须,可选>
      #默认约束<禁止>
    越级-控制？
  类型名 = (类型构造器名, [可选-模版参数名:参数约束], [[模版参数名]:参数约束], 参数约束)
  参数约束
    #冗余信息的计算 及 用于约束的特征值
      = 单参数类型 类型名
      | 单参数数据 数据构造器名 [可选-模版参数名:参数约束] [[模版参数名]:参数约束] 参数约束
      | 单参数常量 数据常量
        #record vs mapping
        #record = @k<-keys. Value<k>
        #mapping = Map K V
      | 互斥并联约束 [参数约束]
        #并行匹配，成功当且仅当锁定唯一分支并匹配成功
      | 优先匹配约束 [参数约束]
        #串行匹配，成功当且仅当第一个锁定的分支匹配成功
      | 共同约束抽取 参数约束 参数约束
        #作为并联分支时，不能提前锁定分支，后续约束失败视为匹配失败而非出错
      | 特征识别锁死 参数约束 参数约束
        #作为并联分支时，提前锁定分支，后续约束失败视为出错
lambda 最少运算
  每个节点 = 原值+计算过程值(直至 终值)+自由变量单替换缓存关联{变量名:弱引用关联{替换指定变量的输入节点，本节点的被替换后节点}}

两个题目:
  * 相等？有无必要？@x -> P x -> Q x 不就是 等同替换？
    P? -> eqv<P> x y -> P x -> P y
    Part<eqv>(P) -> eqv x y -> P x -> P y
      P 这个 子集，包含或不包含 完整的 eqv划分出 的 等价类
  * sort 命名 分为 两部分 (域名:标签集,高度:骨干拓扑节点)
    Top(sort1, sort2)
    Top4pair((n1,h1), (n2,h2))
      = (n1\-/n2, TopH4pair(h1,h2))
    Top4arrow((n1,h1), (n2,h2))
      = (n2, TopH4arrow(h1,h2))
    TopH4pair(h1,h2) = TopH4pair(h2,h1)
    TopH4arrow(h1,-oo)=-oo
    TopH4arrow(-oo,h2)=h2
    otherwise TopH4arrow(h1,h2)=TopH4pair(h2,h1)
    [@[a-:T::sort1] -> (B a::sort2) :: TopH4arrow(sort1, sort2)]
    [?[a-:T::sort1] * (B a::sort2) :: TopH4pair(sort1, sort2)]

什么是相等？
  实仓库vs虚领域
  实品名vs虚概念
  实物体vs虚拟值
  实动作vs虚函数
  ---
  虚领域 中包含 多种 虚概念
  虚概念 包含 多个 虚拟值
  ???某个 虚函数 是 某个 虚函数概念 的 虚拟值
  某个 虚函数 将 虚领域 中 的 特定某个 虚概念 的 任意 虚拟值 映射为 另一个 (不固定 的?) 虚概念 的 虚拟值。
  ---
  虚实映射 将 虚概念 映射为 实品名，将 虚函数 映射为 实动作
  实虚映射 针对 任意 虚概念 将 相应 实品名 的 实物体 映射为 其 虚拟值
    多个 实物体 可能 映射为 同一个 虚拟值
    一个 实物体 可能 映射到 不同 虚概念 中

  同态：实动作 的 输入输出 与 相应 虚函数 的 输入输出 同态。
    任意 虚函数癸，相应 实物体甲:
      实动作癸 = 虚实映射[虚函数癸]
      实动作癸(实物体甲)->实物体乙
      虚拟值甲 = 实虚映射[实物体甲]
      虚拟值乙 = 实虚映射[实物体乙]
      虚函数癸(虚拟值甲)->虚拟值乙
    即：
      虚函数癸(实虚映射[实物体甲])->实虚映射[虚实映射[虚函数癸](实物体甲)]

  ---
  相等/等价 是说 特定于 虚领域.虚概念壬+实仓库.实虚映射/虚实映射/实品名，两个 实物体 实虚映射到 虚概念壬 中，它们的 虚拟值 是否 同一？(还需要依赖一个更基本的 等同 关系？)
    虚领域 引入整个 虚函数 族群，严重影响 同态划分/等价关系划分/实虚映射。

All 凡 Some 某
  逻辑学 是门 既古老而又年轻的科学。
    部分 古老，部分 年轻。
    既红又绿？全部 红，全部 绿。

形式系统:
  命题分类:
    * 该系统无法表达的命题
    * 该系统可以推导出的命题
      * 已有该系统推导步骤的可以推导出的命题
      * 还未有该系统推导步骤的可以推导出的命题
    * 该系统无法推导出的命题
      * 该系统无法推导出的真命题
        * 该系统无法推导出的真命题但可推导出其双重否定
        * 该系统无法推导出的真命题也不可推导出其双重否定
      * 该系统无法推导出的假命题
        * 该系统无法推导出的假命题但可推导出其单重否定
        * 该系统无法推导出的假命题也不可推导出其单重否定
  系统本身的问题:
    可推导出的命题 是否是 真命题
      即 所有假命题皆不可被推导出
      sound
    不可推导出的命题 是否是 假命题
      即 所有真命题皆可被推导出
      complete
    命题及其否定 是否 可能皆被推导出来
      即 是否 包含 矛盾
  语法:
    命题:
      [命题]
      [命题][命题]
      [[命题][命题]]
      [[命题]+[命题]]
      [否 [命题]]
      [否否 [命题]]
      [[命题] -> [命题]]
      @[变量 <- 表达式] -> [命题]
      ?[变量 <- 表达式] -> [命题]
    数据列表/数组:
      []
      [,a]
      [,a ,b ...]
    有序记录/元组:
      ()
      (,a)
      (,a ,b ...)
    表达式:
      (表达式)
      (函数 表达式)
      ([实例表达式 <- 约束表达式] -> [类型表达式])
      (@\[变量 :: 类型表达式] -> [类型表达式])
      (\@[变量 :: 类型表达式] -> [实例表达式])
      (?\[变量 :: 类型表达式] -> (类型表达式))
      (\?[变量 := 实例表达式] -> (实例表达式))
      (\?[变量 := 实例表达式] -> (类型表达式) >- (实例表达式))
      (实例表达式, 实例表达式)
      (?\[变量 :: 类型表达式] * (类型表达式))
      (\?[变量 := 实例表达式] , (实例表达式))
      (\?[变量 := 实例表达式] , (类型表达式) >- (实例表达式))


sort降级
  f :: @T:TopSort -> ...
    数据类的函数/数据用函数/用作数据的函数
    其返回值 必须是 任意sort下的任意 type
  f' :: @T:sort#4 -> ...
  ---
  输入参数 的 类型/集合 可调整为 子类/子集
  ---
  #xxx sort = {...} #符号集合，表示top-of-elements
  sort
    = Symbol
    | Top(sort...) #表示top-of-elements
    | sort[i] where i<-int #not only uint
  sort = sort[0] #后缀增量
  sort[i] :: sort[i+1]
  当一个 类型type 使用了 某个sort作为其构成的一部分(如：A->sort, sort->A, @\[A:sort]->P A)，则 type :: Top(..., sort[+1], ...)
  ---
  sort 拓扑 最顶 TopSort
  sort 拓扑 最底 BottomSort==={}
  任何一个 符号化 的 sort, 有 无限上升空间: sort[+k], 也有无限下降空间sort[-k]
    期间不能插入其他空间
  BottomSort 只有无限上升空间
  TopSort 只有无限下降空间
  LocalTopSort
  LocalBottomSort
  期间不能插入其他空间(局部紧致性 见下面证明)
    sort[-1] 的 含义/用途:
      [[sort[-1] <=: sort][sort[-1] =!= sort]]
      [@[sort2 <=: sort] -> [sort2 =!= sort] -> [sort2 <=: sort[-1]]]
    sort[+1] 的 含义/用途:
      [sort :: sort[+1]]
      [[sort[+1] >=: sort][sort[+1] =!= sort]]
      [@[sort2 >=: sort] -> [sort2 =!= sort] -> [sort2 >=: sort[+1]]]

    ???[sort[-1][+1] === sort === sort[+1][-1]]???
      yes!
    proof:???[sort[-1][+1] === sort]???
      !![[sort[-1] <=: sort][sort[-1] =!= sort]]
      [sort >=: sort[-1]][sort =!= sort[-1]]
      !![@[sort2 >=: sort] -> [sort2 =!= sort] -> [sort2 >=: sort[+1]]]
      [sort >=: sort[-1][+1]]
      [sort[-1][+1] <=: sort]
      [sort[-1][+1] =!= sort]:
        !![@[sort2 <=: sort] -> [sort2 =!= sort] -> [sort2 <=: sort[-1]]]
        [sort[-1][+1] <=: sort[-1]]
        !![[sort[+1] >=: sort][sort[+1] =!= sort]]
        [[sort[-1][+1] >=: sort[-1]][sort[-1][+1] =!= sort[-1]]]
        !![sort[-1][+1] <=: sort[-1]]
        [0]
      [sort[-1][+1] === sort]

    proof:???[sort === sort[+1][-1]]???
      !![[sort[+1] >=: sort][sort[+1] =!= sort]]
      [[sort <=: sort[+1]][sort =!= sort[+1]]]
      !![@[sort2 <=: sort] -> [sort2 =!= sort] -> [sort2 <=: sort[-1]]]
      [sort <=: sort[+1][-1]]
      [sort[+1][-1] >=: sort]
      [sort[+1][-1] =!= sort]:
        !![@[sort2 >=: sort] -> [sort2 =!= sort] -> [sort2 >=: sort[+1]]]
        [sort[+1][-1] >=: sort[+1]]
        !![[sort[-1] <=: sort][sort[-1] =!= sort]]
        [[sort[+1][-1] <=: sort[+1]][sort[+1][-1] =!= sort[+1]]]
        !![sort[+1][-1] >=: sort[+1]]
        [0]
      [sort[+1][-1] === sort]
    [sort[-1][+1] === sort === sort[+1][-1]]
      #定理〖局部紧致性〗
    [sort[0] === sort]
    [sort[-m][+n] === sort[-m+n] === sort[+n][-m]]
  ---
  [sort <=: sort2] <==> [[sort <-: sort2]+[sort === sort2]]
  [sort <-: sort2] <==> [?[sort3 :: sort2] * [sort <=: sort3]]
  [sort =!= sort2] <==> [not [sort === sort2]]
  [sort !<-: sort2] <==> [not [sort <-: sort2]]
  [sort !<=: sort2] <==> [not [sort <=: sort2]]
  [sort !><=: sort2] <==> [sort !<=: sort2][sort2 !<=: sort]
    #无关
  ---
  [sort <=: sort2][@[i<-int]->[sort =!= sort2[i]]] ==>> ???
  称 {sort[i] | i<-int} 为一个『大点』
    两个 大点 要么 相同 要么 交集为空
    两个sort若不在同一个大点，则它俩之间的关系即是 两大点 之间任意元素对的关系
  ---
  Top(sort, sort2) 若非落在输入参数所在的两个大点，则必新造一个大点
  ---
  Top(...) 的定义:
    ====[[[发现问题 任何包含『!><=/无关』的条件都 无用。只用『<=:』『<-:』『===』『=!=』『>=:』不再用『!<=:』『!>=:』『!><=:』:
    [LocalBottomSort <=: sort <=: LocalTopSort]
      大前提
    [Top(sort) === sort]
      退化为常见状态
      [(@a:A:sort -> (B:sort)) :: sort===Top(sort, sort)]
    [Top(sorts...) === Top(permutation sorts...)]
      #Top语义-无序
    [Top(Top(sorts2...)[0], sorts...) === Top(sorts2..., sorts...)]
      #Top语义-人为边界可删除
      #扁平化
      #但是，只有 Top(...)[0] 能拆包，结构依旧复杂！？
      #确实，见下面『后缀增量无法移入』『后缀增量移入则不增』
    [sort2 <=: sort] ==>> [Top(sort2, sort, sorts...) === Top(sort, sorts...)]
      #Top语义-重复元素无效、非极大元素无效
      #删减 重复元素、非极大元素
      #==>> [Top(sort, sort, sorts...) === Top(sort, sorts...)]
      #
    @[sort2,sort3 <=: sort] ==>> [Top(sort2,sort3) <=: sort]
      #Top的语义-最低上界
      ??? [Top() === LocalBottomSort]
    @[sort2 <=: sort] ==>> [Top(sort2, sorts...) <=: Top(sort, sorts...)]
      #Top的语义-非递减-入不减出不减
    @[sort2 <-: sort] ==>> [sort2 <-: Top(sort, sorts...)]
      #Top的语义-非递减-入参元素倾注出参
      #     -更大的宇宙/更大的空间/更大的集合
      <==> [sort[-1] <-: Top(sort, sorts...)]
      #!!〖局部紧致性〗
      <==> [sort <=: Top(sort, sorts...)]
        * ==>> [sort[+1] <=: Top(sort[+1], sorts...)]
        * ==>> [sort[+1] <=: Top(sort, sorts...)[+1]]
          # <<== [sort <-: Top(sort, sorts...)[+1]]
          # <<== [sort <=: Top(sort, sorts...)]
        * ==>> [Top(sort[+1], sorts...) <=: Top(sort, sorts...)[+1]]
          # <<== [Top(sort[+1], sort, sorts...) <=: Top(sort, sorts...)[+1]]
          #!!Top的语义-最低上界
          # <<== [sort[+1] <=: Top(sort, sorts...)[+1]] && [Top(sort, sorts...) <=: Top(sort, sorts...)[+1]]
        * ==>> [Top(sort[+1], sort2[+1]) <=: Top(sort, sort2)[+1]]
          #证明同上
          #『后缀增量移入则不增』
      #非递减
      # 要么 相等 要么 小于
      # 不存在 大于
      # 不存在 无关！！！这点在意料之外
      #之前以为 [sort[-1] <-: Top(sort, sorts...) !<-: sort]
          #bug: [sort <-: Top(sort, sorts...)] ==>> [Top(sort, sorts...) === Top(sorts...)]
                #删减 非极大元素
                #极大元素 等于 或 无关，但 不能 小于 或 大于
      #bug: <==> [[sort =!= Top(sort, sorts...)][i<-int]-->>[sort[i] <-: Top(sort, sorts...)]]
      <==> [[sort !<-: Top(sorts...)][sort =!= Top(sort, sorts...)][i<-int]-->>[sort[i] <-: Top(sort, sorts...)]]
      <==> [[sort !<-: sort2][sort =!= Top(sort, sort2)][i<-int]-->>[sort[i] <-: Top(sort, sort2)][sort2[i] <-: Top(sort, sort2)]]
      <==> [[sort !<-: sort2][sort =!= Top(sort, sort2)][i,j<-int]-->>[Top(sort[i], sort2[j]) === Top(sort, sort2)]]
      <==> [[sort !><=: sort2][i,j<-int]-->>[sort[i] <-: Top(sort[i], sort2[j]) === Top(sort, sort2)]]
          #尊重〖局部紧致性〗，添加 足够多的元素
          #简化结构，以便于比较
          #==>>『后缀增量无法移入』Top内部
          #     即 一般不成立:[Top(sort[i], sort2[j])[k] === Top(sort[i+k], sort2[j+k])]
          #     这里 有问题！！很麻烦，事实上 或者说 设计原意 是 『无关』在不同配置下 随时可以 转化为 『小于/等于/大于』或仍保持『无关』，『无关』应该理解为『待定』，
          #     没有[sort !><=: sort2]
          #     没有[sort =!= Top(sort, sort2)]
          #     一切都是待定/未知！！
          #     但也不是任何配置都有效，仍须兼容 已知的拓扑次序
      #!!『Top语义-人为边界可删除』
      <==> [Top(sorts...) <=: Top(sort, sorts...)]
          ==>> [Top() <=: Top(LocalBottomSort) === LocalBottomSort]
          !! [LocalBottomSort <=: sort]
          ==>> [LocalBottomSort <=: Top()]
          ==>> [Top() === LocalBottomSort]
            #有无必要？
            #实用中，似无用

    #用途:
    #   (@[a:A:sort] -> (B:sort2)) :: Top(sort, sort2)
    =====脱离 上面的 大前提 [LocalBottomSort <=: sort <=: LocalTopSort]
    =====以下 关注 BottomSort 子集/子类/子划分 sort[-oo]
    #用途:
    #   (@[a:A:sort[i/-oo]] -> (B:sort2[-oo])) :: Top(sort, sort2)[-oo]
    @[type :: sort[-oo]] ==>> [type :: BottomSort]
    @[i<-int] ==>> [sort[-oo] <-: sort[i]]
      #没有 sort[-oo][i]
    @[type :: sort[-oo]] ==>> [type :: Top(sort, sort2)[-oo]]
    #没有 [sort[-oo] <=: Top(sort, sort2)[-oo]]
    #   要么 相等，要么 无关，没有 『<-:』
    [[sort[-oo] === Top(sort, sort2)[-oo]]+[sort[-oo] !><=: Top(sort, sort2)[-oo]]]
      #上面的情形不同，由于存在 sort[-1]，导致『<=:』
      #而后缀增量[-1]则来源于 sort 并非最底层BottomSort，也就是说 存在[sort2 <-: sort]，很可能 [sort2 :: sort]
      # 关键在于 是否存在[sort2 :: sort]
      # 然而 并不必然存在
      # 若存在[sort2 :: sort]，则 虽然sort2语义 弱于 sort[-1](并非 最大子，只是 极大子，sort[-1]不存在 或者说是 多个 极大子 构成的集合 或 某些上升途径甚至没有极大子！)，但 [sort2[+1]===sort][sort2 <-: Top(sort, ...)]仍将迫使[sort <=: Top(sort, ...)]。但不论如何，由于sort并非 LocalTopSort，sort[+u]是必须存在的，由于无限长上升途径的存在，其中出sort外，其余都有[-1]，这样一看，sort显得格格不入。虽然sort[-1]不存在，但我们可强行加上。当然强行加上，导致拓扑结构改变，导致『<=:』，虽然语义改变，可能并非合理，不过也算简化运算。
      # 若不存在[sort2 :: sort]，则[@sort2 <-: sort][@u>0][sort2[+u] <-: sort]
    [Top(sort[i/-oo], sort2[i/-oo])[-oo] === Top(sort, sort2)[-oo]]
      #也就是说：Top(...)[-oo] 必可简化为Top(...all-Symbol...)[-oo]，内部没有 后缀增量，没有 Top


    ====]]]
    =======下面考虑废除后缀增量[-i]只保留[0]/[+u]
    =======[-1]原先的设计意图是用于LocalTopSort[-1]下降空间，但其实别的点并无需求，事实上只有TopSort[-1]可以用，LocalTopSort在其他点废除[-1]后也无法使用[-1]，因为它只是变量名。
    [+1]相当于 有向边，形成 有向无环图
    出边 唯一，只有LocalTopSort没有 出边
      [+1]相当于 指向父节点的箭头
    分为 两类入射树:
      * 实根树，以 LocalTopSort为 根
      * 虚根树，无 根，无限长上升途径
        Top两位于不同的虚根树的节点，会得到什么？
          两虚根的最小上界
          Top(甲点,乙点) === Top(甲点的相应虚根,乙点的相应虚根)
          Top(甲点[+u],乙点[+v]) === Top(甲点的相应虚根,乙点的相应虚根)
            #这是在 确定 情形下的结论
            #但是，通常都是 待定状态
            #两虚根树相同可以判定，但不同 却无法判定，只能 待定
    待定:
      输入声明[a <=: b]
        a[+1]与b的关系？
        a[+1]与LocalTopSort的关系？
      不能 输入声明[a !><=: c]，只能说 没能从所以已知关系中推导出任何次序:
        则 将来配置后为：
        [a === c]
        [a <=: c]
        [a >=: c]
        [a <-: c]
        [c <-: a]

  * sort 命名 分为 两部分 (域名:标签集,高度:骨干拓扑节点)
    Top(sort1, sort2)
    Top((n1,h1), (n2,h2))
      = (n1\-/n2, TopH(h1,h2))







remove_Abs :: lambda_expr -> combinator_expr
  view ../lots/NOTE/lambda/CombinatorSKIBC.hs
  lambda_expr
    = Var name
    | Abs name lambda_expr
    | App lambda_expr0 lambda_expr1
  remove_Abs (Var name) = (Var name)
  remove_Abs (App lambda_expr0 lambda_expr1) = (App (remove_Abs lambda_expr0) (remove_Abs lambda_expr1))
  #remove_Abs (Abs name lambda_expr) =
    remove_Abs (Abs name (Var name)) = I
    remove_Abs (Abs name (Var name_diff)) = K (Var name_diff)
    remove_Abs (Abs name (App lambda_expr0 lambda_expr1)) = (S (remove_Abs (Abs name lambda_expr0)) (remove_Abs (Abs name lambda_expr1)))
    remove_Abs (Abs name (Abs name lambda_expr)) = (K (remove_Abs (Abs name lambda_expr)))
    remove_Abs (Abs name (Abs name_diff lambda_expr)) = (remove_Abs (Abs name (remove_Abs (Abs name_diff lambda_expr))))
  #remove_Abs (Abs name lambda_expr) =
    #reduce size by replace some S by B, C
    #copy from ../lots/NOTE/lambda/CombinatorSKIBC.hs
    {-
    combinators
    T[x] => x
    T[(f e)] => (T[f] T[e])
    T[\x->e] => (K T[e]) (if x is not free in e)
    T[\x->x] => I
    T[\x->\y->e] => T[\x->T[\y->e]] (if x is free in e)
    + eta-reduction: T[\x->(f x)] = T[f] (if x is not free in f)
      <==> B I e == e; B e I == e
      B is composition, i.e. (.)
      C is flip
    T[\x->(f e)] => (S T[\x->f] T[\x->e]) (if x is free in both f and e)
    T[\x->(f e)] => (C T[\x->f] T[e]) (if x is free in f but not e)
    T[\x->(f e)] => (B T[f] T[\x->e]) (if x is free in e but not f)
    -}
  remove_Abs property:
    * num of 'Var' not increase
    * xxx num of 'App' not increase???
      'Abs+Var' -> K=>+1*'App'
      'Abs+App' -> S=>+2*'App'
    * 'Var' -> +0
    * 'App' -> +0
    * 'Abs+Var' ->:
        * {-1*'Abs', -1*'Var', +1*'I'}
        * {-1*'Abs', +1*'App', +1*'K'}
        => max=+1
    * 'Abs[high]+App' ->:
        * {-1*'Abs[high]', +2*'Abs[high-1]', +1*'App', +1*'S'}
    * 'Abs[high]+Abs[high-1]' ->:
      recur!!!problematic
    ====精简版
    输入: e::lambda_expr
    输出: c::combinator_expr
    lambda_expr表达式树:
      Var 叶节点
      Abs 丫节点 独子丫节点
      App 丫节点 双子丫节点
    变换后combinator_expr表达式树:
      原自由变量 不变
      原绑定变量 与 I叶节点 一一对应
      但多出 新的叶节点:[SKBC]
        到底 多出 多少？
    假设 所有 free_var,bound_var 两两不同
      则由 叶节点 的 变量名 可 直接 知道 该变量 是否 绑定，绑定的变量 是由哪个 丫节点 产生，并得到一条由该 带绑定变量的叶节点 到 相应的声明该变量的丫节点 的路径（以下称之为 污径）。
      对于 变换过程中的 某 污径（本注释错xxx K的由来，若是 原lambda_expr的 污径，分离出来单独变换则相应路径左旁无K/C，右旁无B xxx），如果 其上 无其他 独子丫节点，则 变换后combinator_expr的相应路径为：
        #xxx ((App (App [S|B|C] ?) _vvv)|(App K _vvv)|(App (App [S|B|C] _vvv) ?))* I
        ((App (App [S|B] ?) _vvv)|(App (App [S|C] _vvv) ?))* I
      对于 极小的 Abs子树（内无更小的 Abs树），其子为 二叉树。所有 污径 构成的 子树 ...
    例：
      T[\x[0]->\x[1]->...->\x[n-1]->\x[n]-> (x[0] x[1] ... x[n] y)]
      = T[\x[0]->\x[1]->...->\x[n-1]->T[\x[n]-> (x[0] x[1] ... x[n] y)]]
      = T[\x[0]->\x[1]->...->\x[n-2]->T[\x[n-1]-> (C (x[0] x[1] ... x[n-1]) y)]]
      = T[\x[0]->\x[1]->...->\x[n-3]->T[\x[n-2]-> (C ((B C) (x[0] x[1] ... x[n-2])) y)]]
      = T[\x[0]->\x[1]->...->\x[n-4]->T[\x[n-3]-> (C ((B C) ((B (B C)) (x[0] x[1] ... x[n-3]))) y)]]
    T[\x[0]->\x[1]->...->\x[n-1]->\x[n]-> (x[n] x[n-1] ... x[0] y)]
      py -m nn_ns.functional._try_CombinatoryLogic > $my_tmp/out4py/nn_ns.functional._try_CombinatoryLogic.case0.1-14.txt
            指数增长？！！！
            view /sdcard/0my_files/tmp//out4py/nn_ns.functional._try_CombinatoryLogic.case0.1-14.txt
  ====其实，并非一定要只使用SKIBC，我起初感兴趣的原由在于除去变量名，这样一来函数体显得更规范更容易比较结构的等同性。调用函数也不必替换变量。
  ====等效来讲，只是将远在叶节点的绑定变量所指引的污径在途中的所有丫节点标记指引
  ======显化局部指引
  T[x]=x #必是 自由变量
  T[App f e]=App T[f] T[e]
  T[(Abs x[i])+ z]=K<1+n> z
      #n 表示 Abs 的数量，(1+n)代表 触发动作的输入参数数量
  T[(Abs x[i])+ x[i]]=I<n,i> z
      #n 表示 Abs 的数量，也代表 触发动作的输入参数数量，i代表 反弹的参数的输入序号
  T[(Abs x[i])+ f (App e[j])+]=S<m+n,[[i<-[1..n]{#sorted#} | x[i] <- FV(e[j])] | j<-[1..m]]> T[(Abs x[i] if x[i]<-FV(f))* f] ...T[(Abs x[i] if x[i]<-FV(e[j]))* e[j]]...
    #批量处理，反正，在头部所有连续Abs丫节点都接受到参数之前，函数体 等效于 未触发
    #注意:这与 单纯地使用 SKIBC 是不同的，批量一次性自顶向下vs多层次碰撞自顶向下，后者代码爆炸/或比较难估计，前者上限必然是O(n^3)，现将前者再转化为后者...关键就是T[(\x[1..n] -> Apps [Apps [f[i]]++x[1..n] | i<-[1..n]])]=O(?<n>)??其中 f[1..n]不含x[1..n]也不含Abs。比较难估计，可见，S<m+n,...>编码了大量信息，缩减代码数量。
    # Apps [] === I
    泛化S<m+n,...>以更好地处理 排列组合:
      #old-name:LocalBatchSchedule局部批量参数转发指引
      LocalBatchRouter局部批量参数路由<触发动作的输入参数数量, [[参数序号]]>
      LocalBatchRouter<L, uintss> x[1..L]
        = Apps [Apps [x[i] | i<-uints] | uints<-uintss]
        where
          Apps = foldl I App
    系统[Var+Abs+App]
    <==>系统[Var+Abs+Apps]
    <==>系统[Var+Apps+LocalBatchRouter]
      #Var自由变量
      #Apps 用于表达 LocalBatchRouter 触发动作后的展开式
    Apps 计算:
      Apps 简化:
        Apps [e] -> e
        Apps [Apps hs, ts...] -> Apps (hs++ts)
      Apps 动作:
        Apps [Abs x e, y, ts...] -> Apps [call(Abs x e, y), ts...]
        Apps [LocalBatchRouter<L, uintss>, ys...{len=L}, ts...] -> Apps [call(LocalBatchRouter<L, uintss>, ys), ts...]

  SKIBC:
    S = \x2f x2a x -> ((x2f x) (x2a x))
        = LocalBatchRouter(3, [0, 2], [1, 2])
    K = \a b -> a
        = LocalBatchRouter(2, [0])
    I = \a -> a
        = LocalBatchRouter(1, [0])
        = LocalBatchRouter(0)
    B = \f g a -> f (g a)
        = LocalBatchRouter(3, [0], [1, 2])
        #= \f -> S (K f) = B S K
        #=\f g x -> f (g x)
        #   = \f g -> S (K f) g
        #   = \f -> S (K f)
        #   = S (K S) K
        ############################
        # S (K S) K f
        #   = (K S f) (K f)
        #   = S (K f)
        #####################
        # S (K f) g x
        #   = (K f x) (g x)
        #   = f (g x)
        #####################
    C = \f a b -> f b a
        = LocalBatchRouter(3, [0, 2], [1])
        = LocalBatchRouter(3, [0, 2, 1])
        #=\f a b -> f b a
        #   =\f a -> (S f) (K a)
        #   =\f -> S (K (S f)) K
        #   = S (\f-> S (K (S f))) (K K)
        #   = S (S (K S) (\f-> K (S f))) (K K)
        #   = S (S (K S) (S (K K) (\f->S f))) (K K)
        #   = S (S (K S) (S (K K) S)) (K K)
        ############################
        # S (S (K S) (S (K K) S)) (K K) f
        #   = (S (K S) (S (K K) S) f) (K K f)
        #   = ((K S f) (S (K K) S f)) K
        #   = S ((K K f) (S f)) K
        #   = S (K (S f)) K
        #####################
        # S (K (S f)) K a
        #   = (K (S f) a) (K a)
        #   = (S f) (K a)
        #   = S f (K a)
        #####################
        # S f (K a) b
        #   = (f b) (K a b)
        #   = f b a
        #####################

    #fix #calc_fix_point
        x = f x = y f
        y f = f (y f)
        y = h h
        h = \h f -> f (h h f)
    Y = H H
        # Y f = H H f
        #   = f (H H f)
        #   = f (Y f)
    H = \h f -> f (h h f)
        = LocalBatchRouter(2, [1], [0, 0, 1])
        #= \h f -> f (h h f)
        #   = \h -> S I (h h)
        #   = S (K (S I)) (\h-> h h)
        #   = S (K (S I)) (S I I)
        ############################
        # S (K (S I)) (S I I) h
        #   = (K (S I) h) (S I I h)
        #   = (S I) (h h)
        #   = S I (h h)
        #####################
        # S I (h h) f
        #   = f (h h f)
        #####################
    DEAD = (S I I) (S I I)







证明的无关性proof_irrelevance
  proof irrelevance
  形式系统
  proof, certificate, witness, evidence
    the type is inhabited
  正常函数类型 A -> B
  证明的证书: Inhabited (A->B)
    这种类型 最多只包含一个 值
    AtMostOne
    注意:唯一 不一定 可实构
      Inhabited 代表 证明存在实构
      AtMostOne 代表 证明最多一个
      Unique 代表 证明唯一
      Singleton 代表 实构唯一
  新增 规则:
    liftI :: A -> Inhabited A
    errorI :: Inhabited ZeroType -> ZeroType
      # ???ZeroType =[ded]= (@[T:Type] -> T)
    applyI/unliftI :: Inhabited (A->B) -> Inhabited A -> Inhabited B
      :: Inhabited (A->B) -> (Inhabited A -> Inhabited B)
      # 没有 :: Inhabited A -> A
        #可逆 applyI (applyI (.) (liftI (liftI . f))) (flattenI) :: (Inhabited A -> Inhabited B) -> Inhabited (A->B)
      # 概念领域 是 虚拟的，无法进入现实世界，无法 构建 真实对象
      #     但 可构建 虚拟对象 见flattenI
    flattenI :: Inhabited (Inhabited A -> A)
      # 扁平化 (applyI flattenI) :: Inhabited (Inhabited A) -> Inhabited A
      # 可择一公设？the Axiom of Choice若存在则可择一/可构建一个？
    ????没有 :: Inhabited A -> not (not A)
      ? xxx: Inhabited A =[def]= not (not A)
        不行！见下面ClassicalLogic/排中律LEM/双重否定
      注意: (A->not (not A)) 是可以自然实现的
        to_double_neg a a2err = a2err a
        to_double_neg = flip app
      注意: ((not (not (not A))) -> (not A)) 是可以自然实现的
      from_triple_neg a2err_2err_2err a = a2err_2err_2err (to_double_neg a)
      from_triple_neg = (. to_double_neg)
    ????没有 :: Inhabited (not A) -> not A
    ????没有 :: Inhabited A -> not (not A)
    ????没有 :: AtMostOne (not A)
    ????没有 :: Inhabited (AtMostOne (not A))
      # 没有 :: Inhabited (not (Inhabited A)) -> Inhabited (not A)
      #     没有 :: Inhabited (not (Inhabited A) -> not A)
      #     没有 :: not (Inhabited A) -> not A
      # 不存在证明 不等于 没有
    eqvI :: @[a,b::Inhabited A] -> @[P::Pred] -> P a -> P b
    from_double_neg :: Inhabited (not (not A)) -> Inhabited A
      # ???没有 排中律 :: Inhabited (A | (not A))
      #     注意: .排中律 the Law of Excluded Middle(LEM) 的 双重否定 是可以自然实现的
      # 但 肯定有 :: not (A & not A)
    fstI :: Inhabited (?[a:A], P a) -> Inhabited A
      # fstI === applyI (liftI fst)
    eqv2I :: Inhabited (AtMostOne A P) -> @[a,b::A] -> @[P::Pred] -> P a -> P b
    proof_irrelevanceI :: AtMostOne (Inhabited A, ID)
        # eqv2I uniI ==>> eqvI
    the_uniqueI :: Inhabited (Singleton A P -> (?[a::A], P a, AtMostOne A P))
  ===extend??
  ClassicalLogic ??<=:?? Inhabited
    增加 排中律
    !!!删除 ClassicalLogic (not A) -> not A
    !!!删除 ClassicalLogic A -> not (not A)
      #     注意: .排中律 the Law of Excluded Middle(LEM) 的 双重否定 是可以自然实现的
      # 所以 ??Inhabited==ClassicalLogic==(not . not)
      # 不对，Inhabited的语义 与 双重否定 不同，外延也不同，不可能相等！
      # ==>> Inhabited =!= not . not) === ClassicalLogic



seed->tiny refactor
seed->cmdline parse-simplified
  2因素:env,config
seed->case/flag/hybrid
  flag:immutable-eq-hash-lt, & | ^
  legal_keys saved at:
    e ../../python3_src/seed/helper/reduce_number_of_objects_with_same_value.py

j::uint%(L+1), us::[uint%L]
  j 分两半，置位与否
  us 非空区间起始
  而 无区间起始的两个可空区间 为离散

通常 默认允许功能不断增加，但不允许减少。其实，禁止某些功能的增加，也很重要。
  from seed.helper.reduce_number_of_objects_with_same_value import SpecialKeyByNonHashable, SpecialKey, ALL_KEYS
  del d[ALL_KEYS] # "ALL_KEYS" is not hashable to distinguish normal hashable key. that is the way to create special keys.
          # slice is unhashable
            >>> {}[:]
            Traceback (most recent call last):
                ...
            TypeError: unhashable type: 'slice'



wrapper hash/eq~is
null_mapping
fold fdefault fvalue default_as_value init,last  flip_op
    factor into (x or not ...) shortcut pass control
repr
    if args using default at tail, shorten
    kwargs...
    view for arg
    eq for arg => is_default
init
    which property need to calc &cache, how? from which property?
    input args/kwargs are which property?




排列组合:
  格式 =
    (有序，格式...)
    (无序，数量，格式)
    (有序单个，数量)
      * 先选 无序，再 排列 ==>> 输出次序 最大元素 最小最先
      * 词典序
        m 排列出 n
        1 2 3 ... (n-1) n | (n+1) (n+2) (n+3) ... (m-1) m
        1 2 3 ... (n-1) (n+1) | n . (n+2) (n+3) ... (m-1) m
        1 2 3 ... (n-1) (n+2) | n (n+1) . (n+3) ... (m-1) m
        ...
        1 2 3 ... (n-1) (m-1) | n (n+1) (n+2) ... (m-2) . m
        1 2 3 ... (n-1) m | n (n+1) (n+2) ... (m-2) (m-1) .
            # 后移一位
        #进位
        1 2 3 ... n (n-1) | m ~ (n+1) (n+2) ... (m-2) (m-1)
        1 2 3 ... n (n+1) | m ~ (n-1) (n+2) ... (m-2) (m-1)
        1 2 3 ... n (n+2) | m ~ (n-1) (n+1) ... (m-2) (m-1)
        ...
        1 2 3 ... n (m-2) | m ~ (n-1) (n+1) ... (m-3) (m-1)
        1 2 3 ... n (m-1) | m ~ (n-1) (n+1) ... (m-3) (m-2)
        1 2 3 ... n m | (m-1) ~ (n-1) (n+1) ... (m-3) (m-2)
            # 后移一位
        #进位
        1 2 3 ... (n+1) (n-1) | (m-1) m ~ n ... (m-3) (m-2)

    (无序单个，数量)
      进位:#1代表 选中
      0{n}10xxx -> 0{n+1}1xxx
      0{n}1{m+1}0xxx -> 1{m}0{n+1}1xxx
      最小: 1{M}0{N}
      最大: 0{N}1{M}

词典序=向尾端聚集
局域序=从头端扩散
f_iter词典序(iterable) =?= reversed(f_iter局域序(reversed(iterable)))



e ../../python3_src/seed/types/flag/Flag.py
e ../../python3_src/seed/types/flag/IHybridFlag.py
seed.types.flag.Flag
  约束 与 互斥 区别: << 自动清空互斥标志
  互斥 并非 等价关系，不该使用 等价划分
  {legal_key:互斥群的集合}
  互斥群的集合
    = {(互斥区, 取消互斥, 互斥区, 取消互斥, , ...)}
      理论上，无需 三层以上（含）
    ={互斥区:{取消互斥:互斥群的集合}}
  alias, not-, deduce-


from seed.types.HistoryGrowOnlyStack import HistoryGrowOnlyStack, EmptyStackError

e ../../python3_src/seed/recognize/SimplifiedCmdlinePrefixParser.py
  -> e ../../python3_src/seed/recognize/cmdline/SimplifiedCmdlinePrefixParser.py
  抽象化
  转义加格式化 vs 字面字符串
  open+local-state...==>> expected prefix2handler_name
  raw-section-open-tag ...
    蛮区前缀型标签-负载区前缀型标签?-预处理前缀*-符号优先级前缀?-内嵌深度前缀?-局部位置前缀?-功能前缀
    蛮区 vs 冠区/牧区
    标签前缀 vs 预处理前缀 vs 功能前缀
      close 依open 决定是否带标签
        但是，是否带 命令名/域头功能前缀？
          open+命令名=功能前缀 #其 可带负载
          若带，则 close_open会有麻烦，2个功能名 如何安排？
            或许 一个close_open 可拆成2个: close, continued_open后续操作符功能前缀
  close_open
    开标志，闭标志，闭连开标志/中继标志/继标志，连开标志/续开标志/再开标志
  open_until_end_of_scope
  open_until_end_of_scope_or_low_priority_close
  不影响解析过程:
    noise
    解包参数包
  影响解析过程-过于复杂:
    变量定义
    透明作用域
    不同状态的相应前缀/后缀集更改
      raw-section
      toplayer
    终止:
      待解析尾部
      出错-条件测试-断言

  影响解析过程-简化版:
    终止:
      待解析尾部
  不影响解析过程-简化版:
    字符串变量定义
      <==> 转义格式化 并不影响 解析
      <==> 解析过程中 并不进行 转义格式化，直接跳过 预处理前缀 读至 功能前缀
      <==> 预处理前缀 至 功能前缀 并不出现于转义格式化生成结果之中
    透明作用域
    参数序列变量定义
      where 定义 参数序列变量 于 前一个作用域 被引用 解包，高层次 功能，与 解析 无关，但 where 必须有 控制 state 局部的合法功能前缀
  取消-简化版:
    不同状态的相应前缀/后缀集更改
      raw-section
      toplayer
    终止:
      出错-条件测试-断言
  ***
  功能前缀
      功能前缀无负载=indicator=标示
      功能前缀带负载=prefix+payload=前冠
      功能前缀带可选负载+(空/空负载标示|负载前缀)=prefix+...
  允省前缀/可省前缀/统一前缀
      允省前缀无负载=indicator=标示
      允省前缀带负载..负载结束标示=prefix+payload*?+suffix=前冠
          相比 功能前缀，多了个 负载结束标示
      允省前缀带可选负载+(空负载标示|负载前缀..负载结束标示)=prefix+...
          相比 功能前缀，没有 空 选项，多了个 负载结束标示
          可考虑 内嵌-带？蛮冠标签-开闭标志对
  ***
  只有 作用域级别 的状态更改影响，没有 短程邻接级别(噪声 如何计算？不论包含与否，均不合适，特别是在 蛮区)
    open..close
    open_until...
      toplayer
  ***
  状态更改后，如何决定 局部的合法功能前缀？
    + 绝对:列举
    + 相对:引入 父作用域、前一个作用域、后续操作符功能前缀 的前操作符作用域
      * 多元运算符
      * 透明作用域
      * where: expr where{变量定义} 
        高层次的 短程邻接级别 影响，但 与解析无关
    ==>> 静态检查 前缀冲突
      使用 动态的前缀注入操作符（统一前缀/允省前缀）？不行！因为无法作 静态检查。
      必须 静态声明注入哪些相对性相连域的前缀:
        父域
        父域的子域
        父域的子域的子域...
        父域的父域
        父域的父域的子域
        父域的父域的子域的子域...
        父域的...父域的子域...的子域
        #静态检查 ==>> 不可能有更仔细的分类（如：前一个域）
        #
        #排除 顶层绑定 的前缀
        #   可否，透明作用域where/参数包 可以 加前缀 而 原前缀 变 负载？部分不行，解析过程仍需进行；部分可行，可避免 部分冲突，但 子域 本身就 很多，即使 成为 负载，仍需 解析，仍有 冲突。
  ***
  这里 标签 不同于 html的标签，而是 类似 C++的raw_string
    标签=临时性依赖于内部数据的非数据标示前缀
    蛮冠标签甲-其他统一前缀*-蛮区开
      蛮冠标签甲-其他统一前缀*-蛮区单功能前缀
      蛮冠标签甲-蛮冠标签乙-其他统一前缀*-蛮区开
      蛮冠标签乙-其他统一前缀*-蛮区闭
      蛮冠标签甲-蛮冠标签乙?-其他统一前缀*-冠区开
      蛮冠标签乙?-其他统一前缀*-冠区闭
    蛮冠标签甲-其他统一前缀*-蛮区闭
  html的标签 相应于 功能前缀

  局部？统一前缀的解析(piece_literal, begin_after_the_prefix, as_if_the_prefix, const_config_args4as_if_the_prefix)
    假设-解析 as_if_the_prefix+piece_literal[begin_after_the_prefix:]
      #注：piece_literal[:begin_after_the_prefix] 并不一定 endswith as_if_the_prefix
    返回: end_of_payload, 解析结果
  解析单块(顶层域与否, piece_literal, state-prefix-set/状态-(蛮冠前缀,允省前缀,功能前缀2全局功能语义名))
    无匹配->可能是上层 闭标志
  前缀信息:
    (前缀，顶层绑定与否，全局功能语义名，种类，其他...)
        #全局功能语义名 是必需的，用于 注入前缀时，相同 功能前缀 的 语义比较(同样的 功能前缀 于不同域 可能有 不同的 语义)
        #蛮冠前缀 的 分类名 已是 其 全局功能语义名，故无需多言。
    种类:
      * 蛮冠前缀:
        (蛮冠前缀，负载结束标示)
      * 允省前缀:
        * 允省前缀无负载:
          (允省标志, 全局功能语义名)
        * 允省前缀带负载:
          (允省前缀, 全局功能语义名, 负载结束标示, 内嵌开闭标志对的列表, 内嵌蛮冠标签的开闭标志对的列表)
        * 允省前缀带可选负载:
          (允省前缀, 全局功能语义名, 无负载标志, 有负载标志, 负载结束标示, 内嵌开闭标志对的列表, 内嵌蛮冠标签的开闭标志对的列表)
      * 功能前缀:
        * 单身功能前缀:
          (功能前缀, 全局功能语义名)
        * 域功能前缀:
          * 域中继标志
          * 开域功能前缀:
            (闭域功能前缀, 闭域功能前缀标示允空, 域头功能前缀标示允空，域头功能前缀2全局功能语义名, 域内功能前缀2功能信息，域内注入式前缀的来源列表::[(向上父域层数>=1 -1所有,再向下子域层数>=0，-1所有)], 虚拟与否，域内继承式式前缀的来源列表::[域功能前缀的全局功能语义名(#虚拟-开域功能前缀-只用于此处#)])
            #开域功能前缀+(闭域功能前缀标示允空+闭域功能前缀)?+域头功能前缀标示允空+域头功能前缀
            #   域头功能前缀标示允空 用于 与 允省的 闭域功能前缀 区分
            #(有闭的开域功能前缀+闭域功能前缀)-自动组合出:
                * 有闭的开域功能前缀
                  ==开域功能前缀+域头功能前缀标示允空+域头功能前缀
                * 无闭的开域功能前缀
                  ==开域功能前缀+闭域功能前缀标示允空+闭域功能前缀+域头功能前缀标示允空+域头功能前缀
                  #直至 父域 结束
                #
                * 闭域待中继的功能前缀:
                  ==闭域功能前缀+域中继标志
                  #既然有 闭域再中继的有闭的开域功能前缀/... 为何 还有 拆开版？
                  #     方便 插入 噪声，注释掉 整个 中继块
                * 中继的有闭的开域功能前缀:
                  ==域中继标志+开域功能前缀+域头功能前缀标示允空+域头功能前缀
                * 中继的无闭的开域功能前缀:
                  ==域中继标志+开域功能前缀+闭域功能前缀标示允空+闭域功能前缀+域头功能前缀标示允空+域头功能前缀
                #
                * 闭域再中继的有闭的开域功能前缀:
                  ==闭域功能前缀+域中继标志+开域功能前缀+域头功能前缀标示允空+域头功能前缀
                * 闭域再中继的无闭的开域功能前缀:
                  ==闭域功能前缀+域中继标志+开域功能前缀+闭域功能前缀标示允空+闭域功能前缀+域头功能前缀标示允空+域头功能前缀

  =====
  内外前缀集切换产生的问题
    为何有 蛮冠？由来
      为了从 蛮区 中识别出 闭域标志
    为何 前置 蛮冠？
      如果 只有 闭域标志 需要 识别，自然不必 前置
      但！
      一来，闭域标志 可能输入出错，后置型 蛮冠 无法 发现 这种错误，稳定性/容错性
      二来，可能 还有其他 功能前缀 需要 识别
      是故 前置 蛮冠，一律特别对待

    * 内外前缀集切换 => 内部的蛮冠符号 与外部不必然一致，允省前缀 也不必然一致
      需要 内部蛮冠 前置 以识别 特殊的/非字面值的/有局部语义的 块:
        "内部蛮冠-局部语义块"
        ==>> "内部蛮冠-闭"
      开 也前置 蛮冠 则:
        "外部蛮冠-开 ... 内部蛮冠-闭"
      但 形式 不统一，不利于 搜索
      ==>> 开 后置 蛮冠 则:
        "开-内部蛮冠 ... 内部蛮冠-闭"
      内部允省前缀(预处理之类) 如何？
        "开-内部蛮冠-内部允省前缀 ... ... 内部蛮冠-内部允省前缀-闭"
      域头功能前缀/域头命令名 如何？
        "开-域头外部命令名-内部蛮冠-内部允省前缀-域头内部功能前缀-负载 ... 内部蛮冠-内部允省前缀-内部功能前缀-负载 ... 内部蛮冠-内部允省前缀-闭-域头外部命令名[可选匹配]-可选负载"
      外部父域蛮冠、外部允省前缀、中继 如何？
        "外部父域蛮冠?-外部允省前缀-开-域头外部命令名-内部蛮冠-内部允省前缀-域头内部功能前缀-负载 ... 内部蛮冠-内部允省前缀-内部功能前缀-负载 ... 内部蛮冠-内部允省前缀-闭-域头外部命令名[可选匹配]-可选负载-外部父域蛮冠?-外部允省前缀-外部中继标志-开-域头外部命令名-内部蛮冠-内部允省前缀-域头内部功能前缀-负载 ..."
        拆开形式:
          "外部父域蛮冠?-外部允省前缀-开-域头外部命令名-内部蛮冠-内部允省前缀-域头内部功能前缀-负载 ... 内部蛮冠-内部允省前缀-内部功能前缀-负载 ... 内部蛮冠-内部允省前缀-闭-域头外部命令名[可选匹配]-外部父域蛮冠?"
          "外部父域蛮冠?-外部允省前缀-外部中继标志-开-域头外部命令名-内部蛮冠-内部允省前缀-域头内部功能前缀-负载 ..."


  ===
  局部开域标志 -> (闭域标志, 静态全局功能前缀集群名)
    含 连续解析 整个组 的 能力，不含相应闭域标志的后续部分
  静态全局功能前缀集群名 -> (继承[静态全局功能前缀集群名], 新增(局部(静态全局功能配置名列表(开域标志2闭域标志+静态全局功能前缀集群名, 单块功能前缀2静态全局功能负载名+终止...)，允省前缀集2静态全局允省前缀名, 中继..., 蛮冠前缀2静态全局蛮冠配置名))
    含 连续解析 的 能力，不含包围本域的闭域标志
  静态全局名等价关系

  静态全局功能配置名列表
  静态全局功能配置名
    含 解析 整个原子功能部分 的 能力，不含 蛮冠、允省前缀 的 解析
  ====块间关系
  原子 = 单块原子 | 组原子 ###冠组原子 | 蛮组原子
  组原子 = 开域块(-域-闭再开域块)*-域-闭域块
      | 开提前闭域块-域
      | 开域块(-域-闭再开域块)*-域-闭再开提前闭域块-域
  域 = 原子*
  ---块内关系
  块 = 单块原子/开域块/闭再开域块/闭域块/开提前闭域块/闭再开提前闭域块
  块 = 块所在域
  ====
  解析一个隔离孤立的块所需要的解析环境:
    历代带参数的域内块的全局格式名::栈<域内块的全局格式名<参数> >
    要解析 本块 的前缀，就必须知道 所在域
    因此，要有：当前域的 域内块的全局格式名
    假如 是 蛮区，我们 还需要 知道 蛮冠标签，以区分 字面值数据/蛮块 与 功能块/冠块
    因此，要有：当前域的 参数
    假如 是 透明作用域 或 where域，则必须要有 父域信息
    因此，要有：当前域的 祖辈信息 即 整个栈
    闭域块 的 解析 相对复杂，可能需要分成多步，于不同域 分步解析 一部分



类型 关系 结构 类似
  比如：repr 与 check 都用到 类型 构造
    repr4mapping(repr4key, repr4value)
    checker4mapping(checker4key, checker4value)
  比如：tester 与 proportion 与 grammar? 都用到 与或非
    tester && tester
    prop && prop
  这一整套接口，没必要重复实现，抽象出 ops4env
    ops4env.mk_worker4mapping(worker4key, worker4value)
    ops4env.mk_AND4worker(lhs_worker, rhs_worker)



writing
escape-header:
  ##################################
  regex'\{\[\}\d*=\]'
  ##################################
  regex'!\[\d*\]?'
  ![]? -> ![0]? -> ![1]? ->...-> ![9]? -> ![00]? ->...
  4 chars act-as '\\'
  excape-char:
    ![]?{x:XX}
    ![]?{u:XXXX}
    ![]?{U:XXXX_XXXX}
  ##################################

e ../../python3_src/seed/recognize/cmdline/简化版命令行前缀型解析器.py

注释
  一门语言，要是 经常 需要 注解 才能 避免歧义，让人看明白，这门语言，如此 依赖 注解本身所用的中间语言，是否 多余？
  一本经典，要是 需要 大量 注解 才能 彰显 笔者的意图，让人看明白，这本经典，如此 依赖 注解者的领悟力，是否 只是 噪声？
    #能否 验证 注解的正确性？

在新民，在止于至善
  人名-取名方法
    我是在至少两次看到『秦明月』这个名字（娘山108星少女[她酷的像冰],召唤美女军团[写字板]）之后，才有意识地使用寻章摘句法来取名的。
    寻章摘句-胡不喜，胡畏威，杨宇内
    谐音-秦寿，杨巅峰，任来凤
    易经-地雷复
    拆字-易日月，走己起，武止戈，胜月生，好女子，妙女少
    药材食材-使君子 花生仁
    其他-应声普雷老母，钓雷老母，动摇仙子，雾妖碧莲，三奥碧池，绝缘子，滚轮王，
    官名/职称/封号
      陆虞侯-林虞
      舒婕
      婕妤jie2yu2？还贵妃才人呢，这倒霉的名字是怎么取的？
        --又是叠声名，看来作者是个直男癌，歧视女性。--那...婕妤怎么样？优雅动听。
  两百两，注孤生
  梁山伯
    山伯？河伯？伯，长，长官。梁山神？

  知止vs知道vs知本
  zai?宰/庄/载/安/裘/糜/巫/幸/裴/胡知止 赵知道
  丁知止-知止而后有定
  药生尘-何愁架上药生尘
  宋知本-必也使无讼乎

$ cd /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/重命名/
$ ls */* | grep 百家
小说天堂txt-2/《百家姓》.txt
小说天堂txt-5/《百家讲坛全集》.txt
小说天堂txt-6/《三字经·百家姓·千字文》.txt
小说天堂txt-9/《传统蒙学三大读物之一：百家姓 》.txt
view /storage/emulated/0/0my_files/tmp/xxx/阅读app备份json/\[20211017]阅读app备份json/myBookShelf.json
view /mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/小说天堂书名归类-细分类成.txt
  ('小说天堂txt-2/6711408086647.txt', '《百家姓》')
  ('小说天堂txt-6/69841426857276.txt', '《三字经·百家姓·千字文》')
  ('小说天堂txt-9/197581621868988.txt', '《传统蒙学三大读物之一：百家姓》')




奥秘心理学
  "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-9/《奥秘心理学》.txt",
  ('小说天堂txt-9/6081408086512.txt', '《奥秘心理学》')
  奥修-静心


逻辑学
  "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-9/《逻辑学》.txt",
  ('小说天堂txt-9/115001438307942.txt', '《逻辑学》')
  足够 潦草随意，特别适合跳读粗读
  曾经 接触过 国内的 数理逻辑，难啃得让我昏昏欲睡，导致长时间不试图去了解逻辑学。后来机缘巧合，由lambda函数到类型理论到PTS(纯类型形式系统),ECC(扩展的实构演算),HoTT(同伦类型理论)，直接跳过命题逻辑、谓词逻辑，以致于混淆过这两概念。自此一直以为逻辑学就是讲的演绎推理，完全务虚。看了这本书才知道原来逻辑学还挺关注实践应用，花样不少。

大学解读
  "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-1/《大学解读》.txt",
  ('小说天堂txt-1/32611410761048.txt', '《大学解读》')
  三纲八目
    明明德/新民/止于至善
    格物致知，诚意正心，修身齐家，治国平天下
    ===
    儒家 首重『格物致知』，外物入人心，人心定人事。
    而 佛经 常强调 心诚心敬，要礼遇要供奉，直接从 诚意正心 开始...
    教育 越来越抽象，务虚的人多，务实的人少
  知本
    但愿世间人无病，何愁架上药生尘。
    听讼，吾犹人也，必也使无讼乎
  何为本？何为末？
    八目 是 目标么？
    终极目标 是 本，中间目标/子目标 是 末/手段/途径。
    到底是 修身重要，还是平天下重要？
    修身的原由是什么？为了家国天下？
    平天下的原由是什么？使人身安心安？
    只有终极目标不能变，其余目标手段皆可变
    国破家亡 不可接受么？找借口对付过去，心安理得者大有人在。
    终日劳碌奔波，心烦气躁，人憎狗嫌，当真就不是日常生活么？既非圣贤又非大人，鄙陋小人 过得便不是生活？


国史四十四讲
    "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-1/《国史四十四讲》.txt",
    ('小说天堂txt-1/196701621696139.txt', '《国史四十四讲》')
    传子-嫡庶-宗法
      三圣王 禅让:
        大灾大难期间，推举 首领 尚贤
        太平世代 尚稳: 夏朝 家天下，周朝 嫡庶之制（立子以贵不以长，立嫡以长不以贤）

马伯庸笑翻中国简史
  "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-6/《马伯庸笑翻中国简史》.txt",
  12('小说天堂txt-6/63241425105262.txt', '《马伯庸笑翻中国简史》')
  五德
    尚啥色:
      * 成本:是否大众化
      * 质量
    黑:极致高质量
    赤:极致低成本
    黄:折中
  祭神如神在/祭如在
    即使是 关于本世界的奇幻设定，也得认真对待的，好好争执一番。
    ===
    想不认真，可能别人会强迫你认真
      要不要 祭祖？祭天？
      采用 什么礼仪？什么说法/来源？尚什么色？还是随便来，自我作古？
      祭祀 毕竟是给活人看的，周围的人认不认同？
      当主流认可 五德时，你想无视 也不容易。
祭祀 就是报告会，看似听众是先祖，其实是臣属。

蓬门今始为君开
  日后再说
  切勿操之过急
  宝剑赠佳人

千家诗
    "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-2/《千家诗》.txt",
    ('小说天堂txt-2/4271408085621.txt', '《千家诗》')
  六经注我
    褒贬 全看读者的立场：
      南朝四百八十寺多少楼台烟雨中
        曲直地表达了诗人对统治者笃信佛教、广建寺院的不满--千家诗
    六经注我 的 两种途径:(*)只摘取看得顺眼的，无视其余；(*)依照自己的立场观点理解进行解释并膜拜。


美得令人窒息的唐诗
  "noteUrl": "/storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-2/《美得令人窒息的唐诗》.txt",
  ('小说天堂txt-2/68441426397298.txt', '《美得令人窒息的唐诗》')
  山居秋暝/终南别业-王维-维摩诘经-维摩诘居士
    想要物质精神的双重胜利，或者假装精神上的胜利，成就别人眼中的精神上的胜利。



('小说天堂txt-1/75231429087163.txt', '《楚辞》')
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-1/《楚辞》.txt
('小说天堂txt-2/29231408901293.txt', '《离骚·九歌》')
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-2/《离骚·九歌》.txt
    文本质量太差，漏字，拼生僻字...不如《楚辞》
  《九歌-国殇》身既死兮神以灵，子魂魄兮为鬼雄。
    生当为人杰，死亦为鬼雄
  《离骚》名余曰正则兮，字余曰灵均；
    正则表达式
    所以名“平以法天”，字“原以法地”。同他的生年月日配合起来，照字面上讲，“平”是公正的意思，平正就是天的象微；“原”是又宽又平的地形[7]，就是地的象微，屈原的生辰和名字正符合“天开于子，地辟于丑，人生于寅”[8]的天地人三统。这在今天看来，只是个巧合，原无所谓，可在当时却认为是一个好兆头。 
毋意毋必毋固毋我
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-2/《论语》.txt
      ok
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语讲义》.txt
      good详细
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《《论语》全集》.txt
      ok
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《朱熹《论语集注》》.txt
      ok
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语精讲》.txt
      节选
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语别裁》.txt
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语疏证》.txt
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语禅解》.txt
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《于丹论语感悟》.txt
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《科学家论语》.txt
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《于丹论语心得》.txt
  ##################################
('小说天堂txt-2/9011408087262.txt', '《论语》')
('小说天堂txt-3/19061404728368.txt', '《论语讲义》')
('小说天堂txt-3/197441621868968.txt', '《《论语》全集》')
('小说天堂txt-3/197451621868969.txt', '《朱熹《论语集注》》')
('小说天堂txt-3/198601622473853.txt', '《论语精讲》')
('小说天堂txt-3/31381409678325.txt', '《论语别裁》')
('小说天堂txt-3/8981408087256.txt', '《论语疏证》')
('小说天堂txt-3/8991408087258.txt', '《论语禅解》')
('小说天堂txt-3/57651421896729.txt', '《于丹论语感悟》')
('小说天堂txt-3/64091425281788.txt', '《科学家论语》')
('小说天堂txt-3/9001408087260.txt', '《于丹论语心得》')
  ##################################



('小说天堂txt-1/70201427001656.txt', '《周易》')
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-1/《周易》.txt
    导读 部分 相当仔细，利入门

find /mnt/m_external_sd/000edt/0my_files/novel/ -name '*逍遥*'
view ++enc=gbk /mnt/m_external_sd/000edt/0my_files/novel/《逍遥小书生》（校对版全本）作者：荣小荣.txt
  第91章~第120章 完全缺失
    第91章 我家小姐有请
    第120章 如仪视察
    其实只是错乱，120前插，缺93，后面章节连续残缺


writing

mro-prototype原型
protocol
DONE:简繁 伪对称字
  风雨雷 电?
  行，彳亍成行
  水？
  白？玄？黄黑赤青
  帝王皇
  天土大人
  日月？光
  田园风光
  登？祭？
  变量
  只需用于某个
  类
  背景音乐？
  子？女？
  草木本末
  井田
  亮丽风景
  杀 同 面？回 从 穴
  空穴来风
  心意？
  我？余
  卐卍
  鼎立
  至？于
  支
  view script/简繁对称字.py
    view ../../python3_src/nn_ns/CJK/CJK_pinyin__ucd/chars_3980.py
    view  script/简繁对称字.py.out.completed_chars_3980.txt






素食:
  荤
    害命:畜禽鱼
    轻伤:鹿茸
    盘剥:鸡蛋
    死尸/濒死/老死
  素:
    害命:蘑菇、青菜、五谷、微生物工程(酵母发酵)
    轻伤:茶叶、瓜果
    盘剥:花蜜、燕窝
    死尸:石油化工
  纯工业无机物合成有机物:
    ...



鱼塘:整区养一次性捞，缺点是出货不平滑，消费却相对稳定；整区养多期共存，缺点是打捞需要区分出大鱼，网眼大未必好使，而且说不定要覆盖整区。分区养，一区一期，循环收割，缺点是水体空间利用率低，优点传染病寄生虫防治隔离简单。回溯，像是无籽香蕉无籽西瓜，可以培养出回溯性的食用鱼，够称时自动跳出鱼塘到指定地点。
电饭煲-按下加热，但指示灯在 加热与保温 之间跳动(实际状态确如所示)，指压面板(直径方向)竟然能稳定在 加热。
不能用开水和面，否则会烫熟成小块面团疙瘩。
  [我的酸辣甜面团]大量水与大量面粉一起搅拌，容易出现面团疙瘩，需要碾碎揉碎，可以这样:
      ##佐料:大量温水+大量糖+适量盐+酵母粉+大量花生仁+辣椒粉/味椒粉/花椒粉/...+适量醋 #蒜蓉？油？脂肪？[xxx五香粉]
      先倒大半盆水，往里加一点面粉，用平板饭勺搅匀，压碎小块面团疙瘩，再加一点，循环；
      等液体变粘稠，倒入面粉在一侧，搅拌粘液使之粘上一层薄薄的面粉，不断蚕食。
      渐渐固化后，直接用手揉，右手按盆左手揉，右手勺清理左手与盆底盆壁，左手清理右手勺；
      揉成大团，以面粉铺底，不断吸收，没必要吸收完所有面粉。
      短时间猛火蒸 不如 长时间开关式加热保温开水烫


秋冬春夏？
白黑青赤黄
金水木火土
金木土水火

生<火<毒

writing

御驾亲征
  太容易，显得大题小做，胡闹，正德 平 宁王
  艰难惨胜甚至大败，劳民伤财大损权威，土木堡 大败


鞭炮-造反跟放鞭炮类似，能听个响就值了。表达异议而已。

相思
  --想...她？--是她们。


莫须有
  公道又不能除恶
梦蝶
  贫困潦倒->美满幸福靠想象->社会如何才合理自身怎样才舒适->旧思成梦->梦境清晰有条有理恍若置身->人欤蝶欤


经验劝说
  没干过这事，说得头头是道，可信否？
  干过没成事，也一堆经验，值得参考否？
  成功起飞，自信满满地营销，焉知不是大风吹的？


重男轻女:
  --说某地重男轻女，想必是错不了，不过主要矛盾恐怕是贫困。经济好了，很多问题都不成问题。


世袭罔替:
  研究 大人其家族:
    若 长盛不衰，则问其原由是好是坏:
      * 门阀结党垄断买办邪教 等等 则打压
      * 反之 则宣传推广效仿
    若 昙花一现，则问其病所在:
      ...


自保:
  个人自带武装力量还是很重要，特别是出使外邦，否则可能成为蟊贼的受害者，或遭受池鱼之殃。

得失:
  将士兵训练成服从命令没有思想的工具，可以加强对外部谣言及逆风悲观情绪的抗性，但对高级军官无效，增加了内部军官叛变的可操作性。
  智力+信息，忠诚+富足

养寇自重
  --不动我，小乱；动我，大乱。一对比就知道，是谁在制造麻烦。

盛世: 可能是吹出来的，可能是比较出来的
守信: 评价个人守信与否，要看是否一辈子践诺；评价一个国家有无信用，要看是否所有官员有信用政策连贯。朝令夕改，人亡政息，党外有党，党内有派，国家的信用可疑。

熬资历:
  凭功劳加官进爵？若是上级无人亡故离任降职，哪来的职位？若越级提拔或顶替成为常例，则夺取属下功劳、打压优秀员工 将愈演愈烈。


缺衣少食没东西
  美貌与智慧并重？言外之意是缺德？

古人诚不我欺？
  说喝墨水，真有人喝墨水；说嚼菜根，真就有人嚼菜根。说话别那么多弯弯绕绕，老让实诚人吃亏。


同窗
  寒窗是窗，铁窗也是窗


旁人挨板:太子犯法，寺人挨板；戒赌戒毒，封杀赌场缉拿毒贩；驱蝇灭蚊，整治沟渠垃圾



--抢亲？我觉得正常人都不会接受...--(轰轰烈烈毕生难忘刻骨铭心的美好回忆，泪如泉涌，非君不嫁)--你刚才说什么？--没有...(其实我才不正常？)

咸-逛窑子
  --都说易经包罗万象，那你说说，它对逛窑子有什么看法？--君子逛窑子以自强不息？君子逛窑子以厚德载物？

不平时追求平等均衡，无差别时追求个性卓越。
    --from 明朝伪君子::第064章 骤然升官
    --  秦堪苦笑，这世道哪来的公平？“公平”二字永远只挂在失败者的嘴上，而胜利者，本就是制造一切不公平的源头，他们永远享受着不公平带给他们的甜头。


明朝抗倭-为何不驭使狗群？养狗费食？

影视剧里，婚礼上新娘跑路，这份子钱可要讨回？

做账:
  流水账，既然信息无缺，那么不比其他记账方式差。信息化时代，计算机替代手工，连耗时的差距都抹平了。
  查账，终归只是虚拟游戏，信息虚拟，左右手倒腾
    ，唯一的作用是增加弄虚作假的难度，跨部门跨主体做假账必然牵涉更多人，涉案人数 换 账目毛病数目，划不划算两说。
    ，除非 各单位各部门 批发零售 的 小贩个人 均独立记账，每一笔交易都有公证，任何 库存，包括 私人耗材、废品垃圾 均有实时更新记录。


劫掠天地成己身#邪道速成
  虽法力低微，但通过大鱼吃小鱼的吞并方式可在最短时间内提升，化解眼前危机不再不能。

差
  看似选A与选B的区别是(A-B)，其实是((A-A')-(B-B'))
  不嫁这个人，可终究要出嫁。差别只是第一选择与第二选择之间的距离。自由恋爱一时爽，婚后生活别有天地。

愿赌服输-实在是一想到赖皮以后见人矮三分难以接受，还不如一次性把脸丢个大方。



君子远庖厨
  不是读书人下厨，而是下厨的人上得起学。
    老人变坏，坏人变老


也先，额森，这谐音跑调如此离谱，意义何在？

民主共和vs独裁专制
  顺滑切换，不靠战争，优则封地兼并，劣则封地分裂，减少旧日勋贵的阻力，增强新晋先进团队的扩张力。

十指不沾泥:
  破案高手成不了刑部尚书

追什么追，人家是要自己当猎手的，当然，如果盯上的猎物脑洞大开相当猎手，装装猎物傻白甜也不是不行。

时无英雄，使竖子成名
  ##################################
  竖子成名
    《晋书*阮籍传》(阮籍)尝登广武，观楚汉战处，叹曰：『时无英雄，使竖子成名。』
  ##################################
  马陵:1.古地名。春秋卫地。在今河北大名东南。公元前584年晋景公与诸侯会盟于此。战国属齐，公元前341年齐将孙膑伏兵杀魏将庞涓于此。
    马陵书树/马陵削树
      1.《史记．孙子吴起列传》:"孙子度其行，暮当至马陵。马陵道陜，而旁多阻隘，可伏兵，乃斫大树白而书之曰'庞涓死于此树之下'……庞涓果夜至斫木下，见白书，乃钻火烛之。读其书未毕，齐军万弩俱发，魏军大乱相失。庞涓自知智穷兵败，乃自刭。"后因以"马陵书树"为神机妙算﹑克敌制胜之典。
    马陵之战
      战国时，魏惠王于公元前342年派兵攻韩，韩向齐求援。次年齐威王派田忌、孙膑率军出征。孙膑以逐日减灶的办法制造齐兵大量逃亡减员的假象，诱敌追击。孙膑于马陵(今河南范县西南)设伏，一举歼灭魏军主力。从此魏国势衰落。
  ##################################
  田忌赛马-马陵之战-不知情老弱病残做前锋溃败减灶诱敌深入
  纸面战损比vs军心民意
    老弱病残的命是命，精兵悍卒的命也是命；知情也是死，不知情也是死。以最少伤亡取得最大胜利，是功。
    保镖为保护镖的而战死，合情合理；为解救人质，绑匪要求杀一保镖放回一人质，则不能接受。上战场杀敌与被袍泽推出去当炮灰，是两个概念，连自己人都不能相信，后患无穷，流毒百世。
  ##################################
死囚 当作 人体实验耗材
酒驾车祸致死 是否 死刑，应该由 不沾酒的车主 投票表决。同席劝酒之人 是否 同罪？酒席举办人 同罪？
暗无天日-监狱
  针对惯犯，屡抓屡犯，小错不断，不算大罪，刑期极短
    可配合劳动改造，不够积极者关之
  特色极低成本，热带海底，温度适宜，剥光衣饰，单人单笼，笼体为环形罐头，狭小仅只容人蜷身，密封无光无声不知日夜，牢固软韧防自残，吃喝拉撒睡病死都在笼中，壁上奶嘴供食，上侧孔通风，下侧孔排除过高积尿，
  目标:让人进了一次，绝不想进第二次。
  ----科幻版:狱外一日，笼中十年

宗教立国
  既然打天下靠武力，治天下靠生产力，画大饼如果没有坚实的理论基础，反而添乱，败事有余，成事不足。

明明是穿越文，一个品行不端，一个扶不起来，为什么非要在他俩之间选？皇帝轮流做，也不是某家私有，甚至废了帝制搞共和不是不可想象。

反对 内战引外援，生死成败无悔，不能开恶例，哪怕此次能够善了。


厚颜无耻-魏征
  兰陵王-编剧-李世民
    #太子申生？

永结同心#身体的一部分
  寄头发？为何不寄指甲、血书？更诡异，更有震撼力。

窦娥冤
  敬天骂天，拜神毁神。
  小民敬畏，大人无法无天。
欺骗自个的人，不值一提。

如履薄冰
  只犯了一次错，被揭发还能说一时失足重新做人；犯了多次错，哪怕自首也说不过去。既然构陷有了第一次，很快就有第二次，纵然你想避风头，别人作局又岂能防得住？趁早自首，免遭陷害。


--鸡肋？无用？虽然知道是在替自己讲价故意将所求之物贬得一文不值，但感觉自己的价值观也开始动摇，真的需要么？
  驻颜、珠宝、神兵

人有百样，或无优劣，可惜你生错时代。
  开创属于自己的时代


可以将利国利民的事变成中饱私囊，自然也可以将牟取私利的事变成利国利民。

痛心疾首
  --狗急跳墙，贪官反扑。『奸人所害』？奸人是指谁？--当然是狐朋狗友。让他们清查账目，偏要包庇朋党。作为先生与举荐人，我当真痛心疾首。


欲施
  己所不欲勿施于人
  人所不欲勿施于人
  己之所欲勿施于人
  人之所欲勿施于人
  ---
  己所不欲强施于人
  人所不欲强施于人
  己之所欲强施于人
  人之所欲强施于人#饱和攻击

善恶vs贤愚
  又坏又蠢-虽然作不了大恶，却最讨人嫌。
  坏而不蠢-即使生灵涂炭惨绝人寰，也有可观处。

勤学厨艺，最终靠蹭饭过日子，这是大智慧。

求贤若渴
  折辱调教，让人家搞清楚自己的工具人定位。

挡箭牌、备胎、舔狗，净想着转正上位，连带着相应的小白文都泛滥开来，自我修养兴致高。

名利若不能使人偷懒随性，还有何用？追名逐利，委曲求全，舍本逐末。

祸福无门
  一厢情愿，何必怨人？情深不寿，当断则断。

叶公好龙
  原以为那些市侩俗气的人碍眼，想着清新脱俗之人才是良友，谁知不走寻常路的人也那么令人难以接受。

竞争关系算不算有仇？若算，没有这个自有那个，终生难免。若不算，财路断绝，国破家亡，也不该生恨。

闷声发大财，做人要低调，既然如此，也就无所谓立威，立威给谁看呢？混黑道能长久的，必然欺软怕硬，凡遇硬骨头直接跳过，只有愣头青才会觉得丢脸，非要找回场子，强按牛低头。
  歹徒怕麻烦，见义勇为者怕麻烦，受害者怕麻烦，围观群众怕麻烦。低调处理，若无其事。

以形补形，食我大屌

--我们江湖儿女动口不动手，年轻人你整天喊打喊杀争强斗狠，不讲武德。
--我要是叫一声就不算爷们！--(打折)--(惊恐)为什么没感觉？


--说轮回转世，和义和团刀枪不入，有什么不同？


折磨机器傀儡，大概是最没意思的事情之一。


--因为过于容易，所以做了没有丝毫意义，说不得还引人讥诮。吊打小孩是个成年人都都得到，小学加减法测验谁都能考满分，体现不出差距，反显无能。

--可以说苦难使人早熟，也可说是天真的孩子被保护的太好，这和身份地位财富权势关系不大。小小年纪，心机深重，这是个悲剧。

--这真是丧心病狂！--一直以来不都是这么抹黑他的么？

--奇怪，你怎么会以为换一批老爷后生活会更好？--反正我已一无所有，不能更糟，相对来说旧的既得利益者会损失更大，损人不利己，就当出气了。

人生的意义在于实现自己的价值，在于对人类发展作出的贡献，而不在于坐上某个特定的位置、不在于婚配某个特定的人、不在于与别人比较高低。

--有没有廉耻之心，与做不做无耻之事，并无关系。只不过有廉耻心要做无耻事，要先洗脑自己，或以大义，或以歪理，或以自性本恶，做过后又痛心难受。

商纣
  --最大的问题就是太过优秀。--这马屁有点冷。--我很严肃地。

--秘密？是指你的穿越者身份？没想到吧，其实只是植入的记忆，用以暗中诱导。

--所谓自力更生，与只能以我为核心的复兴，有何区别？--这就需要一个共同纲领一份共识，来衡量对错，而非站队、打压异己、效忠个人效忠党派。


画大饼，需要一块实验田增强说服力，而建立保护实验田需要武力。理想、生产、政经、军事，向来密不可分。

厌强光之夺目

天地偕力
傻逼神拳
  所谓深不可测，可能只是傻逼。
  复仇都能找错对象。反之，只杀个台面上的负责人，大肆炒作，不杀不足以平民愤，上上下下左左右右，涉案的、同类的，装作看不见，害怕揭穿了组织崩溃，又能精明到哪去？
  装逼引雷真诀
  狗屎-狗神遗物-争夺战
  变身-蓝天白云战袍加持
  笨蛋不知痛
  地名
    老土国
      泥腿子市
        土掉渣村
    二货国
      疯狗城
    小丑国
  人名
    瘪三
    地痞
    无赖
    混混
    狗蛋
    二五
    微瑕
    脑残
    智障
    痴呆
    董装
    小竖子




--为什么有的皇帝这么奇葩？--大概是装孙子装乖宝宝太久太压抑，或者被人得罪却隐忍不发，登基之后再无忌惮。

强扭的瓜不甜，邀约(劝酒/请人表演/...)不成便以为别人对自己有意见，太过以自己为中心，别人自个有自个的安排，也可能突发毛病，放宽心大家都过得轻松些。指鹿为马，天天站队表态，累不累？

就是心情不好，想发脾气，没什么由来。身份高了反而不敢太放肆。

--恶心可以战胜美丽。--可以吃吗？

--死得毫无价值？我猜作者觉得后面的剧情没他什么事，又不想有遗漏，就弄死了。

罪恶血誓vs心诚宣誓
  罪恶血誓:无需公开，只依纸面条款
  心诚宣誓:大白天下，任何步骤不得作伪，自始自终诚心诚意


科技是第一生产力--修道改命

翻译官-领悟精神，言简意赅
  『关我屁事』人言否？:
    (前情:被恶俗邪礼迫害，向外人求救)
    --人如叶，族如树。人惧老，叶有凋。无论如何贡献，人人皆老。强令落木常青，花期久固，蟑螂变凤凰，既不合理也不合适。凤凰真的比蟑螂高贵吗？凭什么用他人的审美观强加于人？即使是罪恶，只有有利于群体生存发展，那便无妨，个人的苦难只属于个人，哪怕是千千万万乃至波及所有人，所有人遭受的苦难未必是有害于族群整体。风俗旧例，短期内固化，长期看变易，取决于众，众人觉得合适就行，至于受害者不服不忿，这我相信，就如同老死，畏惧抗拒，但又如何？鞋合不合脚，什么时候蜕壳，陈规陋习众人想改时自然而然便改，作为外人，无可置喙。
    --(翻译:)关我屁事！

      #各扫门前雪vs域民不以封疆之界
      #筑室道旁三年不成
      #仓廪实而知礼节#廪lin3
      第一尊重别人，第二尊重自己。
        以斗争求团结则团结存。



--为什么？--说实话的人不得好死。--我说过什么？--你说我不详。

天生的带来的身份，自主选择的身份，哪一个在心中更重要？无数一条路走到黑的汉奸卖国贼足以说明。自己选的路，跪着也要走完。人与人之间没有太大差别，良禽则木而栖，楚才晋用，人的选择取决于后天耳濡目染。

顺民是选出来的，不是调教出来的。顺者生逆者死。

当你能掌控他人性命，是否还愿意公开技术与他人，同掌存亡权力？
  法不轻传？

比赛
  内部比拼终究还是不够真实，对外实战比战绩合理一些，但实战规模小，参赛人员少，而且也不是没有漏洞，特别是敌方可能捧出个高级内奸。

巧取豪夺？明明是众人争着抢着送货上门无孔不入防不胜防。

你打你的
  约战决斗拖延时间-死地特训-假死逃生--企图用荣誉绞死我？那就反过来让对方束手束脚。


抚养子女是动物性本能，如果这也算高尚，那因为踢伤脚趾而嗷嗷乱叫也算。


权力来源于人，为公难谋私难，改革难守旧难，提倡难禁止难。
下有对策
  鸟尽弓藏-养寇自重

孩童能够理解镜像中的人是自己，可能是通过发现别人也被倒影其中。但猫狗就难说了。

有求必应，大咒神之陨
  --若是言咒灵验，还要手脚何用！

忘恩负义？岂能让别人影响自己！
  装作遭难，九色鹿救人，捕杀。重点是我是猎人，和猎物对自己有无好感没关系。


同善恶
  --什么情况世人无善恶之别？一是总人数小于二，或唯我独尊目中无人；一是定义相同，或无本质差别。一是概念不成立。

逆天轮
  --奇怪，到底是只能经历一次的人生才是真实的，还是无限反复的人生才是真的？

尊师重道，与君君臣臣父父子子一样，显然是有前提的，先有合格的师傅后有尊师的要求，先有意义重大的道统后有重道的维护之念。

实际情况如何并不重要，重要的是自我感觉良好，自以为是。炫耀，可能起反效果令人嫌弃，但自己认为别人会看到会艳羡，就行。锦衣夜行，深藏功与名的，也一样。满足感成就感，别人知不知道，认不认可，不重要，是以转而向内，唯心。

--(看她辛辛苦苦，连情人一面都见不着，白忙一场)你不厚道。--为情所役，心甘情愿，乐在其中，凭什么说我不厚道？实话实说，缘份没到。

激将，纵然被看破也要让对方甘愿接受安排行险，是阳谋。一看破则失效，那叫糊弄。
--堂堂正正，一招一式解说分明，不行险不诡诈不欺人见识不博学艺未精临阵慌乱。--我恰好相反，除了偷奸耍滑之外别无他能，硬实力？不存在。你这是要我俯首就戮。

心动--媚惑？其实只是自己有非分之想。

忽悠--很聪明所以不会被忽悠？错！即使是小道，哪怕只是制造某种工具，具体点，比如说运输船，其涉猎范围也可非常广博，深究下去更是无底洞。聪明人只会迷失得更彻底。

最仙游
  第一百一十二章 是非对错
　　“他和你一样，想变的更强，以保护门派和自己心爱的人。可是他为了变强，却没有精力和时间去关心门派和自己的爱人。他的爱人嫁给了别人，他也没有为门派尽过一份力。”
    --南辕北辙

慷慨
  坏人慷慨，因是慷他人之慨，大话空话；常人吝啬，底线不可退却。
这种动物，对接近者无差别攻击，只为自保，不能说凶残，只能说智商不够。但是人情多伪，坑蒙拐骗，智商高也难保不上当。一视同仁即是无可奈何也省却许多烦恼。因为凶戾好斗，终究还是被人灭绝。但是，纵容温顺近人，多的是被人肉食，结局不是灭绝就是圈养。所以灭绝非战之罪，只是因为人类很强大人类很凶残罢了。

--什么是春药？--其实就是发春了，以春药之名掩饰。

你现在厌恶害怕这样的生活，将来却还沉迷其中不能自拔。


门派制式法宝炼器房
  --为什么不让进？--空的。--为何挂牌？--门面，别派均有。--没有就是没有，掩耳盗铃欲盖弥彰，当外人不知？--当然不知，我们又不让人参观，再者门人也不缺制式法宝。--制式法宝怎么获得？门派任务贡献点兑换清单上没有。--自己去买，当然，门派鼓励掠夺，弱肉强食。--难怪本门是邪派。--何必以人度己！

『让』，并非无私，只是成全他人之私。
  天道无私，人却不能无偏。割肉饲鹰，人否？

白蚁蟑螂，自然界清洁工，加快物质循环，人们希望长久储备口粮，建筑恒久，但光攒钱不花商业会崩溃。蚊子蝙蝠，配合病毒，加速跨物种基因交流。人们不喜欢生病，但没有战争的世界其发展轨迹难以想象。

杀人:慢慢杀，将其亲友逐一毁掉，掐灭希望之火。

--屈身投靠，静待自乱，名正言顺地鸠占瓜分。--你这么肯定会内乱？

？因为妻子被杀，所以将凶手整容催眠成自己老婆抵命？？？

死刑--反对死刑！有果必有因，被杀自然是恶报，就算今生无辜那便是前世孽债。--恶报？确实是！正因为，破案有难度，死刑还不够坚决，总有鸟人说三道四，如此恶报正是我们围观群众纵容的结果，被害人想必也曾是其中一员。天下谁是无辜之人？！

听话
  有的人试图理解话语的含义，也即言者的意图。中心思想。
  有的人试图辨别真假，虚构的东西显然毫无意义，越是深究越可笑。鸡汤文，有毒。
  有的人试图返本还源，考据历史，认为人造之物、之言皆出于真实，无论真赝。比如：愚公移山，『愚』者『禹』也，乃自辩之言。革对汤疑，所疑者，禹跡；所辩者，桀祸。智叟前笑而后疑。下面应接续『网开一面』。
  ---
  考试，一是自己通过测试明白自己是否掌握学习要点，一是组织对个人的摸底，只有对人群的能力有大概统计，才能作出合理决策人才培养分配。

重宝轻人
  --人质换宗门重宝？比如说皇帝北狩，割地赔款行不行？社稷为重君为轻，一寸江山一寸血，再选个皇帝就行了。可能掌门都没有足够的权限拍板交换。--重宝轻人，看看这就是满口仁义道德的正道。

人定胜天
  --为何要嫉妒进而迫害？--你走在路上，于道旁摘花一朵，以为最佳，继续前行，发现更好，但不能弃而再摘，又不愿自己只能得个次品，只能践踏之。没有更好即是最好，即使摘到的是最差一朵花也无妨，人定胜天，尽灭余花，便是第一。--为何不该换评价标准？比如：规定『只有自己手中的才是最好的』？人人都是最好。--经不起比较碰撞。


出家
  --交流、传承，都是人道特色，隐者孤寡，不现人迹。--修者不是有师承么？道教佛教也可是出家人。--出家？有师有徒，有一群师兄师弟道友故交，比在家还热闹，如何不是在家？若离了血亲之家，便算出家，那兵役至老也算出家，被拐卖人口也算出家。

车:必需:轮(能动而无轮-船/雪橇/腿/翼/...)，板(乘客载货，无底盘-滚石？)，动力系统(推手/拉杆/...，有底板而不能动-屋/笼/...)。

轩辕之丘:
  生于公元前某某年，那时还没有公历。楚庄王干了啥事，他生前还没这谥号。生于中山市，那是后来改的地名。
轩辕
  传说中的古代帝王黄帝的名字。传说姓公孙，居于轩辕之丘，故名曰轩辕。曾战胜炎帝于阪泉，战胜蚩尤于涿鹿，诸侯尊为天子。后人以之为中华民族的始祖。
轩（軒）
  xuān
  古代一种有围棚或帷幕的车：轩驾（帝王的车驾）。轩冕（卿大夫的车和礼服是分等级的，借以指官爵禄位）。轩轾（车前高后低称“轩”，车前低后高称“轾”，用来喻高低优劣）。
  有窗的长廊或小屋。
  门、窗、楼板或栏杆。
  高：轩敞。轩昂。轩然大波。
  〔轩辕〕ａ．传说中的上古帝王黄帝的名号；ｂ．车辕；ｃ．古代星名之一；ｄ．复姓。
  姓。

  笔顺：一乛丨一一一丨

辕（轅）
  yuán
  车前驾牲畜的两根直木：辕马。车辕。驾辕。南辕北辙。
  旧时指军营、官署的外门，借指衙署：辕门。行辕。

  笔顺：一乛丨一一丨一丨乛一丿乛丿丶

投鼠忌器
  --如果我晚来一步，他们一样会死，区别是抓不到现行犯，少死一个妖人，为什么要将他们的死算在我头上？

托付:冒险之前托付珍宝转交家人，问题是：能否活着回去？回去之后身负重任有无精力安排交接？漫漫长路如果适逢危机是否私用？


世上并无风险与机遇，只有弱者的不安和觊觎。

黑脸红脸，欲擒故纵-总有人想害朕:
  兄暗示招揽，以招婿表支持。妹高傲不屑。展露头角之后，兄打压似乎忌惮潜力。妹面露欣赏，暗施援手。玩得一手好套路。

日常用度vs半生积累体验奢侈一把:会员制:隔离区

大-发散，小-趋同
安保、技术攻坚+理论、产品研发+适配、拓展策略+人才，组织+宣传

火灾现场，乱糟糟的，无组织无纪律，逃命救火低效。秩序，生存保障。

献礼-赶时间拖时间凑个巧-朝三暮四-耍猴


强奸？你杀人的时候会先取得对方的同意？

骗术:扁鹊见蔡桓公而旋走#桓huan2

靠自己？别指望子孙？可笑！没有代代积累，始皇帝凭什么一统六合？

迷
  有朋自远方来，不亦乐乎？除非成千上万，一一打招呼都能把人累坏。
  权势熏天，过眼云烟。
  随缘拜访偶像，被拒，后来听说对方由于怠慢自己而处境艰难，『吾不如韩信多矣，竟未能料此』，召见之。

--你恶贯满盈--我英俊潇洒--你杀人放火--我有钱有势...


黑道的最大问题是你再成功，你手下、你手下的手下也很难跻身一流。

我手下的手下是恶霸？看来我也是。

小气偏装大度，打眼了装作捡漏，发现被绿更在人前卖力秀恩爱。

以随便之名，随机选择应对策略。

翻译
  --竟然坐在草坪上，上面可都是狗屎！--他说你是狗屎。

气质？杀气贵气书卷气？有没有傻气？那我岂不是有被人一眼看穿傻逼本质的风险？


算命-注定一贫如洗？那就试着提高穷光蛋的生活水平吧。

明明是爽文，偏偏还斤斤计较，小气得很，没点敢叫日月换新天的情怀。
  --宗教倒是大话连连，现实中坑爹的要命。



身不由己
  既然选择了霸道一途，就不能再收敛锋芒，否则不能完全发挥自己的优势，收获小，潜在的代价却更大，十分不值。


治疗胃胀: 喉头往外铲气-下沉、封闭、上升、打开，循环

武王伐纣
  --以小伐大，众人信心不足，这才要占卜靠天意增强合法性，但会不会弄巧成拙适得其反？--放心！卜筮是一码事，解释是另一码事，还不是全凭我一张嘴？我可是神棍，专业的！--[龟甲灼烧崩裂大凶无需多言]--...[太公决断]...[武王早逝，周公订立嫡长制]
复仇、行医、...在犹豫中一步一步深陷红尘，当初因此被革出门墙，还心存万一，『一入红尘误终身』，不后悔但遗憾，彻底放开，肆意干涉俗世，在各领域成就非凡，再不回头。


对赌也好，争论也罢，站队最重要的是别丢脸，作为少数派，赢了更拉风，输了也更显眼。

古玩捡漏、彩票中奖、投机倒把成功...一将功成万骨枯，且不说本人前期学费能不能回本，光是背后无数失败者无人瞩目便足以令人戒惧。倒是拍卖鉴定抽水等配套服务赚得盆满钵满，正是那个淘金故事的写照。
倒卖，计较涨价风险，只有有刚需，能把一桶屎喝剩一口，哄抬物价；把玩，在乎特殊意义，能把一桶屎熬剩一碗精华，细细品味，悠然回味；炫耀，吃一口倒掉一桶，高喊再来三桶。


原来我才是反派！
  世界早已误入歧途，现如今不过是在拨乱反正，然而对于生在畸形世界中的人而言，世界恢复正常则是末日。



大梦宗-大梦谁先觉-捕蝶

我本无形天赋形，我本无性人赋性。



祈祷
  --老祖宗说啥？
  --『没事多供烧鸡，有事别他妈烦我！』

长相恨-长相难看？令人遗憾？

老贼死来-君生我未生，我生君已老

与天斗-先天桎梏、发展路线；与地斗-生存依凭、修缮迁移；与人斗-

哪有什么正邪对错？不过各行其是。以己非人固然有偏，然则明悟身不由己扮演不同角色，或自怜自艾，或迷茫无前，或以人非己，或沉溺虚无，又何全之有？故知智慧之无用，悟如不悟，觉如不觉，乃失自然，甚或不如。
  清官难断家务事，很多事只是抉择不同，并无优劣之别，天生百样人正是要一一演绎不同人生。

修道的目的是什么？以之为用，蓄养家畜长而宰之？好而乐之，如沉迷黄赌毒？用，若环境长久不变，则必满足于某种程度的『够用』，止步不前。


天上地下唯我独尊-神我-你该死了-老-曾经成功以后必选，不再探索，曾经错误，不再重蹈，不再怀疑；新人试错，老人循例，浪费不死，如常当亡。

所谓命运不过是自己的抉择，何神秘之有？谈何敬畏？
无事献殷勤非奸即盗--也可能是人之将死其言也善，再无保留地传艺。

非是大量洪荒凶兽灭绝结束了洪荒时代，而是洪荒时代结束导致洪荒凶兽灭绝。
  以血脉而自豪者，不免一天亦因之而卑贱。
  真实之眼-天衍-反噬-反噬之反噬-天地崩灭-洪荒时代结束-伏羲/伏牺[以力证道，气运八斗]-抹去第三眼，卜卦算命之术也仅限于贞卜吉凶
  与其说是昔日天地间的主宰霸主，而今失势，倒不如说是曾经的天之骄子而今失宠，更确切地说，是昨日天地摆弄瞩目的玩偶，而今被丢弃。我们人族也会有这么一天么？修仙问道正是出于对命运的反抗。


大道小道：无处不在是谓之大。三千大道，相互混杂，实不可分。名可名非常名，三千乃人心分野，大小乃见识高低。

审判也是一种仪式，重点在于令人信服，进而团结群众。

零食-重点是 包装方便拆开 小包装解馋非填饱
九为数之极，偏偏却是十日凌空？
示范-刻意的完美-不自然而不完美-平平常常实用即可


灵气有毒，过于浓郁，连低阶修士也会死。
自取灭亡
  嫉妒-打压未名-成功族类危，失败己身陷

与人为善？团结友爱？兼爱非攻？强调集体？仁者爱人？若是理念不同，也就是『作恶多端，杀人盈野』的追求，你要如何对待持有这些理念的异端？若是依照仁爱宽恕的理念，则应当包容他们，毕竟不能仅仅因为理念不同就相互攻伐。但此举对受害者而言又算什么？若是禁止作恶，即是禁锢不同理念，不允许做，哪怕允许想象讨论，可此措施对于希望作恶的人又算什么？虐待异端、放任异端、禁锢异端，至少有一样不可避免，而采取其中任何一项措施的话，又有何面目说『兼爱非攻』？
单相思
  相思-相互思念？
  单相思-单向相互思念？
规矩
  自己总会给自己立规矩
  但，人虽能理解外部所施加的规矩的合理性，却未必愿意接受；人虽给自己立下过规矩，当下却未必愿意遵循，更愿搞个漏洞百出的临时规矩以规避繁琐的细节，将来总要还的。
  希望别人遵守合理的规矩，但自己不能接受#双标

保暖御寒
  假设 外界气温变化的长期均值 适宜
  通过延缓气温变化的传入，有望在传入途中便趋于均值
    长期:整天，整年，整个纪元
小包装-酱菜
  有钱-一餐多个菜
  没钱-一餐也吃不起大包装#除非多人合餐

买药治病
  买药治病吃出毛病，怪谁？
    * 本来没病或小毛病，偏要瞎折腾
    * 没能对症下药，误诊
    * 药店卖劣药假药
    * 没眼力，认不出假药
    * 偷工减料买劣药
  ---专利/与民争利/弭谤/死荆公，士绅vs百姓vs黔首


公平-一视同仁
  --from 帝尊[宅猪]::第0107章 天才间的碰撞
　　关于云鹏此人，洛花音也有所了解，他刚刚拜入山门时，打算进入武圣阁，却险些被诛妖镜诛杀，幸好当时掌教至尊席应情镇住诛妖镜，否则他当时便被炼化在镜光之中。
　　他的血脉不纯，半人半妖，所以才会引起诛妖镜的炼化，因为他又有一半人族血统，所以席应情决定网开一面，让他进入武圣阁中。
　　在武圣阁内，云鹏一路通关，一直打通了第九关，引发武圣阁异象。但是席应情因为他血脉不纯，不愿收他为弟子，最终云鹏只得拜在蓝山道人门下。
　　云鹏成为圣宗入室弟子之后，也是修炼普通的功法，与其他人无异，但他从青丘天宫强者之墓中走出之后，便将自己从前修炼的功法废去了大半，实力也变得更加强大。
  ------
  惺惺作态，虚伪，既然接纳，何不一视同仁？到底还是歧视。培养奴隶炮灰，何不明言人分三六九等？

火之门
  火同
    薪火相传虽说是重要的特征，但即使是独立起源，此火与彼火并无不同。
  火毒
    活毒，生命就是火，无限演化的潜力，其中之一成就得窥大道的十二祖巫之一。
反杀
  --又有人被反杀了。继续追杀！他报复心极强，必定不会远逃，仍会伺机偷袭。分开搜索，诱使他出手，拖住他，我会及时支援，护得你们周全。--(这不是之前我忽悠别人当诱饵的话术么，想不到这么快就轮到我受用了)

不堪-天劫
  --人道礼法有何可鄙？须知人道也是天道，天道于一时一地一事一物上的具体显现本来如此。
  --他为何如此失魂落魄？--靠山崩塌，王朝覆灭，游刃有余所御使之规则烟消云散，信仰崩溃，他的凭借、他的天塌了。--我们的天又是什么？我们的天会塌么？天塌了我们如何？--这大概就是天劫了，我们又能如何，怕是没什么两样。
天变不足畏，祖宗不足法
  这功法开篇目中无人，内容里条条框框却甚多，这也忌讳那也有害。...原来是要自己去突破这些禁忌桎梏！

网络小说 穿越打脸 常见桥段--寡嫂被调戏。问题出在哪？守寡？不能保持单身？不能脱离家庭而生存？不能脱离人类社会而生存？

--我不服！为何要限制手段！能赢就行！--这只是比试选拔，不是死斗(结党、场外招、一次性珍贵道具，无下限)，团结友谊为先，连敌我都分不清，还比什么。

刁难的，帮扶的，并无不同。在意别人的蔑视，也必无法拒绝别人的奉承。
热热闹闹很好，清清静静也很好。
讲人情权宜无视规矩、拿规矩砸人 的 是同一批人。

失传
  失传未必是坏事。有些技术一旦扩散开来，会导致无序竞争滥用，竭泽而渔，与其如此，不如敝帚自珍，宁可失传。

戴罪立功
  出了错，生气泄愤迁怒严惩株连，并不能解决问题，还是得认认真真地补救善后。
避难所
  --这设计看起来不舒服。--本质上是个避难所，使用内部贡献点作货币，垄断对外贸易，集体饭堂，集体澡堂，集体厕所，大通铺...个体户？私灶？...不存在！--说不定住很久。--若是需要长期避难，更不该考虑享受。

圈子-贡献点
  货币
  资历
  职位
  职称
    履历
    竞赛获奖
    立功
    发表过的论文的引用数
  人脉
  (论坛里)知名度/论坛等级/经验值/虚拟币/精品贴

国境线
  --(移动国境线标识，暴打，拍照)这场冲突的开始，他们先跨界的

喜欢
  --你究竟喜欢我哪里？脸？若是变丑还喜欢吗？性格？若是性情大变还喜欢吗？志同道合？若是分道扬镳还喜欢吗？若是变成男人还喜欢吗？若是变成牲畜还喜欢吗？若是变成石头还喜欢吗？何必是我？
    剥下脸皮，拒绝骚扰
    后续-窃取 脸皮，施法诅咒

闲云野鹤
  灵芝#蓬萊有路教人到，應亦年年稅紫芝。
  --若是天下动荡，只怕想做闲云野鹤也不行。--恰恰相反，若是真到了『普天之下莫非王土』的境地，才没有闲云野鹤的生存空间。
    盛极而衰-世外干预


有权不用过期作废
  对别人犯罪不是犯罪，对自己犯罪才是。别人都捞你不捞，等于吃亏，等于被别人剥削，是对自己犯下不可饶恕的罪行。
此刻已是巅峰
  人的优点会被逐渐磨去，没有优点的人才是成熟的人。
  曾经宽和，如今计较
  曾经无畏，而今怯懦
  曾经灵慧，而今呆板
  曾经自省，而今责人
  趁着年轻好糊弄多忽悠几个，看破不说破才是真的明白人--捏造史实/传销/传教
    为何谣言没有止于智者，智者反而推波助澜？
  忧虑-养虎为患
    若是受助者会反过来害你，你还会帮他么？
    若是技术被人习得反过来坑害发明者，还愿公开吗？
    若是避免这种恶意的估计，反过来受助者、学生将来会是你的战友、贵人、救命恩人，又如何？

舆情大杀器-反噬:一旦用来抹黑别人出错，从前的定论必然遭到质疑，所有被打压的势力联合一起反扑。


--治疗饥饿，肚子饿了就吃是治标，把人弄死才是治本。--活着一定要吃吗？『吃』是活物的核心特征吗？

与人相处难，与自己相处更难。我发现自己一直恶意满满。

--(看到贫寒帅哥后不无遗憾)为何智慧、外貌、身家不能并秀？--说不定有权有势之后，会变得眼高于顶，变蠢，变丑。



上界空降的观察使？我让你下不来台！（实行保甲连坐，管控户籍人流，压制商贸物流，监控言论书籍。）(化身凡俗，不得显圣人前，也要谋生守法不让人察觉异常)


山涛？之子？
  不愿出仕杀死你，认真做事罢黜你。

十大校花之类，也只有小说里才能虚构出来，现实中即使再沉迷声色的人也不会搞这种排行榜，要排名当然先得遍察一番，如此费心费力的事，如此浮躁的风气，实在不搭调。

扫地恐伤蝼蚁命？
  傲慢自大，自欺高尚，自我陶醉，刻意表演虽然观众只有自己
  世上有自杀弃世的人，有甘做贱民任人宰割的人。以己度人，觉得这人困苦不堪，需要他人援手。蝼蚁哪里弱小？可以预见人类灭亡，却无法预见蝼蚁绝种。若针对个体，帮得了一时，何如帮一世？像鸟雀一样笼囚，防止网罟免受极寒，如何？一生若非由己而造由己而受，不如作泥石，不如作腐尸。雷霆雨露俱是天恩，替天行道者，何其无礼！世上有逢场作戏的人，有言行不一的人。听到他人抱怨哀嚎求助，便信以为真，以为他人真的在求助。其实，就像妓女总会察言观色，说些别人想听的话，想听奉承的便得吹捧，想展现仁慈的便听到命运的无奈。叶公好龙，人们哀嚎虽然可能出自真心，却非实意，真要不堪忍受早已自觉行动，哪里还有心情表演哪来还有空闲等待？


独立完整必重复冗余，精删冗余系统性集中统一注释分析区别则必然出现长距离依赖层次深深有碍观瞻。


九漏鱼-九年义务教育漏网之鱼-这神兽名取得好
  教会孩童认字写作，学校还欠学生什么？不欠，又不是技校。知道如何结网，临渊不必抱怨。
为何我又蠢又坏？我这么愚蠢，却偏偏喜欢瞎想，这是人生中最可怕的错误。
可怜，眼睛看不见，脑子被人填满。
  分类需有严格的逻辑内涵，类际要互斥，诸类合起来要周延。例如『思维四种：第一种是理性思维，考虑问题注重公正的社会规则，强者能获利，弱者有机会。第二种是以利益为考量，有利就做，无利就躲，这叫成熟思维，无可厚非。第三种是以喜恶为标准，喜欢就干，不喜欢给钱也要偷懒，是幼稚思维。第四种是以别人的利益为考量，不惜恶化自己的生存环境，是奴才思维。』显然不知所谓，只是以自己的喜恶为标准，凑够字数，自觉有模有样。依其自身观点，是为幼稚。
  说话之前，要学会思考。
  用自己的价值观衡量别人
  --别人恋途受阻，成熟的人不会玉成其事。--她是我姐姐，两情相悦...--连结婚这点小事都摆不平，将来婚姻注定不谐，还要赖你一辈子。
    钱大均？欧阳小姐？
  『怀疑：如果只是想相信什么，是不需要读书的，如果你怀疑什么，那就需要去书里寻找答案了。』这句话其作者匠心独运，暗示不得通过自己的眼睛去观察社会，不得以为自己的脑子有用，不得亲自动手来尝试种种可能，令人疑窦大起，对出版商心生警惕，完美点题。

大道横陈，何必想他人取经？南辕北辙，大缪。
  人生的终极目标要自己确立，别人指引不了；体悟大道只能靠自己吐纳，别人给不了。
父母对子女的付出不是无偿的，所求回报不外乎:
  * 延续自己的作风理念信仰事业荣光。忠贞之士不能忍受卖国淫乱的后代，精明的人不能接受任人摆布愚弄利用的子女。
  * 作为自己的第二生命，在新的起点向今生未克的心愿发起冲锋，或探索今生放弃的另一条路另一种生活方式。
  背负着沉重的期许，鲜有放任自流，果真如此，恐怕是没被当作子女。


信仰某某
  --为何强调某某是善良仁慈的？若它其实不是，或者某天不再是，仍信仰否？若继续信仰，为何捆绑强调？若不再信仰，则何不直接信仰仁慈，提某某作甚？听到某某之名者是否便得福报解脱，未听到者是否便注定迷途无知永世沉沦？既然自我的努力如此卑微，活着有何意义？某某代表人们思考，代表人们活着，不就是完美？何不去死？


狗娘
  --是人是狗很重要吗？


无可无不可
  不反对歧视，反对无端的歧视，歧视的依据是什么？要做到何种程度？达到怎样的预期效果？这三者是否真实合理？之间是否无矛盾是否环环相扣而非人为拼凑？


坐而论道，平等相待，不要高山仰止，心怀恭敬也是一种偏见邪见，造神与丑化本质实无区别。即是论道便是道友，哪来先后哪来高低哪来门户？千万年前不算先，人文科技蓬勃发展不算高，你的主义我的法门左一个外道有一个嫡传大道无疆道在屎溺之中，得鱼忘筌得意忘言。
  佛经之前，多有编辑者强调静心洗手心怀敬仰云云。由此可见，金刚经反复提及福报，强调供奉，大谈做个录音机很不错等等，十分可疑，所谓如是我闻，只怕也流于形式。名不符实，言行不一，实多矣。
  人们常拿三千世界、一碗水八万四千虫、末法时代比照现实以证明佛法真实不虚，而我觉得这些全无意义，不能说明任何问题。这些即便是真的，与所思所辩可有干系？所谈者务虚，所举例务实，大缪。更何况这些务实的例子模棱两可似是而非，又兼精挑细选粪里淘金，实乃神棍骗人粉丝团灌水之常用手段。
  争论 般若毕竟性空 唯识胜义实有，还不如争论战斗力，狮虎、秦朝罗马 猴子大鹏 之类。胜负的评判标准是什么？目下影响力？古代权威站队？不论以何种标准裁决，该标准或者说建立该标准的基石岂不更为基础可靠？还争什么，改信该标准算了。若无标准，何必争，各信各的，反正不沾边。一谈神佛强调仁慈智慧法力无边，不如改信仁慈智慧法力无边，关神屁事！发展信众强调福报，不如改信福报，追名逐利，拜官拜金，偶像顶屁用！恐吓非议强调恶报，若是政教合一，喂人吃屎那也没法，如若不然，口头恐吓三岁小孩？！金刚经字里行间都是福报供奉，是要不到饭了吗？
    蜗角之争，蛙蟆胜负
  凡事靠祖师爷说来辩论，什么真传秘传，老来精进推翻前论，什么确立为根本不可更改，难道学习修行只是为了成为应声虫？若连自己的独立思考与创见都没有，究竟还要争什么？不足与论道。
  法必待传而修，则不修也罢。道必待言而明，则不明也罢。人蠢至是，人盲至斯，何望为？录音机，两脚书柜，竟不知道。另有知道者，然实为修他人道，终成应声虫，他人分身，势同被夺舍。

一本关于马的书
  我只是想了解马长什么样子，期待第一页就是一张马的全身图。谁知一开头就是马是怎么进化而来的，接着，马对人类的重要意义。。。
    公平地讲，内在逻辑相当严密，有条理有层次
  另一种让人弃书的编排是，直接将大量马的局部细节图糊读者脸上，繁而不要。
    公平地讲，公正无偏


虚必不实原则-文字游戏排列组合符箓咒语精神胜利自欺欺人
  人物现象仅由只言片语搭建，实难说得上真实
  历史虚无？历史造假多？历史记载比之实际嫌少？然而又真又多也无用，连谣言都扛不住更多谣言，当信息多到无人能遍阅，自也无人问津。
  打倒假权威假经典，就要用它们的逻辑它们的方法构造另一套系统，既然不同，说明并非唯一，同一个现实系统对应两个不同的虚拟系统显然不可能。若是质疑，则任何指责皆可移花接木至目标，同归于尽。
  人们奇怪地迷信一些毫无依据的信念。比如，美国宪法简简单单七条便有200年盛世。问：把美国宪法扔猴群里，它管用吗？将美国隔离到火星上不与其他国家接触，它兴盛吗？美国对外战争操纵舆论颜色革命种种看不见的罪恶对内屠戮异端洗脑愚民鱼肉底层。。。又如：共产主义必将实现，因为马列主义是科学的。而证明之方法极为幼稚可笑，因为一次失败便说某路在中国走不通，至于工农革命自是要百折不挠，嘴上反对君权神授，自己却搞起来。又说只有共产党才能救中国，不过是宗教救世主的翻版。对于古代的、远方的、力大的、想象中的未来的、及其他各色各样的想法，总能强行以虚作实，视同真实的科学的必然的和谐美好的东西，迷之自信，自欺欺人。
    不跪过去的英雄圣贤，不跪意志坚定忠恕客观道德无暇的自己，不跪远方的天国桃源，不跪子女后生。人的一切理念，皆是自造的木偶泥塑。
    宗教领袖坏吗？弟子蠢吗？戒律虽陋，不过是担心有人搞不清状况。明事理的人知道谁对他好做什么事有利，看破不说破。不明事理的人何必瞎想挑刺，误人误己，徒作害群之马。
    寇可往吾亦可往。成功的社会团体总是类似的，失败的则花样百出，不要惊讶。
    圣人不死大盗不止。
      武器即是尊严，放下武器即是放弃尊严性命。文人的武器是嘴炮笔杆，武人的武器是枪杆大炮。被人说得跪下，与被人用枪顶着跪下，并无区别。屠杀与教化，同出而异名。
  智慧、感情、勇气 都是人们的幻想，一些相对通行的世界观设定。
  做正常人？首先捏造了一个虚假的概念『正常人』
  没有人需要他人救赎，人人皆可自救。没有人能够拯救他人，人人只得自救。没有人需要他人指导，没有人能够指导他人。--知者不言，言者不知。



人们非议小国寡民，以为愚民，自己向往并沉迷于甘食美服，整日闲聊八卦的生活，千万年的努力终于赢得猪圈。
亲故相助是情谊，路人援手是道义，群众旁观薄讽天经地义，宵小落井下石浑水摸鱼是利益，管你什么功劳背景，抱怨无益。

--既定论能胜彼，又预言此战败，是想说会遭暗算？

--吾师并无道号，观亦无名。--凡尘袭扰，看来离得不够远。


嗷嗷独啸犬也欣，何必成人自夸灵。
人工运河
  人体经脉是生而有之，还是如同人工运河全凭自造？
八卦-理、象、数 之 象
  研究字形，读音因时因地而变实不重要。研究字义，字形通假借用异体同义因时因地而变实不重要。研究章句本意，单字字义避讳改用别字版本繁多实不重要。研究整书义理，章句错漏杂乱附加实不必斤斤计较。人生通达齐家治国，尽信书不如其无，览其大略无需了了得意可止。观天地简而作象，方生方死易学易用，如此而已。
  除开 乾坤，余下的 六卦 可如此解释，只有 孤爻 是 焦点中心，另外 两爻 只是 陪衬，用以 标示 孤爻 的位置：
    兑/艮 - 阴爻/阳爻 在上
      -- 在什么之上？地之上，故是 泽/山
    离/坎 - 阴爻/阳爻 在中间
      -- 在什么之间？人之间，故是 火/水
    巽/震 - 阴爻/阳爻 在下
      -- 在什么之下？天之下，故是 风/雷
  乾坤，天地定位，是说 区分 阴爻/阳爻 的 爻性，即 在 具象系统 中的 定性。
    #空茫茫乌何有处，以心所求定我天。
    定性，相对性，大小高低，五行...
      关注的少数，焦点重点即是主要矛盾
      余下的多数，噪声绿叶即是次要矛盾
      重点 是 乾/阳/孤，余者 是 坤/阴/众。
      落到 具体卦象里 多寡轻重缓急 则可能 与我们目下所关注的 不同。
        关注的焦点不同，推论则不同，歧义由此而来。
          泽山-末、僵，智仁，夭寿
          火水-正、劳，思学，虚实，体用
          风雷-初、潜，内外，废立
          --某某和某某不同？--大不同。
            虚必不实原则
            病变、药变、人变、天变-同病病原在变，草药药效在变，人体素质在变，环境气候在变，单单只有药方不变是不可能的。在实践中产生，在实践中修正，因地制宜与时俱进。
            命题在形式系统中能否推出 与 其否命题 的 推出与否 实不同。
    说一物，是说一类物，相似之物，依此理而显示相似之物，没有判断的理念则无所谓相似。
    说一事，是说一类事...
  象 是 类推 的 基础。凡物有象，只有能够 合于 八卦之象 才能 归类 进而 类比推理。
    演绎推理 只能 建筑于 归类 这一地基之上，它本身无可无不可，无所谓对错。归类 起到 实虚映射 的桥梁作用，而后 才能 搬弄概念，是是非非。所谓 道理 所谓 规律 永远只能作用于 类 这一概念层次，不可能针对特定的具象事物。
    归类？会不会 爻辞 其实 类似 ？日知录？本身驳杂无序，后来整理时借用二进制八卦编序？
  古人 认为 凡物之象 不脱于此，故而 八卦 可用于 归类 万物。易，一切变化皆归于简单，万变不离其宗。
  --这还挺容易的--是的，浅显易懂，没有更多内容了。
    连山易，星宿 方位对应身周山头(甚至屋檐)，以明 日期(一年之内的相对日期)，得意忘形(明白道理，舟筏可弃；知道简明易懂的应用捷径，之前复杂的观测推理皆可不知，便于推广应用)
    --不是说 还有 数 吗？--(学 数，三生万物，世间万物是否也是如此？)...--等等，按照 数 的推理，卦 可以 十分繁多，显然 超过 八卦 的 象 的 归类范围！
      数 先天八卦 天南地北 逆时针/左旋 依次为 乾兑离震1234 8765坤艮坎巽(<-右旋) (低爻为二进制高位)
      九 即是 全(三三井田)，全即一，变 之极
      六 处 二四 八十 之间，稳 之极
      重卦
        块-相邻同性爻组成块
        单块 2
        单块+单块 2*C(1/5)=10
          唯一的变爻之间的间隙
          五间隙选一
        单块+双块 2*C(2/5)=20
          五间隙选二
        双块+双块 2*C(3/5)=20
          五间隙选三
        双块+三块 2*C(4/5)=10 对应 单块+单块？
          唯一的同爻之间的间隙
          五间隙选一
        三块+三块 2
        ===差分？考虑间隙的爻性？变化的内在联系？
  斧
    礼器凶器
  经卦vs别卦
    经卦 三爻
    别卦 六爻
      下/内/贞 vs 上/外/悔
    错卦=反卦=旁通
    综卦=倒卦=覆卦
    本卦vs之卦(本卦变爻之后的卦)
    互/互卦/互体
      三体-二三四爻组成的经卦
      四体-三四五爻组成的经卦
    息卦vs消卦
      12个，坤-复-临-泰...-乾-姤-...
      息卦=复~乾#阳息阴消
      消卦=姤~坤#阴息阳消

  变卦
    我来设计变化原则:
      * 选中 第二底块之底爻，即 底块上侵，或 选中 底爻(增加变化)；由外而内自上而下综卦反演？块中心爻变？概率分布递减？
      * 挤进新底爻，原卦爻皆上移
      * 任选一爻
      * 全变为错，五反？
      * 旋转为综，
    单爻变-三爻卦


  夏商周三代三易，秦汉之易？长生、五德？新中国 历史表明 某某在中国走不通 必须...君权神授，政权天授
  五帝谁在谁之前？怎么自相矛盾？是尊号？不同时代多人同称？不是？那就是同时代？也不是？耍我？
  --一言以蔽之，无用。--太好了，就学这个！--？--追求功用，劳劳碌碌，有害身心。无用者无害。自以为是，才有趣。--这是病，得治。
  易-这本书书本身-假设是竹简
    时、位
    时间方向一:竹简上下
    时间方向二:纬线右左
    时间方向三:一易一版，连山归藏周易三易
    平面方向一:天地定位
    平面方向二:遐迩有别
    读者思维时间方向:
    读者焦点吉凶方向:
  文王拘而衍周易
    为何不在受拘前衍？孔子为何不在年轻时玩索？
    都是穷极无聊打发时间
五行
  被研究的目标系统在其相对稳定的合理时效期间:
  金:贯穿性的透彻性的，完全了解的部分
  水:范围全体的浮沉所有的，未知的或不关注的或超过当下研究能力的部分
  木:折叠复杂度
  火:类似活物的不断增殖的部分
  土:稳定的结构
阴阳
  阳:物形成之前，过去，形而上，无形抽象，奇，天，动
    ??里/远
  阴:物形成之后，未来，形而下，实在具体，偶，地，静
    ??表/近
  三才-横向切分
    九宫
    井田
    九州
    高低
    三进制-空间
    奇数-以表达寡多贵贱高卑主次
  两仪-纵向切分
    日月为易--??参同契
    四象~?~四季
      ?少阳-春，老阳-夏，少阴-秋，老阴-冬
    二进制-时间
    二 是 基本，四 体现 进退/变化趋势
    缺一:缺的就是人，现在的人。将人分隔，探索的是相对性


道
  --道无处不在。--虚空中 有道否？
  尊位 虚假否？团结就是力量，集中力量才能办大事，如此重大的利害，众人不能不理会。既要团结一致，谁来决策？全体决策？人数众多可能难以实现，更何况智力有高低，兼且众口难调，最终必然是少数人决策。尊位固有，不因称谓而异，这就是道。

咄咄怪事
  唐朝以诗取士，现今运动员为国争光？这到底是啥逻辑？
骗子证道
  虚必不实原则，道可道非常道，真理必是废话，有用必非真理，一定要在实践中不断磨合矫正改造创新。
  由技入道，干政，五鼎烹，终老公开
    以前论说均系胡扯，而今证道，假亦成真
  因地制宜与时俱进，毋意毋必毋固毋我
    行骗需赶时髦，当下人们信什么我们便谈什么，最忌不思进取吃老本。
    从无到有作出新断言，推理断案，只凭亲疏喜好利益立场？判断需依凭实证。
    自己已做之判断，前人之判断，在全新的条件下，或新的证据下，要反思。
    原则性坚持？哪来那么多原则？故步自封傲慢无礼的门户之见，揣测人心防人过当的偏见，不愿摧毁熟适的旧格局旧理念的惰性。
    迁怒株连、二过，自我为中心，全不理会别人的感受。邻居杀人你受株连，能接受否？己所不欲勿施于人。礼仪繁琐，例事冗杂，能忍受否？指鹿为马，广告扰民，...，欲与不欲皆勿施于人。
    ---
    何必固执？攻击异端？
    何敢胡扯？名异神似？
    何须怀疑？非此即彼？
    何用包容？即此即彼？
    人之修行，止于己身，前人论述，草长莺飞。

  高处不胜寒
    借力打力
    忽悠激励，类比引导
    发现人才
    培养人才
    再无比肩之人，再无借力之所，为山九仞，最后一篑还是得靠自己。我能于不了解的领域引导专家，实已触类旁通，只是惯于行骗，从未想过当个创造者生产者，或者说这违背了行骗原则，跨出这一步就不再是骗子了。五鼎食五鼎烹，大丈夫当如此。
  ===
  后世质疑，临终自证行骗是他人伪造？自己开玩笑？是唯一一次行骗只为迷途的骗子指明人生方向？
  严禁诋毁？控制舆论？为尊者讳？
    真即是真，罪即是罪，为古人操心，不是指鹿为马强迫站队显示权威，就是试图愚弄群众牟取非法暴利。



道可道，非常道。名可名，非常名。无，名天地之始。有，名万物之母。故常无，欲以观其妙。常有，欲以观其徼。此两者，同出而异名，同谓之玄。玄之又玄，众妙之门。
道可道非，常道。名可名非，常名。无，名天地之始。有，名万物之母。故：常无，欲以观其妙。常有，欲以观其徼。此两者，同出而异名，同谓之玄。玄之又玄，众妙之门。
  老子我说，道可道非，常道。名可名非，常名。产生各种各样有的没的实的虚的现象(的原因)，是一般的客观规律；就好比定义形形式式合理的不合理的概念(的原因)，是人们一般的思维。人们依照身周物类成败推广而区分得到万物有无这两个概念，至于是否合理就不要计较了。实践中，一般通过纵向对比某个部件的缺失与否，以考察该部件对于整体的功用；若确实存在有趣的功用，则再通过横向对比部件之间的联系与区别，以了解各部件的特征以及这种人为边界的划分是否合理（合并或更进一步细分？）。有和没有，虽然名称不同，但它俩是从同一个地方同时产生的成套概念，在实践中也是秤不离砣。一整套概念进而编出另一整套概念，这就是一切令人愉悦的扯淡骗稿费之根本大法。
    老子我说：开宗明义，此书旨在凑字数。



士农工商 轮掌天下 五德终始？
  武人的天下/渔猎牧
  神棍的天下/文人的天下
  工农的天下/匠
  商人的天下/艺人的天下




新词汇
  蛋是
  茶新，船新





当教师成为一种职业，当医生成为一种职业，当士卒成为一种职业，当领袖成为一种职业，当官僚成为一种职业，当父母成为一种职业，当学生成为一种职业，当子女成为一种职业...
  画地为牢，按图索骥
闲聊-谁有空和你闲聊，有事说事被逼逼-工作-心分二用摸鱼-别人闲聊我想私事-心分三用不行
剖析自己-送课本-课堂纠错-仇视对门-轻信-乱涂鼻屎被举报批评-伪装畏惧眼光-不能接纳新事物无法融入新时代-陈人-轻狂粗率不可一世


我们可以制造智能机器人来替代人类劳作吗？既然可以奴役机器人，为何不可以奴役人？不过是当成牲畜工具，减轻自己的工作量罢了。诚然没人希望被人奴役，但，奴役别人并非不可接受，只要区分开就行，一个群体自己不至于畏惧自己人而分裂就足以奴役另外的人。



增强药剂
  提升人的一倍力量、速度...指的是你，只是当时的你。

私下找刺客？太蠢了。还有什么比官僚系统更好的杀手组织？让官府背书杀人，公开，翻案困难，持久，即使最终翻案，也怪不到你头上，干净。

醉
  一切生命皆醉倒，停止呼吸，开始了漫长的朽化过程，既不会被啃食，也不能腐烂。


最严厉的处罚
  --对祖师爷不敬，当处以最严厉的处罚：逐出师门，永不得提及师承。


法律 逻辑自洽 尊重事实
  重婚罪 民不举官不告
  嫖娼 换皇后 即使规定一次只能有一个皇后，也不能阻止一天换一个
在人与人的对抗中，本来也没有必胜法。
  商场、官场、造反...
  焉知所谓『科学』的战略战术不是后人眼中的『迷信』？
  比对手更靠谱，赢面更大 就算不错了。
  孙子 知己知彼，庙算
    虚实结合
  毛主席 实地调研，利用不对称性的人民战争
    特殊前提『不对称』，将论题由一般性的『人与人的对抗』转移到特定情形，『没有必胜法』这个结论也就不再自证其明。


一切规范只能规定正常情形，不正常的情形，一切从权，一切皆可被践踏，规定了也没用。所以看到规章，则当明规章力所不及处。



凭借-桎梏
  财富-依赖于社会-上限也受社会桎梏
  修行-脱离社会，自行一体，但未必能脱离物料资源，脱离理智。
自行一体，三尸

视力差
  离远了看不清，离近了不感兴趣，深处其中看不到。
旧衣服
  --为什么总穿得破破烂烂？--这衣服还穿得，我还要如何？扔掉它吗？永久雪藏吗？
--千万不要掉地上，会变成垃圾，很快消失不见。--有什么不同？


结婚？好好看清楚自己儿子究竟是个什么东西先！主观上没准备好害自己，客观上没准备好害别人。己方如此，彼方也够可疑。
高看低估？不想被看到，但又希望所处群体不被践踏


待遇-赖着不走
  --你这里工人的待遇为何这么差？
  --我嫌弃它们，但又不好意思说出口，不断地降低待遇，试图逼走它们，谁知它们毫无自觉，赖着不走。你说它们怎么就这么贱呢？

家人vs外人
  --为何如此严苛地对待同胞，却宽待外国人？
  --严于律己宽以待人，正因为是自己人，才必须要有更高的要求和期许。
  --为何内销产品，其质量反倒不如外销的？
  --因为是家人，所以随便。因为是外人，一切只讲契约，不谈感情。
  --好！说得太好了，我判你无罪！

--励志书籍？为什么你会看这种东西？为什么会有人看这种东西？到底能改变什么？--时间！是时间！我们需要填满时间，悠闲地不费力地不费脑地用垃圾埋葬过去，埋葬现在，将自己埋葬，合情合理合法。这是最大的默喜。一种享受，省事地打发时间，等待死亡，等待极乐，多么怡人有趣的生活，多么精彩纷呈的一生，因为不需回顾，不能回顾，无暇回顾，一切都是完美的，连遗憾和苦难，都能捏出笑声，乐事无处不在，只要善于挖掘...

--你这混蛋，这么多年了，你要是认真倾听，早该被我吵疯了。要不，你就是毫无人性，没有感情。你见我分身少了，声音也小了，这说明我就快死了。--你不是早死了吗？--死亡也是多层次的。--(一个声音)那是不是说看起来我活着，其实是另一种意义上的死亡？说起来，我也很久没有超越自我的感受了。(并发的另一个声音)你说你快死了，是不是意味着将要获得新生？那会是怎样的？(并发的又一个声音)我分些分身陪你聊天吧......

不论如何描述颜色，无法令盲人赞同
  --为什么人们总喜欢拿恋爱这事作喻体来解释难以说清的体验？--这就跟逻辑学中的矛盾可以证明所有命题一样。


观察 记录 思考
  太初，观察 记录 思考
  但是 变化太快，光是 观察 记录 便已耗尽时间，无暇思考
  后来 记录文档太多，光是 转录维存文档 便已耗尽精力，无暇观察，无暇通读。


--我还是没搞懂『天气晚来秋』的意思，这语法正确吗？--语法？你跟我说自然语言的语法？它不是法，只是对已存在的语句进行归纳总结，将来还有越来越多的新句式出现。

他心通
  刺探隐私？突破交流障碍？实无意义。他人的隐私与我的修行无关；若是双方有意交流，则障碍不成障碍。


风动
  一开始我以为是风...
  不是我答错了，是你觉得我错了。


以礼器当凶器？也不是没有道理。毕竟也有将凶器当礼器的前辙。
  前例，前科，前轨/前辙，前规/前矩/前式/前武，前鉴/前戒

以貌以言
  赶工期、纸面数据好看...牺牲质量，花费更多精力成本于 外观、广告、统计数据...
帅哥美女、老板
  不想回应，因为明显叫的不是我，但不回应又得罪人，多么恶心的称谓

小说靠想象，要么强者恒强，要么弱者开挂，从来没意识到纸面上的实力虚妄不实，要不怎么说『一切反动派都是纸老虎』？


赢得很取巧，赢得很侥幸，赢得很勉强，...。总要让对方心存希望，这场比斗才能正常继续下去，不会横生波澜，最后心甘情愿地接受失败的结果，而非觉得被下套愚弄，心生怨恨。


当你真的有能力重置时空，弥补过失遗憾，这一切又显得毫无意义，只不过是一幕幕已编排好剧情的表演。

--竟然为难这些凡人，你的修行只怕也只能止步于此。--要么燃烧寿元讨生活，要么自找乐子打发时间。与修行何干？
--到底是敌是友？--以死报恩，重生则复仇。

修仙小说，高阶修士不过是大个的蚂蚁，十分无趣。皇帝锄田用的是金锄头？

境界越高，同阶修为的实力差别越大。不论战胜过多少同阶修士，也不敢保证实力居于同阶上游，更别提同阶无敌，所以贸然结怨动手。

功法:同境界更长寿，则未必更好进阶，平均寿元未必更高。

境界
  得形-先天天赋
  得意-后天技巧
  得道


扶危济困，恩将仇报
  --竞争，哪里没有。所谓同胞兄弟，厮杀起来，与外来者并无不同。以此为由而排外，并无道理。至于说扶危济困，或者保持多样性，也实无必要，因为并无不同，这些人与我们并无不同，其死活也无关紧要。

为何是 百世姻缘？不是 千世万世无量世？俗世王朝 末代动荡 民不聊生，国祚是剪。凡人临了，僵衰弱呆。是否 第一百世 将会 夫妻反目，尽断前缘？

神位
  位置永存

积怨

前言不搭后语，口不对心，言行不一，自相矛盾，精神错乱，这样的我，有几分该赖环境？
  破除迷信，纸钱香烛
  科技创新，武侠修仙
  工业兴国，歌星影星


--强敌在侧，危机重重，你要我此时度道心劫？忧虑滋生杂念，心火不熄，年迁月引，此刻并非良机。--正要忘怀生死，方得更进一步。--问道求长生，哪里真能忘我？

沙漠绿洲
  对于寄生于北极熊身上的寄生虫来说，环境温度并不更冷，它们察觉不到大环境，更遑论差异。

朝三暮四
  是生来就注定要成为固定型号的零件好，还是自己定位合适的型号并努力将自己铸造成该款零件好？
  叶公好龙
    有的人嘴上不愿意成为零件，但还是努力让自己成为合格零件，甚至由于不达标而烦恼，一旦发现出格的人、离经叛道践踏礼俗的人、灭绝人性的人，则鄙视之、嘲弄之、仇视之。

  疼痛会时时提醒人疼痛，舒服的事态则不会让人天天舒心。受难人群渴望平常，和平下的人群却不甚在意。


横生枝节
  --为什么要撕票？我就是不想节外生枝，才舍宝救人。我这样想，便也以为别人这样想，带着人，我便有所顾忌，所以极大可能赎回人质，再不济也不过多敲诈几次，为什么？我以为野兽不通人言，无法沟通，可人还是可以的……--不仅人质要死，你也活不了。我说一不二，从来没人敢违逆，若非投鼠忌器，担心你临死毁宝，怎么可能好言相劝，绑票威逼！


--有多大的机缘便有多大的风险。--不是说很安全吗？--没危险，人们会自己制造危险。

逆天轮 的 由来
  为复活某人而制造无数世界用以模拟其生前环境，任何生物都不是孤立存在的。
  官官忘 举办 创世大赛
  --这个小世界与过去很像，……有人飞升了……
  ===
  --只是创世而已，为何要选一个掌控者（掌控逆天轮）？
  --催化剂，加速成材

孕夫
  给宝器开灵何必专找女修，男的也行，修真界没有不可能！
罪
  --我有何罪？
  --推算，提前阻止。
天材地宝出世，必然伴随某些特殊的宝气。想不到这次的宝物居然已经有了人形……人？修士？没关系，死物灵物，植物动物，皆可炼宝。机缘或功法所致并无二致。

草木
  --真好啊，活着无忧无虑，被砍伐也不悲不痛，一岁荣枯也好，千载长茂也罢，只是平静度过。
  --它不说不闹而已，你只是看不到听不到就觉得它麻木不仁，发不出声的表现不出来不明显就没有感觉没有感情了吗？

一路走来，现在，我竟然只是旁观者，前半生到底在干嘛？
  麻木不仁？有心无力？
求全知-苦且乐；已全知-无欲-不快；真正所求者何？
  人求富贵，既得，清闲，又生 富贵病。长久太平，则武备废弛。福兮祸所伏，追求的目标本身可能会破坏追求者的欲望、身体健康安全、追求所用到的手段的根基...反抗追求者的长期据有。
      反动，反者道之动
  智力推衍将极端化与现实不符
    禁止堕胎vs父要子死子不得不死vs小受大走
      实际情况是，孩童的性命受父母掌控，一个大意就可能丢失营养不良患病夭折。哪怕约法三章杀人偿命，也套用不到亲子关系上，因为实在是毫无可操作性。反之，子女长大后，要求他们无条件服从父母，也不现实。
    那只是看到的，还有许多没看到。那只是想到的，还有许多没想到。从前的经验构建了与现实对应的虚拟世界，未来的经验却不一定中规中矩，要么虚拟世界本身就有缺陷，要么所试图对应的现实完全不是原先的领域，要么映射的方法有问题。
  智力局限:终极目标达成后，还有存在的意义吗？存在本身就是终极目标衍生出来的子目标，离之，毫无意义。
  终极目标是否存在？终极目标是什么？终极目标可否达成？
    是否 不该由理智推导得出？是否 不言自明？
    是否 是低级的动物性？是否 犬儒主义？
      不是 所有 欲求 都是 终极目标，大多数 欲求 并不值得 尊重，大可归于理智统治。
      然而，究竟哪个欲求从来不受理智约束？
      似乎 并无 不言自明 显而易见 的 那么一个 所谓 终极目标，是否说明 它 并不存在？
  大学之道，...，在止于至善。知止而后有定...
      至善=止
      莫非古人也认为，终极目标=人生终结？

礼-理（情/伦/法/俗/规/度）
  草木一族，风媒虫介，与人不同

领地
  长期驻留一处，吐纳祭炼身周元气，使得一定范围内如同一个体外丹田。
出手前需要蓄势蓄力，说明爆发力还有很大的提升空间。


因为一件小事起争执，最后成死敌，修真一万年，相互设计陷害，说要放下，毕竟起因实小，可惜终究不能，起因早已不重要。
  放下，只因你再也无法对我构成威胁（我俩之间的差距只会越来越大）


--忠心耿耿？你有没想过为何只有你一个？其他忠心耿耿的人在哪？说不定都被舍弃或灭口。
  与其等泄密后疑神疑鬼，或能杀错不放过，而人财两失，不如提前灭口。


罚酒三杯
  --岂是一句『犯错』便可一笔带过！
  --人吗，总是会死的，关键是在其死前榨取更多的价值。如今后有用，则既往不咎。反之，若今后有害，则兔死狗烹亦无不可。

欺天
  自欺-欺人-欺众-欺天
    幻术-自迷心神-入侵他人心神-牢笼众生-虚幻净土-以虚衍实
  心想事成-明心门/欺天门
    --这剑怎么回事？到底用的是什么材料？
    --我的剑就是我的心。
    --仅靠心神温养，真的能将本命宝剑的材质提升？甚至达到天材地宝都不能及的程度？
    ...
    --自欺欺人，进而欺天，你还叫什么明心门，叫欺天门更合适。

天空绿色
  为何天空是绿色的？
  为何星辰固定不动？
  为何河流竖直向上流动？树干
  为何群山跑来跑去？为何大地一直在晃动/地震？
被封印的记忆
  吞噬他人神念，发现一段与自己相关的记忆，自己却记不起，被封印的记忆从外部找回，是否忽略（不实、不在乎）？是否跳读？是否研读？
安
  不显特异
    财，才，色，...
  不入危地
  不争重宝


压力测试
  飞升天劫的威力是否有上限？建造巨阵笼络整片大陆，大陆连同其上所有生灵一起飞升，是否可行？

--可有发现什么可疑异常？--（那就是 你，不过这显然不是 对方所期望的回答，必须规避这类 错误答案）...


占卜
  --龟因壳能卜而被杀，你着卜者活得好好的，肯定是不灵验吧！
  --无用即是大用，灵不灵不重要，重要的是会说话。

退而求其次
  飞升无望，退而求其次？其他人生目标还有意义么？这还有得退么？余者皆不足论。

诞生罪恶的土壤有罪否？
  你邻居杀了人，你要不要受罚？
  土壤本身并不能自主生产何物，但其特性是带有偏向性的。

不时相互封印记忆，时情时仇，最熟悉的陌生人。

等待
  等待最后一片叶子长成。平均时间？即使侥幸进阶，费时说不定比当下的树龄还长。

分配
  依照什么条件？亲缘(与分配者的亲疏)，潜力，功勋，实力（权势），声望，背景，内部竞价（财富），对外交易（不用于内部分配，而是用于对外交易）

开启新地图，便更换称谓，这样一来一旦被人提及，就能从称谓判断出自己被认知的途径。

抱团-本该开枝散叶，各得其所，谁料被迫抱团，如同零件，同模铸造，休戚与共，到底哪个方向才是人道正途？

农场主关心牲畜健康到底算不算仁慈？



或以虚与委蛇为苦，吾以坑蒙拐骗为乐

被讽刺必然是因为理亏，公道自在人心，若只是胡言乱语，群众会自发抵制，影响必小。

奢侈品-广告-穷人
  广告费多-成本虚高-性价比低
  赚穷人的钱
    手工:先收押金，最后成品验收通不过。
    招工:中介吃两头
    奢侈品:广告大范围轰炸穷人，筛选蠢货，想成为别人眼中的有钱有地位的人吗？

指间牙缝
  你指间牙缝漏下的食物残渣滋生出它们，众多且顽强，会成为你的大敌。


守株待兔-一锤子买卖-强盗/三年不开张开张吃三年的古董店-短期高收益长期低收益个人高收益大众低收益



老东西
  两初中生对话，其一问『苏联不是分裂成两个国家吗？一个是俄罗斯，另一个是不是中国？』
  起先我震惊于其无知，然而仔细想想，我对清朝民国也没啥了解。比如，清朝几个皇帝，民国几个省级行政区。毕竟它们过气了。看来现在苏联也过气了，在新一代的知识构成里没位置。我终于光荣晋级为一个老东西。


我不想负一丁点责任，不要对我抱任何期望。

书面经典 与 权威解释 最终解释权
  书面化 正是为了 防止窜改
  而 最终解释权 所在 的 权威 则 打破这一目的

--如若还其自由，必叛！--强加罪名灭杀，置于死地暗害，是无罪而诛，不可；永远奴役，欺诈拖延，是逼其反叛，不可；归还自由，虽叛，然而兄弟尚有反目之例，又有何妨？
  下属，潜在下属，在看着；盟友，潜在盟友，在看着。
    分情况，立榜样用于宣传，例外则有罪责意外。

想要认真起来，则又觉得可有可无，十分无谓。想要彻底放开，则又患得患失，反倒斤斤计较起来。
  背后说人闲话坏话，说工友亲人
    亲戚的钱才好赚
      既不信任，又何必与亲戚做买卖？
    借款给亲戚，生意出问题，催债谩骂
  村中流浪汉，拾荒露天而居，无人理会。知手足同胞为虚言。美言不可信，称誉不可信，贬损不可信。
    城里满巷小卡片（美女上门），警察如何能不知？知禁黄为虚，禁黄赌毒可疑，法律能敌潜规则否？
  既不耐烦说话及听别人说话，更不耐废话套话寒暄问候（谢谢，吃了吗）绕来绕去，结局早已注定。被人道排斥，死有余辜，只增笑耳。
    会为了钱而吵架，会为了钱而买彩票，不会有什么共同语言的，更别说我还在为了活下去而不断地给自己找打发时间的例事。


誓约
  各种魂誓、神念禁制（封印记忆/禁止回忆/禁止泄密）已经成为沉重的锁链，阻碍修行。
  魔:守言，守形
名可名
  年，地球围绕太阳公转一周，体现在气候周期性变化，树轮...
  但 怎样算一周？
  即使 能定义怎样算公转一周，可如何划分各年的边界？春分秋分冬至夏至？


货与帝王家
  培养各种才能，不过为人打工
  自己当老板，也不过是给更大的老板打工，在别人制订的规则框架下打工。
  ====
  争权夺利，固然可能最终一无所有。可是不争，就可脱身事外，不被人鱼肉践踏吗？不过听天由命罢了。



千幻仙子？谁又敢说见过它的真面目？是条公狗有何稀奇！
  夫妻多年，一场噩梦
  有大腿抱有何理由不抱？能享受特权为何不享？无论如何变化，也只是图个行事方便。

你可以觉得别人的妄想仪式信仰可笑，但绝不能无视他们认真对待的态度。其实都是接头用的暗号，认真意味着以虚妄干预现实，进而可能影响你的生死。



救
  绝望，趁着暂且还能自主自裁，谁知此时旁边传来『且慢』，还没走！还躲在这里！还有救！心声希望，是向着更绝望的深渊滑落。
  ----
  千钧一发之际正打算激发传送符逃脱，『且慢，此处空间已被封印，必须先打破封印才能传送，不然将浪费这唯一的一张传送符』

百花齐放
  百花齐放百家争鸣的时代，真的是好时代么？恰恰相反，正因为是战乱频仍的最坏年代，所有人被迫寻找改变现状的方向。有的出世老死不相往来，有的主张进攻追求武力一统，有的指望加强防御阻止战争，有的寄希望于下一代人寡欲守礼，有的通过农耕医药等细节直接改善百姓生活。

--怎么那么多天下第一？--代代新人，行行状元
  ===
  不管多么惊艳，只要冠以『天下第一某某某的传人』即显得理应如此。盖因 收徒挑剔，功法非凡。---盛名所累，能平凡乎？能幼稚乎？非得熟透熟烂卓尔不凡？


鸟尽弓藏
  以战养战，越战越强，可惜这样的功法在将来的太平世间恐会失传。
  虽然本身并不是直接血祭凡人修士以炼宝，但却需要掠夺邪道修士成就己身，间接残害无辜。战时犹可解释，太平年间依然不衰，只怕是有人暗中扶持圈养邪道修士，牛羊吃草人吃肉。
道侣
  谁说道侣只能是良师益友？仇敌可乎？禽兽可乎？法宝可乎？

皇位
  ----idea from 觅仙[何不语]::第482章 三王招贤
  --为什么？你知道，我并不感兴趣，也没相应的手腕，根本不合适。
  --我知道。
  --你一直在争，梦寐以求，就算我得到了也会让给你。
  --我知道。可惜，可争不可让，频繁易手过于儿戏。
  ----
  --半开玩笑而已。我说选皇储，可能从护卫中选，只是开玩笑。我说考察品性，却是认真的，只是未必如你们所想的。不信任即是信任。王者需要对所有臣民负责，对某个下属过分信任，就是对其他下属的不信任，对某个下属托付生死，即是罔顾其他下属的生死。监察掣肘防备制衡，实乃应有之义，须尽之责。



自相残杀
  --自相残杀，残魂苟且，与野兽融合，我看不出有多高明。
  --我辈逆天改命，形形色色，自相残杀怎么了？死的固然是我，可活下来的也是。赢的最终还是我。

鼎
  器灵-众念国-几度兴衰-看见过外界天地众生，于内界流传下无数荒诞不羁的上古传说
  ---
  其实也可反过来，有人进入鼎的众念国，将所见所闻带到外界。但不会误认为上古史。

幻化-法力+境界-仙草-一年分千万株 供能+高境界 幻虫==>>万年分一株；空间换时间
  法宝、动植、人、离体部件、神通




禽兽动画、瓜果菜蔬动画
  何必分男女老少？何必是人？

断根
  摘果毁树，饮水填井，过河拆桥
    既然我以后用不上，不如毁之。

钓人
  散发宝光，伪装宝物出世的假象，诱杀寻宝修士，打一枪换一地。只道某地域宝物有灵，四处乱晃，却谁也没见过真容。
  钓人这所以罕见，乃是因为一旦败露，人们便会口口相传，提防特定情形，于是变成攻防战，斗智斗勇，如此一来，开发高效的钓人手段收益也不高，不划算。
  社会越不平等（武装财富知识信息），人钓人则越有利可图:富有者垄断剥削贫者，机者忽悠盲聋。


散养在村里的鸡狗猪牛，即便有机会逃走也不逃，可能真当成家了。没有历史，没有沟通，麻木地围观其他牲畜被宰杀，并不能反省自身处境。

痴呆
  不必担忧明天是否有饭吃，不必在意别人的褒贬，无需供养父母，无需养育后代，无需顾虑死后埋在哪儿，虽然可能挨打挨饿受冻，可是即便痛苦也直接简单，转眼忘却或死去，几乎完美。
是名明日#明日复明日，明日何其多
  刻舟求剑-假象真相-掉落之剑真实不虚，船侧之剑虚妄不实
  带着小弟挨家挨户要钱，不歧视
  为何欢喜？听到你说了什么吗？--我什么都没说，我说我什么也没说。
  来世，明日，是名明日。反正蠢到会被『今世』『苦难』这两种假相所欺，那再欺之以『来世』『极乐』也无不可。
      蠢-信 神、彩票-韭菜
        会买彩票的人是赌博的候选受害者，国家先割一波韭菜怎么了？
  没有福德没有福报，因为他们蠢到以为有我有福有多有得，所以我说福德多，如果真有福德，我就不会这么说，毕竟我从不说谎。
  为何要灭度众生？乞食糊口罢了。
  --应礼敬供养？如此他们得到什么？否则你将要如何？--不如何，如果人们以为有祸福，威逼利诱，那是人们自己的想象，我没说过。--既然是这样，为何反复强调供养？--作文要万字，演讲要半天，愚夫愚妇才会注意到。反复重复只为凑字数。
  ---
  保生男孩，无效退款#保健养生vs治病抢救
    祈福灵验须还愿
  心诚则灵
    不灵因不诚，请加大力度，大力出奇迹
    赌徒翻本，沉没成本，添油战术
  医之好治不病以为功
    治病
      治一切病，治愈之，固然是我的理想，但无病可治，无人需治的情况可不是，没有病人，医生只能改行预防疾病养生了。
      更糟糕的还有：能治但不希望治愈就逮着一个薅光羊毛，能治愈但希望反复复发禁言预防广宣有害的生活习惯生活环境污染环境传播出售有害物，不断制造新病一无中生有危言耸听将非病说成病二制造病源。
        心忧炭贱愿天寒-棺材铺/墓地/天灾囤积...
        修自行车的 撒玻璃渣于路旁？
        做电灯的/做电器的 联盟垄断约定使用寿命上限
双方信徒吵了起来，究竟谁家偶像更加神通广大？当然是帮亲不帮理，曾被谁保护过救助过，谁的功劳便高，神通便广。受益人群有别，各执一词，到底是一家。

孰能浊以静之徐清？孰能安以动之徐生？
  如水因静而慢慢变清，谁能保持糊涂？如树因风慢慢摇曳，谁能保持安定？



快快长大。（应验）抱不动了，倒霉的孩子。

法治大抵是相对于人治而言，可就算人治不靠谱，法治便不证自明的正确么？
  我常常怀疑罪犯，特别是落网贪官，其待遇要比露宿街头靠捡垃圾讨生活的老头老太要更好。
  法-简则一刀切不能因时因地因事制宜（制宜则人治），繁则无所措手足，禁繁则通者少违者众，解释权归于讼棍。
搞封建迷信要与时俱进
  别人喜欢什么，就往什么靠。当下的权威是什么，就主动融合之。
  好古？编造玄学古籍古修传奇
  尊儒？把易经孔子编队
  谈玄？把道家编队
  礼佛？把佛像编队
  现代科学？编队之
  马列唯物辩证？编队之

君君臣臣父父子子，显然不能拆开来独立看，有先有后，先是条件后是职责。君若君，则臣须臣，君若不君，则臣不必臣。#诛一独夫

宝物
  *保卫节省时间人力物力
  *摧毁物什生命
  *消遣-打发时间

理
  言学思存之理
    人与人之间交流，不过语言文字图画音乐舞蹈动作气味食品...
    人与自己交流，不过思考推理回忆幻想...
    一切理，必经言与思，理即是人对道的理解的言论。
    研究『言学思存之理』，即可洞察一切理。
    边界外观等效
  识悟信之理
    『言学思存之理』局限于手段
    不言不思，言思之外更有他物，影响人的认知
    如何识别器物概念？如何归纳领悟规律？如何御使『信仰性格情绪反制实况』这一现象？
  气运之理
    『识悟信之理』局限于有知有念的组织个体。
    万物皆气，万象皆运，『气运之理』即是世间理。
      形成的根由，组成的成分，变化的规律
      说『凡所有相，皆是虚妄』，然而一切流变并非随意，道在其中。
        『常见』『断见』
    实体仿真
    世外理？


佛学分属人道否？在人道内，何须度？在人道外，何必度？
  #/mnt/m_external_sd/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-1/《金刚经》.txt
  #/sdcard/0my_files/git_repos/txt_phone/txt/古籍整理/金刚经[小说天堂xstt5][修订版].txt
  金刚经::正信希有分第六::注释
　　言说章句：专指「修行要无修，证悟要无证，布施要无相，度生要无我」的真理。
  ---
  须菩提:就我一个人当托捧哏，也忒省事了些吧！就不会多找几个，非逮着我薅羊毛。

  ---
  六经注我:明明只是不断重复，偏能看出侧重不同，注释者是真的牛逼。
  ---
  反复重复
    --不足万字，重写！




中国小说史略::第二十六篇　清之狭邪小说
  然自《海上花列传》出，乃始实写妓家，暴其奸谲，谓“以过来人现身说法”，欲使阅者“按迹寻踪，心通其意，见当前之媚于西子，即可知背后之泼于夜叉，见今日之密于糟糠，即可卜他年之毒于蛇蝎”（第一回）。则开宗明义，已异前人，而《红楼梦》在狭邪小说之泽，亦自此而斩也。
　　《海上花列传》今有六十四回，题“云间花也怜侬著”，或谓其人即松江韩子云〔12〕，善弈棋，嗜鸦片，旅居上海甚久，曾充报馆编辑，所得笔墨之资，悉挥霍于花丛中，阅历既深，遂洞悉此中伎俩（《小说考证》八引《谈瀛室笔记》）
  =====
  云间花也怜侬--抠脚大汉，没毛病


道岂远人
  道不远人
  掠夺之掠夺，寄生之寄生
  你的机缘就是我的机缘，这是我道。
    虽然同境界最弱，但胜在够快无瓶颈，要比就和低境界的比，杀人足够了，以战养战，杀生不死。
吾欲仁斯仁至矣
  --身不由己，非我所愿。--原来只说人话，却不干人事。
灭门-求告无门-修真界本来如此-当年门中其乐融融误我许多年

谦卑如是，言必称『老祖宗说』，我曾见过。
  修真界以修为境界的高低定辈分，初听古怪多变，但而今看来却甚合理。
  孩童之视成人，子女之视父母，晚辈之视前辈，今人之视古人，虽有先后，何有必然之高低？
  可仰望，可平辈论交，可俯视，可褒可贬
  ===
  不过，一知半解的庸才常常哗众取宠，靠胡说八道挑刺贬低别人博人眼球，自以为是，这样的人很多，很不幸，我也是。


人如猪
  猪舍猪食日渐洁净
  猪多有褒誉:浑身是宝
  影视动画多有猪的正面角色
  ===
  所谓国民富强中华复兴
  所谓烈士为民族脊梁
  文章评论剧目多盛赞牺牲
  ===
  猪不过口中食
  父母手足受害，无动于衷，终日乞食待宰
  蒙满入关，屠我汉民，称兄道弟，亲如一家
  欧美日俄，戮我百姓，命运共同，双赢发展

鲲鹏
  比，有『双』之意（比目鱼，比翼鸟）
  鲲-鱼日日-鲳？鹏-月月鸟？

人皆自以为是，包括否定自己的人。

--原来并无此号人物。--现在有了，只是不知有多少化名。

目欠阿那#身姿婀娜

移民鸠占鹊巢
四非罪
  吞、锢、乱、崩
  无性vs有我
    #浑沌
    #崩
    平等自由无差别无局限
    不自觉，无人我，无历史，泯然无知，没心没肺，无法无天
    纯种乃臆想，我辈皆杂种
    历史由人筛选、捏造、窜改、无中生有，信不如不信，有相当于没有
    兴衰与我无关，人间看客
    和光同尘，随波逐流
    都是我
      为什么世上要有这么多相似的人？其实都是我，正是用作实验的素材，以研究自身。这不是冷血残忍，只是解剖自我，探索大道。你们诽谤我，来来来，让你们看看我的心肝脾肺可有不同！(自剖，剜心，说文原用，殉道)
  不餍vs内省
    #饕餮
    #吞
    开拓进取
    欲壑难填，漫无涯际，肆意挥霍
      生产制造产能过剩，一切形同垃圾，埋没珍宝
        噪声污染、谣言四起
        伪劣产品泛滥
        语言文字声影多乱散杂
    不餍足于外物:
      弃 自强自立
        祈祷乞讨
        期待来世#异世
        坑蒙拐骗
        奴役掠夺寄生
        移民投胎#异地
          我所在处即是地狱，天堂在哪我去哪
          建设家乡神奇腐朽，我所在处即是天堂
      惧 他人强盛
        嫉贤妒能
        打压弱小，垄断封锁抹黑后起
        斩草除根，株连无辜
          养虎为患？不信任后人，对未来不抱希望，对自己的道路缺乏信心
          恃己之不败，不恃敌之可胜，不当畏惧敌人的存在与强大，而当忧虑自己的弱小缺陷
      恐 公开真相
        阴私勾当，名为大义，所谓罪恶在我一力承担不能公开。不信任亲众，口上说为你好，实则提防戒惧，视若智障儿童。
        为尊者讳
  绝通vs经纬
    #梼杌
    #锢
    整齐划一，健康长寿
    规范健康僵化长寿，井井何田田-目田术
    族群稀寡，人道基石是 人口数量+人口密度
    禁忌律法繁杂:经验理念交流，知识记录承传，运输，通婚，斗争
      闭关锁国
      一团和气，和稀泥，各打五十大板，罚酒三杯
      监控天下，保甲株连
    禁止开枝散叶，强干弱枝，钳制地方，唯恐尾大不掉。不愿散布火种，因为即使只给予种子残缺的技术，在未来漫长的独立发展中，子体仍有可能超越母体，作为两个独立的个体，将来难免再见，发生战争。
  迷信
    #穷奇
    #乱
    自足常乐，志骄意满
    是逃避痛苦？是失去感知痛苦的官能？是看不清现实的苦难？
    活在精神世界，沉迷虚拟游戏，将虚幻当成现实，无视现实或否认现实（认为是观察出错记录出错故意窜改欺诈）
      对现实无可奈何，只能躲到幻想世界里靠精神胜利法度过余生
      理想社会:净土，来世，远方，天朝，上古治世，黄金时代...
        静止不变的完美世界
        其实社会一直在发展，永远有缺陷，不可能完美无缺，也绝不会依照人们的规划运行，一切理论也不可能完备正确。
    久-经久耐用-追求稳定恒久不变-人会改变-不能依赖信任人，自己别人--寄希望于机器、法律、思辨上的满足、...
    数学 就是 历史悠久 玩家众多 的一款虚拟游戏
      设计算法，设计编程语言
    物理 分为 实验验证 与 理论假设推导 两部分，后者 虚拟，前者 连结 后者 与 现实。
    玄学:神鬼灵异，星象术数，气运风水，宗教仪式
    神话传说传奇故事...等 小说世界
    ...
    虚拟绝非现实，两者无关。但人们确实会对现实规律作出某些假设，并信以为真。一般的验证分为两步:先是检查一下是否逻辑自洽，二是实践验证根据假设推衍的虚拟世界是否与现实世界同态。所谓实践，有时只能凭借大跨度历史记录；而同时，理论又常用于辨识记录言论的真伪，这就使得虚拟的人造理论被认为有客观性，并拥有否定或拒绝观察结果的权威。注意:客观规律（道）与人造理论（理）不是一个东西，类似实物与画像的关系。
      #人能思考，这是道的体现，但人是如何理解自己的思考方式的呢？推理方面，现代用逻辑学来将人的推理形式化显式化，但逻辑学只是理，并非真是人的推理根由。
    皇苑帝乡，神国佛土，胜境仙界
      [观 神秘学 有感]谈玄说妙，解理务虚，比之纸堆书柜如何？比之收音机如何？比之逻辑演绎形式系统如何？于国何益？于人何益？于己何益？若仅止于自慰平生，不过是找说辞找借口找得体的应对。若仅止于打发时间，还不如运动运动身体。若仅止于堵上童蒙满是疑问的嘴，还不如说不知道。抢占理论高地，引导政治方向，抱团标识，神棍不仅无益。
        手印口密/掐诀念咒 - 可能 古代曾有科技先进的智能生物披着人皮混迹人间研究相对落后的异种文明，它们通过手势语音设定命令：远程通话，调派机器人作业...古人见而效仿，野心家用以忽悠恐吓普通人继而用于糊弄威慑奴隶，传而久之便是今天的手印咒术？
    辩解
      有多少言论只是在为自己的行为找借口？
      精神胜利法，聊以自慰
      自欺欺人，掩耳盗铃，企图蒙混过关
      自了汉


二三
  阴:固化，阳:变化
  过去:唯一，未来:不定
  现在:感知变与不变
  地:阴:往:唯一
  人:交:今:感知
  天:阳:来:未定
  ---
  n+(n-1) 线性联系
  n+n 环状联系


能则示之以不能
  显露出来的破绽可能是陷阱
  隐藏爱好，反而将厌恶的事物装作喜好，若有人碰巧以此讨好，则知其伪。

需求
  定制货物的需求规格 越是大众化就越是简单容易便宜竞争激烈供过于求，订单未必轮得到我；可真要是只有我能提供，仿佛为我量身定制，怕不是陷阱试探分我心。

担忧
  先是担心杀鸡取卵，接着担心无止境敲诈，再是担心狮子大开口，...


价格
  官府出低价强买收购？那就别怪人们囤积隐藏走私资敌。

人当然比蚊子强大，只是若是睡觉时被蚊子包围，到底是选择继续睡默默忍受，还是选择不眠不休杀一晚上蚊子？这可不好选，说不定白天有很重要的事，说不定接下来几个月都要直面蚊子的围攻且没有阻隔退避的办法也无驱蚊灭蚊的手段。对抗，无眠吃不消；忍受，可能失血过多而亡。

人道凿我七窍
  我们被教导如此，既然人太半后天所成，他人铸就，区别又在哪呢？所谓『我的』所谓『个性』所谓『自由意志』岂非臆想？
  贵者人所贵，贱者人所贱，由来好恶皆操人手。
人道发展
  人道越是发展，个人桎梏便越发严苛。
  资源向资质好的苗子倾斜，起点低的人越发没有前景
  野外资源稀薄，只有整个天下都被瓜分殆尽，满目皆是有主之物。
  污染严重，共享的丰富的资源偏偏越来越难直接利用，只能加工后才能使用。
  脱离社会，个人实已无生存的土壤。所谓苛政猛于虎，无立锥之地，不外如是。
  分工:
    有的负责繁殖，有的负责教育，有的负责生产，有的负责战斗，有的负责管理，有的负责科研，有的负责装神弄鬼修仙问道，有的负责扰乱治安犯上作乱
    血脉？鸠占鹊巢？对大我而言，并不存在

  修真界终究未能脱离人道，有人的地方就有江湖，人数越多人道威能越彰显
    抱团
      同类抱团
        交流:道友、道侣
        传承:师徒、宗门、血脉体质探究繁衍家族延续
            #资质好但道途断绝，则为了收回投资，只能沦为配种工具生殖机器
        垄断:材料，产品，理论，技术，人力
      互补抱团
        协作:分工合作精研小道
        交易
        剥削
        奴役
      利益抱团
        区域性抱团
    争斗:地、宝、材、徒、法统...，抱团裂地
    富集:损不足以奉有余
  张弛
    优胜劣汰，弱肉强食，穷则思变，无敌则嬉，用进废退，兔死狗烹，盛极而衰，僵而老，老而死，故往新来，存亡由兹，张弛交替，实难超脱



为谁而守
  本宗由来:祖师飞升前，自觉受了此地恩惠，不愿离去后青山绿水为人大肆劫掠采伐，故而开宗立派，守护一方水土。
  --贵派窃据宝地，天材地宝独占七分，当共享之。
  --天下修士竭泽而渔，乃有今世之荒凉匮乏，有何颜面觊觎...
  --冥顽不灵，不穷搜天地，如何快速壮大自己？强大无也有，弱小有也无。以前不能允许只有别人刮地，如今也不能看着你们一家享福。愚不可及，为我等守宝而已。


--我有一个可怕的猜想，从之前种种看，这本小说可能是...搞笑小说！--不可能！从未有人这么想，因为一点也不搞笑！--这就是可怕之处。

罪
  德不配位/怀璧
  大用威胁
  无用多余
  绊脚有碍




生命安全等级
  肉食<草食<餐风饮露吸收日月精华<吞噬万物化归己用<不再呼吸不再吐故纳新自成一界

他们算来算去，都只在那些强大的传统旧势力，全然不知默默无闻的后起之秀。

什么问题都是小问题
  作为一只走地鸡，我开心吗？作为一只笼养鸡，我抑郁吗？其实一点都不在乎，生死犹不可控，生存模式也不能自决，那么没有什么问题是大问题。


草兔
水太多，焚书
  信息少固然有碍发展，信息太多太杂太碎太乱太水太假，更要命。去伪存真，筛选精华，搜索所需，整合修缮，所费的功夫说不定都超过自己重建信息的工作量。
  焚书
  ---
  生存环境:深水浅水，咸水淡水，冰水暖水...
税紫芝/岁灵芝/税shui？岁sui？
  view /sdcard/0my_files/unzip/e_book/全唐詩\[ctext.org].txt
  [h2]:'《新沙》'
  [etext opt]:'陸龜蒙著'
  #渤澥聲中漲小堤，官家知後海鷗知。
  #
  #蓬萊有路教人到，應亦年年稅紫芝。
  #

  [h2]:'《雲》'
  [etext opt]:'來鵠著'
  #千形萬象竟還空，映水藏山片複重。
  #
  #無限旱苗枯欲盡，悠悠閑處作奇峰。
  #
新沙-陆龟蒙:渤澥声中涨小堤，官家知后海鸥知。蓬莱有路教人到，应亦年年税紫芝。
云-来鹄:千形万象竟还空，映水藏山片复重。无限旱苗枯欲尽，悠悠闲处作奇峰。


三劫:
  比如：冬天，东北凿了一地冰雕，如果某尊冰雕被砸碎了，这是意外，是人劫。春天回暖，所有冰雕融化，这是意料之中，是地劫。天劫？
  人劫/外劫，虽称谓中含『人』字，但和人没啥特别关系，主要强调特定个体单独面对的劫难，因缘际会人各有难。
  地劫/内劫，存身之地依凭之所崩毁的大劫，故曰地劫，各种存在依凭不同，地劫形式各异，强调种类群体共同性，具体某个存在可归属不同种类，子类、交集。即使针对特定种类，地劫也有不同层次，对于人而言，首先是寿元有限，即使突破寿元限制，还有记忆有限，资源有限+密度有限+速度有限（用作存储器+读写），基本粒子衰变，...
  天劫/无关劫，无关而相关，无理而成理，天道有缺，变数不存，命运无改，无人无我无灵无知无时无间无存无亡无有无无无运无易无形无类无德无道，灵智无用，道基动摇信仰崩溃，道途断绝，...
    过去不可为，未来不可为，现在不可为
    我命由我不由天？
      神通不及天数
        故事里的英雄神魔，不论如何惊才绝艳，终不过是故事里的角色。
      理是人对道的认知理解，是对道的偏见曲解，实则无用。思考也不过是气的运转，道的体现，何能御使道？灵智有何用？知与不知有何区别？
        智慧不能决定目的，只能服从欲求，服从命运
          德-种群理想形态存在意义行为指导目标
          有德方有正邪之分
          三个代表 就是对 正 的一种阐述
        智力推衍将极端化与现实不符，是简化条件简化理论步子太长看得太远的必然结果，这就是古人强调中庸，强调实事求是的原因。
            乐观也好，悲观也罢，想法只是想法，并没有什么卵用。事是做出来的。
    不论多么非凡，到底只是人力，人力有穷。
  作出改变突破桎梏成就伟业必有劫数
    存在-维持存在-保持现状-生存-保持自我-惯性-反作用-反弹反抗-反噬-反动（反者道之动）
      物质有惯性，文化也要对抗（意识形态领域斗争，宗教斗争-佛争一炷香，利益集团斗争-阶级斗争/旧势力新兴势力冲突/商业竞争/技术竞争（石化能源vs清洁能源））
        再造一人，是否算是复活？另叙故事，是否算是改变？
      刻舟求剑
        此一时彼一时
        文化作为助力应运而生，却也难免沦为阻力



祭祀成神，虽死犹生；远人成妖，虽生犹死。
  公祭为神，私祭为鬼
  逍遥为仙，不类为妖
  异常为怪，杂念为魔
  有念为灵，统念为性
  得意为精，得一为名
    //逍遥-超脱礼法名利兴衰存亡的计较，只有不依赖任何力量，才能不计较任何得失
    //造字:左右对称，类比 当代大部分动物
  人造偶像人拜之
    我们创造了神，要我们膜拜神？
    我们创造了鬼，要我们畏惧鬼？
    我们养活了寄生虫，要我们臣服？
  ---
  精气神:
    气-物质基础（不同领域 基础不同，此领域之基础若同时出现在彼领域，则未必还是彼领域之基础）
    精-横向关系/结构组织/形制制度/人脉事态/形势能量
    神-纵向关系/意图功效/运行规律/统计规律
    刀:
      神-用来劈砍切开东西的工具，剔骨刀、餐刀、侧刀、手术刀...
      精-刀的形制，关刀、剪刀、弯刀、小刀...
      气-刀的材料，木刀、钢刀、石刀、激光刀...



探索发现原理，可算立言；发明创造物什，可算立功。立功者，功在当代，利在千秋。立言者，还需后来者学习思考糅合其他道理创意，因时因地具体应用，间接立功。

可再生
  种粮可再生，石化不可再生，使用源自石油的化肥催生的高产作物是否是可再生资源？
  ---
  地球吸收的太阳能=入射的太阳能-反射的太阳能
    入射的太阳能=f(地日距离,地球半径,太阳发光功率)
  地球吸收的太阳能+燃烧释放的化学能+释放的核能=地球对外热辐射+地球内能+新增生物体化学能+其他新增的势能动能
  假如小型化核聚变实现，但宇航技术没有突破性进展，地球上肆意挥霍核能六亲不认。地球温度该增加几摄氏度？
    新平衡时，新增核能=新增地球对外热辐射(温度上升，热辐射波长变短)
    旧平衡时，粗略地有：地球吸收的太阳能=地球对外热辐射



五行
  道德经:有无相生，难易相成，长短相较，高下相倾，音声相和，前后相随
  五行不过是相对概念，如同大小，世上并无一个叫『大』的东西，并无一个叫『小』的东西，自然也不存在什么纯粹的五行之物。金水木火土，借用的称谓而已。既然提到五行，则必然隐含着一个包含它们的系统，五行的区分识别是基于该系统而言的。如同磁铁，有南北极，并非真的有南北，借用已有称谓而已，碎了之后的小磁铁一样有南北极，但此南北极是基于小磁铁而言，非彼南北极。



不必
  不得不做某类事，但并不一定是具体某件事。打工赚钱，却不一定局限于特定工种特定单位。养育后代，却不一定要与特定某人结婚，也不一定养育的必需是自己的血脉。
欲
  奇怪，为何我会患得患失？明明对任何人任何物任何事都无真感情。可这占有欲这收集癖这巧取豪夺的权力总会时不时地提起我的兴致。

大巧不工
  了不起，大巧不工，从心所欲而不逾矩，无拘无束偏偏中规中矩，仍在框架之内当真了得，可惜依旧在框架内。
  ---
  可笑！之前你能对抗我的魔染，是因为你心中有规矩，谨守本分，虽说画地为牢但也算是德位相配，虽弱却足以守住方寸之地。而今你心中无忌，肆意散漫，杂念丛生，岂能敌我？


欺骗
  自欺欺人
    欺骗自己，意图欺骗别人，掩耳盗铃，掩盖自己的缺点
    修来世
      怯懦（惧怕纸老虎、传统势力）
      无能（埋藏欲望，有心无力）
      懒惰（借口为来世努力）
  欺人自欺
    欺骗别人，最终自己也会信以为真，或者被裹挟，或者子孙后代被骗...
强者为何欺凌弱小？
  多生多杀 杀生不死 残害 吃 食物 原料 工具 生命 灵智
  欺凌弱小，是强大乃至生存的根本
  需要某种形式的食物，需要原料及工具来生产食物，这些原料工具可以是有生命的，甚至是有灵智的，乃至于本种族、血裔、自身。



不废江河万古流
  人道浩浩汤汤，无始无终
  逝者如斯夫，不舍昼夜
  这旦夕之威也配称雄？数战之得也配称胜？百年之祸也配称功？
  都一样
    薪尽了火还可传，火熄了仍有再燃之日，此处此时之火彼处彼时之火并无不同，都一样。
    传承很重要，但是即使传承断绝，也没什么，人道洪流滚滚向前，未知之地终有人涉足，已有之路必有再行者。
      不孤不穷，人道必兴，仁者无忧
        仁出于正，正出于德，得者众，众者寿，是故仁者不孤。兴衰有时，人道不绝，必成必兴，不必在我，故无忧。
          一切反动派都是纸老虎
          愚公移山
          逝者如斯夫，不舍昼夜
      天行有常，道理气运，智者不惑
        不拘于虚，不笃于时，不障于知，不殆于思，不迷于信
        不迷于信
          救世主，神仙皇帝，来世福报
          不理解的事物，因知道在其中，故不惑于怪神乱力。
          --不了解故而棘手，只要代代坚持探究，不及牺牲，终可剖析清楚，对付它不会比对付猛兽更难。--那得假设它不会对抗学习变异进步。
        不障于知
          朝三暮四 涸辙之鲋？
        不盲于目
          南辕北辙
            以斗争求团结，以战争开太平
              和平不会主动到来，它无法成就自己，需以暴力铲除不公，需以暴力维持稳定
            修真界尔虞我诈勾心斗角，欲求天真先泯天真
            要求自由，汲汲权势，制度驱役，劳务承责，权利即义务，自由即桎梏
          不忘初心
          五色，令人目盲；五音，令人耳聋；五味，令人口爽；驰骋畋猎，令人心发狂；难得之货令人行妨。是以圣人为腹不为目，故去彼取此。
        不殆于思
          实事求是
            刻舟求剑 削足适履
            实践是检验真理的唯一标准
            黑猫白猫，能抓住老鼠的才是好猫
      天命有归，得失无憾，勇者不惧
        必要做的事，即使不可为也要为之，因明必为是故无畏。
          --敌人是杀不完的。--是敌人就该杀，杀不杀得完不重要。
          害怕真相，有害形象团结稳定？
          害怕信任，群众乌合，他人害我？
          害怕未来，域民无界，敌我不分？
      仁智勇
        --你说仁智勇三名一体，然而我却见过智勇无仁之人，虚怀探索可谓智，无忌毋固可谓勇，远人离情可谓不仁。
        --无有坚定的意志不动的追求不可曰智，律己显性可曰仁，智者必仁；为人愚弄盲目横行不可曰勇，勇者必智；贪乐惧死不可曰仁，仁者必勇。你所说的人，对自己越严苛，说明他以仁义之心为刀雕刻自身越精微清白，大仁不仁，无情因情。
      一视同仁
        当你站在平地上，亲疏远近清楚明白，当你越走越高，近的也变得远，曾经的远近现在区别不大。
  无辜受戮，冤仇极矣。等待手足同胞给我们报仇，他们苟且图存。期待后人给我们报仇，他们与敌人后裔称兄道弟。亲故不可指望，一切亲疏皆戏言。后人不可指望，百世复仇成笑谈。有冤不能申，天又何公？人道此天非我天，无有来世兮无有他国，唯尽情与义，不知长与远。
    #人命如杂草，岁岁年年一批批。他们有名字吗？你叫得出来吗？名字连人的实在的边都摸不上，连名字都记不住，可见人命实是无关紧要。至于重视珍重，至于报仇雪恨，都是笑话。为了无名杂草？#参见『驯服的奴隶』
    何人使我面容扭曲丑陋，何事令我口中只能发出诅咒？
      为万世开太平，自是要得，只是为何不能在诛尽这些罪人之后？两者并无冲突。
    既往不咎？冤冤相报何时了？屠灭仇雠之后再说此话犹未迟！
    要怪只能怪自己无能，死了也活该，但仇还是要报的，这是生者的责任。
    防备天灾，我们做好准备；外敌入侵，我们共抗；鱼肉百姓，众人无视，非是不见，愿鱼肉他人耳。
  敌我
    能用在敌人身上的手段，自然也会用在所谓的自己人身上。敌我之分未必清楚明白恒久不变，代际替换疆域更动文化变迁...
        欺骗、奴役、屠杀
        当众承诺公然食言，言而无信即使有利于己方，只怕也会威严有损，让己方人员担忧自己得到的保证是否可靠。
    为谁辛苦为谁甜？
      高层有商有量，联姻，相互承诺不对战败方的子嗣赶尽杀绝，不过是一场仪式一场游戏；低层为了封妻荫子却不得不冒合族灭绝的风险，敌我仇视不共戴天。
        谁还不是这场仪式的祭品？都要死，都一样。
      不愿曝光丑闻？组织缔造者用心险恶，但后继者多有仁人志士，恐曝光后离心离德？这真是农场里的牲畜维护农夫，奴才维护主子，受害者沉迷被迫害的事实，不愿认清现实？
        以妥协求团结则团结亡
      手段
        强大的不是手段，而是目的，强大的目的最终会被实现。不需要隐秘不需要藏私，公开一切，允许敌人学习，威胁是不存在的，要么只是临时的，要么我们本来该败。
          倘若这般施为，只可怜我们看不到结果了。
          功成不必在我，但事必须有人做，前赴后继，我当为其中一员，等待相信祈祷是不会有结果的。
  ---
  凡道/繁道/众道/人道
  数量即是正义
  众人开辟的路，自然适合大多数人走，必为坦途；个人开辟的路，可能是险径，难以通人。
      不用担忧公开自己的修行法门会暴露跟脚，其实没必要，你的路只属于你自个，对别人未必有多大参考价值。完全可以召集众人，群策群力，共同开辟更为普适的修行法门。
      两难:
        * 福难:
          天资高、背景深、气运强，难以强求，资源自聚，然而也由此而成为猎物、斗争工具。
        * 寡难
          人少力弱，对资质要求高，则修习之人少，人少则难以快速发展，说不得最终比普通法门还不如。
      低调
        既担心被孤立，又担心平庸无奇。


  统治
    作为统治者，究竟是要推动发展还是阻碍发展？版图扩张国民富强百花齐放，难免有自信自强自立自治分裂的离心倾向；民不聊生万马齐喑，无恒产无恒心，了无生趣民不畏死，贼盗滋生，起义造反。
    靠外部压力天灾人祸保持向心力？实腹弱智禁欲虚心？分裂群体小国寡民，老死不相往来或者相互攻伐？

    --辉煌成就？如何奴役控制监视族群测谎读心窜改记忆？如何引导培养制造人格？如何伪造民意欺骗愚弄分离群众拉一派打一派鸠占鹊巢？如何以药物操控肉欲塑造人生观？如何设计血脉桎梏改变创造仆从种群？罪恶的传承留之何益，我们必断绝之。--世上没有善恶没有贵贱没有存亡，都一样，你们这批瑕疵品（青帝）以为可以磨灭我们存在的痕迹，但你我必将再遇。--那我..我们便屠灭未来，一切你们死灰复燃的未来。(修剪未来分支)
        手段
        社区/社会实验-宣传错误理念(迷信？五德终始？鸡蛋胆固醇？肝脏排毒生物钟.../钻石)
        掌控他人的口粮
            外围控制，截击商路，做唯一的二道贩；宣扬错误理念，使之交恶四方/潜在盟友
            内生扼杀，制造天灾人祸:瘟疫虫灾，种子供应，土地矿产，海陆交通，倾销主宰市场
    白帝-不存在
      修身养性，没心没肺；替天行道，无法无天
      不存在的候选未来，绝望中的希望。
      为自己的诞生而战！
      虚室生白
      成劫阻道
      神子坠凡，个人修行，高阶修士繁衍困难，批量制造困难--难道不是理当如此？--并不，至强至弱者 的意志，世界的样子。
        生来如此？不应当
        是否 该将子女至于穷山恶水？人的所得全凭自己后天努力？分裂成 未成年区 先进成人区 落后成人区 以保证 社会的发展推力？
    黑帝-不固名/易道
      神通-逆流:能使炼尸硬抗破邪金光；...
      痕印宗
        高阶修士 在照片/图像/影像制品/记忆里 日渐模糊，收敛自身的一切物质信息
        复活邪教教主:『一派天真出自然，好一个同心同德邪教教主！』--嗯？我本不愿醒，为何还能因为念及我的名号而夺舍重生？[被灭杀-见:同心同德赤帝失珠-哪有什么很多族人，这里不是只有你一个人吗？]...原来是将我当作实验品，...（痕印宗灭亡序幕拉开）
      阴极阳生，邪极乃正
        禁锢却充满活力与创造力，奴役统治偏偏安宁祥和团结友爱，...本来就是历练更兼磨砺仇恨，提前设想过种种黑暗与苦难，然而所见的一切，是超出想象之外的大恐怖，不能接受。
        猎杀、濒危、休渔轮耕游牧、圈养种植、越来越重视规模与健康、强调秩序...
      指明15极境
        竟然有人？
          黑帝指明 时，『通幽』一道点亮瞬息，小狐发现前方有人。道友？人劫？
      时光长河
        束缚众生，自此才有时间
        没有时间之前是什么？不存在。既说『之前』，便是有时间。
        ---
        造人者谁？自然不是人。
      正邪主宰同一人，冶炼众生
        把痛恨某种族的人变成该族
        对某人忠贞不二，则将该对象一化为二
        重男轻女？多送几个女儿，暖暖心。--我他妈谢谢你！--不用客气！
      普天之下莫非王土，率土之滨莫非王臣
      雷霆雨露俱是天恩，酸甜苦辣不挑食
        斤斤计较 也是一种生活乐趣。如果一切井然有序，没有任何意外，没有任何瑕疵烦恼，那是另外一种不完美，十分呆板无趣。被嫌弃？被歧视？被胁迫？忍受、无视、变形、斗争、施害...，五味杂陈舌才有用，五色纷呈眼才有用武之地，喜怒哀乐并享心才有生存空间。
      --我屠你族人，你父母也在其中。
      --但我还活着，这是您的仁慈，恩同再造！
      --我奴役你们，剥削你们，侵占你们祖辈开垦的土地世代积累的财富你们自己的劳动成果，只给你们残羹冷炙。
      --若无您的恩赐，我必饥寒交迫，死去多年，您是我的衣食父母，我的天，我的主宰。
      ---
      以慈善事业公益活动，培养傲慢畏难懈怠懒惰之风气，荒废业艺，满目虚荣，贵轻贱重...
    赤帝-不可知
      天行健君子以自强不息，地势坤君子以厚德载物
      不可察不可思不可知
      神器-矛盾
      《天开经》-内修，塑己
      《工物经》-外修，假物
      #洪荒以降，人族大兴，制霸天地，时至今日，竟有饿殍，尸位素餐，...
    黄帝-不神奇/凡道
      天地不仁，以万物为刍狗；圣人不仁，以百姓为刍狗
      天下一家:《礼记*礼运》:故圣人耐以天下为一家，以中国为一人者，非意之也。
      天下本无事，庸人自扰之:《新唐书-陆象先传》:天下本无事，庸人扰之为烦耳
      不求甚解
      各随其好
      丰杀随时:丰：增加；杀：减少。随时代不同而作增减变动。
      反对:天下大光，绝私杜恶；长生久视，无疾无苦
        人皆平凡，人皆老死。私如何？恶如何？老死，饥疫兵不能及，人道所钟，功过不移。
      凡道坦途
        人，皆平凡。智慧？勇敢？残忍？....不存在的。世间岂有天地主宰？
        走的人多了，路会更宽更踏实更好走。好走与走的人多，两者互为因果。
      借道vs工物:召唤未来强者--还能这么玩？
          ---
          凡道vs天开:此道由我开vs此天由我开、化神奇为腐朽vs化腐朽为神奇(藏死载生，只取其一，余者天成；由一而二vs内外兼修由二而一；人杰地灵？神魔葬地！为求一线生机，顺天而行转生，世为神棍，迷惑愚民，不至于真的归于尘土)
          历史唯一vs繁道-无穷历史无穷现在无穷未来
          --莫装逼，装逼被雷劈。--修行至此，世间何雷能奈何我？--当然是那道劈死你的雷。你甚至可能喝水噎死。
      借道-大同
        养育孩子，赡养老人，预备岗位与残疾人就业，治疗病患+当作实验品，既因既果，有借有还，人不能独立完成的任务，通过多人协作可轻松达成。
        保护大型动物，保护雏鸟鱼苗...(修行不易，相互提携保护)谁在救谁，谁在保护谁，还两说呢。
      人皆平凡
        人人可为桀纣尧舜。别人会犯的错误，你也会犯。别人能做到的事，你也能做到。
        中庸-矛盾？妥协？折中？
          官员-大公无私，要有资薪；人人平等，特化待遇，多劳多得；任人唯贤，封妻荫子；不问出身，忠良之后；低调简朴，好大喜功。
        我愿
          我愿乱世不以杀人称雄，我愿盛世不以嘲讽为乐，扶持替代作践，合作替代争斗。
          我所见的，不过是以作践为荣，奴役使唤、空间隔离奢侈标识，攀比嫉妒...。
          ---
          饿极了就会死，头被砍了就会死，任你再壮志凌云，任你再虔诚无畏，人要尊重事实，而最明显最直观的事实是，人皆平凡。我从不高估人性，我也不过分低估。有人恨不得将自己捧得高高在上，用尽手段将他人贬低得卑如蝼蚁。我追求胜利，却不依赖于苛求万众一心，..
            部族之间的仇恨大多源起于生存空间的争夺，比邻摩擦日剧，渐成世代血仇，仇恨直接见于上一代人的牺牲；若是一方迁居远离，仇恨也无从谈起。记录历史，不是为了牢记恩怨，而是为了认清人性，了解自身。对外探索，法天相地，对内探索，历史礼法。人性也是客观事实，历史唯物。行万里路识百族人，体验各地气候生态风俗民情，学子齐聚一堂求同存异，交友之重不下读书。
              重要性次序，千里殊风雨
                --说一个女人漂亮，等同于羞辱。因为人有种种美好品质，再不济多才多艺，啥都没有只能论外貌。--风俗不同，也可能反过来。若是漂亮，必称其美，因为外貌是女人最大的资本。实在见不得人，只能说些看不见摸不着的内在美。说性格好，等同于说是丑八怪。


      世界很大#人皆平凡，世界很大；人若不凡，地窄天低。觉得小，并非心大，恰恰相反，乃因心小。--哇！完美演绎了如何正话反说，完美掩饰了傻逼的本质！(见:『傻逼的本质』)
        路线之争vs生存空间之争
          路线-未来规划 理念不同 并且 无法兼容
            比如：有的求环保、可持续发展、控制人口数量，有的肆意污染、竭泽而渔、人口扩张，一方的努力成果被另一方所破坏，故 无法兼容
            产出 与 消费，建设 与 破坏
            输出性成果 的 存续
          生存空间-当下资源 当下群体划分
            资源是否紧张？世界是否很小？对未来发展持悲观态度与否？
            输入性资源 的 竞争
        合法性
          占用，并不是自言自语地说自己拥有，并不是在标的上刻下自己的名字，并不是牢牢掌握在手中，占用这种关系只存在于众人心中，人们达成共识承认某人占用某物，这样才算数。
        路线之争，最残酷的是无法回头而非走弯路。覆灭可待，而前途无量则无可诅。稳定状态多种多样，破局方向也多种多样。人们对未来的判断各不相同，故起纷争。
            按照手头上已有的技术资源进行规划(过于保守，毫无希望，逃跑投降)vs按照想象中未来的成就进行规划(步子太大，摊子太多，盲目乐观)
          一切的所谓『正确』，皆属人为臆测，过往一切验证皆不足凭，所有孤注一掷的虔诚具是自取灭亡。泛而言之，一切概念皆属人造，一切真理皆不足论。
              见:『思维实验:双球落地:自由落体定律』
                空气摩擦
                  -低密度，氢气球，漂浮上升
                  -特殊形状，降落伞滑翔翼，慢速下降
                  -小质量，雨滴蚂蚁，低速平衡匀速下落
                  -大质量，陨石，高速焚毁
                超远距离自由下落
                  轻微扰动，相互旋转，路线混沌，或螺旋下降，或卫星环绕，或再次远离。
                超大质量
                  地球倒贴，以更大加速度。
                  所谓自由下落，直线相撞情形实则是地球与落球同时靠近共同质心(动量守恒，两者组成的系统动量始终为零)，当此质心处于地壳之内、两者之间、落球之内这三种情况时，会让人觉得相当不同。
                  从这个思路上看，重球确实先落地，因为重球使得地球移动得更快，两者距离越近双方加速度越大。地表近地真空常规试验下，如果发现双球同时落地，那只能说是精度问题。
                特殊物质
                  万有引力有无可能是斥力？
                  空气可以产生浮力，凭什么真空就不能产生斥力？
              围城:你所要逃难的目的地，其中的人想要逃难到你这里。
              --四海之内皆兄弟，大同兼爱。--好。--亲疏远近爱有差。--对。--你这样赞同等于没赞同。--强扭的瓜不甜，爱咋咋，各行其是，无不可。(无可无不可，不如隐世修仙)
                --东南雨多，西北水少，天尚不公，而况人道？南水北调，耗费几何？成本不同，到手价不论同否，终是不平。若是坚持生活在沙漠里又当如何？必要求损有余而补不足，公平否？恶地人稀，灵地人稠，岂不应该？
              此一时彼一时:大灾大难，三圣王应运而出，对灾害广度久度估计不足，故尧宽和，帝力于我何加焉，大旱大涝漫漫无期，故舜严苛，万方有罪罪在朕躬。
          物质第一，精神第二，既然如此，那么就有：生存第一，自由第二。


      和:配合+多样性-体制-手眼心协调配合-巨蚌vs灰烬
        生命也好，文明也好，从来都是过程，不是结果，不是目标。
            我害怕人们不懂得如何犯罪作恶，那是另一种形式的灭亡。趋利避害，好逸恶劳，这是人性，但要是真的梦想成真臻至极境，又是怎样的情景？#止痛药，治标不治本(比如邻里纠纷天天挨打)，但用用还行，彻底废黜痛觉神经，用衣物遮盖伤口，自己感觉不到，别人看不到，当伤口不存在，就过了。
              #叶公好龙
              #见『翻译官:关我屁事』
              #为什么非要等犯罪行为发生后进行刑罚，为何反对提前消灭其发生的可能性？
              #所有人长生不死，好不好？世世代代所有人都遭受的苦难，若是有益于族群发展，可否接受？若能按时吃饭，有无食欲关系不大；但肚子饿提醒人该吃饭了，总是没错。手段终究只是手段。
              #不断变革，如同在大地上漫无目的地闲逛，虽谈不上进退，但也不可能回到原点。
        之所以分出很多人，正是为了同时具备各种可能的特点。没有必然的优点缺点。筋柔骨硬，相得益彰。如若人人一个模样，哪怕个个拥有再是天大的所谓优点，也必然成为致命的弱点。金子同质而长久，但未必是生灵所应求的形骸。人人精明？其实做个傻子也不错。
        纷争-另类的合作。人以群分，任何一个群体又会自动分出小群体，利益有别，纷争遂起。
      无名-使 名称 消失-灭族-名可名非恒名
        哪有什么融入不不融入，谁融入谁，谁归依谁，只是大家聚在一起分享分享经验交流交流心得，一起探索大道，聚散随心。
        名教-华夷之辨-江河日下-厚古薄今？
        融合 无需 称谓、服饰 等形式上的统一，而是 信念杂糅，习性近似
          红衣黄衣-理论有别，外显成服饰的区分
          人们经常制造许多无用的词汇概念

      史正-巨兽启蒙-没有史官的政府甚至都不能算正式，更别说合法。
        --内镇英杰，外抗强敌，绞尽脑汁维持高高在上醉生梦死的生活，引以为傲。不过就是奴役人，人杀人，聚群割据，一盘散沙，卑微如是，置身其间真如与蝼蚁为伍。他人俯瞰大地，我却仰望天空。我要的是风雨卑服，星辰从命，你说启蒙巨兽？很好，这也是我的志向。
            --傲慢无礼，想想而已谁不会，做到才算数。
        --人们批评自杀，以为自私轻率，毕竟生命并不仅仅私属于自我。要活着，就必须戴上桎梏，成为奴隶，没有其他被允许的路，这样很美好。但假如有人活着，却不愿做奴隶，践踏世俗规范，涂炭生灵，人们则编造罪名，指斥异端，恨不得生啖其肉。要是幡然悔悟，痛改前非，或许也能得到宽恕。到这里便能看出『批评自杀』『罪责屠戮』的本质只是需要更多活着的『驯服的奴隶』罢了。
        --谁在奴役？
        --所有人，所有循规蹈矩的人，所有人共尊的事实规范。『天人感应』『非攻兼爱』『弱肉强食』并无不同，一旦被众人高举，便成为培养镇压驯服奴隶的凶器。礼法笼罩天下，普天之下莫非王土，哪里还有世外桃源、法外之地？纵然想要自食其力茹毛饮血也不可得。一切资源，已发现的未发现的，尽皆为人侵占，还未出生便已被剥夺所有。
          邪信偏见自杀作乱，既不是蠢也不是坏，有果有因，有末有本，穷极无聊，了无生趣，对当前正统政权理念风俗潜规则诸般罗网的不满，消沉乃至于爆发，未必需要针对特定对象，本来就是针对整体而生。
      浮光掠影/吉光片羽
        --看到未来，感觉怎样？失望么？
        --只是些杂乱的光影，谈不上感想。
      嫘祖(lei2zu3)#一作“累祖”。传说西陵氏之女，黄帝轩辕氏(公元前2550年)的元妃。被后人推崇为中国养蚕治丝方法的创始者。北周以后被祀为“先蚕”(蚕神)。据考古资料，中国利用蚕丝时代应比嫘祖更早。
        恩爱？婚姻只是两族联盟的图章，天长日久两看相厌是真。送我蚕衣，我便明白。人到底需要新奇的玩意，不断索求有趣的信息。也罢，就用这蚕衣为一化身，赔一个日日新趣的半生。
        --没什么感情的。
        --这丝绸它保暖吗？--它光滑柔顺。--这丝绸它产量高吗？--它轻盈纤薄。--这...还是很不错的嘛。
          光鲜亮丽vs量大料足
          解放生产力#水泵
            有土地，气候宜人，才谈得上农业。
            吃饱饭，有大量空闲时间，才会琢磨各种小道。
            整天奔波劳累只为糊口，怎么可能搞好教育研发？九成人口种地打工，读书何来前途？要提高生产效率，普及自动化工业生产线，解放一线工农，人口才能集中到脑力劳动上。

        --终于暴露了你傻逼的本质！--为什么要说『终于』？
          --就你机灵。话说我年齿日长，无数后生仰望，压力巨大，感觉我傻逼的本质就快暴露。正所谓大愚若智，有没有什么方法可以使我显得很聪明？--什么话都反着说，与主流观点拧着来。哗众取宠，名扬域内。抑或绕来绕去，云里雾里，高深莫测。
          (『傻逼的本质』)

        --盘剥？如果我不盘剥，平分土地，那将没有足够的凝聚力对抗外部压力，很快会被外人蚕食鲸吞。

        --是逢年过节一顿顶级料理好，还是日日粗茶淡饭管饱好？

      对抗 大光明心
        将影子化为遮蔽天地的黑幕...#又一分身
      凡-腐朽神奇-化神奇为腐朽
      人道如树人如叶，生死本是寻常事
        vs 赤帝-天眼-简在帝心-无有隐私，罪恶无所遁形，监控天下，清明世界，消灭所有罪犯
          树叶 掌控 整树？私自削弱多样性
    青帝-不尽得/繁道
      天听自我民听，天视自我民视
      为有牺牲多壮志，敢叫日月换新天
      我命由我不由天
      对比 忘
        繁衍
          被预言的未来？成为未来无限多可能分支之一。
          历史？成为过去无限多可能分支之一。
      青帝赐劫:
        修行:毁而后立，不断循环 的 赐劫法(通常是 道侣相互磨砺，摧毁对方的世界观，等对方领悟更高明的道理，再行论道)
      灭:神、名、圣、...
        定义神，神即消亡
        遗忘则无名，无我则无命。
          有利必有我，我在利之先，小我大我无人我，近利远利无祸福，名可混淆名可废，名可创造名可忘。
        高低贵贱贤愚，病征、苍蝇、盗匪、圣贤，其实都一样，说明高高低低，世间不平，毛病不断加重
          圣人不死，大盗不止
            盗圣同出而异名，同出于世事不平，平不平者，非圣即盗。
            同源而生，相关而同生灭，非是因果关系，灭除圣贤并不能消灭盗贼平息乱象。
            病征 非 病因，苍蝇不臭，大盗圣贤也无罪，异常病变而显现病征，垃圾腐败发臭而引来苍蝇，世道不公而产生高低贵贱
              世上岂有无辜之人？我既遭殃，他人亦不可独享安泰！有福同享有难同当，谁能身外！
          削足适履，南辕北辙
          一切传承，当明其义其用，既然不利，可去之
      环极/圆极:
        以繁入道#vs 为道日减
          见下面:一难多易
        优点即缺点，专攻敌人长项，一胜可定，敌方无有再起之日
            优点，即是 不可或不愿改变的特点，如若改变恐怕也得换个称谓。为了形成此优点，不可避免的伴生相应缺点。优点难以掩饰，容易被针对性识别，进而试探出伴生弱点。
            封印
              封印只针对指定对象，可避免分散力量以致成为破绽。但同样由于无视他物，对破坏者毫不抵触，任由攻击，却也不可避免的成为另一个破绽。
              复杂，固然可能提高效率，但也多出许多受攻击点。比如识别这一环节，就有可能被针对。
        至强即至弱，世界的样子乃至强者的意志，无需再改动，等效于对世界无影响
          #道德经:自胜者强
        尽得尽受，得其利则承其弊，得到就是失去
          #道德经:
            三十辐共一毂，当其无，有车之用。
            埏埴以为器，当其无，有器之用。
            凿户牖以为室，当其无，有室之用。
            故有之以为利，无之以为用。
          ---
          不变的过往我可磨灭之，注定的未来我可翦除之，沉重的现在我可掀翻之
        先后左中右曲直
          道德经 无私以成私
          国富论 自私以成无私
          ---
          有人强调纯粹极端
          有人强调兼容并蓄中庸
      花祖
      羽化登仙
      破而后立，无往而来
      赐劫
        --如何躲过？他之一瞬，吾之永恒。
          藏终生于濒死一瞬，全矣无憾。
          宙版须弥芥子

  ---






刻意随意
  刻意而为，孜孜以求，泥
  随意而生，漫无目的，殆

完美
  所谓完美，体现的正是观察者认知的局限。

长而后宰
  鸡、猪...备受压迫，没有文明没有文字，只是人类的血食
  老鼠偷得自由，狗...

炼
  内外兼修，不可偏颇:炼神魂意志，炼血脉肉身，炼红尘历世，炼宗族承传
信任
  被信任是一种负担，不被信任是一种享受。

主角配角
  先天神是预备种子，后天生灵是对它们的考验，人劫，回收次品。

此情可待成追忆
  方生方死，旋起旋灭

圆极
  优点即缺点
  --既然是道体，亲和大道，那便乱道无道重构天道。
  --不可能阻隔大道，只是表象类似名义所言。随手制作的笼子对于婴儿而言也算牢不可破坚不可摧。


有用
  有用性并非内在属性，而是外在属性
  本源皆是气，如同云千变万化，如同海每一个浪头即是人心中的一个物件
  金属，可以制成各种物品。剪刀，对于鱼儿无用，因为无手。硬币，战乱期市场崩溃，寒不能衣饥不能食，也无用。
  鸟尽弓藏兔死狗烹，工具有其特定的被加工对象，若这种被加工对象灭绝，则工具无用。加工后的制成品若已无用，则工具也无用。
  领袖，需要大时代，需要同心同德的民意。


开头结尾最难
  开头难，是因为还没有找到破釜成舟孤注一掷的前进方向，就算立了志，第一步也迈得不踏实。
  结尾难，是因为很可能已经耗尽一切潜能。
女扮男装
  既言女子不必不如男，又何必男装？过于注重外物、外人的眼光，...
  礼俗皆是外物，难道要赤身裸体？
鬼神
  私祭为鬼，公祭为神
  私:血脉后裔
  三才:天地人:神祇鬼？
  祗zhi1:敬
    祗zhī 敬，恭敬：祗回。祗仰。祗奉。祗承。祗候。祗应。
    笔顺：丶乛丨丶丿乛一乛丶
    ？？神祗shen2zhi1:指天神和地神,泛指神明。如：吾不知子之牧羊,何所用哉?神祗岂宰杀乎?——唐·李朝威《柳毅传》。
    庸祗:信用敬重。语出《书．康诰》:"庸庸，祗祗，威威，显民。"孔传:"用可用，敬可敬。"
  祇qi2:地神，地，神
    祇qí古代称地神。
    祇zhǐ同“只2”。
    笔顺：丶乛丨丶丿乛一乛
    神祇shen2qi2:天神地祇
    一路神祇:指同伙的人。意含讥讽。#？一丘之貉he2/hao2/mo4#??he4??

世俗
  强，但需妥协屈服
  弱，但可自我不羁
  这是为获得世俗权力的必要付出

永动机
  不屈的斗志？死后仍要挥舞兵器杀敌？不如试着用做永动机，要么磨灭战意要么得到永动机。
饕餮
  吞噬即是杀戮、炼化、知觉、思考、领悟、成长、移动、穿越、创造

明易
  以日为首，以月为尾#from 人道至尊
  ---
  头顶无天为大 --from 人道至尊
  人首蛇身为道 --from 人道至尊
  ---
  易明字六九
  赵昊字知道
  ---
  日月易明
    日月为易--??参同契
  拆字:
    弓虽强，石更硬
    女子好，女少妙
    从心怂，心音意，心田思，今心念，王里理，角用刀，宝且宜宝至室，养我义
    拆字的问题在于: 字形与字体相关
      笔画延长缩短造成半包围结构
        左长竖撇-上下结构 还是 半包围结构（左上角半包围结构）？
          辱
          垕
          风见贝帝凫
        ---最，聽，帝，死
      戈字长横-是否拆成两横
        戢
      必，匆，义，刃
      裹，衙
      簡繁:
        #古田葉#古田叶

弱者
  前狼后虎，对于弱者而言，到处都是危险，人人都是威胁。你虽灭他仇敌，他却未必感激你，因为你也是他的潜在仇敌，狗咬狗罢了。

传
  传承重要还是血脉重要，技艺重要还是理想重要？
  在修仙问道逆天改命的修真文里大谈血脉？主角靠提纯血脉变强？还不如改造人机械飞升！
    当修真界修士繁多时，人道的威能开始显现。
    平均资源减少，竞争激烈，可再生资源被肆意掠夺浪费，日益枯竭，抱团消灭异己，垄断资源知识，排外。
    数量开始代表力量，持久的数量产生传承，对自身血脉的研究开放也可以成为一种强大的力量传承。

顾名思义vs望文生义
叛徒
  做人要有价值，才会被社会接纳。帝皇是，带路党也是。侵略者败退，则无价值；攻城掠地顺风顺水，也无价值；最好迁时延月地僵持(制衡，对双方既帮且坑)。入侵者得民心也不行(狐假虎威鱼肉乡里)，被信任也不行(信口开河败坏威信)，否则带路党太多，变成可被替代的可有可无的廉价零件。
  ===
  --之所以这些叛徒投靠我方，还不是因为我方势大？兵多将广，君臣协力同心，才是根本。若是使这些叛徒身居高位，反在旧属之上，岂非本末倒置？不论它们靠背叛立下多大功劳，都比不得我一兵一卒。
  ===
  投敌的，通敌的，跪下的，漠视族人苦难的，忘记历史忘记自己身份的，采用邪道复仇而玷污先祖荣耀的，都是叛徒。
  唯二的幸存者，你要杀我，归拢一族气运？气运一说虚无缥缈，我并不认同。不过有心向我族的势力，有前人隐藏的资源，这些人脉物资倒是看得见摸得着，确实会因为你我的分裂而分流，也不能说完全没有道理。你虽孤注一掷，却也未必成功，毕竟连我你也还没杀死。即使你设计我，我也不想与你自相残杀，只因我担心自己失败，多一个人多一份可能。只要不是叛徒，我可以容忍，早置生死于度外...
    你就是叛徒，穷则思变，但走邪道是彻底地背叛



祸福无门
  吃一堑长一智，要把吃亏变成成长收获，不打不相识，而非积怨树敌。
  --这是好事……
  --在你看来，有什么事是坏事吗？
  --别人以为是大灾大劫，我则认为是大浪淘沙的大机缘大舞台。一切失败错误，正是通向成功正确的坚实坦途...祸兮福所倚，福兮祸所伏，祸福无门，唯人自招。
    * 羊吃人
    * 奈何百万漕工
  ---
  劫狱
    来往人流多则可改扮潜入，冷冷清清则可直接堵门杀入。
  ---
  等死
    瘟疫、洪水、地震、恐怖袭击、火灾、车祸...，为何这等好事没让我撞上？


活成他人眼中的样子
  你觉得我讲道理我便讲道理，你觉得我不讲道理我便不讲道理。我不喜欢被人冤枉诬蔑，若你觉得我有罪，那我可真要犯罪了。
包容/排斥 * 弱小/强大
  上升期
    因为弱小所以包容:团结一切可以争取的力量，以弱众抗强霸
    因为强大所以包容:百家争鸣，百花齐放，海纳百川，无惧宵小阴谋诡计
  衰落期
    因为强大所以排斥:人多物少，竞争激烈，内卷严重，相互倾轧，小团体滋生，有分裂倾向，内里离心遑论对外
    因为弱小所以排斥:域民以界，依靠束缚威压聚合民众，保持特色区分人我


自由
  反噬真意
    哪里有奴役哪里就有反抗
    分身必反噬
    蛊虫/役兽/炼尸/鬼灵...
  --真的是两个人？为何会是两个人？
  --因为我给予他自由，这也成就我的自由。
出世
  世外之人脱离人道，何必是人，人何必言，言何必信？
辩日
  金乌
  有的说亿兆万里，有的说三千里，有的说几十丈，有的说碗口大小，有的说汤圆大小，有的说针尖星火大小。究竟哪种说法是真的？
  越是靠近，发现距离越远。初始以为距离是自己与洞口的距离，到了洞口才发现深的很。

试错
  错误是正确的一种表达形式，没有对错误的深刻了解，对正确的领悟便算不得完整。
  所谓无用，只是人们还未发现它的有用。
标准
  成败乃是衡量合理性的唯一标准
  胜负乃是衡量强弱的唯一标准
  一时一地一人一族的胜败能说明什么问题？谁能笑到最后？哪些理念能禁得起时间的考验？恐怕很难从历史事件中得到结论。
不屑
  以己之长度人之短，多生不屑
  称道--除了赞扬之处，皆不入眼


四手手指相扣，心心相印？（就是两个猛男一直在怒吼喊打喊杀的场景有些离谱），……居然真的让你们练成了！

玄功
  玄:一生二，二生三，三生万物，玄之又玄，众妙之门。
  并非只能炼出三个分身，三个元神，而是意味着有无限可能，数量无限，方向无限。
被骗
  年轻人被骗是因为阅历太少；老年人被骗原因恰好相反。奇葩的事经历多了，对危与机更敏感，遗憾多了，反应也会更大。
  传言不论多么荒诞不羁经不起推敲自相矛盾，也可能是真的。证据链不论如何完整严密，也可能只是巧合偶然也可能是人为构陷。

象齿焚身，怀璧其罪
  居穷山恶水，身无长物，与世无争，以为可长存世间。
    然而，久居世间，博闻广志，通晓秘辛，有人求教，不告得罪人，有人希望某些事情被淡忘，记住便是错，有人希望独霸一切，拥有则阻人道。知识即是宝藏，即是祸端。

乾坤
  --甘为子孙后代铺路牺牲，有这样的传统，这样的族群不该灭绝。--那为何不曾兴起？--因为缺德。
  --明明只是自救，与吾等何干？--虽然不幸地处要冲，被迫成为前线，但事实上确实也为我们挡了灾，总该要有所答谢，补偿一二。
  一体
    涸泽而渔，焚林而猎
    焚林而田，竭泽而渔。看似一时之事，明年无获；看似一地之事，流窜借粮。

情报人员
  对己方了解越少越不可能泄漏信息，但也容易忽视有用情报。
多余
  作为被饲养的肉鸡，脑子、眼睛、翅膀鸡腿、骨头，都是多余的。


死敌
  其实羊并不需要比狼跑得快，只需比其他羊跑得快就行，因为一般来说，狼只是要吃羊，而非特定的某只羊。种内竞争的重要性如果超过种外竞争，那么，谁是死敌？
  只有团结一致有效的发挥群体的力量，团体内外才能分出远近，这与血缘关系不是特别密切。

生而有之
  朝生夕死，开灵启慧
  借势以弱克强，比如：放火烧山，但再弱，也有最低需求，至少要能生成小火星
  系统完整的修炼法门 并不存在
    众生 生而不同，有些能力生而有之，或 随着成长 自然而然 拥有，未必会多花时间研究所以然，也不见得 容易出结果。
    每一种法门都有最低要求，不可能从零开始，因为零根本不存在，只有更差的基础，没有最差。
      虽然修行就是要逆天改命，无所谓最低要求，但具体功法则不然。

因果
  体量大（地广人众流动快），故需用明文法，僵化没有人情味
  体量小，政策更加灵活多变
  并不是因为善变而弱小，而是弱小者为了生存而多变。
  鞋子大小需匹配脚掌，穿上大鞋不代表脚大。

郁闷
  --- idea from 蛮荒仙界
  -叫他也不答应一声...气色不好，一定是初经战事，直面生死，尚不习惯...什么？死了？可我明明看见...原来被夺舍...这下轮到我郁闷了...

训练 与 实战
  训练代替不了实战
  未经训练直接以实战代替训练是浪费

计划外
  计划之外一律拒绝！我不需要好运。

舞乐分流
  舞-自由不屈
  乐-稳定和谐

内卷
  内卷！内斗！灰心...
  难道敌人就不内斗？难道一团和气发展更快？

为了饼干
  为了饼干，我自愿自觉提前上班推迟下班五分钟，每天多干30分钟，多挣3块钱，多吃6块饼干！
  啊！零食，我的生命之火动力之源。
  村里
    盖街强者，擎坊巨擘，绝代村骄
    村里无敌，村里第一，宏图霸业，称霸村里
      那有什么无敌，只是手下败将给自个脸上贴金。
      不是功法强，是人强故而功法扬名，而非反之。与曾经村里第一修炼同一门功法便自以为无敌？
    ===
    即时通信
      登高吼一嗓子，全村马上就都听到了。
      你们怎么连传个话也要花几年时间？

小事糊涂
  将将，不同于将兵，非是整齐划一而是众口难调，小事不得不糊涂。
算命
  命中注定贫困潦倒？看来只能努力提高社会最低生活保障了
资质
  心灵手巧
  体魄强健
  勇猛无畏，置之死地而后生
  体弱多病，百病不侵(免疫系统过强，压迫身体)
  博闻强记，智计深沉
  见微知著，洞察人性，通达世故，为善可立教，为恶能倾国
  ...
  垄断
    垄断 生产(原材料、技术专利)、市场、渠道


入门
  师傅领进门--指 开宗明义，明了所学的大方向，知晓原则上的大禁忌，知道如何判断美丑优劣、是否有进步，虽然未必懂得修习的法门但是否通达是必须懂得，唯有如此才有能力独自摸索前进。
  比如：编程实现数学定理的自动证明：1）需要定义『形式证明』依之判断证明是否合法，是否证明了目标定理；2）目标定理的形式表达；3）所有合法证明的穷举。第3）步相当于独自摸索，第1）步相当于领进门，第2）步是具体问题相当于个人志向。
  --
  传承累聚与损耗
    语言文字，不能承载述者的完整精确的理解，受众也只能根据自身阅历领悟，当受众变成述者，学生变成老师，所能传授的内容也就仅限于自身的理解。失真越来越严重。
    但同时，各人也在加深理解，发前人之所未发，甚至探索前人未曾涉足的领域。

    。
困难
  过于复杂，难以归类，记不住
  过于简单，面对实际问题不知如何应用，甚至不知是否有关
  捷径？
    --这就是你的骄傲吗？说是不甘屈居人下，阴谋叛乱，却是仰仗外人？--所谓靠人不如靠己，不过心胸狭隘者、才智浅陋者、怯懦无能者的言辞。役使众生，才是真正的强大。人道之争在于众，不在于独。在于久，不在于短。小人之心，装不下这浩浩汤汤的人道要义。
享受
  饱腹是一种享受，饥饿也是。
  纵欲无度是一种享受，忍耐等待也是。
  虽然推迟的享受只存在于想象中的未来场景，但当下的想象意淫就是一种享受，一种与现状矛盾的无时无刻由主观意识产生的蜜糖。
  只懂得无限制地满足欲求，只会变的麻木。

机缘-好奇
  --要先活着再论其他。探索未知秘境的不可预知的危险，迷失与无涯新奇之海不知老之将至的危险...
  --可以预知风险，可以预知收获，可以预知命运，稳稳当当的一生必然错失良机，何谈逆天改命？

涸辙之鲋
  高价抢购明日黄花，别说买家，就连卖家都觉得不可思议，将货物又仔细检查一遍，以免被人捡漏。价值，因人而异，因时而异，我现在有需要就是道理，与人何干？

自愿
  自愿买卖
    价值因人而异，这是交易的基础。
    医得眼前疮，挖却心头肉。--不管农夫如何肉痛，在贱卖青苗买粮活命与指望青苗成熟丰收先把自己饿死之间该怎么选是很清楚的，交易完全是理性自愿的。
    这也证明货物并不存在一个内在的客观的价值。
    土地私有+土地自由交易 必然 导致 土地兼并
    人人都说土地兼并有害，其实只是投机失败者的哀嚎，只恨地主为何不是我。
  『自愿』？这个词用得好！我们可以先把一个人折腾得死去活来，让他明白今后的日子皆是如此，毫无希望，生不如死，若是自杀绝不令人意外，当然是『自愿』的。
  当选择空间由别人裁定，规则由别人制订，自愿又有多大意义？

择贤-选举
  靠平庸的人选举杰出的人才？
  靠鼠目寸光的人评价提案是否有远见？


一难多易
  一个问题可能难以处理，但多个问题凑一起可能反而更容易解决。
    一个具体的问题可能很麻烦，但泛化成一个抽象问题，可能有一个直观的答案，甚至可能存在大量成熟解决方案。
  大同
    一个人如何养老？健身，寄希望于无疾而终，难度大，谁也说不准哪天自己就生活无法自理；攒钱，年老之后雇人照料，通货膨胀会偷走钱的价值，更何况无论何时，让年轻人花时间照顾老年人，代价太大，社会难以承担，养儿防老也有同样的难点。
    所有人如何养老？可以搞个夕阳互助组织，让有活力的老年人照顾生活无法自理的老年人。现在，我为人人，将来，人人为我。
  ===
  监控天下
    保甲株连，几个人完全捆绑如同一人，同食同宿无隐私，相互监督行踪，众念国外显，个性磨灭
  ===
  规模出效益
  人口数量越多密度越大则对文明发展的推力越大，人道变迁越快越完善。
  ===
  --开辟一个前人未知的全新秘境，融入到已有的修炼体系中已是无比困难，失败连连。你竟然要我一口气重开万千秘境？欲速则不达，只怕成功毫无希望。
  --正是因为你是个弱渣，所以才必须一起上马，相互制衡以期稳定，数量越多越好平衡，数量越少越考验悟性。若是道法通天，自然可以分解开，一步一步悠闲地前进。
  ===
  以进为退
    将摊子铺得大大，看似尽善尽美避免将来修订升级反复折腾，实则苗而不秀华而不实，不仅当前的资源不足以支持，光是完成详尽规划便要耗去的时间便非众人当下实际所能支配。


与人斗
  与神一般的敌人斗，与猪一般的队员斗，与愚昧无知/泯灭人性/得过且过/傲慢妄想/恐惧残忍斗，
就在那里
  不管你听不听，意见就在那里。不管你知不知道，现在所有人是否都不清楚，分歧就在那里。只等着人们踩上去。
  战争一直在，何时远离过？

方人
  攀比，人比人
  大道独行，修行是私事，与人何干？
  人与人之间 为何要对比？
    三人行必有我师焉
  人，要有野心，文雅一点说，士不可以不弘毅，野心并非天生，需要仔细培养，羡慕攀比嫉妒，不择手段地追求，欺诈盘剥劫掠，这样的人生完美充实，比那些修身养性的战五渣强多了。
      修士其实大都是行为表演，用余生在编织谎言，于心中于口中塑造庞大的雕像以展示傲慢，掩盖无能与自卑，认真算起来也分属诈骗同行，道行高的，奴役信众，外力也很强大。
      王莽谦恭未篡时

巨婴
  计件作坊变托管所
  我就是巨婴
为何禁止？
  恶性传染病（性病、新冠）、毒品、...如果研发出有效药对抗，不再有难以根治不可逆的严重伤害，仅相当于感冒酒精，是否还要忌讳禁止？
口碑:建立 变现 崽卖爷田心不疼(君子之泽五世而斩，二世而亡:秦朝、隋朝、民国) 愚公移山(众志成城，自力更生，团结专一，自强不息（与天斗，与人斗，与己斗，以阶级斗争为纲） vs 造不如买) 猫论（与时俱进，因地制宜，分散多变，厚德载物（厚德即厚人厚欲，满足人民日益增长的欲壑) vs 削足适履/刻舟求剑/古之糟粕/两个凡是）
  中庸:
    《论语*尧曰第二十》：允执其中
  人存政举 人亡政息 只争朝夕
    背叛？革新？
  。
公私
  花费公家的钱引进的技术，当然要共享！
  罚酒三杯
    尸禄害政
    公事私办 变 人情/私怨
    公器私用 假公济私
    营私植党 公报私仇
    蠹民梗政 扛着红旗反革命
    如果 违法行为/渎职 得不到 应有的惩罚，那么 即使再怎样有力地保障守法公民的权益也无意义，因为 守法不再是牺牲而是无能。
  义务权利
    我不是来参与建设的，我是来享受便利的。
  对待潜规则
    消极脱身 以待将来 因人成事
    鲜明抵制 公开斗争
    妥协退让 曲线办事 政以贿成 积极利用以便成为受益者
信息服务/情报服务
  需求发现
    主体 注册
      记录 工作领域，已掌握工艺，急需的工艺，不需要的工艺，可出售工艺
    某方 欠缺的工艺 = 所有他方 已掌握工艺 - 某方 的 工作领域，已掌握工艺
    某方 可能的新需求 = 某方 欠缺的工艺 - 某方 急需的工艺 - 某方 不需要的工艺
      ==>> 推送通知、接洽业务
教育
  +个人获取信息的能力
    阅读、搜索、交流/问答、鉴别真伪
  +信息平台
    遍历、搜索、在线交流/问答记录、权威鉴别真伪
  +个人基本生存技能
    锻炼身体保证健康、工作能力保证获取信息所需资金、保证生存:
      粮食储备、医疗、治安、战备
      工作机会
  +个人综合表达信息的能力
    书写、回答、综述、日志、计划/规划
  +个人志向/价值观(三观)？
信任 平庸 权利
  过于信任，长期不闻不问，放任自流，相信最终不负所望，如同毫无期待好不重视
  过于不信任，频繁检查，吹毛求疵
  一抓就死，一放就乱
  不是蠢就是坏
  是平庸的人太多？抓则能人被庸人压制，放则被淹没？
  是坏人太多？抓则严以待人，打压异己，扛着红旗反革命；放则宽以律己，胡作非为，倒行逆施，以权谋私，假公济私
冒险 与 殉道 的 区别是什么？
名利
  货币，一旦离开认可它的国度，便毫无意义；名声，一旦离开相互吹捧的圈子，便毫无意义。
有的人无视别人的困难，有的人故意凭空制造困难，到底谁负责监督？信息如何无分巨细地披露（来源、渠道、接受（人、时间、反馈），零隐私）？如何确保信息真实性？
回扣
  回扣当然要加在价格上，对方负责人有能力有胆量搅黄并以此索要回扣，理应为抬高的价格开绿灯。
诚信
  --你这人说话遮遮掩掩，我一发现疑点你就换一个说法，我还能不能相信你说的话？
  --见什么人说什么话。交浅则不言深，找个普通人能接受的说法糊弄一下，双方心知肚明即可。非要追问，已然失礼，继续糊弄也只是不想搞得太僵。
傲气
  一个领域里的牛人，有傲气也没啥，总比唯唯诺诺阿谀逢迎来得好，有一技之长却不能扬眉吐气，那样的社会一定压抑绝望的。
  要做就做到最好的傲气！这是交流的基础，是共同语言。
事业
  谁受惠？如何分配利益？允许使用哪些手段获利？谁接班？如何吸引？怎么培养？
离开
  --去那里
  --那里还不是这里？
  --其实只是想离开，离开熟悉的地方，离开认识的人，无人认识便是清净之地。
  ===
  这里那里
    追求什么？其实只想看看脱离人道的我是什么样子。

后悔？
  后悔？不存在的。比如说，现在有个妖怪要杀你报仇，问是什么仇什么怨，原来是粒稻谷得道，临死之前你可有悔意？
龙生九子
  赑屃，螭吻，蒲牢，狴犴，饕餮，趴蝮，睚眦，狻猊，椒图


登泰山而小天下
  饭是一口一口吃的，路是一步一步走的，哪来什么绝招捷径？不过前人的经验有助于少走弯路，开拓视野，从眼前的蝇营狗苟中挣脱而出，观百国春秋而明人世兴衰，岂能安于芸芸众生的平凡命运？
过犹不及
  自力更生？造不如买？任何思路一旦推衍至极端，基本上都会出问题。
该奖则奖，该收则收
  立功、帮忙，事后给好处是合理的，除非穷到给不出，只能口头感激。这两种情况，都合理。但要是说，义当如此，当奖不奖，当收不收，那才是 不宜不义。

知我罪我，患得患失
  出世之人 真的在乎么？言辞何用？荣辱何用？仁义何用？

结婚还要认证？
  看起来 更像是一场 长期交易，需要外部的强力约束。男方 保证提供充足资源，不得分流给其他女子；女方 保证生育孩童，不得与其他男子有染。
早熟
  农牧林业，早熟 增产？
  人类早熟 是否 与 野生动物 类似 可以 提高生存率？提高 社会生存能力？
  社会发展 是否 可从 早熟 获益？
  社会 是否 歧视/迫害 晚熟/弱智 儿童？
仓储不易
  食物 虫(蟑螂、米虫、蛀虫，保鲜袋 也能咬破)、霉(啥也挡不住)、鼠(什么都能咬破)
努力奋斗
  经过不懈努力艰苦奋斗，终于把自己的身体搞垮了。御使身体不以其道，作为奴隶主是不仁，作为自己又算什么？
小孩子
  --无所不能...毕竟是小孩，在他眼里偶像便是无所不能，但凡有点阅历也不至于如此。
  --小声点，你可把世上的脑残粉跟宗教信徒都骂进去了。

酷刑
  实用的 酷刑 可不是 拍脑袋 就能想出来的。要有视觉效果，要有想象上的冲击性，要能引起本能的恐惧，要有肉体难以承受之苦却又保持清醒不危及性命但又不能使人的耐受性越来越高，要能让人受刑后完全不敢回忆。真要花心思去设计酷刑，有这能耐有这水磨工夫还不如干点别的，毕竟酷刑只是手段，相比要达成的目标，实在不值。
打发时间
  并非兴趣爱好，只是打发时间
生而不同
  有的人需要鞭策才会用功，有的人需被期待才有方向，有的人需经苦难才明事理，有的人需要孤独才能安心。
层层压迫的稳定性
  在层层压迫的社会里，虽然大部分人都是受害者，却难以团结反抗，只因大部分人也是施害者。人们不去痛恨社会结构，而是痛恨自己没能站得更高。不论是追求自己现世更上一层楼、子孙更上一层楼，还是寄希望于来世投个好胎，这份压迫都无疑地在激发人们的积极性，社会整体而言反而是健康的。
法治亦人治
  法律规章，终究是人在执行。
  人们不愿做-大明诰？此一时彼一时，与时俱进。说一套做一套，潜规则黑社会。扔一本法典给猴子，猴群会怎样？
  人们做不到-规定选出一个人来完成所有生产劳动、开疆拓土保证每个人自由活动有无限资源空间，不与他人发生矛盾，其他人负责玩耍。这样一个完美社会如何？
  鸟儿在天上飞，其实不是正常状态，掉到地上才是。努力维护一个不自然的状态，与天斗，乃人道精髓。由弱肉强食的丛林飞往各得其所的大同天空，由人治飞向法治，飞翔只是一个过程，终点永远不会抵达，坠落是理所当然的结局。因为沉浸于想象中，而当看到现实而惊讶不满，只能说是弱智。

私有
  团体私有知识
  法不可轻传
  保障自身安全-防止他人利用这些知识反过来危害自身（了解能力局限、发现漏洞破绽、军备竞赛）
  满足自身发展的需求-每一份付出都期待收获，互惠互利关系才能长久，从这里得到知识，理应为这些知识的增加做出贡献。
  私有 到底 好不好？合不合理？
  大多数情况下，外部环境是弱肉强食，私有合理。
  但少数人为的强力组织显式地屏蔽掉弱肉强食法则，公有 才有其生存空间。

量变到质变
  单纯数量的堆积，加上漫长岁月的演化，甚至能够自成天地，诞生生灵，乃至仙神
  何必为了炼制法宝而穷搜天地？天地这个无尽藏就在眼前。
  要是能掌控天地似操控法宝般如臂使指，也算得道。这是神道。
育种
  灵根可遗传，高阶修士生育率低
  大量圈养有灵根的凡人
青出于蓝
  这份传承十分凶险，原主极其骄傲，既然留下传承，必然要求传人青出于蓝，功法修炼过程绝不会四平八稳，因为初创他自己肯定没练过。
既受其利则受其弊
  既然依靠家族得了好处，自然也要牺牲自己去维护家族利益。不遵守规矩的人，便要受到所有家族的讨伐，因为这些家族正是靠着这规矩才能长存。
  --凭什么要帮理不帮亲？真到了生死存亡的时候，会与家族共存的人是谁？是这些讲道理的人吗？错！只有我们！不计利益不计生死。--你说得对。那我们是否要自绝于正道，合家举族充作杀人越货的强盗？我们是否已做好举世皆敌的准备？
  压力平衡
    扩张-稳定时边界必定压力平衡
      1. 外对内压力-外部环境险恶
      2. 内对外压力-兵力物资密度
      3. 向心力-个人发展资源的政策倾斜造成的梯度

市恩
  物资充裕时怎么搞都无所谓，但却需顾及大灾大难。在灾难面前，是携手共抗，还是互相鱼肉？互助者人，相煎者亦人。囤积有形易腐之物，使人生不均之愤，不值。

凭什么让我独自承受灾难？
  雪灾，南侵/内战/剥夺老弱病残的口粮，死够人抢够粮
  人道法则 公平 患不均
      不患寡而患不均:不论这种情况是如何造成的，是你祖祖辈辈辛辛苦苦点点滴滴积攒起来的，是你奇思妙想发明创造见识过人引领时代，是你敢打敢拼豪赌投机功成万骨枯，是你机关算尽坑蒙拐骗巧取豪夺抄袭剽窃盘剥垄断买办，是他人遭遇天灾人祸一夜赤贫负债累累，诸般原由造成贫富悬殊的事实，结果并无不同，堆出于岸，流必湍之，原因并不重要，人性只看眼前，鼠目寸光本能而已。
  一方有难八方支援
    同一件事，可以有不同说法做法，不管好听难听，本质不改

开宗明义
  --（野路子蛊师）突破炼蛊瓶颈:不能繁殖只能靠斗蛊来产生强蛊？效率太低！寿命短？在正常的外部环境中存活时间短？太折腾！改！
  --伤人伤己，作为威慑性的战略武器和大量低成本制造的临时性战术武器，最重要的禁忌是:避免反噬。事实是这些所谓的缺点一点都不自然，明显是人为的。你一生的成就其实只是在突破前人布下的禁制。聪明却未及根本。

奢侈品
  --闪闪发光的珠宝？艳丽多彩的皮毛？哼，女人！
  --削铁如泥的宝刀？耐用顺手的工具？哼，男人！

保护 攻陷
  能挡住外部的风雨，难道还能插手内部的管理（内政外交:人事安排、管理制度、人际交往）？难道还能干预上下层的志向情感？

答谢
  虽然 没有成事的功劳，说不定还试图扒拉到自己碗里，但毕竟没有下死力气败事，这会儿来邀功请赏，当然得承这人情。
离
  混在一起没效率。要么 将混日子吃闲饭的赶走，要么 将有能力有志气的调走，要么 将大伙拉低到同一水准，要么 将大伙拉高到同一水准。
诈
  --（听着众人视死如归大义凛然的壮语，十分感动）好！接下来就是考核环节，本来应该暗中进行，但现在危机四伏...--等等、刚才是什么情况？！前几日暗地里的关于暗中考察的流言 其实是 骗我们去送死，对吧？！
考核
  择偶、选择官员...
  喜欢高颜值，便会整容；喜欢大胸细腰大屁股，便会垫垫束腰；喜欢长腿，便会穿短裙高跟鞋拉伸照片；喜欢蠢萌，便会伪装成傻白甜；喜欢感性，便会伪装成有爱心小动保；喜欢女人，便会伪装成女人；喜欢才学，便会伪装成高知；喜欢钱财，便会有名牌或冒牌货包装自己；喜欢成功，便会伪装成成功人士。
    外交无小事，就会有人 借皮搞优惠搞特权享受超国民待遇狐假虎威挟洋自重，出口转内销，曲线行使正当权利
    强调集体高于个人，多得是 假公济私
    喜欢讲套话讲原则，多得是 扛着红旗反革命
    不讲人情，鸟尽弓藏过河拆桥，，多得是 养寇自重
    劣币驱逐良币，道高一尺魔高一丈，谁能留存一目了然
    良币联盟抵制劣币？联盟最终也可能成为作恶的权威。顺昌逆亡，捆绑垄断策略作为加盟条件（产品价格设置下限乃至哄抬，电器寿命设定上限，旧版手机变慢，强迫用户更新换代）
  不论如何考核，终究只是形式套路，当不得真。漏洞、伪装、敲门砖、人脉、特权...，考核的意义很快会被无关紧要的东西替代，就如同前人珍而重之的礼仪会逐步失去含义剩下形式化为桎梏乃至凶刃。最终仍要看实际工作中的表现，不只眼前，更要放眼未来，当下与未来统一。可惜，一则职位有限，责任重大，政策久远，任职机会难得。二则对后世的影响当下是很难真切体会，想要盖棺论定都难。问题回到原点，如何开始？选谁上位？如何结束？孰优孰劣？从基层干起，任期足长。但 基层 同样是 竞争，考核期再长 也不见得 足够。
剑
  棍-兵器之祖
  刀-应用最广泛
  矛-低成本战阵用兵器
  弓-远程
    石
  剑-人文底蕴深厚-正直，忠诚，复仇

辩利 辩智
  智力 有其局限 见下面『天魂』/『终极目标』
  利 我 小大 近远 贱贵
    有利 必先 有我
      大我 小我
      激情之我 众念之我 当下之我、未来之我 子孙之我 亲族之我 国族之我 人类之我 信仰之我
    轻急缓重
    利益 有 远近
      短期利益 长期利益
    利益 有 贵贱
      正常的交易 之所以 能进行，是因为 对于买卖双方 需求不同，对 交易物 的 价值判断不同
      所谓 贵贱，因人而异
天
  #医学:先天 后天 是与个人相关的，天 大约是指 人本身。
  这天乃是人道这片天！
    天听自我民听，天视自我民视 vs 天地不仁，以万物为刍狗
      天外有天，有好多重天，说的不是同一重天
      官府/朝廷/政府 - 这是一重天
      人道 - 一重天
      天道 - 一重天
      声张正义，当然只能靠人。天理昭昭，终究是要我们自己维护。
          从来就没有什么救世主也不靠神仙皇帝
          人道 不需要 来世
            恩怨-现世报
          人道 不需要 神
            替天行道
          人道 不需要 原罪
            --天下谁是无辜之人？--人道 才定罪，天道 无不可
          人道 不需要 前世
            天道酬勤
            我命由我不由天
            王侯将相宁有种乎！
    出世-脱离人道
      说得轻巧，其实哪有那么简单！传承 即是 人道 的 一大特征。记忆-交流-语言文字-记录-命名-定义-自己与自己交流-听听过去自己怎么说跟将来的自己说说当下的想法-当下不同念头之间的交流-众念国-可以将整个族群当作一个生物也可反过来将一个人看作一个生物聚落
          宇宙众生未尝不是尽归同一众念国。
        树叶
      人道 以人命名，但 与人并无什么特别关系。只是因为是人在命名，并且认为人乃万物灵长，故有此称。
      人类远未将人道推衍至极，而众生也皆在人道上蹒跚前行。
      将所有生命视为一个整体也无不可。旨在不断磨砺壮大自己。
    逆天改命
    人道。 要你按时老死，你偏要长生久视？
    人道圣人，将道果融入人道之中？这也是外道法门，与 器修/剑修/符修/乐修/阵修/御兽驱虫/傀儡/驭鬼炼尸/化身惑众/神打召唤/香火神道/功德神道/山水神道/借势夺运/诅咒/体修/寿修/吉修/法修/空修/梦修/遁修/禁修/洞修/真修/劫修 差别不大。丹修用药，由外而内，打了个擦边球，亦算不得正统（内道法门）。
      别家传法，我宗传道，传的便是行侠仗义的道！--剑宗
      如果认为个人并非独立的存在，只是人道者大江大河的一个小小浪头，那修人道也不能算是外道法门。--逝者如斯夫，不舍昼夜
          我见画中色彩斑斓，不知有人不知有物。
            白衣苍狗-体现人性，『断见』是无人性
          究竟 孤单自觉的野兽 和 紧密契合的零件 哪一个更有人性？
    神通不及天数-以人为本-道不远人
      科技发达若不关注民生
        医疗系统天下第一，但穷人病死用不起
        物资丰沛，狗豕食人食不知俭，路有饿殍不知发
        武器流通，民众生命却得不到保障
        律法繁浩，贼盗多起
    雷霆雨露俱是天恩
      龙生九子，子子不同。因为 龙不是生出来的，是磨砺中造就的。信仰认知 难以承传，父子乖离，愚公移山 的 想法太简单。子孙不会理所当然地接受祖先的控制，这既是灾难也是生机。--山与海之间
      天行健君子以自强不息。消灭了敌人还有远方更强的敌人，消灭了外部的敌人自己内部将来也会分裂，度过天灾还有未来更大的天灾，度过外加的灾劫自己的体量膨胀对资源不竭的索取将成为内生性的灾劫。
          人的最大敌人是自己，是自己无穷无尽的欲求，这是进步的动力，这是自毁的根源。理智告诉你，以阶级斗争为纲；感性告诉你，『人民日益增长的物质文化需求』是主要矛盾。理性 理所当然地 败退，因为 一切智慧 围绕 终极目标 运动。
      国语*楚成王以周礼享重耳
        #冀州之土其无令君乎
        #十室之邑必有忠信#子曰：“十室之邑，必有忠信如丘者焉，不如丘之好学也。”《论语*公冶长第五》
        #令尹子玉曰：「請殺晉公子。弗殺，而反晉國，必懼楚師。」
        #王曰：「不可。楚師之懼，我不修也。我之不德，殺之何為！天之祚楚，誰能懼之？楚不可祚，冀州之土，其無令君乎？且晉公子敏而有文，約而不諂，三材侍之，天祚之矣。天之所興，誰能廢之？」
        令尹子玉曰⑧：“请杀晋公子。弗杀，而反晋国，必惧楚师。”
        王曰：“不可。楚师之惧，我不修也。我之不德，杀之何为！天之祚楚，谁能惧之？楚不可祚，冀州之土⑨，其无令君乎？且晋公子敏而有文，约而不谄，三材待之，天祚之矣。天之所兴，谁能废之？”



    三魂:爽灵、胎光、幽精
      天魂-不灭真灵，终极目标，真，命。
        命者名也，所谓 真名，即是人生的终极目标，但大部分人主观上并不能觉悟自己的真名。人一生一世的活动、思考 就如同滚落的石子，『轨迹虽然复杂，但大势是趋向更低处』一般，是围绕着 自身的终极目标 的。
        为什么会有这种东西？比如说，故事里的角色，他们有自己的天魂，一切的思索行为会依此自行的发生，即使 故事 可有诸多版本，作者、读者、同文作者 必须 在某种程度上 体验到这一点共识，否则就不是故事 只是 文字白噪声，或者说 只两个偶然同名同姓的角色，他们的真名并不相同。只要真名相同，角色不论叫什么，是男是女，是人是仙是妖是鬼，是器灵是机器人是人工智能，读者都应该能认出来。
        天真--《庄子:渔父》『礼者，世俗之所为也；真者，所以受于天也，自然不可易也。故圣人法天贵真，不拘于俗。』。
        天魂不灭不易，是恒在的，并不是人出生时才产生的。具体类比，可比 数字、公设（前提假设，非真非假）、人设（人设为何不是作者创造的？简单地说，人作为一个信息处理器，并不能产生新信息，一切思维产物有其源自，质量能量信息守恒，有的只是表面形态上的流变）、某一句话某一句诗（诗句并不是诗人创作时才出现的，作为文字的某一排列组合，自然而然地存在着）
        真名 并无 时空属性，无 时间属性 即 恒在，无 空间属性 即 可重叠 多处出现（比如：3这个数，一堆沙子，随便3粒 可表达3，3堆沙子也是3）
      人魂-记忆，人生历程，社会关系，国功民劳，恩怨情仇，缘。用小说来打比方，则是 同一个角色 在 不同版本中的 经历。《三国演义》、《西游记》、《水浒传》都是同人小说。
      地魂-人之德（不是 个人的遗传信息，是 族类的遗传信息）。联系 三魂七魄，人之所以有人样的模版--人之德，人样子。
        德者，得也，子肖父，人肖德（人 肖 人之德、人样子）。用强类型编程语言来打比方，就是 地魂之于人 等如 类型之于对象。
        德 虽然 不仅仅只是 形体，但形体之德 肉眼可见 最好 理解。如果世上只有九个人，或缺左手，或缺右手，或缺左腿，或缺右腿，或盲，或聋，或哑，或六指，或两性人，试想 人之德 在形体上的表现 为何？
          德，直心之得，如 审美观，有先天遗传的成分，也有后天人文风俗潜移默化的成分。
        肉眼不可见的：昆虫会变态，人类幼儿智力水平会随着年龄快速提升（修仙小说里灵兽成长自然进阶），人是群居动物...
          德:群体意识
            印度-种姓/神灵/宗教
            欧美-强盗/掠夺/欺骗/胁迫
            中国-大同/统一/从众/保身
            生活环境对人的潜移默化自幼年便开始，人在长大后会对自己进行再教育式自学，虽然有时会显式地与群体意识相抗衡、反对、摒弃，但这种言行一致十分浅层，乃刻意而为。当外部压力过大（受威逼利诱以至于无法相信自己）或过小（完全无责任以至于无法引起注意），随时都会保留本性。
    人道惑人: 寿，智，志
      寿:活物求生
      智:灵物因智
      志:志为智纲
        老:僵化，不接受新事物，不学习新知识，只因志向（人生终极目标/欲求）早定。
  面相-嫌丑爱美
    脸上长瘤/恶眼之相 面相不好命格不好 妨害至亲？
    这贼老天也忒嫌丑爱美
  树叶-寿命限制的根源
    人的生死如同树叶的茂凋，乃是人道意志的体现，什么文治武功都是臆想，该死的时候就会死，与奴隶贼寇无异。
    天地不仁，圣人不仁
    岁寒，树叶无用甚至有害，故被舍弃。一代新人长成，陈人占据着同样的生存空间资源，不利族群更新，故而老死。
  取长补短，分工合作，德配其位，人处其份，各展所长
    贵精？贵多？
      对集体而言，究竟是一个样样精通的人才更有利还是多个专业人才更有利？样样精通固然更容易打穿壁垒推陈出新，但毕竟生命有限，探索试验、交流教导、制造改进……诸般事务耗时永无止境，一个人终究是不如多个人对集体更有利。
      中底层贵多，顶层贵精
      一个师傅只收三两个徒弟，长年累月在实战中教导，这种模式的问题在于即使最理想的情况弟子个个成才，对于技艺的推广而言也极其缓慢。若是弟子不成气候、不收徒弟、不善教导，只怕传承断绝都有很大可能。
      普及初等教育，事实上是集体自身发展的需要，为顶级传承筛选接班人，并不是为了个人的发展。所以有人觉得九年义务教育很多内容用不上，学了浪费时间，只能说没看明白为何免学费还有奖学金，并不为你。
      并不为你
        养蛊万千只留其一
        养兵千日用兵一时
        多少莘莘学子，三年只有三甲
        普及九年义务教育，遴选苗子，财政支出、学生无数课时 都是 付出的成本，值不值自有说法，总而言之，并不为你
      待遇
        养猪场对猪可好了，分配对象，养育猪崽，包吃包住，免费医疗，打针吃药，补钙清洁...
        不允许自杀#百草枯、毒品、安眠药

青
  徒有人形罪
巨蚌
  这边界防御实是多余，浪费人力物力，最好磨灭。边界自在人心，并不因为我说磨灭便磨灭，也不因你说永存便永存。只能说同心同德是个长期目标，慢慢来不急。
功劳体系-缺陷
  战争 应该摆在哪里？
  要么不得一统，战乱不断，要么和平之后用进废退，纷乱再起，治乱循环
    巨兽启蒙，记史不宣，传承不灭，补足战乱缺陷
  为什么要接受挑战？他有什么资格挑战？凭啥要按战力评高低定权位？为什么不同要求偏要捆绑在一起？过去的传统就让它过去，我们现在分工看专长。
    你不正是靠战争胜利才地位巩固？勇武、智慧、名声、权势、财富，本来就是高度统一的，你这么强行拆分，全靠政策律法维护，毫无稳定性可言，混乱自此始。
  排资论辈
    德不配位，众议其非
    年少位高，究竟有何功劳？地位高更容易斩获大功，地位低只能小打小闹，还得分润些功劳给上级。资历深厚，功勋积累也多。排资论辈，难以避免。到底是死循环，还是正反馈，还得看看。
      人脉。慧眼识才，提拔后辈，水涨船高。功劳哪有可能一人包揽，但门生故旧满天下，也是一样的。
  功成何必在我？
  人的任何一个缺点都足以将其击倒。让人各得其所各展所长，谈何容易？
  你以为 功劳体系 是手段，但它其实是 目标。
世间无尽藏就在眼前，却还需去哪里争夺天材地宝？
玩游戏，玩数学，玩艺术，玩技术，埋头苦干，为民请命，舍身成仁，不为名利，有何稀奇？喜欢搂钱，说不定也只是喜欢存款额上涨，跟贴吧水经验一样。逍遥自在，不在别人口中。乐在其中，不足为外人道。
  --你竟然 将 游戏搂钱 与 殉道成仁 相提并论？
  --何止！赌博，嫉妒，旅游探险，争辩，极限运动跑步，仪式拜神，阅读八卦...
天部主杀务虚，地部主生务实，人部主导统御。
  《国语-卷二-周语-中-3-阳人不服晋侯》武不可觌，文不可匿。
      #《国语全译》贵州-黄永堂 此处 目录有误（正文标题无误）:公侯，等候时候
  天部:开疆，征伐，审判，法律，理论，实验，游戏，享乐，艺术，文化，历史，新闻
    不变:不跟风不从众不同流合污（比如：错别字、多音字发音不准）
    变易:智者乐水，天地不仁，优胜劣汰，文化-避免 削足适履/刻舟求剑，人体改造
  地部:生产，工艺，运输，教育，医疗，人事，销售
    不变:仁者乐山
    变易:和光同尘，与世浮沉，众乐乐不独乐乐
  人部:信仰，统筹，路线
  天地人-上太玉
  游戏设计-剧情-吞噬者-吞噬记忆--分支开启阈值:剧情/记忆/勇气值/智力值/仁义值/...
    地-道不远人-以此被认为得意，称道友序为师兄妹。影视反映修行种种，暗讽师兄种种过失-即-离人
    人-有朋自远方来，不亦乐乎？坐而论道，宾主尽欢。吞噬者来，生灵涂炭，这便是论道。大道独行，制造种种傀儡、生灵，引导它们修行，尝试各种途径。根据各人境界授予不同权限及封地。地部、天部 即是 其中成就最高者，平等相待。

剑修像邪修
  不贪生，夭折死于非命，无法想象躺在床上寿终正寝的样子:生死本是寻常事-邪教口号
  重杀不重养生，不畏因果业力:一剑斩之-天劫加重？那就炼更强的邪器
所有老师都希望学生聪明有天赋，面对愚顽没有进步的学生会暴躁崩溃。但是假如能自学成才无师自通，还要老师干嘛？
既然连遍知遍识都做不到，人自然便有亲疏远近，对不认识乃至于不知道存在与否的人，其死活又有何影响？自有亲近的人在乎。
合理
  合不合理，是人道范畴的概念，是人们对于耳闻目睹的事件与过往的经验心中确认的理论进行比较嵌入得出的结论。道就是道，无所谓合不合理。
  如果某理论与事实不符，该理论便不合理。哪个理？即是不合『实践是检验真理的唯一标准』这个理。但这个理本身合不合理呢？又该合什么理？人类目前恐怕还未探索到这一层次，或者说无此需求。
怎么高个子都躺下了？哦，原来现在我才是
五毒
  与其说火毒有生命，不如说一切生命尽属火毒
多少
  作一选择，自己得利一，众人各得利万。众人虽心知肚明，却不仅不分利，还要笑你蠢笑你穷，欺你辱你，如此抉择你作是不作？
  用进废退，和平时期，军备废弛，人才流失，军人地位卑下。
弱小
  被压迫剥削，仍不肯脱离，因为无法独自生存，只能抱团取暖，被迫害也只能忍受。

若不辜负你的信任，却是要辜负属下高升一步的期冀。信任？一文不值。帝王术又如何？凡事还是要讲规矩。
绝地？难道不是这些孑遗的最后家园吗？
祭祀
  香火成神？不，人人可为尧舜，祭祀有功之人其实祭祀的是心中愿为之洒血的正道，是表达效仿先贤自力更生的呼喊，是团结同志的宣传。若是变成祈求施舍的磕头虫，这祭祀不要也罢。
  人助，助人。又何必认脸？
重因不重果
  有罪无罪当依源头看

功德无量
  彩票主任 领奖，教 希冀不劳而获的穷鬼 做人，肃清歪风邪气，功德无量
  不怨天不尤人，只做该做的事，不计成败。
开挂反杀
  我看出来了，这故事是说，如果没金手指开不了挂没有贵人抬举不是大能转世背景深厚，就只能认命当咸鱼。
  以暴易暴
      明明是爽文，为什么打脸目无法纪的权贵偏偏要依赖更大的权贵？(比如：《符宝》)
  青帝不是某个人，不是成功登顶的某些人，而是不因失败而退却、前赴后继的所有反抗者
  功成何必在我？
    我……我们……（亿兆小人 法天相地）
    我们...我...(众念归一)
  为什么要按别人制订的规矩玩？不爽就直接掀桌子
  什么公子大少，什么宝物权柄，想不到你竟然还痴迷敌方的名利圈。人所定义，我若不认，屁都不是。什么你的我的，我若不认，连你的命都不属于你自己。
  小人-法天相地#idea from 蛊真人-幽魂分身小人族紫-仙蛊『大』
    --你为何不用法天相地？--为何用不了？[......我怎么变小了？...原来已经用了]
      #小人族 由来: 黑帝 科技发达纵横宇宙，但是律法森繁，普天之下莫非王土，逸民苦寻桃源而不得，自缩形骸...但竟然还是没有躲过掌控...求放过，绝地天通
      #
  公道自在人心，就算你能所有人闭嘴，难道众人心中就不鄙视你了？
  钱是我的钱，天灾是别人的天灾，别人才该出钱出力，我有众人无数年血汗铸就的堡垒，要死肯定是最后一个死。
  人口数量+人群密度==智慧基石
  和谈？是要把我的血肉论斤卖么？我不需要赔礼道歉。你砍我一刀，我还上十刀就行。
  抹杀人道功德-抛弃点歪的科技树，断绝传承，摧毁一切成果/造物/传奇/经典/技术/艺术-人贱物鄙，恨屋及乌-再造人间
      --何至于此！何至于此啊？！--一而再再而三，卑鄙无耻偏偏还得意洋洋，留下的也只是恶名污名，与其污染世间，不如断绝你们的一切
      另起炉灶才能正真超越。毕竟别人的技艺流传在外的只是皮毛，甚至有缺陷。
  青帝赐劫
    隳名屠圣
      抹杀 过去种种 及 未来无数可能
      唯有 超脱时间海 的 圣人 才有资格参战，为自己的生存甚至是诞生的可能性而战
        过去明王拳/未来明王拳
小惩大诫
  你以为别人会在乎，其实没人在乎，你以为后人会记得，但后人根本不了解。被害人，凶徒，皆无足轻重，所有人皆无足轻重。不过小小惩罚以示警告，严厉的惩罚对维护稳定的社会关系有害。奴隶、贱民，你所压迫的人，无论正义与否，不论是否弱小愚顽，终至暴动反抗。
私了
  民不举官不告？
  私了？
  若禁止私了，可具有可操作性？
  私了，无非威逼利诱。利诱，则钓鱼，虚假的受害者。威逼，则被自愿私了，不了了之，罪犯逍遥法外。无论何种情况，罪行得不到惩戒，依旧在继续，至于更甚。
  解决方案:消除过大的物质精神双重差距
逆流
  逆时
痕印宗-界神人虫
  痕迹-不可能完全消除，不可能得不出有效信息，但，轻易的破坏可极大的提高得到特定有效信息的难度
    显化，识别，抹除，掩盖，追索（血迁株连）
    遁术-一般与空间相关，万物联系之网，但是，通过抹消痕迹，可脱离时空之网，十分另类的遁术，只是落点定位需另寻法子。
    修行:为道日减，遗忘，成为 不可知的存在 即是 超脱
      #天道不全，书中世界，逃离读者视线
      # 读者-界神人虫 之 虫
      #     痕印宗:痕派:人->虫->界，虫~至弱者方向，不呼只吸/乌，不能影响人，却被人影响；印派:人->神->界，神~至强者方向，只呼不吸/金，能影响人，却不被人影响。界~至强至弱者，不呼不吸，圆极。人~人口人，虫~口人，神~人口,界~口。
  印象-由外而内制造赝品，以假乱真；窜改消息渠道，幻境迷人，乱人耳目；直接窜改性格/情绪/记忆/历史/推演结果
      修行:以假乱真，以虚凌实，无中生有
      符箓:存储，封印
      分身/重生:由他人记忆中的印象重生
      伪造过去
        伪造痕迹/证据，报错仇，断错案
      伪造未来:窜改他人的推演，迷惑众人的眼睛思维
        --我见过未来，你们都死于此役，我才是赢家！战况很快就会扭转了...
        --若非未来之我修成宙道神通，蒙蔽天机，焉能让你容忍我发展？...
      捏造幻想
        人所爱所恨，皆是自己的想象物，现实中的对应物只是一种寄托，并不完美契合幻想物。
逼迫
  约定轮值戍守，拒绝加盟的人会被视为占别人便宜，会遭到围攻。这就是人道压迫。现在别人就在逼迫我。
    关我屁事？当然有关。恩将仇报，有违人道，惩奸除恶，路人有责
  行政上的欺骗是怎么产生的？
    明明我们抱团取暖，理应以诚相待
    指标层层加码，截止日期/产量/
    伤亡人数/损失财货...
    回扣/层层外包/...
    职位只升不降
投降
  不接受投降。你的加盟可以增加我们的实力？别开玩笑了。我们的力量才不是靠投机分子支撑。
修道非修心
  念头通达，意志坚定，修的是己道
    己道、神道 隶属 人道
    证据
      一服己，二服众
      由于技术手段不同、层次有高低，证据并不通用，过于简单容易伪造，过于高级无法理解

  了悟天道，天人合一
教你说人话
  --孽障（坐骑），会不会说人话？明明是除魔卫道，怎么说得我倒像是逐利蝇营之人？（鞭！）组织言辞再给我说一遍！--...--教你说人话真不容易。
压力-内卷
  孤儿寡母 被同族迫害？不是应该帮衬么？
  人口众多，社会生存压力大，弱小无力者自然是先崩塌。
  可早些动乱年代众志成城难道压力小了？
  那是压力太大不得不抱团取暖，现在压力不大不小...好吧，生存压力大但惩罚力度小...
  行了，别压力大压力小，
商
  垄断 生产(原材料、技术专利)、市场、渠道
  垄断 渠道 # 武装二道贩子，零售 交易平台 金融？
  攫取利益 甩锅灾责
    通货膨胀
    污染转移+剪刀差

以战养战
  法宝炮弹
邪不胜正？不过是主流定义了『正』，是以左道旁门『邪』成了小众非主流的大口袋。而人数加长期稳定意味着力量。至于主流是啥，这可没有一定之规。
有用无用
  在有用无用之间...概率分布，个人随机应变？群体各异自由选择？
    分而治之，拉一批打一批
  人只有作为整体才有意义，个人只是树叶。
竞争-弱肉强食
  团体里面又有小团体抱团取暖，内部竞争烈度更弱，形成凝聚力。
  推恩令
    赢者通吃，富有是真，但只是个别人，因为担心均分后力量分散被淹没
    这又形成离心力
  小团体『对外一致』原则+『少数服从多数』原则+优势民主小团体序列==实现少数人控制多数人的民主反向控制
    2人小团体 决定 3人团体的对外策略
    2 -> 3 -> 5 -> 8 ....
    实现2人在民主制度下对8人的奴役
  补有余
    世家，窃据高位，票多资源倾斜，强推更多庸才，打压异己，窃据高位，死循环。

众念国
  --（被人诬蔑羞辱，即非当面又非背后，只在身旁细语又故不掩饰，明明自觉无关，为何面皮火辣气愤填膺，轻巧敷衍，细细体察，莫非这身体自个别有想法）
    ...被别人靠近，戒备心会让整个身体紧绷
  幽冥界-众念国 外显
  神器 如同植物/海绵 有灵无性 - 地域博大，难以一统
  小物件 反而容易诞生器灵，但提升质材，器灵有泯灭之危 - 扩张加速崩溃
  帝流浆--大型基建工程-铺设高速交通网络信息网络，统一语言文字--中央集权自然而然发生
  分久必合，合久必分:广度搜索，深度搜索
      一切斗争都是与自己作战--大我认知，化身亿万
外力
  我要的不是胜利，而是靠自己赢得的胜利。战争及其他一切形式的争斗，不过是仪式，判断德行的人道仪式。

斩红尘
  党争，站队，纠葛已深，如何断？与其让我对得起你，不如让你对不起我。得罪本派系太子党...，不容于各派系，自此脱身。

第一机缘体质-拉仇恨体质
  随便喜欢上一头母猪，该母猪也会立即成为炙手可热的大众情人。
  出门在外，必有肥羊打劫送人头


杠杆原理
  越长越软越容易弯曲，因为杠杆原理
官僚系统 设计
  各级部门/整个官僚系统 分成两部:
    世间部
      来源:任何人
      来源广，思路广，避免本本主义，接地气实践性高，满足大众权欲
    世外部
      来源:从婴儿选取，公开培养，无隐私无私财，没有移民外国的权利。
      执政知识更系统规范，避免世俗人情权财纠葛，有利于矫正歪风邪气
  共同:
    执政起，人生再无隐私
    从底层历练晋升
    #禁止按比例分配

明日黄花
  什么九纹金丹，不过渡河的舟筏，巨舰也罢牛皮也罢，纵使徒手凭河，只要过得河去皆是一样。既过河便是垃圾。

裹尸布
  炼尸的裹尸布 秒变 母猪赛貂蝉-香喷喷的 绫带类法宝

祸福无门，唯人自招
  祸福无门人自招
  总有刁民想害朕:
    抚孤恤寡的老者，仰慕含情的绝色，英明神武的领袖...任何靠近的人、有影响力的人、，重点提防。

生死本是寻常事
  --这一路千里追杀，无数百姓皆因你而死！你算什么正道人士！
  --生死本是寻常事，看破自己的生死，更看破他人的生死。竟然企图用无辜路人的生死来拖延我的步伐？我只为除恶而来，岂能由你摆布！


因为太子需要对手，新皇帝上位需要自己的战功，改朝换代需要砍掉一半树林腾出空间，新班子需要血淋淋的投名状。
说聪明也未必，只是尽心尽力考虑众人的难处缓和矛盾罢了。

正道嘛，肯定占道理，就是没理也得掰成有理；邪道占便宜就是道理。

追名逐利没问题，只不过名利只是工具，关键是用来干嘛，要是将之当作人生目标，或用来享乐，向人炫耀，那就有点可笑。

你吃我，我吃你，自己吃自己

为难
  端午节前，同事派粽子，也不问我要不要，直接放下。
  若是问了，我便顺势拒绝。
  退回去？会得罪人
  吃下去？会被毒死
  悄悄扔？老来饿死-还是做个人渣，浪费粮食算了



档口
  晚上出门，无人留守，关风扇？要不要关灯？若关灯，必须要关门。不如假装有人在里面或附近或很快回来。
歌
  情歌，只有孤男寡女时，还功放情歌，听的人不尴尬，尴尬的是放的人。
二维码 打印 截屏放大移动 避开屏幕缺陷点防止屏幕太小 结果:只有打印的才行，放大移动无效

恭维
  --老板（没看我就一计件兼职打工仔吗），你做得好快（就我最慢房租都够呛）...
  --（同样的事发生了这么多次，我竟每次都无言以对，想来到底是自己情商低）


资格性测试，选拔性测试，自检性测试
  面向自己:
    自检性测试
  面向公众:
    证明能力达标，不限出线人数:
      资格性测试
    证明比别人强，限制出线人数:
      选拔性测试


===============
设计design TODO
===
资源网站
  资源只增不减，链接固化
  修缮+更正+补充+对比评论？标签增减（来自用户？）？游客评论评分？用户提供的资源？
  待填坑？
  ---组织形式
  列表式增加:
    有序 且 紧致
  映射式增加:
    如：梅森素数，其发现是跳跃性的，不能紧致列表
    如：按日期命名，其数据可能有缺失，可后来有补充，不能紧致列表
  集合式增加:
    无序
  ---浏览+下载
  标签、分类(按 内容主题/用途、资源作者、资源编辑者、资源上传者、文本语言（自然语言、编程语言@源代码、机器语言+平台@可执行文件）、文件格式（txt,html,xml,pdf,djvu...）、上传收录日期、实体资源发布日期、文件大小)
  评分/排行榜
  资源当前的推荐款的最新版链接（变动型链接）~此刻相应 资源的固定型链接
    同一资源 多来源 质量不同，同一来源 经过 修缮+更正+补充 会有 新版本
===
输入输出流分类:
  #顺序存取序列（非树状），固实对象（无引用）
  * 按tell返回值是否等价于数组下标分类:
    * unformatted_stream/word_stream vivi array
      tell :: () -> idx
      定长对象
    * formatted_stream/token_stream
      tell :: () -> Unit underlying_stream_idx
      易长对象
      解码
  * 按是否缓存分类:
    * raw_stream
    * buffered_stream

变量分类:
  有无地址:
    有地址:区
      储区:读写区域
      影区:只读区域
    无地址:值
      止值:常量
  含不含地址成员？
    不含:
      定长固实数据
    含:
      黑箱:boxed
        可变长并联数据引用
      白箱:unboxed
        ...

存储文件分类
  书/标准=稳定+找回
  软件=稳定+更新+找回
  他人代码/网页=变动+找回
  我的代码/文档=变动+不可找回
  配置=稳定+更新+不可找回

===============
糖亢奋
  对抗睡眠
  适当的饥饿+温暖，助眠

核酸检测
  必须微信？
  没微信不是人？没手机不是人？


酵母的保存


面粉
  1.734 kg * 4.76 元/kg = 8.3 元
  20210523 蒸作 20 个馒头（1个留作酵头）
    ==>> 馒头 1.7两面粉/4毛/个


我的面食试制
  面粉+糖+盐+开水，随便搅匀，隔水炖、薄盘蒸，沥水筛 晾干。
      盐太多，忘加花生
  干蒸面粉，再混入开水搅拌，团成球状减少发霉面积、减少与存放容器的接触面积。
      花生、盐、糖、少量水，烧开
      倒入面粉，靠花生隔水，覆盖水面，干蒸



嘉5月
  擀面杖 4.5元
  红辣椒粉 4.5元/罐
  玉米粉 3元/斤
  豆皮 6.8元/斤
  面粉 2.8元/斤


安康多功能骨碟 1.2元/个 圆、圆角矩形
正宝简约牙签筒 1.5元/个 翻盖式，推拉门式


三套装 盖盒 9.9元
桶+面盆 9.9元


桶 梳 菜 玉米粉 面粉 小盒子（用作蒸笼）
小功率小体积热水棒  面粉加少量水-醒面-加糖加盐吸水-隔水炖

