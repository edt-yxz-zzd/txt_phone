
天真
  《庄子:渔父》『礼者，世俗之所为也；真者，所以受于天也，自然不可易也。故圣人法天贵真，不拘于俗。』
拘挛补衲
  拘挛：互相牵扯；补衲：缝补连缀。形容诗文勉强拼凑而不自然。
  南朝:梁:钟嵘《诗品:总论》:『遂乃句无虚语，语无虚字，拘挛补衲，蠹文已甚。』
  蠹 du4 流水不腐，户枢不蠹
水浒hu3

for backup cmd:
  view ../../python3_src/nn_ns/filedir/backup_tools/main.py
  view ../../python3_src/my_convention/backup_cmds.txt


to explain:
  novel 新奇的
  refrain from 避免
  horror 恐怖
  hierarchy 阶层 分层结构
    hi/er/ar/chy
      hai er ra: ki
  preclude 阻止
  reject 拒绝
  panic 恐慌
  nickname 略称/简称/绰号
  controlled 受控的 vs open
  conceptual 概念上的
  opaque 不透明的
    o/pe/k
  automatic 自动的
  互斥 mutual exclusion ==>> mutex
    并联 parallel
    串联 series
    优先
      priority
        优先处理 priority processing
        优先电路 priority scheme
        优先调度 priority scheduling

      precedence
      preferential 有优先权的
        preference 偏好
      fallback 退路，应急办法
      preemption 优先购买权
    前瞻 提前 短路 bypass
      prospective 预期的，未来的，有希望的，前瞻性
        prospect [名词] 前景，希望
      advanced 提前的，高深的，先进的
        advance 预先的 [动词] 提前，推进
      短路 short pass, short out
      bypassing 忽略，分流，分路
      bypass 支路，旁路 [动词]忽视，省略，规避，绕道
      预言 predict[动词]
        predicted 预计的/提前预测的
        predictable 可预知的，平庸的/无创意的
      预见 foresee
        foreseeable 可预见的，不远的
      远见/预见性 foresight
        foresighted 前瞻性，深谋远虑的
      预知
        precognition[名词]
        foreknowledge[名词]
        foreknow[动词]
        unforeknowable 无法预知的
          ==>>?? foreknowable 可预知的？
    mutual exclusion parallel
    priority choice/switch
    plain series
    predictable series

  cased 包装，装入
  contiguous 邻接的，无中断的，连续的
  chrono-  [前缀]用于组词表示计时相关的词
        /data/data/com.termux/files/home/../usr/include/c++/v1/chrono
  取消，回退，后悔，调头，回溯
    rollback 卷回
    后悔
      regret
      repent
    取消
      cancel 取消（预定）
      abort 流产，夭折，终止
      draw back
      annul/disannul 废止
      repeal 撤销，废除
      revoke 吊销，撤回
      discharge
      withdraw 提取，撤销
    回退
      backspace 退格键
    后退
      fallback
      give away
      step back
      draw back
        drawback 缺点，弊端，故障，障碍
      backstep
      recession 退却，退离，（占领地的）交还
      regression 倒退，退行
        regress后退 <--> progress前进
    调头 回溯
      turnaround 回转
      back tracking 回溯法
      backtracking 沿原路返回
  预定 预订
    reserve 保留
      booking/reservation 预约 预订
    preset 预置，初调 #类似 default
      ?preplace
    preliminary 初步的
    predefine 预定义
      predefined
    prearrange 预先安排
    preplan [动词] 预先计划
      preplanned
      preplanning 预先计划，前规划
  中途 预告 预感 宣布claim 占领 独占 识别，锁（禁止回退），不归路，单行道，不能调头，不能回溯
    intermediate 居间的，中间的，中等的
    halfway [adj/adv] 不彻底的/不彻底地
    midway [adj/adv] 在中间
    stage 阶段，舞台
      staging 分期，上演
        staging station 中途站
      staged 分期的，分段的，阶梯式
    预感
      forefeel
      premonition
      presage
      presentiment
    提前
      beforehand 预先
      preact 提前
      延期
        postpone/delay 延迟
        defer 推迟
      提早
        early
        advance
        premature 早产的，草率的
          premature optimization is the root of all evil.
    加速，加快
      boost 助推，哄抬，增产，力捧，鼓吹，推荐
      speed-up 加速
      acceleration加速，促进<--> deceleration减速
        accelerate加速，促进[动词] <--> decelerate减速
        accelerated 加速的，早熟的
      hasten 催促，匆匆
      expedite 速办
      stepped-up 加速的
        step up 提升，逐步增加，升压；登上
      quicken 加快

    one-way 单行的，单向的，单程的，自私任性的
      <--> two-way 双向的，两用的
      one way entrance 单行入口
      one way traffic 单行交通
      one way street 单行道
  独占，垄断，排他，独霸，霸占，所有权，主权，私有，拥有，占有，占据，修剪
    monopoly 专有，专卖，专利，独占权
    monopolize 取得垄断
    monopolization 独占化
    排他
      exclusive
      exclusion
      sole 独家的，单身的
        sole licence contract 排他性许可证合同
        sole and unconditional ownership clause 所有权独有条款
    独霸
      dominate 占优势，威压，操纵，支配
    occupy 霸占，占有，占据
    主权
      sovereign 自治的
      supreme 最优的，最高的，最权威的，极端的，终极的
        supreme power 统治权
      supremacy 霸权
    所有权
      ownership
    私有
      private
    修剪
      prune 修剪，简洁
        pruning
      shave 剃
      trim
      clip

  assist 帮助
  mission vs task
  request 申请
    response 应答，响应，灵敏度，反应，回答
  acquire 获得，捕获
    <--> release 释放，发表
      #publish 发行，发布
      #distribution 散布，销售，流通
    resource managerment
    RAII ===‘‘Resource Acquisition Is Initialization’’
  claim 断言，主张，要求
  parallel vs switch vs choice vs alternative
  staged premature accelerated/early failure/success detection conditional pruning exclusive series(backtracking two_way series, exclusive monopoly one_way supreme series)
  ===
  decide 决定
  frame 框架，帧
    [stack_frame]
    stack frame of func to hold automatic object
    automatic vs static vs thread_local vs free-store vs temporary
  operation 效能，作用，业务，工事，操作，运算，实施，运转
  合作
    coordination 协调，对等关系
      coordinate 坐标，坐标系，配位，配价的
    cooperation 合作，协作，互助
      cooperative 非常常用
      cooperate[动词]
      我觉得 强调 协调运转，环环相扣，过程性，并行
    collaboration 合著
      collaborate[动词]一起工作
      我觉得 强调 共同努力以得到一个结果，结果性，可能串行
  serial 串行的，串联的
    serialization 串行化
    series
  并行，并发
    parallel 并联的，并列的，平行的，并行的，并发的
      parallelism[名词]并行性
      时间点上有重合
    concurrent 并行的，并发的
      concurrency[名词] 并行性，并发性
      时间段上有重合
    coincide[动词]同时发生
      coincidence[名词]
    同步 异步
      #chrono- 计时
      #syn chrono us
      synchronous 同步的，同期的，同时的
        synchro- 同步的
        synchronize[动词]同时发生，并发
        synchronized
      asynchronous 异步的，不同期的，不同时的
    simultaneity 同时性
      simultaneous 同时的，联立
      simultaneously 同时地
      ===
      vs simulate[动词]模拟，伪装，仿真
        simulator 仿真器，伪装者，模拟程序
        simulation 赝品
    collateral 旁系的，附属的，次要的，侧的
      lineal 直系的，正统的
      branch分支 vs trunk主干 #stem 茎，干线
      次要
        secondary 次要的，第二位的，衍生的，从属的，辅助性的
        subordinate 下位的，下级的，附属的
        accessory 补助性的，附带的
        auxiliary 辅助的，协助的，补充的，备用的
        minor
        side effect 副作用
        collateral
        non-dominate
        non-essential
      主要
        main 主要的
          mainstream 主流
        chief 最高的，最重要的，最大的
          ?supreme
        major 多数的 <--> minor 少数的
        principal 首要的
          prime 第一流的，原始的，根本的
          primary 初等的，初步的，初期的，原始的，第一位的，根本的
        ruling 支配性的，占优势
          ?dominate
        key 关键的，基本的，重要的
          key link 主要环节
        leading 卓越的，领衔的
          leading role 主角
        essential 必需的，本质的
        basis/base 基础，基准
        mass 主要部分，质量
        master 主要的，支配性的
        prevailing 流行的，优势的
        cardinal 极重要的
  efficient 有效率的
    coefficient 系数
  category 范畴，种类
    ?class
  material原料，资料 vs resource资源
  product产品
  parameter 参数
  contradiction 矛盾
  碰撞
    collision[名词]
      collide[动词]
        vs conflict 对立，争执，斗争，冲突
          such a conflict is resolved by adding an overriding function to the most derived class.
      collision-free
    clash 冲突，碰撞
      name clash
    crash 垮台
    impact 冲击
    knock 敲击
    bump 冲撞
    impinge 碰到，侵犯，影响
  -free
    smogfree 无烟的
    carefree 不关心的，不负责的
    taxfree 免税的
    collision-free


  promise + future
    promise 承诺（做某事）指望，可能性
    compromise 妥协
    future 未来，远景
  无限制
    unlimited 无边际的，无限的，极大的，过度的
    unrestricted 不受约束的
    unrestraint[名词] 放纵
    unbridled 不羁的，无束缚的，放纵的，蛮横的
    unconfined 松散的，自由的，无拘束的
    unbounded 无边际的，无止境的
    open-end 开放的，可广泛解释的
      open end licence 开放式许可证
      open-ended 有无限多的，可扩充的，可扩展的，开口的
  超长
    * 超过额定长度，超过允许长度 extra-
    * 超级长的，非常长的 ultra-
    overlength
      over-length
    superlong
      super long
    extra long
    ultra-long
    lengthy 长久的，漫长的，冗长的
  extra- 额外的，临时的，特别的，格外的，另外的，超出的
  ultra- 极端的，偏激的，过度的
  flow 流动
    data flow diagram

  qualified 合格的，适任的，通过检查的，有资格的；有限度的，受限制的，受限定的
    ##qname-受限定的标识名，被限定词修饰的标识名
  受控的，受管理的，受管制的
    受控
      controlled
      influence[名词] 有影响力
    管理
      administer[动词] 统治
        administrative operator 管理操作员
      rule [动词] 统治
      control 管制
      manager 经营
      direct 指导
      superintend 监督
      supervision [名词] 监督
        supervisor 监督者
        supervisory [err:受监督的？]还是[yes:作为监督者的/用作监督目的的/监督用的？]
          #类似 monitor
          supervisory operating system
          supervisory program 管理程序
    控制
      control
      master 驯服
      bridle 抑制
      curb 限制
      dominate 支配
      govern 治理
      manipulate 操作，窜改  #篡改？窜改？
      cybernation[名词] 电脑控制
        cybernate[动词] 使受电脑控制
        cyber- 网络/数码/电脑
        cyberpunk 网络朋克

    管制
      restrain 克制，羁押
      surveillance 看守，监视
    监控
      monitor 监控器
      supervisor
        supervisory
      watch dog
    维护
      maintain[动词] 维修
        maintenance[名词]保养
          upkeep
      conserve 节约，保存
      preserve 保持
      safeguard [动词]防护 [名词]保护装置
      uphold 支持
      defend 保卫，辩护
      assert 坚持，断言
      service 服务
      working 实用的，现职的
      attendance 看护
    被占领的，被占用的，被分配的，被瓜分的，有主的（无主之物）
      ownerless 无主的
      荒地
        wild 野生的
          <--> tame 驯服的
          <--> cultivated 被 耕作/栽培/养殖 的
        barren 不毛的
        wasteland
      lord 领主
        lordless 无君主的，无丈夫的
      host （待客的）东道主，寄主
      ruled 直纹的，带方格的
        unruled 未统御的，不带方格的
      圈地
        enclosure 圈地，围场
          <--> common 共有地
          enclosed 闭式
            enclosed area 封闭区
  中继
    relay 继电器，接班人，转播
    retransmission
    repeater 中继器
      repeating
      trunking #trunk- 长途
  篡改？窜改？
    窜改 原文/账目
      改易（文字）:窜改旧史
    篡改 历史/经典/政策/理论
      用作伪的手段对经典﹑理论﹑政策等进行改动或曲解。

  union
    anonymous union #匿名
    tagged union === discriminated union
      #mine:cased
    new(&s) string{ss};//placement new: explicitly construct string (§11.2.4)
  lollipop==lollypop 棒棒糖

  目的
    purpose
    destination
    goal
    aim
    target
    objective
    intention
  消耗
    consume[动词]
      consumption[名词]
  ？朴素，天然，质朴？
    severe 严重的，苛刻的，简朴的
    austere 节俭的
    sober 不鲜艳的
    unadorned 未加修饰的
    modest 谦逊的，有分寸的
    rustic 老土的，粗糙的
    stark 写实的，纯粹的，无装饰的
    naked 裸露的
    raw/rude/crude 未加工的
    natural
      innate 天生的，先天性的 <--> acquired 后天性的，获得性的
    plain 清楚明白的
    simple 单纯的
    easy 容易的
    innocent 无罪的，无辜的 <--> guilty
    naive 天真幼稚的
    childlike 童真的
    pure
    天真 《庄子:渔父》『礼者，世俗之所为也；真者，所以受于天也，自然不可易也。故圣人法天贵真，不拘于俗。』
  使用中/工作中/在线/线上/活的/存活的
    use 使用
      usable 可用的
      usage 用法 abusage 误用
    exploit 利用
    apply 运用
    active 活跃的 <--> passive 不活跃的，消极的
    working 在职的
    on-line 线上，在线，联线，联机
      <--> off-line 脱机，离线
      on-line operation(OLO) 在线操作
      on-line data processing
    in-line 在线，同轴的，内联，直列的
    demountable 可拆卸的
    alive[表语？]/living[定语？] 在世的 <--> dead 已死的
    survival 残存的
    dangled 悬挂着的
      ?undangled
    ??scoped??
    lifetime 终身的
    duration 存续期间
    life span 生存期间
    嵌入
      inlet 入口 outlet 出口
      embed
      inbuilt
      builtin
      buried
      telescope
  嵌套
    nest
      nesting
      nested procedure
      nested recursion
      nested structure
      nested loop
    escape 脱逃
      escapable cost 可节省的成本
    imprison 监禁
    detain/jail/intern 拘留
    arrest/apprehend/capture 逮捕
    captive 被俘的，被监禁的，被系住的


  chunk vs block vs piece
    chunk 厚块，厚片，大块
    block 木块；阻塞
    part 部分（构成全体的一部分）
    portion 从全体中划出的一部分
    piece 碎片，零件（脱离全体的一部分）
      piecework 计件工作

  error-prone
    prone 倾向于，有...倾向的
  specific
    unspecified
    specification
  indicate
  formal argument === parameter
    vs actual argument
  facility 设备；容易<-->difficulty
    facilities and equipment
  variadic template
  arbitrary
  ellipsis =?= ...
  logical criteria = precondition | postcondition | ...

  illustrate 举例说明
  demonstrate 示范，论证
    undemonstrated 未证实的
  fault-tolerant
    failure[名词]失败 <--> success
    fault 缺陷，故障，过失
      faultless 完美无暇的，无失误的
  plausible 貌似真实的
    implausible 难以置信的，不似真实的
  decent 得体的
  deprecated
    deprecate 非难，藐视
    outdated 过时的
    duplicate 重复的
  syntactic sugar
  name clash
    accidental name clash
    potential
  explicit qualification
    qualifier
  synonym
  confusion
  orthogonal
  iterater/iterator
    err:iterater
    iterator
  marginal
  section
  examine
  technical
  aspect
  compose
  convenience
  safety
  accessible
  using-declaration
  using-directive

  intrusive
  backward compatibility
  consequently
  particular
  circumvented
  realistic
  circumstances
  guarantors of invariants
  access specifiers
  obey rules
  intricacies of our code
  fortunately
  implicit conversion
  explicit
  be optimized away (elided)
  mundane sophisticated complicated
    the simple and mundane is statistically far more significant than the complicated and sophisticated.
  contrived
  opportunity
  refinement
  eliminate
  denote
  typical
  immensely
  overelaboration
  leads to inconvenience
  deliberately being a bit paranoid
  sloppy
  firmly entrenched
  mandatory
  concrete classes(value types) vs abstract classes vs class hierarchies
    value-oriented programming
    object-oriented programming
  distinguish
  emphasize
  similarity
  intent vs purpose
  incurs no hidden overhead
  indirection through pointers
  housekeeping
  gross
  establish the invariant
  inevitably
  homogeneous
    how to define constructors to accept arbitrarily sized homogeneous initializer lists (such as {1,2,3}and{1,2,3,4,5,6}).
  delegating constructor
  shallow copy vs deep copy vs move operation vs copy-on-write
    shared state vs independence
      entangled when the requirement of independence have been violated
        garbage collection
    praised for ‘‘efficiency’’
  obvious
  alternative
  caveat
  ancillary function
  no compelling reason
  directed acyclic graph
  unsurpassed
  homogeneous containers
  heterogeneous lists
  conceived
  brand-new
  contextual keyword
  indulge
  interface inheritance vs implementation inheritance
    abstract class + pure virtual function
    using baseclass::f;
  in contrast to
  multiple-inheritance lattice
  inquires
  turning a knob
  ?frontend
    sibling
    ambiguous
  replicated
  nuisance
  consistent
  terminology
  mixin
  class hierarchy navigation
    class lattice === class hierarchy
  be unduly concerned about
  virtual call mechanism
  RTTI vs RAII
    RAII ===‘‘Resource Acquisition Is Initialization’’
    RTTI === ‘‘run-time type information’’
  downcast vs upcast vs crosscast
    Casting from a base class to a derived class is often called a downcast because of the convention of drawing inheritance trees growing from the root down.
    Similarly, a cast from a derived class to a base is called an upcast.
    A cast that goes from a base to a sibling class is called a crosscast.
  abbreviated to
  dynamic dispatch
    double dispatch
  a region of memory
  generic
  subscripting, concatenation, and comparison
  instantiation, specialization
  parameterized
    A version of a template for a specific template argument list is called a specialization.
    The process of generating a class or a function from a template plus a template argument list is often called template instantiation.
    特化 - 特化版本的模版声明+定义体
    实例化 - 模版绑定实际参数后生成的实际代码+对象
    point of instantiation 第一次使用模版产生实例代码+参数相关的错误检查
  code bloat, code shrinkage
  early detection
  granted
    I made all members of Link private and granted List access.
  acronym, synonymous
  nonsensical
  exposure
  encapsulate, encapsulation
  concept, constraint
    Concepts and Constraints
  weave
    This implies opportunities to weave together information from different contexts.
  manifest
  endeavor
  accomplishment
  craft, reflect
    I see a concept as a carefully crafted entity that reflects fundamental properties of an application domain.
  hesitate
  semantic specification
  emphasize
  lexicographical ordering
  archetype #仅止于刚好满足概念约束最小需求的类型，用于 检查模版的实现 有无 超出声明的需求
  sufficient
  backbone
  performance-critical areas
  mature examples
  paramount
    run-time efficiency and compactness are paramount.
  policies#policy
    parameterize classes and functions with ‘‘policies.’’
      comparison criterion for a map
      actions for algorithms (§4.5.4, §32.4)
        sort()
      allocators for containers (§31.4, §34.4)
      deleters for unique_ptr(§34.3.1)
  comparison criterion
  elaborate
  crucial
  tedious
  refrain
  deliberate, tradeoff, flexibility, opportunity, obscure
    Not allowing an ‘‘empty’’ argument to mean ‘‘use the default’’ was a deliberate tradeoff between flexibility and the opportunity for obscure errors.
  traits#trait
    The technique of supplying a policy through a template argument and then defaulting that argument to supply the most common policy is almost universal in the standard library (e.g., §32.4).
      Curiously enough, it is not used for basic_string(§23.2, Chapter 36) comparisons. Instead, the standard-library string relies on char_traits(§36.2.2). Similarly, the standard algorithms rely on iterator_traits(§33.1.3) and the standard-library containers rely on allocators(§34.4). The use of traits is presented in §28.2.4.
  primary template vs partial specialization vs complete specialization
    template<typename T> class Vector {...}; //general vector type #primary template
    template<typename T> class Vector<T∗> : private Vector<void∗> {...}; //partial specialization
    template<> class Vector<void∗> {...}; //complete specialization

  code bloat~type erasure
    'The C++ Programming Language(4ed)(2013).pdf' :: pg731[746/1366]pg733[748/1366] #code bloat代码爆炸~type erasure类型擦除
  consistent
  customization point #e.g. overload std::swap
  distinction, razor thin, irrelevant
    With this last version the distinction between specialization and overloading has become razor thin and largely irrelevant, so we can simply write:
  irregularity, irregular
    irregularity of an argument type
    ‘‘irregular types’’
  provide, flexible, efficient
    provide flexible and efficient parameterization of types
  notation
  mechanism
  manual, eliminate, redundant, replicated, instantiation
      eliminating redundant replicated instantiations
      26.2.2 Manual Control of Instantiation
  innocent-looking
  coincidence, incidence
  mysterious
  overaggressive
  verbosity
  manipulator
    the endl manipulator
  exploit, various, commonality
    exploits various forms of commonality

  deceptive, duality, rough, approach, individual, accommodate, appropriate, optimal
  polymorphism
    * run-time polymorphism
    * compile-time polymorphism === parametric polymorphism
    ---
    The rough duality of the generic and object-oriented approaches can be deceptive.
        Object-oriented programmers tend to focus on the design of hierarchies of classes (types) with an interface being an individual class (Chapter 21).
        Generic programmers tend to focus on the design of algorithms with the concepts for template arguments providing an interface that can accommodate many types (Chapter 24).
    The ideal for a programmer should be mastery of both techniques to the point where either can be used where most appropriate.
        In many cases, the optimal design contains elements of both.

  undesirable
  premium
  essential
  inhibit vs forbid
    permit vs allow
  be a struggle
  disaster
  instantly vs immediately
  compensate
  constitute
  hypothetical
  devise
  expert territory
  trepidation
  compiler intrinsic
  departure, conventional, shine
    departure from conventional notation that lets implementation details shine through
  indispensable
  compelling
  divergence
  encapsulation
    exposed(‘‘leak out’’)
  exotic
  scaffolding/boilerplate
  repetitive
  potentially, possibility, violation
    potentially differing types
    possibility of type system violations
  plus vs add vs subtract vs minus
  erroneous
  parameter pack
    args...
    ‘‘peel off’’
  hypothetical
  quantity, unit, dimensionless #？不带单位？
    unknown quantity 未知量
    known quantity 已知量
      quantity数量 vs quality品质
    if (speed == 20)//error : 20 is dimensionless
    A Quantity is a numeric value with a Unit.
    A Quantity is a value with an associated Unit:
  physical measurement
  dictated
  magnitudes
  tensors ？张量？
  irregular vs jagged
    check_non_jagged
  utter nonsense
  designate, unknowns, equations, diagonal coefficients, ‘‘back substitution’’, pivot
    the x_s designate the n unknowns;a_s and b_s are given constants.
    The goal is to find values for the unknowns that simultaneously satisfy the n equations.
    the square n-by-n matrix defined by the coefficients
    Gaussian elimination [Freeman,1992], [Stewart,1998], [Wood,1999]
      we transform A and b so that A is an upper-triangular matrix.
      If we can get all the diagonal coefficients to be nonzero, then the system has a unique solution, which can be found by ‘‘back substitution.’’
      Vec classical_gaussian_elimination(Mat2d A, Vec b)
      {
        classical_elimination(A, b);
        return back_substitution(A, b);
      }
  fused operations #融合？
  conscious
    to satisfy performance-conscious users
  accommodate
  stringent
  moderate fluency
  try not to reinvent the wheel.
  cult of orthogonality
  obscure or dangerous
  mnemonic
  commentary distinguishes
  associative containers multimap and multiset
  diagnostics vs debug
  container adaptors
  consistent
  contexts vs categorys
  permitted
  retrieved
    future_already_retrieved
    promise_already_satisfied
    broken_promise
  ultimately originate
    ultimately vs finally
    optionally
    error-message
  potentially portable
    system-specific
    category-specific
    multiple platforms
  convenience
  tedious
  deem, roughly, devise
    This roughly means that any test for equality that you can devise on the value of the objects must deem the copy equal to the original.
  amortized linear time
  dwarf a small cost proportional to
  logarithm
  quadratic
  asymptotic
  perennial
  emphasis
  capacity, increased, exceeded, reserve, surprised, measurably affect performance, essentially, growth strategy, estimates, invalidation, predictability, prevent, delay
  chars.push_back()
  caused a relocation, ‘‘invalidated’’
  design, minor, stylistic, binary, framework
    this design is with minor stylistic differences that of a real binary tree framework [Austern,2003].
  benefit, optimization
    I benefit from the empty-base optimization.
  traversal
    indirect through a pointer
    consecutive access through a vector-like structure
    optimal
    efficient random access
    underestimate these benefits
    incur
    an order of magnitude more expensive than
    equivalent data
    spectacular
    surprising
    suggest
    compactness and efficiency
    unintentionally compromised
    two-dimensional matrix
    two obvious alternatives
    subscripting
    stores elements contiguously
  tendency
  semantics, occasionally, disadvantage
    enables efficient move semantics
    that occasionally puts it at a disadvantage
  pessimization
  minimizing
  worthwhile
  massive
  empirical
  splice
  comparison criterion
  bewildering
  convenient 
  realistic, scenarios, typically
    load factor of an unordered associative container = .size()/.capacity()
    (worst caseO(n∗n)) how unordered_map::rehash()?
    in realistic scenarios typically do
  experimentation
  adaptor, provide, restricted
    A container adaptor provides a different (typically restricted) interface to a container.
  ======
  appending
  ======
  ???!!!
  重命名

    串===序列/流
    规范串===数组
      #变长|定长
      #变长（变短）？易长（异常）？动长？
    链串===链表
    单端改动串===栈/后进先出队列
    单向移行串===队列/先进先出队列
    双向移行串/双端改动串===双向队列

    阵===矩阵/二维矩阵
    点
    有序正交点===元组/向量/位移/一维矩阵
    有序命名正交点===命名元组
    无序索引正交点===记录/结构体

    #associative containers multimap and multiset
    关联表===映射/词典
      #单主键|多主键 / 单索引|多索引
      #单一等价代表|复数等价代表
    无序散列关联表
    有序散列关联表
    全序平衡树关联表

    集===集合
      #单一等价代表|复数等价代表
    无序散列集
    有序散列集
    全序平衡树集


===
to read:
  book:C++
    '/sdcard/0my_files/book/lang/C++/The C++ Programming Language(4ed)(2013).pdf'
      e others/book/The\ C++\ Programming\ Language(4ed)(2013).txt

    download: cppreference.com
      termux
      update clang c++20
===clang
$ view ../../../usr/include/c++/v1/list
  TODO:how both .size() and .insert() O(1)?
  ls.insert(at_before, begin, end)
    ==>> ls => this.sz
    ==>> copy => this.sz ++ repeat n times
    ==>> NOTE: insert() copy not emplace-move/snap from another list!!!
  lst.splice(p,lst2)
    Insert the elements of lst2 before p;lst2 becomes empty
    O(1)
  lst.splice(p,lst2,p2)
    Insert the element pointed to by p2 in lst2 before p; the element pointed to by p2 is removed from lst2
    O(1)
  lst.splice(p,lst2,b,e) Insert the elements [b:e) from lst2 before p; the elements [b:e) are removed from lst2
    I think must be O(n)
      yes! clang::list::splice using distance() to count!!!

$ ls ../../../usr/include/clang -1
  ARCMigrate
  AST
  ASTMatchers
  Analysis
  Basic
  CodeGen
  Config
  CrossTU
  DirectoryWatcher
  Driver
  Edit
  Format
  Frontend
  FrontendTool
  Index
  Lex
  Parse
  Rewrite
  Sema
  Serialization
  StaticAnalyzer
  Tooling
$ ls ../../../usr/include/clang-c/ -1
  BuildSystem.h
  CXCompilationDatabase.h
  CXErrorCode.h
  CXString.h
  Documentation.h
  Index.h
  Platform.h
$ ls ../../../usr/include/c++ -1
  v1
$ ls ../../../usr/include/c++/v1/ -1
  CMakeLists.txt
  __bit_reference
  __bsd_locale_defaults.h
  __bsd_locale_fallbacks.h
  __config
  __config_site.in
  __cxxabi_config.h
  __debug
  __errc
  __functional_03
  __functional_base
  __functional_base_03
  __hash_table
  __libcpp_version
  __locale
  __mutex_base
  __node_handle
  __nullptr
  __split_buffer
  __sso_allocator
  __std_stream
  __string
  __threading_support
  __tree
  __tuple
  __undef_macros
  algorithm
  any
  array
  atomic
  bit
  bitset
  cassert
  ccomplex
  cctype
  cerrno
  cfenv
  cfloat
  charconv
  chrono
  cinttypes
  ciso646
  climits
  clocale
  cmath
  codecvt
  compare
  complex
  complex.h
  condition_variable
  csetjmp
  csignal
  cstdarg
  cstdbool
  cstddef
  cstdint
  cstdio
  cstdlib
  cstring
  ctgmath
  ctime
  ctype.h
  cwchar
  cwctype
  cxxabi.h
  deque
  errno.h
  exception
  experimental
  ext
  filesystem
  float.h
  forward_list
  fstream
  functional
  future
  initializer_list
  inttypes.h
  iomanip
  ios
  iosfwd
  iostream
  istream
  iterator
  limits
  limits.h
  list
  locale
  locale.h
  map
  math.h
  memory
  module.modulemap
  mutex
  new
  numeric
  optional
  ostream
  queue
  random
  ratio
  regex
  scoped_allocator
  set
  setjmp.h
  shared_mutex
  span
  sstream
  stack
  stdbool.h
  stddef.h
  stdexcept
  stdint.h
  stdio.h
  stdlib.h
  streambuf
  string
  string.h
  string_view
  strstream
  support
  system_error
  tgmath.h
  thread
  tuple
  type_traits
  typeindex
  typeinfo
  unordered_map
  unordered_set
  utility
  valarray
  variant
  vector
  version
  wchar.h
  wctype.h

$ ls ../../../usr/include/c++/v1/*/ -1
  ../../../usr/include/c++/v1/experimental/:
    __config
    __memory
    algorithm
    any
    chrono
    coroutine
    deque
    filesystem
    forward_list
    functional
    iterator
    list
    map
    memory_resource
    numeric
    optional
    propagate_const
    ratio
    regex
    set
    simd
    string
    string_view
    system_error
    tuple
    type_traits
    unordered_map
    unordered_set
    utility
    vector

  ../../../usr/include/c++/v1/ext/:
    __hash
    hash_map
    hash_set

  ../../../usr/include/c++/v1/support/:
    android
    fuchsia
    ibm
    musl
    newlib
    solaris
    win32
    xlocale
$
===
TODO:
  c++头文件 新建自动化
    #escape include guard
    #len{ddd}_{name}
    #len{ddd}esc_{escaped_name}
    #len{ddd}ext_{extension_suffix_name}
    项目根目录+头文件相对路径
    ==>>
    //{xxx}.hpp
    #ifndef INCLUDED__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{xxx}_hpp
    #define INCLUDED__len{ddd}_{dir0}__len{ddd}_{dir1}__len{ddd}_{dir2}__len{ddd}_{xxx}_hpp
    //#include "dir0/dir1/dir2/xxx.hpp"
    #include "xxx.hpp" //this header
    namespace dir0{ namespace dir1{ namespace dir2{
    ... ...
    } } }
    #endif//INCLUDED__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{dir}__len{ddd}_{xxx}_hpp

TODO:
  vector with fixed capacity
  deque with fixed capacity
TODO:
  矩阵高斯消元 携带 rhs向量/矩阵

TODO:
  ops
  计件薪时
    单位运算模块 unit system
      可度量概念=时间|距离|钱|质量|...
        量纲dimension维 维度
        量纲关系 dimension relation
        量纲常量 dimensional constant
        无量纲dimensionless
        无量纲系数dimensionless factor/coefficient
      量纲=mul~ measurable_concept**n {(measurable_concept,n)<- 可度量概念*整数}
          <<==量纲的乘除法
      基本单位=未知量*可度量概念
        unit
        unknown quantity 未知量
        known quantity 已知量
          quantity数量 vs quality品质
      复合单位=未知量*量纲
      由于 部分同量纲单位 之间的比例关系 未知 或 待求(如：每月的工作日数，每工作日的工作小时数)，故 带量纲值 = 多项式分式<未知量...> * 量纲(<<==加法的量纲一致性原则)
        ==>> 需要 带多个变量的 多项式分式
        ==>> 需要 代数ops
        ==>> 需要 IOps!!!

    每月的工作日数、每工作日的工作小时数、每大件的小件数、每小件几分钱、每月收入、每日大件数、每大件起步耗时、每小件几秒
    每月收入=每大件的小件数*每小件几分钱 * 每月的工作日数*每日工作小时数*每小时大件数
      每大件耗时=(每大件起步耗时+每大件的小件数*每小件几秒)
      每小时大件数*每大件耗时=1
      ==>>
      每大件耗时=
        =1/每小时大件数
        =每大件的小件数*每小件几分钱 * 每月的工作日数*每日工作小时数/每月收入
      每小件几秒
        =(每大件耗时-每大件起步耗时)/每大件的小件数
        =(每大件的小件数*每小件几分钱 * 每月的工作日数*每日工作小时数/每月收入-每大件起步耗时)/每大件的小件数
        =每小件几分钱 * 每月的工作日数*每日工作小时数/每月收入-每大件起步耗时/每大件的小件数

TODO:
  make_makefile
    独立式辅助文件 vs 注入式描述
      集中控制文件 指明 哪些文件 拥有 注入式描述，字符编码 及 如何 注入/抽取 的 格式(格式=开始行 结束行 行前缀(以注释的方式存在))
    描述:
      文件类型(==>>处理方式):
        *用户预先提供的
          真实文件名
          前置依赖扩散 抽象目标名...
            要不要 预处理 预编译？
              指明 预处理的 抽象目标名
              这样一来，所有 依赖本文件的目标 将也依赖 本文件的预处理目标
          前置需要 哪些项目内部文件 真实文件名 用于 编译期
          后置需要 哪些项目内部文件 抽象目标名(本头文件的实现文件)、哪些项目外部库 抽象外部库名 用于 链接期
        *make自动生成的
          #由 文件类型 决定如何生成
          抽象目标名+构造器参数-依赖类型(见下面)
            (+文件类型+最终配置(后缀名+项目输出根目录<文件类型>(.gch预编译头文件 最好与头文件 放在一起，否则 源文件 依赖的 就要从 头文件 改成 .gch预编译头文件 最好与头文件 放在一起，否则 源文件 依赖的 就要从 头文件 改成 .gch，而且 编译器 还不知道 在哪找到它)))==>>真实文件名)
            #含 相对路径(相对于 本文件所在目录) 不能是 绝对路径(相对于 项目源代码所在根目录，不行 是因为 可能移动))
          前置依赖扩散 抽象目标名...
          前置需要 哪些项目内部文件 真实文件名/抽象目标名 用于 编译期
            //<==>构造需要 哪些项目内部文件 真实文件名/抽象目标名 用于 编译期
      依赖统一表达:
        [依赖类型][依赖跳转类型]:对象名...
        ---
        依赖类型:
          如:
            +前置依赖/编译期依赖
            +后置依赖/链接期依赖
        ---
        依赖跳转类型:
          如:
            +吾之所需
              (本文件我依赖哪些对象？)
              头文件 编译期依赖 其他头文件
              头文件 链接期依赖 自身的实现文件/源文件的目标文件+外部库
              源文件的目标文件 编译期依赖 该源文件
                  直接依赖 用作 构造参数
                  直接依赖+间接依赖+捆绑依赖 仅用于 决定 是否需要 更新/构造
              可执行文件/库 链接期依赖 目标文件
                  直接依赖+间接依赖+捆绑依赖 用作 构造参数
                      但 如何 区分 目标文件 与 外部库？
                          命名规则，一为 抽象目标名，一为 抽象外部库名
            +吾之捆绑
              (若依赖我，则捆绑依赖其他对象，虽然这些对象 并非 吾之所需)
              xxx.hpp 捆绑 xxx.gch
              xxx.cpp 依赖 xxx.hpp 并自动捆绑依赖 xxx.gch
                  先 预编译 xxx.gch 再 编译 xxx.cpp
              xxx.gch 依赖 xxx.hpp 但 并不捆绑依赖 自己！！
                多个 捆绑对象 之间的依赖关系？？
                  如果 它们都依赖xxx.hpp，那么 必须 解开 依赖循环！
                  必须 显式 声明 有无依赖关系？若有，谁依赖谁？

TODO:
  矩阵乘法 与 单位乘法
  假设 行i的单位 叫 r[i], 列 c[j]
    则 mx[i,j] * (r[i]/c[j]) 每个元素 都拥有与众不同的单位
    输入输出 两个面 箭头arr a->b . b->c === a->c
    乘法 将lhs的输出cL[j]与rhs的输入rR[j] 匹配
      匹配的 均作乘法
      最后 出现 多个 元素 带相同单位 rL[i]/cR[k],求和简并为一个， a->c+++a->c === a->c
TODO:
  def:[并联串联]
    语法+数据结构，指令，偏序（有向无环图，类继承关系）
    语法+数据结构:
      并联-空间上的重叠-union 并集
      串联-空间上的先后顺序-direct_product tuple
    指令:
      并联-时间上的重叠-并行
      串联-时间上的先后顺序-串行
    偏序:
      并联-偏序无关
      串联-偏序大小

    // C++ class 有问题: 数据成员的次序: 逻辑次序/概念次序，内存布局次序，初始化次序，大小/相等比较次序(+部分数据成员无关)

  class grammar:#parser/recognizor
    @input_filter(f...)
    @plain_token_name #rsymbol
    def token_name(sf, /)-> None#not callable after @plain_token_name
      #或 istream -> position -> tmay token
    @output_filter(f...)
    @plain_rule_name #lsymbol
    def rule_name(sf, /)-> rhs

    @switch_rule_name
    class rule_name:
      def branch_rule_name

    #arg = data_arg | symbol(lsymbol/rsymbol, plain/arged)
    @input_filter(f...)
    @template_token_name #rtemplate
    def token_name(sf, /, *args)-> arged_token_name
    @output_filter(f...)
    @template_rule_name #ltemplate
    def rule_name(sf, /, *args)-> rhs #after @template_rule_name become: (*args) -> (arged_rule_name :: () -> rhs) #lazy call && hashable <<== recur ref

    obj used in grammar:
      look_ahead(post_rule_seq) <: ignore
        ignore: match and discard output, as-if output not in init seq output
        failure-look_ahead vs fullmatch-look_ahead vs premature-look_ahead vs nonzero-consumption-premature-look_ahead

      try_enter(pre_rule_seq, post_rule_seq)
        pre_rule_seq success ==>> forward decl I match!
      token_tester #acceptor, set, required for arged_token
      filter for data flow
      field-name@series ##idx?
      branch-name@parallel
      ===
      istream<token> .tell/seek/truncate_before/read_le/peek_le
        token.rsymbol #token is not rsymbol!!
        cache symbol match result at posotion until pruning backtracking
      ===
      left-recur ?? recursive-recognizor?
        left-recur detect for grammar&&runtime-parsing/recognizing
          NOTE:look_ahead create a branch
      ===
      前后约束:xml tag，C++ raw-string-literal
      ===
      错误信息 在哪提供？
        根/主左符/不能返回:
          每个 左符/右符 都可能成为 根，均提供一个零消耗匹配失败信息
          最长匹配？
        非根/非主左符/允许返回:
          并联:
            平行:冲突性歧义错误
            平行/优先:无匹配，返回 上层
          串联:
            早产后失败:早产之后，成为唯一路径，后续 左符/右符 变 根，必须 成功 不能 返回
            早产前失败: 返回上层
      ===
      乱序？
        比如: int const === const int
        比如: f()... override final;
        比如: rf'' === fr''
        乱序+重复？
        乱序+分散式重复？
          具象语法树 依 字面 次序排列
          抽象语法树 有序+归组
      ===
      mutual exclusion parallel     __or__ |
      priority choice/switch        __true_div__ / #__rshift__ >>
      plain series                  __mul__ *
      predictable series            __mxmul__ @  #__xor__ ^
        parallel vs switch vs choice vs alternative
        staged premature accelerated/early failure/success detection conditional pruning exclusive series(backtracking two_way series, exclusive monopoly one_way supreme series)
          no plain series
          early-success-detection-series(backtracking-subseq, err_msg, exclusive-subseq)
            premature-series
            early-pruning-series
              zero-consume match can decl pruning-or-not
              look_ahead 模式 标志位:完全匹配、直到修剪信号、非零消耗
          parallel(alternatives, err_msg, *, ordered:bool)

    is_symbol
    is_lsymbol
    is_rsymbol
    is_template
    is_arged_template
    is_partial_arged_template

TODO:
  path naming: dir vs file
    if dirname ends with "/":
      ${dirname}/{relative_path}
        ==>> sep = "//"
      path_sep = dir_end + join_sep + relative_begin

TODO:
  整数<->string
    builtin/literal_type <-> [begin, end)
    <symbol_classify, digit2output_uint, is_sign, is_sep, allow_sign<true>, allow_multi_sign, allow_sep, allow_leading_sep, allow_tailing_sep, allow_contiguous_sep, must_have_digits, must_have_sign, allow_empty, max_output_uint, allow_leading_0s, allow_leading_0_radix_prefix, read_radix>
    digit::value #literal_type constexpr
      instead of digit<builtin_integral>
    digit2output_uint::call(digit::value)
      'A' / 'a' -> output_uint{10}
        output_uint is literal_type
TODO:
  整数表达:

    ##is_same_type
    template<typename S, typename T>
    struct IsSameType{
      static inline constexpr bool is_same_type(){return false;}
    };
    template<typename S, typename T>
    constexpr inline bool is_same_type(){return false;}
    template<typename T>
    struct IsSameType<T,T>{
      static inline constexpr bool is_same_type(){return true;}
    };
    template<typename S, typename T>
    constexpr inline bool is_same_type(){return IsSameType<S,T>::is_same_type();}

    template<typename T>
    struct StdFormOf{
      using type = typename T::StdForm;
      using StdForm = StdFormOf<type>;
    };
    template<typename T>
    using std_form_of = typename StdFormOf<T>::type;
    template<typename S, typename T>
    constexpr inline bool is_eqv_type(){return is_same_type<std_form_of<S>,std_form_of<T> >();}
    /////
    using MaxWord = unsigned_max_t;
    static_assert is_unsigned<MaxWord> # is_integral<T>()
    template Word<MaxWord>;
    template CheckMax<MaxWord radix_minus_1, MaxWord...>;
      radix_minus_1 >= 1
      radix_minus_1 >= args...
    template Natural__0isM__little_endian<MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm
      StdIntegerType
          #Integer__0isM__little_endian
          #Integer__0is0__little_endian
      StdNaturalType
          #Natural__0isM__little_endian
          #Natural__0is0__little_endian
          #for mix use cooperation in continued fraction
    template Integer__0isM__little_endian<bool is_neg, MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm #is_neg ==>> nonempty
      StdIntegerType
      ?StdNaturalType

    template Natural__0is0__little_endian<MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm #to_drop_tailing_0s
      StdIntegerType
      StdNaturalType
    template Integer__0is0__little_endian<bool is_neg, MaxWord radix_minus_1, MaxWord...>;
    template Integer<bool T4_0isRADIX_F4_0is0, bool T4_big_endian_F4l_ittle_endian, bool T4_neg_F4_natural, MaxWord radix_minus_1, MaxWord...>;
      CheckMax
      StdForm #to_drop_tailing_0s #is_neg ==>> nonempty
      StdIntegerType
      ?StdNaturalType
    template Rational<typename Integer, typename Integer__ge1>;
        template Fraction<typename Integer, typename Integer__ne0>;
    template FiniteContinuedFraction__gt0le1<typename Integer__ge1...>;
    template FiniteContinuedFraction__ge1<typename Integer__ge1...>;
    template FiniteContinuedFraction__ge0<typename Integer__ge0, typename Integer__ge1...>;
    template IterContinuedFraction__ge1<typename calc, typename args...>;
      call::next(args::value...) -> <result_pint, next_args...>
    calc_lazy_value<CalcWithArgs>()->R;
    iter_next<IteratorWithArgs>()->(void|BoxWithLabel<typename R, NextIteratorWithArgs>)

    # __0isM little_endian
    mul1__0is0 :: uint%M -> uint%M -> (low__0is0::uint%M, high__0is0::uint%M)
      # 3*5 % 9 == 6 > 5 > 3
      # 3*5 % 10 == 5 == 5 > 3
      # 3*5 % 11 == 4 (< 5)(> 3)
      # 3*5 % 12 == 3 == 3 < 5
      # 3*5 % 13 == 2 < 3 < 5
    mul1__0is0 u v | u>v = mul1__0is0 v u
    #[u<=v]
    mul1__0is0 u v | u<=1 = (u*v, 0)
    mul1__0is0 u v | v <= floor_sqrt (M-1) = (u*v, 0)
    mul1__0is0 u v | u <= floor (sqrt(M-1)/x) && v <= floor (sqrt(M-1)*x) = (u*v, 0)
        where x=continued_fraction[1; 1...]
          #[1<x<2] #1<x=1+1/x<2 #(-1/x)=1+1/(-1/x) #1/x=x-1
    mul1__0is0 u v | v <= (M-1)//u = (u*v, 0)
    mul1__0is0 u v = (l0+d*l1_h0, l2_h1+d*acc3_h2)
        where
            d = 1+floor_sqrt(M-1)
              # [(d-1)^2 <= M-1 < M <= d^2]
              #[M>=2][d>=2]
              #[(M-1)^2 < d^4]
            (qu, ru) = divmod u d
            (qv, rv) = divmod v d
              #[d<=v<=M-1<d^2]
              #[1<=qv=v//d<=(M-1)//d<=d-1]
              #[u<=v][0<=qu<=qv<=d-1][u*v<=v^2<=(M-1)^2<d^4]
              #[0<=qu,qv,ru,rv<=d-1]
              #[max ru qu * v <= (d-1)*(M-1) < (d-1)*d^2 < d^3]
              #[u*v < d^4]
            (l0,l1,l2) = mul_h_hh ru (rv, qv)
            (h0,h1,h2) = mul_h_hh qu (rv, qv)
            (l1_h0, acc2) = add_h_h l1 h0
            (l2_h1, acc3) = full_add_h_h acc2 l2 h1
            acc3_h2 = acc3+h2
              # (l0, l1_h0, l2_h1, acc3_h2)
              # output here

            add_h_h :: uint%d -> uint%d -> (uint%d, acc::uint%2)
            add_h_h x y = if d-x <= y then (y-(d-x), 1) else (x+y, 0)
              #[half+half<=2*(d-1)==2*d-2==d+(d-2)<2*d]
            full_add_h_h :: uint%2 -> uint%d -> uint%d -> (uint%d, acc::uint%2)
            full_add_h_h acc x y =
              #[acc+half+half<=1+2*(d-1)==2*d-1==d+(d-1)<2*d]
              let (z0, acc0) = add_h_h x y
                  (z1, acc1) = add_h_h z acc
              in  (z1, acc0+acc1)
            mul_h_hh :: uint%d -> (uint%d,uint%d) -> (uint%d, uint%d, uint%d)#little_endian
            mul_h_hh x (y,z) =
              #[x <= d-1][y+z*d<=M-1]
              #[x*(y+z*d)<=(d-1)*(M-1) < (d-1)*d^2 < d^3]
              let (qxy, rxy) = divmod (x*y) d
                  (qxz, rxz) = divmod (x*z) d
                  #bug:add overflow@[M=2] (acc, qxy_rxz) = divmod (qxy+rxz) d
                  (qxy_rxz, acc) = add_h_h qxy rxz
              in  (rxy, qxy_rxz, acc+qxz)
                  #[0<=acc<=1]
                  #[acc+qxz<=d-1]
                  #if[M:=4][x,y,z:=1]:[d=2][acc=1][qxz=0]
                  #if[M:=2][x,y,z:=1]:[d=2][acc=1][qxz=0]

    mul1__0isM :: uint%M -> uint%M -> (low__0isM::uint%M, high__0is0::uint%M)
    mul1__0isM 0 0 = (0, M-1) #==M*M==M+M*(M-1)
    mul1__0isM 0 v = (0, v-1) #(0,0)<==>M+0*M==M==M*1
    mul1__0isM u 0 = mul1__0isM 0 u
    mul1__0isM u v =
      let (low__0is0, high__0is0) = mul1__0is0 u v
          #[1<=u,v<=M-1]
          #[1<=u*v<=(M-1)^2<M^2]
          #[M^2>low__0is0+high__0is0*M == u*v >= 1]
          #[0<=low__0is0,high__0is0<M]
          #[(low__0is0, high__0is0) != (0,0)]
          #[low__0is0==0] ==>> [high__0is0!=0][high__0is0>=1]
          #[high__0is0 != M][high__0is0<=M-1]
          (low__0isM, high__0is0_) = if low__0is0==0 then (0, high__0is0-1) else (low__0is0, high__0is0)
      in  (low__0isM, high__0is0_)

    us__0isM :: [uint%M]
    us__0is0 :: [uint%M]
    us2int__0isM us__0isM = sum((u if u else M)*M**i for i,u in enumerate(us__0isM))
    us2int__0is0 us__0is0 = sum(u*M**i for i,u in enumerate(us__0is0))
    us2us__0is0__0isM us__0is0 = ???
    us2us__0isM__0is0 us__0isM = ???

    us2us__0is0__0isM [] = []
    us2us__0is0__0isM (0:us) = dec__0isM__ge1 1 (us2us__0is0__0isM us)
    us2us__0is0__0isM (u:us) = u:us2us__0is0__0isM us
    dec__0isM__ge1 :: uint%M -> [uint%M] -> [uint%M]
    dec__0isM__ge1 1 [] = []
    dec__0isM__ge1 1 (u:us) = 0:dec__0isM__ge1 u us
    dec__0isM__ge1 0 us = (M-1):us
    dec__0isM__ge1 u us = (u-1):us


    us2us__0isM__0is0 [] = []
    us2us__0isM__0is0 (0:us) = 0:us2us__0isM__0is0 (inc__0isM us)
    us2us__0isM__0is0 (u:us) = u:us2us__0isM__0is0 us
    inc__0isM [] = [1]
    inc__0isM (0:us) = 1:inc__0isM us
    inc__0isM ((M-1):us) = 0:us
    inc__0isM (u:us) = (u+1):us

    u2p__0isM__0is0 :: uint%M -> uint{1..M}
    u2p__0isM__0is0 0 = M
    u2p__0isM__0is0 u = u
    p2u__0is0__0isM :: uint{1..M} -> uint%M
    p2u__0is0__0isM M = 0
    p2u__0is0__0isM p = p
    func_pow :: uint -> (a->a) -> (a->a)
    func_pow 0 f x = x
    func_pow exp f x = func_pow (exp-1) f (f x)

    half_add1__0isM :: uint%M -> uint%M -> (low::uint%M, acc__0is0::uint%2)
    half_add1__0isM 0 v = (v, 1)
    half_add1__0isM u 0 = half_add1__0isM 0 u
    half_add1__0isM u v =
      let x = (M-1) - u
            #[1<=u,v<=M-1]
            #[2<=u+v<=2*M-2]
            #[2-M<=u+v-M<=M-2]
            #[u+v<=M] ==>> [2<=u+v<=M]
            #[u+v>M] ==>> [1<=u+v-M<=M-2]
            #
            #[0<=x=(M-1)-u<=M-2]
            #[v<=x] ==>> [v<=M-1-u][2<=u+v<=M-1]
            #[v>x] ==>> [v>M-1-u][1<=v-x==u+v-(M-1)<=M-1]
            #[v>x] ==>> [0<=v-x-1==u+v-M<=M-2]
            #[v>x][v==x+1] ==>> [0==v-x-1==u+v-M<=M-2]
            #[v>x][v!=x+1] ==>> [1<=v-x-1==u+v-M<=M-2]
      in  if v <= x then (u+v,0) else if v==x+1 then (0, 0) else (v-x-1, 1)
    full_add1__0isM :: uint%3 -> uint%M -> uint%M -> (low::uint%M, acc__0is0::uint%3)
    full_add1__0isM acc__0is0 u v =
      let (s0, acc0) = if acc__0is0==0 then (u, 0) else half_add1__0isM (p2u__0is0__0isM acc__0is0) u
          (s1, acc1) = half_add1__0isM s0 v
      in  (s1, acc0+acc1)

    add__0isM :: [uint%M] -> [uint%M] -> [uint%M]
    add__0isM = full_add__0isM 0
    full_add__0isM :: uint%3 -> [uint%M] -> [uint%M] -> [uint%M]
      #full_add__0isM acc__0is0 lhs rhs
      #full_add__0isM acc__0is0 [] [] = if acc__0is0==0 then [] else [p2u__0is0__0isM acc__0is0]
    full_add__0isM acc__0is0 [] rhs = func_pow acc__0is0 inc__0isM rhs
    full_add__0isM acc__0is0 lhs [] = full_add__0isM acc__0is0 [] lhs
    full_add__0isM acc__0is0 (u:us) (v:vs) =
      let (s, acc_) = full_add1__0isM acc__0is0 u v
      in  s:full_add__0isM acc_ us vs
      ----
    #full_add__0isM acc__0is0 (u:us) (v:vs) =
      let s = (acc__0is0 + u2p__0isM__0is0 u + u2p__0isM__0is0 v)
          (q,r) = divmod s M
            #[0 <= acc__0is0 <= 2 <= M]
            #[q*M+r == s <= acc__0is0+M+M <= 3*M]
            #[0<=q<=3][0<=r<=M-1]
            #[q==3] ==>> [r==0][acc__0is0==2==M][u==0][v==0]
            #[r!=0] ==>> [q!=3][0<=q<=2]
            #
            #[q*M+r == s >= acc__0is0+1+1 >= 2 > 0]
            #[(q,r) != (0,0)]
            #[r==0] ==>> [q!=0][1<=q<=3]
          (q_, r_) = if r==0 then (q-1, M) else (q,r)
            #[0<=q_<=2][1<=r_<=M]
      in  p2u__0is0__0isM r_ : full_add__0isM q_ us vs
    subtract__0isM :: [uint%M] -> [uint%M] -> (is_neg::bool, [uint%M])
      #subtract__0isM lhs rhs
      # [1,1,2] - [0,0,1] == [1]
      #full_subtract__0isM :: uint%3 -> [uint%M] -> [uint%M] -> (is_neg::bool, to_drop_tailing_0s::bool, [uint%M])
        #full_subtract__0isM borrow lhs rhs
    subtract__0isM lhs [] = (False, lhs)
    subtract__0isM [] rhs = (True, rhs)
    subtract__0isM (u:us) (v:vs) =
      let (is_neg, abs) = subtract__0isM us vs
            #[is_neg] ==>> [abs != []]
          (a, b) = (u2p__0isM__0is0 u, u2p__0isM__0is0 v)
            #[1<=a,b<=M]
          is_neg_ = is_neg || (abs==[] && a < b)
            #[is_neg_] <==> [is_neg]or[abs == []][a<b]
            #[is_neg_] ==>> [abs != []]or[abs == []][a<b]
            #[! is_neg_] ==>> [! is_neg]([abs != []]or[a>=b])
            #[! is_neg_] ==>> [abs != []]or[a>=b]
          (a_, b_) = if is_neg_ then (b,a) else (a,b)
            #[is_neg_] ==>> [abs != []]or[abs == []][a_>b_]
                #flip
            #[! is_neg_] ==>> [abs != []]or[a_>=b_]
                #not flip
            #[abs != []]or[a_>=b_]
            #[a_ < b_] ==>> [abs != []]
            #[1<=a_,b_<=M]
            #[a_ < b_] ==>> [a_+M-b_==a_+(M-b_)>=a_+0>=1]
            #[a_ < b_] ==>> [a_+M-b_==M-(b_-a_)<=M-1]
            #[a_ < b_] ==>> [1<=a_+M-b_<=M-1][abs != []]
            #[a_ > b_] ==>> [1 <= a_-b_ <= M-1]
          abs_ = if a_ < b_ then let (h:ts)=abs in (a_+M-b_):(dec__0isM__ge1 h ts) else if a_ > b_ then (a_-b_):abs else case abs of
              [] -> []
              (h:ts) -> 0:dec__0isM__ge1 h ts
            #[abs_==[]] <==> [abs==[]][a_==b_] ==>> [! is_neg_]
            #[is_neg_] ==>> [abs_ != []]
      in  (is_neg_, abs_)
    mul1s__0isM :: uint%M -> [uint%M] -> [uint%M]
    mul1s__0isM u vs =
      let (lows__0isM, highs__0is0) = mul1s__0isM__lows_highs u vs
      in  add__0isM lows__0isM $ us2us__0is0__0isM (0:highs__0is0)
    mul1s__0isM__lows_highs :: uint%M -> [uint%M] -> (lows__0isM::[uint%M], highs__0is0::[uint%M])
    mul1s__0isM__lows_highs u [] = ([], [])
    mul1s__0isM__lows_highs 0 (v:vs) = (0:dec__0isM__ge1 v vs, [])
    mul1s__0isM__lows_highs u (v:vs) =
      let (lows__0isM, highs__0is0) = mul1s__0isM__lows_highs u vs
          (low__0isM, high__0is0) = mul1__0isM u v
      in  (low__0isM:lows__0isM, high__0is0:highs__0is0)

    mul__0isM :: [uint%M] -> [uint%M] -> [uint%M]
    mul__0isM [] vs = []
    mul__0isM us [] = mul__0isM [] us
    #mul__0isM (u:[]) vs = mul1s__0isM u vs
    mul__0isM (u:us) vs =
      let highs = mul__0isM us vs
          lows = mul1s__0isM u vs
      in  add__0isM lows $ mul1s__0isM 0 highs

TODO:
  真名屏蔽，虚拟注册名需要真名支持
    三方:
      个人，服务器，政府
      个人+政府 共享 真名+真名密码
      个人+服务器 共享 虚名+虚名密码
      服务器 可要求 政府 鉴定 真名存在性/真名签名有效性 得到 hash(服务器+真名) 避免 重复注册 或 控制 个人小号上限。
        虚名密码 找回？不行！
        政府 不得与闻 虚名密码
        服务器 不得与闻 真名密码
      政府 可由(服务器+虚名)得到 真名

TODO:
  lang:
  lang_design:
    ====
    ？
      ？empty base optimization: 外挂接口+无用参数(参数化标识名)+虚基类？或 重复 空基类(带虚析构函数) 这种情形 究竟如何？
        see:[[无用参数]]
        empty-base optimization
        The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8).
        完全可行！
    ====
    ops:
      immutable ops
      emplace ops / inplace ops
      ---
      immutable obj
      readonly view
        template parameter role:tag forwarding
      mutable obj
      ---
      property:
        @obj
          ops.get_xxx__of_obj_at_obj(obj)
        @obj_ops
          ops.get_xxx__of_obj_at_obj_ops()
          ops.get_yyy__of_obj_ops_at_obj_ops()
        @obj_ops_cls
          type(ops).get_xxx__of_obj_at_obj_ops_cls()
          ops.get_yyy__of_obj_ops_at_obj_ops_cls()
          ops.get_zzz__of_obj_ops_cls_at_obj_ops_cls()
        []:
            ops.of_obj_at_obj["xxx"](obj)
            ops.of_obj_at_obj_ops["xxx"]
            ops.of_obj_at_obj_ops_cls["xxx"]
            ops.of_obj_ops_at_obj_ops["yyy"]
            ops.of_obj_ops_at_obj_ops_cls["yyy"]
            ops.of_obj_ops_cls_at_obj_ops_cls["zzz"]
      ---
      method/property
        覆盖控制:
          abstractmethod/virtual=0: 必须 被 override
          final: 不得覆盖
          协同工作:___kwargs___={?:?}
            @协同工作
            def f(self, ___kwargs___, /, ...):...
          正在新建vs正在覆盖override
        get bound_method/unbound_method
        access control section:
          public/private/protected
          因为 部分成员函数 对外不可见（命名空间 也 错开）
            基类 定义 f --> ___f___
            派生类 覆盖 ___f___
            外部 调用 f 而非 ___f___
          @using_private_section
          def f(self, self_private_section, /, ...):...
      ---
      协作构造
        协作构造:数据成员、协作函数的返回值+输入命名参数
        约束:
          +独立约束::一元约束
          +拓扑偏序约束::二元约束
          +其他参数参与的复杂约束
        协作构造的初始化方式:
          *无需初始值
          *某个共同基类提供
          *最外层派生类提供
          *作为参数由用户直接输入
        协作构造方式:
          必须提供 融合操作
          *或顺或逆的任意一种拓扑序
            需要 初始值
          *独立产生增量，无序融合
            *有初始值
            *无初始值
          有无初始值:
            必须提供 融合操作+概念上的偏序小于等于
            *有初始值
              必须提供 增量操作+[可选]偏序小于等于
              v[n+1]:=v[n] op x<ops.f>
              要求: x op y op z === x op z op y
                即：后续操作可交换，支持无序？
                (op z) . (op y) $ x === (op y) . (op z) $ x
            *无初始值
              必须提供 融合操作+偏序小于等于
              融合操作 是 可交换的二元运算
              融合输入 偏序小于等于 融合结果
              正整数:
                乘法
              自然数:
                加法
                比特位操作:与、或
                排除:异或
              集合:
                集合交
                集合并
                排除: 对称差
              映射:
                xxx 键值集合交/并？
                可选映射值的融合操作+偏序
                  #Map K V --> Maybe V
              元组|定键记录:
                分解成 各元素
              变键记录(映射作记录):
                各键 独立的 可选映射值的融合操作+偏序
                  #Map K V<K> --> Maybe V<K>
              数组:
                数组长度:增|缩+元素相关操作
              互斥并联:
                ？
            .
    ====
    def:[[无用参数]]
      #never_use/unused/abandon/useless
      #useless_parameter, runtime_discardable_argument

      void g([[无用参数]] Xxx x, ...);
      g :: [[无用参数]] Xxx -> ...
      仅用作 编译期函数重载，其输入值无用，只能静态计算constexpr，不得动态计算，(一类一值？其实，多值也可以，只是 类似 模版参数，每值实例化一个函数)，运行期不得构造不得传入，如同不存在。
      * 部分支持 enable_if（无返回值的构析函数）
          但 类模版 的enable_if？
            template<..., [[绑定默认值_禁止用户提供]]typename=Enable_if<b,void> > class Xxx;
      * 通过 函数重载 部分实现 参数化标识名
          虚函数 不能是 模版函数，但 可以是 重载函数
            #xxx 外挂接口 总需要 一些辅助实现函数，它们 ？？？不，不是
            外挂接口 独立开发声明 一个新的成员函数(虚函数)，必须 避免覆盖基类接口：避免被子类接口覆盖，则 必须 采用 统一命名方式-参数化标识名: class [[外挂接口]] Xxx<A,B>{[[新接口]] void g([[无用参数]] UseLess_RunTimeDiscardable<Xxx<A,B> >, ...)=0;};
        see:[参数化标识名]
          参数化标识名 可用作 私有标识
            私有类+参数化标识名==>>私有标识


    ====
    异常基类/抛出所在地基类--用作标签的空基类
      各包 必须定义 一个 包异常基类
      各库 必须 定义 一个 库异常基类
        任何 直接 从此库中 抛出的 异常 必须 基于 本库的 库异常基类
        库异常基类 是 所在包的 包异常基类 的 派生类
        细节实现库 的 库异常基类 是 其所要补充的库的 库异常基类 的 派生类
      由于 十分 规整+繁琐，可自动化 由 语言 默认支持，并行异常=普通用户定义的异常+语言提供的抛出所在地基类
        catch(用户异常基类&&抛出所在地基类)
    ====
    特化 依 概念/约束 enable_if
      概念偏序:
        [is_X<T>()] ==>> [is_Y<T>()]
        [is_X T] ==>> [is_Y T]
        is_X <: is_Y
        X <: Y
      多元约束偏序:
        //is_same<X,Y> Is X the same type as Y?
        //is_base_of<X,Y> Is X a base of Y?
        //is_convertible<X,Y> Can an X be implicitly converted to a Y?
        is_same <: is_base_of <: flip is_convertible
      声明式定义 比 计算式定义 更好 推导 处理
        比如：特化
        当 多个定义 存在时，解决方案 就是 约束之间的偏序
        约束 必须 是 可分解的

    ====
    可修改容器 异常保证 与 元素 的 操作异常
      容器的最低异常保证 应作为 模版参数
        如果 发现 元素操作 相对 安全，则 提升 异常保证 的 规格
      赋值？移动？交换？
      容器的某个 多个元素就地修改的操作 的 『强异常保证』版实现:
        可基于 元素相关的就地修改操作 的异常保证 来选择实现
          *『无异常保证』:
            容器直接修改元素
          *『强异常保证』:
            ...竟然无用！只能降级使用，仅相当于『基本异常保证』...
            //可见『强异常保证』可最后 再考虑实现，可不实现，外部能够自动实现
          *『基本异常保证』:
            *1:
              +容器的deep_copy/deep_clone
              +容器此修改操作的『基本异常保证』版实现
              +容器的『无异常保证』swap/move
            *2:
              +元素的deep_copy/deep_clone
              //+另外保存新元素+最后一次性批量更新
              +元素的『无异常保证』swap/move
    ====
    多元运算符vs迭代器
      命名输入参数vs多元运算符（正则表达式 形式）
      歧义/竞争/优先级？开头？结尾？调用态？完全调用态？
      短路？惰性？语句组？
      语法糖宏
      框架宏
        局部 输入输出 + 环境敏感 隐参数
        与外部的流程协同
          就地调用 非匿名函数
        对外部环境静态状态更新
      迭代器（静态状态 正则表达式 形式）
      ---
      多元运算符
        前缀:
          #『`』or『,』
          开头词:
            <`xxx arg0
          中间词:
            ...argI `xxx argJ...
          结尾词
            ... argN `>xxx
          半开头词:
            arg0 `<xxx arg1...
              当无歧义时
            <` arg0 `xxx arg1...
              当有歧义时
          半结尾词
            ... >`xxx argN
              当无歧义时
            ... `xxx argN `>
              当有歧义时
          开头词/半开头词 && 结尾词/半结尾词
            开头词&&结尾词
              <`>xxx
                独立运算符
                惰性值 变现运算符？
                处理 隐参数？
                IO 语句？
            开头词&&半结尾词
              <>`xxx
                前缀运算符
            半开头词&&结尾词
              `<>xxx
                后缀运算符
            半开头词&&半结尾词
              `<>`xxx
                二元运算符
      多元运算符 正则表达式/LL1
        #不得递归，下面是 大分类，但 值 不能 递归！严格 变小！
        #必须 符合 LL1 编译器语法要求，不得冲突
        #输入参数的结构类型:选择=并联Either，串行先后=串联 元组Pair，重复=串联 数组Array
        含头尾 =
          | 选择<含头尾>
          | 开头词/半开头词 && 结尾词/半结尾词
                独立运算符
                前缀运算符
                后缀运算符
                二元运算符
          | 含头 不含头尾* 含尾
        含头 =
          | 选择<含头>
          | 开头词/半开头词
          | 含头 不含头尾+
        含尾 =
          | 选择<含尾>
          | 结尾词/半结尾词
          | 不含头尾+ 含尾
        不含头尾 =
          | 选择<不含头尾>
          | 中间词
          | 不含头尾+
      其实 头尾 皆可重复，只是 中间的不是头尾
      重定义:
        含头尾 =
          | 选择<含头尾>
          | 含头 不含头尾* 含尾
        含头 =
          | 选择<含头>
          | 含头 不含头尾+
          | < 不含头尾+
            #开头词 在后
          | <` 类型 不含头尾+
            #半开头词 在后
        含尾 =
          | 选择<含尾>
          | 不含头尾+ 含尾
          | `>结尾词
          | >
            #半结尾词 在前
        不含头尾 =
          | 选择<不含头尾>
          | 不含头尾+
          | `中间词
            #可能是 中间词/开头词/半开头词/结尾词/半结尾词
            #可能是 独立运算符/前缀运算符/后缀运算符/二元运算符


    ====
    收敛 数据 函数
      函数分类:（收敛，异常（可捕获，不可捕获），发散/不返回/不退出/不停机）
      保证递归/循环 终结:关键输入参数 的 数据等价类 的 全序 + 循环引用函数组 的 等价类 全序
      所谓 数据类型偏序 究竟是 哪个层面上的声明？
      约束 引入它的源代码的使用？==>>抽象概念声明
      约束 最终用户的配置/配置协调相容？==>>配置约束声明


    ====
    区分 带量纲的值 与 无量纲的值
      量纲
          量纲的乘除法
          加法的量纲一致性原则
      无量纲的值 由区分为：真无量纲、量纲幂指数为零的值

    ====
    区分 可移植的值 与 不可移植的值
      见下面:
        字符全序 可称为『临时性局域性不可交流型全序』 类似 对象地址 有效性 并非 全局性永恒不变
      low level system error_code
        各系统 有各自的编码、逻辑概念，与实现绑定
      所有参数都是 可移植的值 的 表达式 产生 可移植的值
        一旦 含有 不可移植的值，则 产生 不可移植的值
    ====
    内存值表达 与 等价
      表达结构等同 vs 抽象概念值相等
        即使 存在 抽象概念值，表达结构的规范标准型 却
          * 未必 存在(有限表达)？
            #lambda-expr，外延等价（作为映射的等价）
            #实数的有限表达 不可能，部分 可用 函数 表达，但 难以比较是否相等
          * 未必 可计算（不能保证运算收敛/停机）
            #knot 结的规范标准型
            #group 群的归一化关系表达型的规范标准型 #群同构#<a,b,c | a*b==1, a/c/b/a==1, b*c/b/c==1>
            #命题的真性
            #定理证明的规范标准型（即 标准化 已存在的某份证明）
          * 未必 可移植？
            #字符全序 依赖于 字符集内码，不同的字符集 或 不同的内码方案 都将 导致 排序结果 不同 #gb18030 vs unicode
            #       可称为『临时性局域性不可交流型全序』 类似 对象地址 有效性 并非 全局性永恒不变
          * 未必 可在合理空间内存储(即存储 该规范标准型)
            #零阶逻辑命题的规范标准型
            #带集合运算的正则表达式（集合减、集合交），指数爆炸
          * 未必 可在合理空间内计算
            #IDFSM非确定型有限状态机的规范标准型（MDFSM最小确定型有限状态机）
          * 未必 可在合理时间内计算
            #group 简单无向图的规范标准型 #图同构
            #魔方魔数 保证/证明/检查
        同理，等价 判断:
          * 未必 可计算（不能保证运算收敛/停机）
            #knot 结的等价
            #group 群同构
            #实数的有限表达 不可能，部分 可用 函数 表达，但 难以比较是否相等
          * 未必 可在合理空间内计算
            #IDFSM非确定型有限状态机的等价
          * 未必 可在合理时间内计算
            #graph 图同构
            #零阶逻辑命题的真值表等价
            #
      自然数:
        #M>=2, little_endian
        us__0isM :: [uint%M]
          无冗余，但运算慢/不自然
        us__0is0 :: [uint%M]
          有冗余/有重复，但运算自然
          最高位无效0
      平衡树:
        树高度 对于 等价关系 无效
          <<==树高度 必须 满足 o(logN)
      正则表达式/有限状态机:
        标准化/规范化 难#时空占用o(expN)
    ====
    宏
      宏==>>环境敏感的表达式==>>使用地点 自动填充 隐参数==>>接口文件声明隐参数==>>实现文件 显式配置隐参数 或 隐参数是局部作用域的输入参数
    ====
    切面继承/切面偏序
      某个类的某个切面 是 另一个类的某个切面 的 子接口/子切面
      反转:[类A的I切面 <: 类B的J切面][类B的W切面 <: 类A的W切面]
        读操作切面 vs 写操作切面
      禁止 crosscast dynamic_cast
        允许 upcast 隐式
        ??允许 downcast dynamic_cast
    ====
    声明
      声明 的 目的 在于强调 如何使用（源代码语言层面上） 而非 实际定义 或 实现细节
        但 可以有 对实现的约束 以确保 能够 实现...
      更严格的更强约束的更多需求的输入方面声明==>>更自由的更多选择余地的更大设计实现空间的输出方面定义体
    ====
    物理性状#虚拟物理声明#physic_sort
      声明类型时 可附带 虚拟物理声明，用于 强调 某些类型的某些物理约束是相同的，这个 物理约束 无需 用户提供定义/配置，可能 由 编译器 推导出来，甚至 仅止于 作为一个 虚拟约束 完全无需定义
      代码爆炸+类型擦除==>>声明模版时，参数的物理性状 的 哪些方面 应用于 实现中 而无法 擦除？哪些 参数 影响 模版的物理性状(可细化到各性状方面)？本模版与其他模版，特别是 本模版带不同参数 之间的 物理性状 关系（相同？特别强调必须不同？细化到方面）？
    ====
    逆推收敛
      类型匹配逆推 是在 编译期 进行，不得 死机/发散/死循环/无穷递归
      ==>> 终究还是要有一个 所有函数收敛的子语言
    ====
    def:[循环引用与泛强引用的伪强连通分量]
      #C++因为使用 基类引用、函数对象，不可能避免 肿瘤，必然存在 内存泄漏！
      #bug:弱引用 可生成 强引用！函数状态 的 弱引用 不简单！重点 注意！！
      泛强引用 指 强引用数据成员 或 内嵌式数据成员(unboxed)
        核心:（分享析构权）
      以 泛强引用 作为 有向边，以 内存实际对象 作为 节点，形成 的 有向图 可能有环形路径，即 不平凡的强连通分量（以下 简称 肿瘤）。
      以下 循环引用 专指 肿瘤(泛强引用 的 循环)。
      数据成员 可随意修改，则 难以 作出任何 约束、检测、发现 肿瘤...
      但 假设 所有 强引用成员 不得修改 或 绑定 惰性表达式
        （当然，表达式 本身作为一个对象，也服从 本假设的约束，即 表达式 的 自带 状态 的 强引用数据成员...）
        （所谓 绑定，指 该成员可从引用 表达式 更改成 引用 表达式 的 计算结果（如果 表达式 是 生成器，甚至 允许 不断 修改该成员 以 引用 最新结果））
      全局变量 与 局部变量 一样 不得无条件 循环引用
      但凡 涉及到 循环引用的对象 必须集中在一起，同批次定义
        特例1:函数
          函数递归相互调用 很常见
          这意味着 一个函数 能否 直接调用 另一个函数，不能只看 函数签名/声明，还要 确立 包/模块偏序 以此 进一步 确立 函数偏序，最终用户的配置方案 也必须 满足 函数偏序 约束
            外挂接口 ~ 函数签名
            外挂实例 ~ 函数定义体
            静态的 外挂实例 之间的依赖 ==>> 模块偏序
            动态生成的 外挂对象，作为参数而被 函数 接受，似无不可
          ？？无状态函数 只是 代码块，是 实心数据，循环引用 仅止于 保证 存在性，又是 平凡构造/平凡析构，连构析次序都不要紧，只需注意 同批次构析，静态无状态函数（常见）甚至都无需管理！！静态只读数据！！
        特例2:数据 自引用
          即 数据 的 构造表达式 使用 未来的输出的计算结果 作为 输入参数
            def:[未来强引用] 注意 避免 死循环
          此 表达式 及其 内部状态成员 也算作 同批次成员
      同批次对象 会绑定 一个 同批次的计数管理节点(以下 简称为 肿瘤窗口)（当然 如果 输入的参数 蕴含 更早更更外层的 未来强引用，则 无需 新建 新的 肿瘤窗口，直接 使用 该 未来强引用 绑定 的  肿瘤窗口）
      肿瘤窗口 就是 整个 肿瘤 的 外部共享计数器
        肿瘤内部的对象 无需 独立的 外部共享计数器
      循环引用的析构:
        乱序==>>不得假设成员存在==>>先将可能的构成肿瘤的强引用置空(nullptr)
    ====
    不使用 垃圾回收 的 数据结构
      #! def:[强引用下游固化数据类型]:（即 所有 强引用、内嵌（unboxed） 延伸的 所有下游数据的 强引用成员 皆不可修改）
      #     接近 functional datatype，只是更宽松
      #! 浅层不重叠数据类型 #doubly/singly-linked-list
      #! 动态变化的循环引用固然难以检测、处理，但 固化的或惰性的循环引用 可预先安排一个 伪强连通分量计数节点，所有 指向 该伪强连通分量 中的对象的引用的中转计数节点 需要 指向 该伪强连通分量
          [循环引用与泛强引用的伪强连通分量]

      #任何 折叠起来的类型 都必须 固化: Haskell::GADT 比如: base_ops<physic_sort> = forall T<-physic_sort. pair<ops<T>, T> ；forall即意味着 折叠，T 既然可以是 任何 类型，当然 只能 固化 以阻止 循环引用
      首先 排除 函数、基类引用，除非是 强引用下游固化数据类型(完全固化的ops外挂接口对象，十分实用:代码 与 数据 分离，代码 可自带状态 但必须固化)
        它们的 共同点 是 函数体、子类/派生类 十分自由
        可冻结函数(yield)、带状态函数(lambda) 状态数据 类似 派生类，函数帧 甚至是 成员数目类型动态变化的 状态数据
      ==>> hs::datatype  | 完全实心结构体（不含任何引用，可树状化表达（无重复引用、无共享引用）） |  完全显式依赖偏序数据类型（类型构造器 a『小于』b 表示 a可被b直接或间接使用，反之则不行；；小于 而非 小于等于，保证 没有 循环引用『完全』指 无遗漏，这保证 即使在使用引用的情况下 与 完全实心结构体 等价） | 强引用下游固化数据类型
      其次 声明时 必须 指出 定义体 允许使用的直接使用了哪些数据类型(类型构造器->直接许可类型构造器->延伸许可类型构造器，不需要 声明 完全实心结构体 及类似类型；『小于等于』而非仅仅只是『小于』)，怎么用（引用本身可修改，引用本身不可修改，unboxed，weak_ref，in_use_ref，同批次循环引用，全对象引用）
        #这里 可区分 类型构造器 参数 的 角色:
        #   有些参数 最终后 成为 数据成员，有的 不会
        #   datatype T a = T (A B a)
        #   这里 直接用到两个类型构造器 A,B
        #       A 已然用于构成 数据成员，B 则要看 A 对于 自身参数的归类
        什么关系重要？
          分享承担析构任务的引用（强引用）
          构造后、修改后 不得出现循环
        def:[构造后修改后]
        构造时，新对象还不存在，不可能 有它的 强引用（但可能有 全对象引用 不得在 全对象构析过程中解引用），是故 不可能出现循环引用。
          <<== 构造成功后，才可以 出现 强引用
          ==>> 强引用下游固化数据类型
        修改 强引用 时，必须要求 可以静态判断出 替换的新对象 无法产生循环引用
          * 被强引用的类型 的 延伸许可类型构造器 中 并无 全对象的类型构造器，则 不可能 出现循环
          * 被强引用的类型 可区分为 两种，构造后 与 修改后，修改后的类型 可以是 构造后类型的 删减变体，即 减少 某些 可能 导致出现循环引用的 并联分支(允空引用->nullptr肯定没毛病)
            see:[类型增删变体]
          * 更复杂的推导证明
            singly-linked-list
            doubly-linked-list
            list-op:
              list-slice(remove)
              list-insert(remove)
        weak_ref，in_use_ref，全对象引用，同批次循环引用 类似，皆非 强引用(最多 也只是 伪强引用)，无需考虑
        引用本身不可修改，unboxed 两者类似，构成 有向无环图 的一部分，不可无视，直接许可类型构造器
        引用本身可修改，见上面:see:[构造后修改后]

    ====
    状态空间:
      * 多维正交
        标志位
      * 拓扑偏序
        类继承:
          迭代器:输入(不可重复的单向)迭代器、可重复的单向迭代器、双向迭代器、随机迭代器
          内存并发次序:relax, ..., 一致
    ====
    检查 与 报错
      约束检查 作为 声明 的 一部分，是 状态分流的构成部分，不能通过检查，只是 匹配失败，相当于 缩小匹配空间
      约束检查 作为 定义体 的 一部分，由于是在 状态分流 之后，不能通过检查，意味着 参数 不符合 前置条件（可能是 隐含的，与 实现紧密相关的，如：部分复杂情况待定义，当下只实现最简单的基础功能），出错，停止编译。
    ====
    原则:追加 声明/定义 不得 破坏/更改 之前的 代码 含义/实现/编译/和谐/稳定
      #追加: 纵向 新版本；横向 不同模块集成协作
      除非 封闭式，状态分流 不得 兜底/重叠
      局部性检查 必须 隐含 全局性约束
        否则 两个大系统 在独立工作情况下 各自和谐，但 一旦集成一起，可能 违反 全局性约束，这是不能接受的

    ====
    自动维护的辅助性数据成员
      概念性的声明 vs 带实现细节的声明
        概念性的声明 用于 匹配分流、证明推导
          #using/let...in 再自定义内部使用的 参数
        带实现细节的声明 用于 声明 私有功能性成员、辅助性成员（公开/私有）、内存布局次序、构造次序、对齐方式、对象的字节大小、physic_sort(物理访问声明)
      cache
      lock
      举例:
        datatype SizedList a = Empty | Con1 Size a (SizedList a) | Cons Size (SizedList a) (SizedList a)
        Size 无需用户维护
      函数的默认参数，特别是 模版的默认参数 某些很可能不希望用户提供，因为 它只是 cache(let...in)或 enable_if 之类的实现细节
    ====
    声明 多个对象 之间 不存在 共享的可修改状态
      容器里所有对象？
      经过 映射表 解释 索引 之后 也无重叠？

    ====
    异常
      不可捕获异常:
        未定义行为异常 #因为 不保证能检测到 未定义行为（当在虚拟机上仿真运行时 由于不考虑效率，不少 未定义行为 可以被检查到）
        待明确声明异常 #某些 情景分支 未有实现，更谈不上 声明。将来 可能 抛出指定异常，也可能 正常 返回，故而 当前抛出的异常 并非稳定接口，不可依赖，故不可捕获。
        in_use_ref 异常 #in_use_ref 与 weak_ref 的区别在于 in_use_ref 逻辑上 假设 被引用对象 生存期 长于 in_use_ref本身，故而 不必、不可、也可能做不到 检测 存在性，不能生成 强引用，一旦出错，将是 全局性错误 而非 局部性错误，用户 不能忽略它 也不能成功处理它
        未来强引用 异常 #表达式引用自身，出现死循环，严重的逻辑错误
        若 抛出的异常 不在 函数的异常声明列表中，则 该异常 只能是 未定义异常，该 抛出行为 只能是 未定义行为，不可捕获。函数的异常声明列表 可用 类似 C++ metaprogramming 的 方式 构建（抓取 输入参数 的 异常列表 进行 填充，而 静态已知子调用的异常依赖 需手动填充）
        调试用断言异常 #因为 该异常 仅存在于 调试版 不存在于 发布版，所以 并非 稳定接口，用户 不可依赖它。
        重大灾难防备中止异常#破坏外部数据完整性安全性的代码逻辑异常#在 发布版中仍存留，只因 错误影响到的不仅仅只是应用软件本次运行，而是 有更深远的影响，责任重大，比如:读写不匹配-影响持久性存储/网络流通
          读写不对称性
            同一个值 对应 多个表达
            比如:python字符串 是使用 单引号 还是 双引号，是否 raw？multi-line？是否只允许ascii？（比如 中文字符 是直接输出 还是 \Uxxxx_xxxx 还是 \N?{...unicode名称...}）
            写-不同格式<参数> 但 要求 格式相容无歧义
            读-统一#版本？
            ==>>
              写操作 返回前 必须 使用 读操作 对 输出结果 进行 检测，抛出 读写不匹配 的 代码逻辑异常

      可捕获异常:
        逻辑无关的不可控制的异常:
          算法 所需资源不足:
            timeout
            调用栈溢出(递归太深、自动栈帧变量太大（巨大数组）)
            动态内存分配失败
        逻辑无关的依赖底层的不可移植的可控制的异常:
          整数机器字长溢出
        逻辑相关的可以控制的异常:
          内部逻辑异常
            难以提前检查的前置条件:
              文件格式/字符编码 的 正确性
              累积误差约束
              带误差矩阵求逆 的 满秩要求
            算法实现 出错 的 断言异常 #debug
              如：矩阵乘法 要求 行列匹配，代码作者 粗心大意 可能造成不匹配。也可能使用脚本，而脚本解释器 作简单映射转发参数，并不负责检查 前置条件 因为 工作量太大
            继承性的底层异常: 算法 使用 外挂接口，则 除了 算法 框架 自己 抛出的异常，还继承了 外挂接口 抛出的异常
          外部协议异常:
            协议异常
            io异常
    ====
    等价
      同一对象 #object
      同一结构树 #datatype ADT
      复制 赋值 等价 #即赋值时，如果等价，可直接跳过赋值操作，当作已经赋值 #复制构造 时，若 两方 均是 不可修改，则 可跳过复制，直接使用引用？生存期？
    ====
    需求/约束/概念
        最小需求 <<== 某一具体算法
        联合需求 <<== 同一算法目标下的多种可选的合理算法
        通用概念 <<== 多种算法目标下的多种可选的合理算法的共同需求
        可选需求 <<== 有则开启更多功能声明
        需求 一般 出现在 声明 中，为了 实现的多样性，需求 应当 更多
        到底是 逻辑与 还是 逻辑或？
        逻辑与: 需求 更严格，算法可自由挑选
        逻辑或: 需求 更宽松，但 算法 只能在 具体参数 已知后 在 匹配的需求分支 下挑选
          其实 逻辑或 可能更合理
          因为 满足 逻辑与 的具体参数，意味着 满足 逻辑或 的 所有分支需求，挑选其实是 自由的。
          只是 逻辑与 只需 提供一个实现，但 逻辑或 必须 给 每个分支 提供一个实现
          不只是 实现/试验用原型 难度大增，有时候 某些需求分支 可能需要 底层系统支持，而这并不具有可移植性，亦即 无法实现。
          逻辑与 的 严格需求 提供 可移植性，在 底层系统支持缺失的情况下 提供 替代方案
      ==>> 存在 可移植性 毛病的 分支 必需 与 可移植性 分支 逻辑与
      ==>> 混合 逻辑与 逻辑或:
        ((逻辑或(可空所有 偶然可行需求分支) `逻辑或` 逻辑真) `逻辑与` 逻辑或(非空所有 必然可行需求分支))
    ====
    ...
      字符 相等 全序 关键字 有毛病: 跨字符集 难以 自动 判断相等。全序 在不同字符集间 不能兼容。关键字 如何 映射到 各字符集（最小字符集？）？
      外挂接口~同态
        随便指定某个类型的两个值，完全可以替代Bool，无需对最终结果使用类似fmap进行转换（从Bool转换成指定值）
        甚至无需是两个值，可以是两个等价类
      隐参数自动构造 ~ 环境感知 直接获取|依赖子对象|构造匹配逆推 唯一途经 不能冲突
        依赖子对象:
          共性: class S a => R a
          特化: instance T x => R [x]
          依赖子对象 冗余 与 兼容/同一/等价
        隐参数 举例:
          Java: this.this 类的内嵌类
          Haskell: Ord a
          全局变量？
          浮点数 误差 管理
          logging 配置
        显式的隐参数自动填充:
          {f} -- 将f所需 隐参数 从当前环境中 构造并填充
          {f} {g} -- 先填充f,g，再应用f于g
          (f {g}) -- f仍未填充
        隐参数 声明 全局性注册:
          用户 独立发挥 各自 承包 部分子空间 的 隐参数 构造 #逆推 需求+正向构造
          由 引用方用户 负责 引入的已被承包子空间（设置为 当前文件 默认构造）无冲突
              依『最终用户配置一切』的原则，引入的只能是 声明+约束，不能是实现。
              所以 隐参数自动构造声明 中 必须 含有 所承包的子空间的整体范围信息（内部如何细分，如：优先匹配，是无用的信息），在 最终配置 之前 便能够排除冲突。
      匹配~拆包~比 只能用 构造器 多一层抽象
        拆包==逆运算==解方程
          a@(b+3) ==>> b=a-3
          a@(divmod_result_of d q r) <==> [a==q*d+r][0<=r<d] <==> (q,r)=divmod a d
        def:[类型拆包]
        类型拆包 可分散后独立承包实现为 开放性外部虚函数表
          see:[外部虚函数表的开放性]
        类型拆包 应用举例:
          C++模版 类里的类型别名 无法逆推拆包
            实现 自动挑选 函数参数 传值 还是 传引用 的元编程 实际上 用途不大
            see:[自动选择传值或传引用的元编程]
      全局变量/常量~必然偶然 重定向 命名对象 代理 热刷新
        偶然:
          局部性偶然:
            编译期输入的宏常量 与 实现、底层系统相关
          临时性偶然:
            加载期初始化读入的全局性配置常量 与 用户应用 偏好 相关
          不时更新的全局变量，热刷新，不该 保存 或者说 只能 通过 路径 访问，或者说 使用 代理

    ====
    如何将 多类型变量的外挂接口 归结到 单类型变量的外挂接口？
      ??? class C a b c <<==??? class X x
      ???instance C (A a) (B b1 b2) (Y x y z w)
      class C<A,B> d
      instance C<A,B> d => C (A a) (B b1 b2) d
      instance C<A,B> (Y x y z w)
      ==>> instance C (A a) (B b1 b2) (Y x y z w)
    ====
    外挂接口特化 举例:
      class Show a where
        show :: a -> String
      class Show a => Show4List a where
        show4list :: [a] -> String
      instance Show4List a => Show [a] where
        show = show4list
      instance [a!=Char] Show a => Show4List a where
        show4list = ...
      instance Show Char => Show4List Char where
        show4list = ...
    ====
    def:[关系的匹配与定义]
      hs::class
      C++::template #type_traits?
      R 外挂接口
      E 具象实体
      D<R, [E...]> 关系定义
      关键是:
        * 这三者的作者 不同
        * 在哪找 D<R,[E...]>？如何 匹配？
      唯一性全局性封闭式模糊匹配:
        D 的 作者 必须是 R 的 作者
        D 与 R 捆绑一起，无需考虑『在哪找』
        E 的 匹配 类似 hs 函数的 优先模糊匹配+条件保护，反正是 封闭式 怎么爽 怎么玩。
        全局性 指 所谓『封闭式』包含 所有 可能的 模糊匹配
        唯一性 指 D 是 唯一的，与 R 一起出现
      命名式局部性封闭式模糊匹配:
        命名 D
        引用 D 的 标识 解决『在哪找』
        局部性 指 所谓『封闭式』仅限于 当前命名
      唯一性开放式规范匹配:
        有 很多 E，选择一个 作为 主E，成为 ME
        D 的 作者 必须是 ME 的 作者
        D 与 ME 捆绑一起，无需考虑『在哪找』
        『规范匹配』:ME 的 匹配 类似 hs::instance 匹配，ME 的 类型构造器+参数变量，不允许 更 模糊，也不允许 更 特化。但 其他 E 则 使用 局部性封闭式模糊匹配
        唯一性 指 D 是 唯一的，与 ME 一起出现
      命名式开放式规范匹配:
        D 的 作者 不是 R/E 的 作者 或 有 很多 E 而无 ME
        『在哪找』只能用 标识解决
        为什么 受 命名 约束 还要 规范匹配 而非 模糊匹配？
          方便 组合 引用，在 实现文件 引入 标识+匹配声明，在 匹配声明 无冲突的 情形下，可 无标识化/默认化
          是否 允许 规范匹配 的 内部模糊匹配？可以 考虑，不过 对于 无 隐标签 的 类型并立，其实现 必然 更复杂，甚至 可能 需要 任何 使用 它的 实体 都要 预知 模糊匹配 的 结果，或者说 模糊匹配 的 形式 成为 规范匹配 的 声明 的 一部分，但这又是不可能的，因为 通用的 规范匹配 实例化后 形形色色，难以 进一步 规范，除非 一开始就 存了 给指定 对象 开后门 的心思。
      预先式模糊匹配声明 vs 规范匹配实例化声明
        规范匹配实例化声明:
          R的实例 (E 是 (类型构造器 所需的参数变量的数目))...]
          所需的参数变量的数目 <= 类型构造器参数数目
        预先式模糊匹配声明:
          声明 会有哪些模糊匹配分支出现，以怎样的优先次序出现
          这样一来，在变量传入之前，便会 先进行模糊匹配，带着 隐形的匹配结果分支标签 进入 调用，这样一来，静态类型 就转化为 动态标签，适用于 动态外挂接口对象的构建。
          其实，这种 匹配结果/分支标签 完全可以 显化！！显化 成一种 关系/约束/匹配约束 R！
      『重点』:实现 方式:
        * C++ 代码爆炸
          无需物理兼容
          无法 使用 命名式匹配？
          或者说 命名式匹配 就是 type_traits
          type_traits 的 实现:
            唯一性全局性封闭式模糊匹配
            唯一性开放式规范匹配:
          『在哪找』是个大问题
          C++通过#include指望能够包含 够用的 兼容的 匹配，而这是无法确定的:
            * 若有默认匹配，若漏掉特化，将难以察觉。
            * 不同作者 重复定义 同一特化，发生冲突。
          共性接口 vs 特化接口
            vector<bool> reference_type value_type 的 关系 与众不同
        * Java 类型擦除
          物理兼容
          无 隐参数
        * Haskell 动态组合构造 外挂接口 对象
          物理兼容
          隐参数自动构造
          隐参数 依赖子对象 冗余 与 兼容/同一/等价
      无限空间互斥切分承包责任制:
        无限空间 切分后 一般仍是 无限空间（带参数变量）
        禁忌: 独立承包 却发生 空间重叠
          （如 :兜底的缺省实现C++模版 经常如此，一旦 遗漏有效特化版本，直接采用默认版本 而非报错，难以察觉；
          二来 将来版本追加新分支 竟然 会修改 旧版本的选择，这正是C++模版所求的，却 未必合理，特别是对于 永恒代码 而言 不合理；
          除非 封闭式优先匹配，否则 不许 兜底、特化、重叠）
          ==>> 平行匹配 vs 优先匹配
        可以 承包整个空间
        可以 承包空间后 再减去部分空间 （类似 集合操作，已达到 平行匹配 如同 优先匹配）
        承包后 允许采用 封闭式优先匹配的细分承包（如:允许 兜底匹配）

    ====
    类型并立
      //==>> [无标签+虚函数===隐标签===虚拟标签]
      //    err!!! 除了 内联式的虚函数 紧邻式的带标签，还有 分离式的外挂接口！！！
      //            分离式: ([A]|[B]) != [(A|B)]
      无标签: C++ union | polymorphic baseclass
      带标签: hs datatype
      无标签 多态:
        虚函数 转发
        但 (Show a) | (Read a) 的 自动化 实现 比较 麻烦，转发 序列化后 无标签！
        当脱离 内存中的 虚函数 体系后，标签 是 必须的！
        可给 类型 排个序，用 整数 索引号 作 标签！
          但:
          * 子类型 无法 兼容
          * 因为 无标签，所以 实际上 并不 知道 是 那个 类型。//除非 typeid()，但这样 其实是 隐标签 不是 无标签（虚函数 本来就是 隐标签）
        能否统一 各种编译器实现 各个应用软件 的 自动化生成标签？简洁 的 标签？子类型 兼容 的 标签？
          可以 让 用户 选择 一套 虚拟标签，它 并不 真实 存在，仍是 无标签/隐标签，可用于 序列化；不同套的 虚拟标签 之间 虚拟标签 与 无标签 之间 可以 相互转化，但需 显式指明

    ====
    def:[类型擦除]#java generic type
      physic_sort
        see: 'The C++ Programming Language(4ed)(2013).pdf' :: pg731[746/1366]pg733[748/1366] #code bloat代码爆炸~type erasure类型擦除
      对于 接口类体系 很重要
      因为 有多个 版本的 实现类体系
        （类体系 一组相关的类）
        （接口类体系 一组相关的抽象接口类）
        （实现类体系 一组相关的具象实现类）
      固然 可以 从 实现类体系 一对一地 映射 到 接口类体系，但 无法 强调 类体系内部  相关性，即 可能 通过 一致的 接口类体系  产生 不同的实现类体系之间的 混用
      可通过 模版参数 区分开
      但此 模版参数 并不影响 physic_sort，即可 进行 类型擦除，以防 代码爆炸，用户 代码也不必 重新编译
      模版参数 声明约束:
        * 是否 影响 physic_sort，是否 影响 模版实例化，是否 可擦除（可==>>不能靠这参数区分特化+本模版定义体内部使用的模版本参数 也是 可擦除的）
        * 类型 #typename/int/...
        * 值约束 #physic_sort/logical-concept/predicator/...
      底层系统设计 无需 考虑 高层用户自定义类型
        GUI 返回 基类引用，对于 应用程序而言 损失了 派生类的诸多有用信息
        使用 dynamic_cast 还原？
        太麻烦！
        但 底层系统 预先分离编译，不可能 实现 静态多态，只能 类型擦除+动态多态
        解决方案:
          * 底层类型擦除，高层模版参数大范围跨对象约束
            有点 外挂接口 的意思
          * see:[外部虚函数表的开放性]



    ====
    const data member:
      static const data member:
        for complicate type has no constexpr constructor
      static constexpr data member:
        enum
      non-static const data member:
        e.g. Map::Item::fst #Key
      non-static constexpr data member:
        e.g. tag as-if typeid() for dynamic_cast
    ====
    see:[类型增删变体]
    ====
    see:[覆盖源自数据成员的虚函数]
      +隐式/显式 类型转换
      +using 数据成员::成员函数
      ==>>更灵活的 基类
      [浮动数据成员]+[浮动基类]
      实现接口 无所谓 浮不浮动、共不共享、重不重复，因为 没有 可修改的数据成员
      继承实现+共享数据 一般 都是 浮动共享+保护//virtual protected @C++
      继承实现+不共享数据 一般 都是 固定重复+私有//non-virtual private @C++
    ====
    like “strict”
      声明 输入输出参数 之间 是否有 共享数据 entangled？
    ====
    see:[必然偶然]
    概念/接口->等待最终用户配置的具象类
    『任何一个』的 两种含义:
      * 每一次出现 均是 forall x<-I. [...]，即 产生一个新的待配置类型参数
      * 只有第一次声明时才产生一个新的待配置类型参数，以后均引用 同一类型
    约束（必须怎样配置） vs 优化指导（最好怎样配置）
    ====
    批量处理
      比如: 虚函数表，类继承图格导航
      比如: 同步对象 所有读写操作 默认 锁保护
        实现 同步对象 的 转发代理类型
    ====
    面向对象 的 最大问题是 只是 面向单个对象
      当需要产生 新对象、需要 处理多个对象时，还是要靠 外挂接口
    ====
    文件头部声明
      1) 语言+版本
      2) 方言/自定义语法糖+[输出为该版本抽象语法树]
      3）文件类型 // 前瞻性声明、API声明、ABI声明、内部实现私有友员声明、定义实现
    ====
    see:[外部虚函数表的开放性]
      内部虚函数 标志位:
        * 我是不是 虚函数？virtual
        * 我可不可 被覆盖？final
        * 我需不需要 被覆盖？=0
        * 我需不需要 被每个具象子类覆盖？typeid()
        * 我需不需要 被每个子类覆盖？
        * 我是不是 正在覆盖？override
        * 我 是否私有？private #不可调用，但能覆盖！！ #protected 允许子类 调用 该子类的对象的 本虚函数我
        * 我 需不需要 默认实现？
            ...单继承的包裹式...
            ...多继承的协作式...
            super 链 会触及 声明虚函数的类，所以一开始就需要 默认实现。
    ====
    永久
      关键字 的 命名空间 必须 与用户 命名空间 区分
      像C++那样，毫无节操地添加 关键字，谈何 后顾性兼容？
    ====
    显式省略:
      按个数: _, _, ...
      前瞻性预留 不确定个数（只确定 个数下限）: ... ...
    ====
    对象:强调约束vs强调表达vs强调修改vs强调接口vs强调标识
      强调标识Q:带标识，绑定一个对象/转发另一个命名对象，区分 必然偶然
      强调接口I:外部只能看到 纯接口引用，不知 具体类型，无法 赋值、比较、多元运算...，无法 显示(repr)，除非是 命名对象
        boxed
        防碰撞: ref.interface_alias::f
        see:[辅助函数与关联辅助开放空间]
        一套接口多种实现
          整数<n,endian>: (0|(sign, pint)) where pint=[word%n] #omit leading 1, little_endian/big_endian
          复数:(实数，虚数)|(0|(preal,real%2pi)) #polar coordinate
      强调修改D:正交空间直积点，自由修改，无约束，保存+加载+显示+标准化+传输（序列化/字符串化(repr))
        unboxed
          ??where is unboxed tagged/cased union??
        无继承，不允许 虚函数
        see:[辅助函数与关联辅助开放空间]
          无成员函数
        D===单标签E
      强调表达E:带标签并集，无约束，保存+加载+显示+标准化+传输（序列化/字符串化(repr))
        ???互斥并联？？？hs-datatype???
          tagged/cased union??
        E 的 负载 是 D，即 负载 可 自由修改
          但！标签难改
        所以 总的来说 不可修改
          无 默认构造器，永远 需要 显式构造
        boxed
        (E&D)===hs.newtype<D>|单标签
      强调约束V:表达不可修改的值，与 静态约束、并发访问 配合良好
        通常 V === (E|D)+静态数值约束，即 V 是 (E|D) 的 子类型，存储/表达 为(E|D)，只是 不可修改，并且 符合 声明的 约束
        #Date#年月日约束
        boxed/unboxed

    ====
    UndefinedError
      Throwable but not Catchable
      因为在以后的版本里可能细化 未定义状况，部分变成 有明确回应。任何catch UndefinedError后进行的行动都是无效的
      不是 稳定API 的一部分
      API声明 以外的 异常 不可捕获，即 所有 线程 必然 终结
      API 异常声明 分两种:
        * 声明 的 异常 属于 稳定API的一部分，含义明确，允许 其他异常出现并终结 进程
        * 声明 的 异常 属于 稳定API的一部分，含义明确，不允许 其他异常出现，是对所有 内部调用函数的 强约束。保证 进程 不死。但 是否 返回？是否 没有 死循环/发散性递归/调用栈溢出/内存不足？
          实心数据 不需要 动态内存，可提前保留 内存空间（如：std::vector 保留着一些未初始化空间），只要 构造函数 无异常 则 必无异常（除了 栈溢出）。
    ====
    package/module API 中继
      转发
      挑选？指定成员名 或 指定 版本
      合并?碰撞？ 要么 挑选  要么 分别赋予 限定 前缀
      版本？所有？包括 以后？
      必然偶然
    ====
    package/module/entry access control
      private+friend
      invisitable-as-if-not-exist #importance to inherit
      ？对于 某个类，即使是 某个库 私有的，只要 通过 合理的方式 将其 类名 暴露到 其他库，那么 其他库 就可 正常使用 该类。
        比如:
          class A{
          private: class P{};
          public:
            vector<P> ls;
              //是否允许暴露？
              //是否允许vector使用P的成员函数？
          };
      是否可接触=通过指定方式是否可接触|是否可暴露（是否不可能通过任意方式接触？）

    ====
    永久？永恒代码
      同版本 修订:
        订正:注释、文本常量
          追加补充 注释
          并不影响 编译/改变可执行文件
          仅作为文档，给人看！
          当然，最终用户 可通过 配置 显式地真正订正 可执行文件
        订正 vs 再版
          再版 只能 兼容/包含，不能更改
          必然偶然？
          可移植的值 能否 订正？
            会影响无数 存储空间中的文件及格式
      再版 巨大影响！
        比如：再版时，数据类型定义的同时 特化 某个关系/外挂接口
          包xxx 再版为 yyy
          包zzz 原来引入 xxx
          包wee 引入zzz，但希望zzz引入yyy而非xxx，即zzz<yyy>而非zzz<xxx>
          如果 引入包 自动由旧版变成新版，则 代码含义被窜改
          如果 仍维持引用旧版，则 对于 有使用新版的需求 的用户而言 将有两个麻烦:
            +再版 zzz，zzz<xxx> -> zzz<yyy>
            +必须 通知 zzz的作者
          如此一来，一包再版，所有依赖它的包被迫再版
          可见，直接引入 包 是 错误的设计
            应该 引入 包接口！
            由 最终用户 进行 配置！
            包 是 模版，引入的包接口 是 模版参数
      文件存储单元
        字节？当下的标准 存储单元，网络通信单元
        但连二进制都不是永久保证，字节 不可靠！
        先考虑 字符集，再考虑 编码，最后考虑 摘要函数
      字符 可靠 但！
        字符 的 数字化 表达 有疑问
        那个字符集(有序，对应 模剩余系)？
        字符 在不断增加，有来自过去的，有当下创造的，潜在的 字符集 无限大
        任何一个 字符集 都不可靠！unicode 不可靠！
        字符集名 必须 作为 参数
        字符集名 用那个字符集？
        文件系统路径字符集？显然，文件 本身 不能提供 自身所用的 字符集 及 编码方案，需要 额外信息，要么 编码 在 路径（如：后缀名） 里，要么，系统性设计 一一对应的 关联文件，要么，集中在 某个地方 进行 说明
        对照表？假设没有一个 字符集 能包含 所有 字符集名（无法统一标准称谓，比如:私有临时草创实验性的字符集），假设 字符集名 并不能 存在于 所有字符集 中。
        可是 字符集 不同 如何 交流？（相等比较？）
        假设 编译时 有一个 类似unicode的编码方案，能够 整合所有 字符集，...？
          用 函数实现 来代替 命名，如何？
          获取带外信息(文件路径)->(解码器<字符集名>)
          解码器<字符集名>.读文件(文件路径)->(字符集名？，整数串)
            ？？字符集名 用那个字符集？
          解码器<字符集名>.读文件(临时整合用字符集，文件路径)->(整数串)
            ？？关键字？？字符 归类？
        ???

      整数 可靠
    ====
    引入:接口、参数
      至于实现 可由 外部 配置
      当然 可声明 内部实现的 逻辑必然性: [某些 引入的接口 需要 相同实现/甚至同一对象]
        只描述关系，具体实现 仍由 最终用户 配置！
        但 可提供 缺省 具体实现 以供 最终用户 参考。
          * local constraint for global setting
          * local default for global setting
          * global setting
        上面是的 静态配置，只要求 API声明。还有 动态配置: 要求 physic_sort/ABI 兼容 才可互换(1.用函数参数控制 2.dll/plugin) #数据配置 最简单:加载/读取 初始化参数
          多层次 头文件

    ====
    假设 用户 是 机器/程序，而非人
      更一致简洁的语法+数据格式，更少的隐含参数、假设，更多更显式的输入输出参数+约束要求，更多地提供源文件信息（在各处代码），更少的人为限制（命名字符约束、缩进、（代码）长度限制深度限制）、更自由的排版风格、更灵活的代码次序排列、更少自作聪明的sugar语法(syntactic sugar)
    ====
    def:[约束的产生]
      约束 可以 很容易的 声明，并用于 推导
      但它如何产生？
      显然是有 具体的实现细节 逐步构建而成
      这并不容易，只能 假定 一些虚拟属性，冻结 某个时刻的对象的值，然后 忽略 非局部性的作用，进行一些粗略推导，以得到 约束
        而是否停机（收敛/不发散/无死循环/无限递归）更难，通用编程领域里通常不予考虑
          但在特殊领域，如 编译期计算（constexpr, type construction, type pattern match）必须停机！
          归纳法？收敛？发散？
    ====
    def:[API_ABI]
      #不同层次，不同用途(前瞻性声明，完整声明；用于输出的对外声明（进一步细分:普通级、专家级），用于实现的对内声明（更多私有实体）)
      什么是API？有别于ABI，关注的是用户代码的不变性，即与API的实现无关
        如:声明 类公开数据成员，但它的实际定义是类似C++的数据成员 还是 类似python的property，对API并无影响
        C++头文件 保护 ABI信息 甚至更多，并不完全合理
        可以 分离出 API 用于 维护 用户代码不变性 / compiler
          __api_decl__
        可以 分离出 ABI 用于 维护 用户可执行文件不变性 / linker&loader
                __abi_decl__
        API 描述 高层关系、约束，逻辑上的必然关系的定义体，公开规范的人为定义
        ABI [type_erase][physic_sort] 即使是 底层接口 弱类型 仍是 有类型 即 physic_sort
          physic_sort: 如: 对象指针，函数指针，数据成员指针，它们分属不同的 physic_sort，在弱类型的ABI接口中，physic_sort扮演重要角色（即 作为 更大颗粒的数据类型）
          如：python 的 object-reference 如何 取出 object.__class__.__getattribute__ 以便 进行 完全受用户定义的__class__控制 的操作。
            如何 取出 就是 physic_sort，它是一个协议:
              reference 如何 解引用 得到 object 地址
              object layout 如何 存取 __class__
              __class__ 如何 取出 __getattribute__
                显然 不能 无限 循环
                至少 py::type 要有 明确 取出 __getattribute__ 的 方法
                实际上，python 明确将 特殊属性 直接 保存在 __class__ 里。即 均明确 取出 __getattribute__ 的方法，所以 无需 先取出 object.__class__.__class__
        physic_sort 作为 协议/约束，显然也是有 偏序的
          比如 上面的 python::reference 很可能 细化 shared_ptr的physic_sort
            shared_ptr的physic_sort
              描述了 占用内存的大小+对齐，如何 复制/移动/赋值/析构

        # 前瞻接口声明
        # 类公开成员
        # 类关系: 继承关系
        # 约束:
        #     如:static_assert(std::is_pod<T>::value, ...)
        #     由于 T 定义 并不完整，ABI不全，故此 约束 只能用于推导。只有 最后 配置 实现 时 才能 用作 对 T 的检查。
        # 必然性定义体
          #see:[必然偶然]
        # 某些 ABI 声明:
        #     如: 声明 X 是 physic_sort
        #         声明 S,T 符合 X
        #         这样一来，S 与 T 之间 就有了 某种 逻辑上的必然联系
      idea 4 c++?
        def:[big_ptr]
        big_ptr = {.data_ptr, .ops_ptr}
          ops_ptr -> ops:: physic_sort s.t. decltype(big_ptr)
            ops is static
            ops for subobj/baseclass is a subobj of bigger ops
            e.g. ops = {.decl_type_info, .ops_offset_at_derived_most_obj_ops, .?ops_offset_at_whole_obj_ops?(not required), data_offset_at_derived_most_obj, data_offset_at_whole_obj?, pvtb(ptr_to_virtual_function_table of decltype(big_ptr))}

    ====
    常量/资源
      def:[必然偶然]
      真常量:
        #必然性相同
        公开协议参数
        数学公式参数
        文件格式参数
        ...
        枚举类型~头文件~API~程序员之间的协议
      可配置的常量:
        #偶然性相同 #named-obj/value 之间的 is/== 关系，也有 必然/偶然 的区分
        #这些实现相关的细节信息 不该出现在 头文件 里，可用 编译期函数提供（该函数必须显式表明自己的返回值 并非真常量）
        机器字长~移植性变化
        字符串字面常量的地址
        可翻译的文本/日期/带单位数据~地域性变化
        默认值~可重置，除非是API的一部分（公开规范）
        测试数据
          测试用 的 数据 的 集合 有很多，只是偶然选中当前 样本
        样例数据 #提供几个有效参数做示例
        版本号
        ....
        历史数据
        物理公式系数
      什么是『必然』？
        其实 只有 两样:
          * 定义
            各种 数学对象，它们的 定义 也就是 公设
            各种 规范标准、协议、API、文件格式...
            高层对象 之间的关系: 如 类继承、有哪些公开成员...
          * 从定义出发推导出的逻辑结果
      历史 与 物理:
        历史记录 以后 可能订正
          历史文本 古代书籍 可能更新/或有 很多版本/底本/变体
        物理 皆是 测量值，有误差
      C++ 赋值两个相同 字符串常量，它们的地址是否相等？依赖于实现
        当进行 == 测试时，可 返回 不确定值//并行态（既真且假），见下面xbool
        其实 C++ 头文件 并不只 包括 API，还包括 ABI，甚至更多。这显然是『实现依赖』的，并非出于逻辑上的必要。当用 类型 定义变量、声明成员 时，其实 并不需要 完整定义，只需 前瞻性声明 即可。如果 使用 公开成员，那也只需 公开部分的API，私有部分是实现细节 并不需要 出现在 头文件 里。
      『保证』
        所谓『保证』，有其前提。
        比如，这个 版本 的 语言标准 保证
        比如，这个 版本 的 编译器 保证
        比如，这个 版本 的 平台/操作系统/虚拟机 保证
        除非 前提 成立，否则 不必然
        检查 前提 其实 就是 分支版 的 『实现依赖』
      forwarding_reexport:[转发式重新输出]===转发引入名作为输出名
        这种情况 如何 区分 必然偶然？
        分情况:
          * 必然性 API 声明 一般都是 必然性转发
            但 注意到 声明 也是 有 层次的，某些声明 就像 不完全定义体
          * 必然性ABI声明、必然性定义体 的 转发 可能是 偶然的

    ====
    tag everywhere: require pseudo-import to decl the meaning of tag
      syntax: {[}tag{]}
      syntax: {<[}tag{]>}
      syntax: {(<[}tag{]>}...???...{<[}tag{]>)}
    vs inline comment: {-[}inline comment{]-}
    ====
    alias pattern && reversable alias pattern
      we can easily go from left to right by alias-def given alias constructor+args(pattern match args on lhs of alias-def)
      but how can we go from right to left?
        reversable ==>> alias is injection/互斥
    using alias, we can simplify construction that use original constructor
    using reversable alias, we can simplify pattern-match that use original constructor
    ====collision-visibility of identifier
    成员名 防碰撞（多继承）
    函数 命名参数 防碰撞（多转发）
      变量名 肯定是 不够用的
      至少 也得是 路径名/qname=qual_name
        可用 symbol/object 'is'
    私有/可见性控制
      无论是 class/pkg/namespace 都很重要
      对外 要完全 不可见，如同不存在，而非 只是 禁止 使用。禁止 使用 意味着 可见，意味着 碰撞。
    ====collision-公开的成员名 防碰撞
      * using qname，qual_name, qualified-name
        见下面 包名 防碰撞
      * using parameterized identifier
      parameterized identifier
        def:[参数化标识名]
        参数化 标识名: 参数 可以是 任何 编译期的值，相等+读写（<->文本），包括:类型、参数化标识名。重点在于 标识名 并非 字面 值，允许 参数 实例化 时 使用 引用 变量名/别名，甚至 参数化标识名 本身 也可 alias
      ===参数化标识名 vs 参数化模版名
      ===参数化标识名 只命名 唯一一个 标识 vs 参数化模版名 命名 所有潜在组合（导致 不能 作为 虚函数 名）
      encoding identifier/complex identifier
        embedding type-name:
          f[T]<S>()
          S~template arg
          T is part of whole identifier "f[T]"
          why?
            #err: virtual g<T>()=0;
            virtual g[T]()=0; //ok!
            但！可添加无用参数重载函数 而非 特化:
              see:[[无用参数]]
              virtual g_who(Tag<T>)=0; //ok!
      ====
      标识-参数-自定义 .xxx.xxx
        分解 标识:
          py.unittest test_xxx
          listener.on_xxx
          set_xxx/get_xxx
        自定义 静态 __getattr__
          如: x..f(...) = {x.f(...); return x;}
            ==>> x..f(...)..f(...)
          __getattr__ 通常 需要 分解 标识
        可用于 metaprogramming，复制 整个类 的 公开成员函数，用于 实现 ref
      ===
      参数化模版名 可用于 命名 私有标识，只要 某些 参数 是 私有类
        私有标识 可用于 框架宏 在 展开处 就地 定义 私有变量，以防 与 用户变量名 碰撞

    ====collision-unbounded-ultra-lengthy-identifier
      无限制超长标识名
      unlimited, unrestricted, unbounded
    包名 防碰撞:
      当前 包名 这么短，必有 独立提出 并发生碰撞的。随着时间的推移，代码数量剧增，顶级包名 必然 越来越长
        问题 只出现 在 完全 开放空间，不特定 人员/团队 不特定 时期 不受控地 自由使用/占有 包名，相当于 并行编程-数据竞争
        问题:如何优雅地使用 长度极长的包名？包 安装？包 引用？
      hname = huge_name ~ 几无可能 碰撞 ~ 防碰撞机制的唯一根源
        唯一的 目的是 有别他人，不需要 明显的 含义(如:库用途，与 库内容 无关！，库相关 命名 当在 非开放空间之下)
          #？第一行 是 nname？
          作者团体标识，库创建时间，地点，随机数
        #xxx #under __subspaces__/.../.../.../
        #xxx #under __open_space__/.../.../.../
        under __ospace__/.../.../.../
      nname = nickname/agname/byname 略称/简称/绰号 ~ 极大可能碰撞
      msuffix = manually-choosen-collision-free-suffix
        路径名 里的 nname[msuffix] 只能是 以使用它的 库 的位置为基准 向上搜索 先辈，不能搜索其他！也即 向下 公开，对外 私有，非API。但 alias 是以 路径名 前缀 为 基准，属于 API 的 一部分，也区分为 必然、偶然，必然 则 连同 定义体 都是 API 的一部分，偶然 则 只有 alias 存在性声明 是API的一部分，定义体 可能 更改/可配置/可替换。
          see:[必然偶然]
      rsuffix = auto-choosen-collision-free-random-suffix
      cname = controlled-name
        #xxx #under __subpackages__/
        #xxx #under __controlled_space__/
        under __cspace__/
        under __pspace__/
      pspace = private controlled-space #__private_controlled_space__
        enclosed space + invisibility
        有主受控秘藏空间
        路径名？ 必须 与 公开 空间 区分开（受控私有空间，受控公开空间，开放公开空间）
      cspace = controlled-space #__controlled_space__
        enclosed space + visibility
        有主受控公开空间
      ospace = open-space #__open_space__
        common/wild space + visibility
        无主众竞公开空间
        ### xxx ### e.g. for others to fork and ...impl his variant to same API
        e.g. 大地域/大团体 分配 空间 给 子团体
      nsroot = namespace root
        #xxx #__root__
        #__nsroot__

      包自动管理:
        即:下载，安装
        依 本包 前缀 寻路，本包 既然 使用 hname，则 父空间 是 开放的 无限制注册空间
        安装于: 父空间-根目录/__ospace__/{nname}/{digest}/{随机名-同目录区别而已}/
          #本包 根目录
          #hname_pkg
          ===
          __hname__ #文件，保存 hname # 声明/输出 export hname #../*/__hname__ 的 值 作为 键值 必须 唯一
          __nname__ #文件，保存 nname，冗余 检查 __hname__ 第一行
          __digest__ #文件，for __hname__, 方法名+摘要<方法名>(hname) #用于避免 依赖庞大无限制更新的 只增不减 摘要库 或 只能 使用 固定有限的几个 古董摘要库 # 直接用做 {digest}/ 目录名 #受文件系统规范，只取最大前缀，其长不超过系统限制
          __encoding__ #文件，for __nname__,__hname__,__digest__
          __cspace__/ #含 本包 所有 子包根目录 及 子模块文件
            #cname_pkg
            {子模块名-module-name} #文件，模块
            {子包名}/ #{子包 根目录}
              #无 __hname__, __imports__, ...
              __cspace__/
              __ospace__/
          __ospace__/ #含 本包 所有 子空间 的 根目录
            {子空间-nname}/{digest}/{随机名}/...recur def...
          __imports__/
            {他包-nname}/{本包 作者 手动 选的 防碰撞 后缀-msuffix}  #文件，保存 输入包/他包 的 hname
        定义目录类型:
          ==举例:
          开放空间:
            #xxx #如：源代码根目录/
            #如：__ospace__/
          受控空间
            #如：__cspace__/
          长名包
            #如：__ospace__/{nname}/{digest}/{rsuffix}/
          短名包
            #如：__cspace__/{cname}/
            #xxx #如：__cspace__/{cname}.{ext}
          ==定义:
          源代码根目录/ #xxx <: 开放空间
            #禁止出现 __hname__,__nname__,__imports__/
            #禁止出现 __cname__
            #禁止出现 __cspace__/,__alias__/
            __nsroot__ :: 空文件
            __ospace__/ :: 开放空间

          开放空间/
            #xxx #禁止出现 __nsroot__
            {nname}/{digest}/{rsuffix}/ :: 长名包
          受控空间/
            {cname}.{ext}
            {cname}/ :: 短名包
          长名包/ <: 短名包
            #禁止出现 __nsroot__
            #禁止出现 __cname__
            __hname__ := hname
            __nname__ := nname
            __encoding__
            __imports__/
              {nname}/{msuffix} :: hname
            #以下 与 短名包 相同
            ...包文件夹共同内容...
          短名包/
            #禁止出现 __nsroot__
            #禁止出现 __hname__,__nname__,__imports__/
            __cname__ := cname
            #以下 与 长名包 相同
            ...包文件夹共同内容...

          ...包文件夹共同内容.../
            __version__/
              {version}/
                __后顾性兼容__
                  #声明 兼容哪些旧版本
                  #声明 哪些部分 应该 废除
                  #     新用户 使用 新版本 时，可有 两种引入模式: 完全兼容旧版，不完全兼容旧版
                  #为保证 引入 文件 未被窜改，各处引入语句需添加 ((路径名+版本+其间{nname[msuffix]:hname} 或 完全展开后的路径+版本)+被引用的文件的内容)临时变换后的 散列值
                    #完全展开后的路径 是 模块的隐含输入，它绝对如何解释nname[msuffix]
                  #为保证 本文件 的 位置 未被移动，需声明 本文件 完全展开后的路径+版本 临时变换后的 散列值
                __export__
                  #声明 输出哪些 包/模块 及 版本，只有 选中的，才是 可见的
                __fork__
                    # fork-branch #声明 继承 别的包 的 哪些版本的实现
                __abi_decl__
                    # see:[API_ABI]
                __api_decl__
                  #re-impl-API #声明 实现了 哪些 别的包+版本 的 哪些 API

                  #声明 本包 API #输出 本包/本模块 的 哪些 对象
                    # see:[API_ABI]
                __module__.{ext} # 本包作为 模块
                __main__.{ext} # 本包作为 主模块
            __pspace__/ :: 受控空间
            __cspace__/ :: 受控空间
            __ospace__/ :: 开放空间
            __alias__/
              {alias} := {路径名}
                #set curr pkg, then rhs to 绝对路径名（且是标准的:不含alias/向上后续路径）
                  #acyclic 防循环

      引用 他包 的 本包内的 代码/本地命名:
        {他包 前缀}/{他包-nname}[{msuffix}]
          #开放空间 搜索 __ospace__/
        {他包 路径}/{他包 子包名/子模块名}
          #非开放空间 搜索 __cspace__/
        #不存在 全局命名，如果有，那 只能 直接嵌入 hname，只能是 机器 理解，对于 人 来说 可读性 差
        路径名 格式:
          # qname，qual_name, qualified-name
          # regex".*:" ==>> 开放空间 #__ospace__/
          # regex".*[.]" ==>> 受控空间 #__cspace__/
          # regex".*\]" ==>> 长名包
          # regex".*\w\>(?![\[\]])" ==>> 短名包
          #
          路径名 = 绝对路径名 | 相对路径名
            绝对路径名 = ///:{开放空间后续路径}

            许空相对路径名 #许空
              = 相对路径名
              | "" #空
            相对路径名 #非空
              # 独立 或 在 长名包/短名包 之后
              = .{受控空间后续路径} #『.』当下的最近先辈__cspace__
              | :{开放空间后续路径} #『:』当下的最近先辈__ospace__

            受控空间后续路径 #许空
              # 不独立 且 在 受控空间 之后，而 受控空间 必然 从属于 包（长名包/短名包）
              = 向上后续路径
              #受控 向下
              | {cname}{许空相对路径名} #『cname』当下的短名子包
              ##特殊:结束，解释别名
              | "" #空
              | ${alias}{许空相对路径名}
                #在指定位置的别名
              | $?{alias}{许空相对路径名}
                #在指定位置的向上搜索别名

            开放空间后续路径 #非空
              # 不独立 且 在 开放空间 之后
              = 向上后续路径
              #开放 向下
              | [{nname}[{msuffix}]]{许空相对路径名}
              | [[[{hname}]]]{许空相对路径名} # 上面的展开式 # 机器交换用 全局极长唯一命名
                #hname 与 cname 在不同 命名空间，哪怕 值相等 也不 发生 碰撞
                #但 {cname}/ pkg(__module__.{ext}, __main__.{ext}) 和 {cname}.{ext} module 发生 碰撞？

            向上后续路径 #非空
              #向上
              = {相对路径名}
              | ?{cname}{许空相对路径名} #『?cname』按名搜索当下的最近先辈__cspace__
              | ?[{nname}[{msuffix}]]{许空相对路径名} #『?[nname[msuffix]]』代码所在包 向上搜索 先辈__imports__/，以得到 最近 符合 该 略称 的 hname，在于 目标路径上 向上搜索 该hname
                ###bug!!! 中途跳过的先辈 再版可能 提前 截胡 nname[msuffix]!
                ### 所有 nname[msuffix] 只能在 最近的 长名包(短名包 没有 __imports__/) 里 搜索！不能fallback到更上的先辈 # 或 显式指出 具体向上跳过几个 开放空间/受控空间
              | ?[[["{hname}"]]]{许空相对路径名} # 上面的展开式



    ====
    初始化函数 分割:
      + 检查输入是否符合 前置条件 （可能 异常）
      + 构建数据成员的临时副本（不该 出错，或者 异常 作为 前置条件 的一部分？）
        # 分割的意义何在？在于减少 动态检查，这里的初始化 跳过前置条件检查，而将它们的这些前置条件 添加到 上面的 本类的前置条件，合并精简
      + 检查 类类型不变量（不该 出错，或者 异常 作为 前置条件 的一部分？）
      + 移动赋值给数据成员（无错）
    =====
    xbool = true|false|wait|err
      xbool-推导
        * 有限步
          不相容-既真且假
          无关-不真不假
        * 不停机/不收敛/发散
          计算未结束-可能真可能假
      wait={true,false}0b11/待确定/计算中/并行态/偏序相等{<=,>=}
        整数素性判定-快速测试 未成功
        连分数比较/带误差浮点数比较
          无穷长连分数 相等时 无法判定
          浮点数 误差范围重叠，也无法比较
        实现依赖 的 结果: 见上面 两相等字符串常量地址是否相等？sizeof(int)==sizeof(long)？既真且假，并行态
      true={true}0b10/偏序大于{>=,!<=}
      false={false}0b01/偏序小于{!>=,<=}
      err={}0b00/出错/未定义/输入在定义域外/前置条件不成立/算法逻辑出错/偏序无关{!>=,!<=}
        除零
        整数素性判定-输入 非整数 或 0,+1,-1

    ====
    多对象约束:
      see:[concept_const__storage_const__recur_const]
        obj-concept-value = obj-name + stmt-label = value-of-the-named-obj-just-before-the-stmt-label
      其实可想象有一个虚拟对象，以这些对象为成员
      我们使用 构造函数 建立 不变式
        我们使用 检查函数 建立 约束
      我们使用 成员函数 进行修改 维持 不变式
        我们使用 相关修改函数 维持 约束
      局部破坏性修改 是 允许的，只是在 返回 之前 必需 重建约束
        而且 不允许 递归调用 外部函数（那些仍以为 约束 成立的函数/闭包/引用）
          或 采用 一次性全体批量更新策略，避免 非全体的就地修改。可简单实现 不改动or成功，避免 不确定的中间状态。
            但还是有毛病: 一个对象 可存在与 多个约束中
            上面 只考虑 维持当前的输入约束，却未考虑到 其他 不可见的外部约束
            内存空间存储的值===内存地址+时刻点===概念上的值===约束中的值
            所以 不是 多对象约束，而是 多对象的值的约束
    ====vs class/data invariants
    #conceptual property/attr
    #decl/build-up opaque-condition using opaque-condition-constructor via postcondition/class-invariants #check-func/class-constructor
    每一个函数 都该有 几个版本:
      调用者 静态证明 前置条件(比如 动态检查建立静态证明)
      调用者 不想静态证明 前置条件（特别是 混合调用 接口相同仅前置条件不同的 函数（template内部））(实现==动态检查以建立前置条件静态证明或抛出异常+转发 调用 前一版本)
      被调用函数 静态证明 后置条件
      被调用函数 不想静态证明 后置条件(抽象类的虚函数 需要 用户提供 实现，某些情形下，为了 减少用户负担，可免除 用户 后置条件 的 静态证明，而统一集中在 公开的包装函数。公开的包装函数=转发调用私有的虚函数+动态检查以建立后置条件静态证明或抛出异常)
    前置条件 分层: 基本的带明确异常的，保证无异常的；产生不同后置条件的（比如 增强后置条件）
      后置条件 反推 前置条件: 等价于 逆否命题，但 正向表达 更自然（相比于 开头not）
        [后置条件]->[前置条件]
        [前置条件]<<--[后置条件]
        [not 前置条件]->[not 后置条件]
    pre-post-condition:
      [precondition] -> [postcondition]
      ==
      [common-AND-precondition][...] -> [common-AND-postcondition][...]
        * [branch-precondition] -> [branch-postcondition]
        * [branch-precondition] -> [branch-postcondition]
        * [branch-precondition][...] -> [branch-postcondition][...]
          * [branch-precondition] -> [branch-postcondition]
          * [branch-precondition] -> [branch-postcondition]
    ====
    外挂接口的C++实现:
      // not good below, I shift to use data-member instead of iherit
      template<template m> class Monad : Functor<m>{
        template<typename i, typename o> m<o> operator >>=(m<i>&, std::function<o, i>&);
        template<typename o> m<o> return_(o&);
        private:
          virtual ...impl<m,i,o>...
      };




    [type_erase][physic_sort]
    type erase: reduce to physic_sort: ABI: aligment/size_of/copy/move/del are all the same
      java ref/builtin-types are have diff physic_sort, so type-erase-generic not support unbox type，i.e. the param for generic (typename) has type constraints too, that is physic_sort
    type param role: label-only, data(view, immutable, uninit, init, init_or_uninit_并行（禁止读写/构造/析构）..., impl whole alias)
      how role to cooperate with tag?
        tag: e.g. const in C++
        template: e.g. char* <==> ptr<char>
        what role of char for ptr<char>?
          <<== what relationship about ptr<char> and ptr<const char>?
            单向隐式就地转换(仅静态类型声明更改，无任何动态动作)
            physic_sort are the same
      Functor newtype : fmap <==> static_cast
    IO <: MemberAssign <: MemoryWasted/Consume <: Monad
    IO <: DateTime/Abs-Clock <: TimeSpan <: TimeWasted/Consume <: Monad
    IO <: GlobalVarsAccess <: GlobalImmutableVarsAccess <: Monad
    ===
    ref+DAG-proof
      a.x := b
      require proof: [acycle a b] =[def]= [b != a][not b-*->a]
      比如: DLL = doubly-linked-list
        建立 类不变式:
          prev -[shared_ref]-> next
          prev <-[weak_ref]- next
          [acycle prev next]
          [[DLL.head a][DLL.head b][a != b] -->> [acycle a b]]
            注意: 此处 引用 所有其他已存在的 链表 共同参与 此约束的构建
              let a=this. any b <- DLL: [[DLL.head a][DLL.head b][a != b] -->> [acycle a b][acycle b a]]
        这样一来，就可以 实现:
          链表 切割、截取、串联、插入
    ===
    lazy_ref = ???
    top_ref = shared_ptr4top_owener
      shared_ptr -> block{.shared_count, .weak_count, raw_ptr, destruct_free_mem_func}
    sub_ref = {shared_ptr4top_owener, raw_ptr4this_data}
      sub_ref.x ==>> shared_ptr4top_owener not change, raw_ptr4this_data change

    shared_ref = top_ref | sub_ref
    inner subdata impl type = boxed-top_ref | boxed-sub_ref | unboxed-local_member_room | unboxed-raw_ptr (as-if unboxed what the raw_ptr ref to)

    data cycle prevent? #-free
      #copy-on-write?
      immutable nonlazy data property := any ...
        #part construction before whole construction
      mutable or lazy data property :=
        #part construction may not before whole construction
        | weak_ref
        | in_use_ref/captive_ref/scoped_ref/local_ref/active_ref/survival_ref  #可配合 shared_ref/unique_ptr，但这里unique_ptr的实现 更复杂，类似shared_ptr，只是共享计数的值只能为1，故可省略，不能支持weak_ref？但可支持更弱版的weak_weak_ref，不能取出shared_ptr/in_use_ref，但能检测是否还存在，比较是否相等，散列，甚至大小？，需要weak_weak_count?（两版本，有/无）, in_use_count (无需shared_count，weak_count)
          #like weak_ref, use count, not share ownership
          #but weak_ref can point to nullptr
          #     in_use_ref assume 'data in use' like usage of raw_ptr to local/stack/call-frame var
          # in_use_ref neednot detect nullptr when dereference
          # when shared_ptr decide to delete data, and found in_use_ref exist, abort()
          # save src location(shared_ptr->mk in_use_ref) info to show at abort()
          #     how to generalize this src info access idea?
          #     see:[how_to_access_src_info]
          # automatic/stack_frame unboxed obj --> in_use_ref/weak_weak_ref no shared_ref hence no weak_ref
        | raw_ptr to static-obj
          #到底是 变量的类型 本身 只能用于 定义 静态变量
          #还是 raw_ptr 的约束，只能 指向 静态变量？
          #泛化: 仅本线程可用的类型，raw_ptr to thread_locals
          #泛化: 同时定义帧？线性定义栈？生存期覆盖？
        | change only to spec-branch (e g. nullptr ==>> FIFO-doubly-list(backward using weak_ref, head in, tail out)) ... type-dec-tree-disjoint-branch but can init with anything???
          #init always ok
          #cycle occur only at member/field/property/attr [any-depth] assigment
          #
        | ???constraints on lazy
          #global-data-flow-check?
          #     every func: input, output, nonlocals/globals, which var (whole or part?) put into which var tree?
        | type-strictly-decrease-for-same-type-constructor-in-tree{edge=non-weak_ref}
          ==>> all datatype complete, not only forward decl # or using forbidden set? 外部约束-针对 不透明/未声明 的那部分数据成员
            ==>> no open-inherit #开放式继承 成员数据无限可能
            ==>> no func/lambda #函数的实现 引用静态变量 绑定局部变量，无限可能
              #函数 都是静态变量，只是绑定的数据变量 不同，函数允许 循环引用（用于 递归）（反正 所有 函数 只有 在程序结束时 才析构）
              ==>> 仅用于定义静态变量的类型 不需要 计数共享，允许 循环引用，直接用 raw_ptr（也不用负责其析构）
                init order: using var member or only as-if-uninit-var-ref
                静态类型 分两个阶段: 全局变量初始化 完毕 与 未完毕 #甚至 具体到 某个 静态变量的某个变量 初始化 完成
                  析构则是反转这些阶段
                ==>> [循环引用] 同批次构析多对象循环引用
                  //同批次，同年，同时构造同时析构（类似 同一结构体的 数据成员）
                  //各对象 不负责 析构 循环引用的对象，在 构造期 及 析构期 不得 解引用。
                  //？？<==> 隐参数 批次帧引用，+lazy 数据成员 获取
                ==>> 声明 数据类型时，必须 声明 该类 如何 处理 循环引用 的。（避免~如何避免~符合 何种 协议？，允许~如何实现-符合 何种 协议？）
            ==>> no sub_ref #owner is untyped
            ==>> if lazy: global? binding? forbidden set as template param ...


    call-frame, yield-stmt-position, func-impl-friend(known goto/yield-label, yield-output-type(cased by yield-position))
      "yield from" ==>> frames
    局部约束增强 vs 输出约束更改 vs 独占约束更改（如:inplace-new）
      声明于各个分支各自初始化
    约束 vs 模版参数:
      mx_mul(lhs, rhs)
      mx_mul<R, M, C>(lhs<R,M>, rhs<M,C>) -> mx<R,C>
        许多函数，虽然 可以 调用 free 以避免 代码爆炸，但 很难 用作 脚本/C-API/虚函数
      mx_mul(lhs, rhs){lhs.num_cols==rhs.num_rows} -> mx{mx.num_rows==lhs.num_rows, mx.num_cols==rhs.num_cols}
    hs::
      datatype 的 类型 与 值: 值构造器 是 有限的，受控
      Type 的 类构造器 是 无限的，开放
      受控:则 穷举遍历 case ... of
      开放:则 单独 实例化 + 类型推导 自动匹配: 接口与实现: class ~ instance
        vs C++动态多态: 各子类 实现 虚函数
        vs C++静态多态: 各特化模版 匹配不同 类构造器
        ===回想起来:我的Earlay?解析器 的 实现: 定义 接口，添加 新数据 到 接口 名下，监听器 将其 监听的接口名下的 新数据引起的 新组合 发送到 执行器（先送到 检查器，以确定 与 已存在的数据是否相容）
          其实 开放式 定义 也可 以此，先添加 前瞻性声明（用于 循环定义），再添加 定义体；后面 是 依赖之前 定义 的 定义。
          组合性接口:成员数据 正交 直积空间，全部有效 存在，并不需要另行声明
          关联性接口: 接口+实现（多种可能，所以需要人为干预，命名区分防碰撞）
            = 开放性接口 | 受控性接口
          开放性接口 关联一个 只增 序列/集合 以包含 不断添加的 实现
            如何处理这些 实现？什么时候处理？
              注册 监听器 检查器 执行器
          受控性接口 关联一个 固定 序列/集合
            ？一次性 完成 初始化？
              或 要求 在 结束处理（编译）前 必须 有 一个 封装 信号 表示 完成 初始化
            别的执行器 可判断 是否 已声明 该接口（存在性）？是否 完成 定义/初始化？如果 完整，则 启用 执行器 遍历/穷举/归纳处理。
          开放性接口 的 实现 在哪存取？
            很多关系 都指望用户 添加
            如: hs-class-instance
            这里 牵涉到 很多实体:
              实现者/用户/作者
              关系实例名=关系类名+关系实例参数
            这里 还牵涉到 模糊搜索:
              #用户 为避免 重新发明轮子，必然 需要 遍历搜索
              #在哪找？怎么用 程序 快速找？tag 特性 过滤？
              #数据库？
          提供多个 可替换的 配置文件（夹） 作为 代码的一部分，这样 编译器 指令 更有 含义（全都 指向 代码树，加上 编译命令 本身，再无其他不可见的额外信息）。
              see:[必然偶然]:[配置偶然信息]

  obj vs val
    obj ~ 析构/资源管理/IO
      decl has swap? copy-constructor? ==>> auto has assigment
      #move-constructor always auto
      iterater #st mutable/IO
    val ~ immutable
      StateMonad
      builtin data type #unboxed immutable value, no address
  decl-qual-kwarg + packed-args-kwargs to support foward call
    外挂接口 也是 kw:
      sort :: Ord a => [a] -> [a]
      <==> sort<a>(vector<a>&, *(Ord<a>)=...)
  decl-qual-member to avoid multi-inherit collision
  反转实现依赖:
    Functor a => Monad a
    Functor a <<== Monad a
      在缺少 Functor 的情形下，定义 Monad，则反过来 自动定义 Functor，但这样一来，Functor a 可能就有多个实现！
      其实若非自动生成，则 2 kw 参数 各自取 数据成员（相当于 取出依赖），也可能 不一致

  named value
    type is compile time value
    type-constructor is qual-named value
    when no address, qname is identity

  idea?
    unque impl
      e.g.
        forward decl
        hs::infix
        parameterized

    multi-impl
      e.g.
        abstract class / interface ~ derived classes
        type ~ objs
        template ~ specializations
        hs::class ~ instance
      naming?
        named
        parameterized
        ...
  idea 4 c++?
    another inherit hierarchy: just used as tag to classify subclass and offer default-value and requirements(abstract api/interface)
    the only problem of c++ inherit hierarchy is that multi-inherit require virtual baseclass, since there is a subobject has exactly type of the baseclass.
    the new hierarchy has no such subobject
  idea 4 c++?
    tag:
      exception specialization:
        void f() throw (A,B);
        void f() throw ();
        void f() noexcept;
      ....why r() not decl I'm to rethrow?
        int r(){
            throw; //rethrow
        }
        int g(){
          try{
          }
          catch(...){
            r(); //rethrow
            throw; //rethrow
          }
        }
      decl 4 func: long-rethrow, long-return, long-break, long-continue, long-goto
        // long-goto === long_jump
        func as subroutine/macro/snippet
      decl 4 func: O(NlogN) time/space
      decl 4 func: exception guarantee
        基本:所有 对象 状态 有效，可析构
        强保证:若 异常，则 不修改参数
          无副作用？(显然 不可能没有，因为 有一个 新异常对象)
        无异常保证

  idea 4 c++?
    宏输出+宏输入#包管理？
    头文件 定义的宏/输入的宏 并不 自动输出
    只有 头文件声明输出的宏，才是 外部可输入的
    包含头文件 并不自动 输入其输出的宏，只有 显式声明 输入 才行
    头文件 保护: 避免 二次包含 理应是 默认设置
  idea 4 c++?
    框架宏
      其命名 必需 依序包含 未匹配括号
    语句组/透明语句组（stmt_group vs scope） 只是一个 透明的组，并非 真正的 作用域
      可用作 框架宏 的 参数
      ？？？可用作 解包用 左值 声明:
        {int x, int y} = z
        {auto x, int y} = z
        auto {x, y} = z
      用作 被注释的 代码片段
        注释领头 解释目的，代码片段 随后缩进
        //反过来的情形也有
        //单行语句/语句组 领头，多行注释 随后缩进
  idea 4 c++?
    break 退出最近作用域，而非仅是loop/switch
    break + for/while/do/loop/switch/label...
  idea 4 c++?
    hs::newtype
    C++::class 添加 __this_type__
    这样，当用newtype定义新类型时，operator/成员函数 __this_type__ 自动 转向 新类型
    ？？？但还有很多问题：
      类继承关系？
      模版特化-类型参数角色问题#role

  idea 4 c++?
    all static (global/thread_local/static-member/static-local/...) as non-static-member in a virtual class
    we can inherit this class then overload some member, and pass its instance into func-call as implicit-param

  idea from c++.cin<< ?
    见上面 自定义 静态 __getattr__
    设计 新语法:
      x..f(...) ..g(..)
        #as-if return x
        <==>
          x.f(...);
          x.g(...);
      or:
        with x:
          .f(...);
          .g(...);

  idea 4 c++?
    def:[concept_const__storage_const__recur_const]
      #16.2.9.2 Physical and Logical Constness
    约束: [logical-const] vs [physical-const] vs both vs recur-both
      * [logical-const]
        允许(私有)实际成员修改，但(深度)公开概念成员 不变
        c++::mutable
        synchronized/parallelism obj .lock()
        cache to save computation for queries
        std::string::c_str()
          #在必要时，需附加NUL字符#不允许&s[0]
          #与vector::data()不同#允许&v[0]
      * [physical-const]
        不允许(任何)实际成员修改，但(任何)概念成员 可变（本身vs深度引用）
        只读存储器
      * both
      * recur-both
        ...
      强联系（拥有） vs 弱联系（索引）
        强联系（拥有）vs 直接成员
        弱联系（索引）vs 间接成员
      key@mapping
        绑定与否
        key 不变，但 mapping 本身可变
        ptr作为key，默认绑定内存空间，故指向的对象 有默认定义
        其他key基本 无法绑定特定mapping，所以 并无明确的 指向对象
  idea 4 c++?
    约束: [non-freeable/deletable-ptr]
      #like "const"
      not allow "free(p)"/"delete p"/"delete[] p"
      deletable_ptr can implicitly convert to nondeletable_ptr
      get address "&x" always return nondeletable_ptr
      deletable_ptr of derived_class cannot convert to deletable_ptr of baseclass without virtual destructor
    idea 4 c++?
      标签
      member alias with diff tag
        distinguish use purpose
      比如:大小/相等比较次序(+部分数据成员无关)
        声明 某些数据成员 参与或不参与 某些活动
        比较、复制/赋值/移动/交换、垃圾回收/垃圾收集
        可见性控制:public/...
        extern/static/inline/constexpr
      比如:const/mutable //c++ keyword
      比如:override/final/virtual //c++ contextual keyword
      比如:无用参数
        see:[[无用参数]]
    idea 4 c++?
      tag droppable/addable
      some kinds of tagged type can convert to non-tagged version
        noexcept
      some kinds of tagged type can convert from non-tagged version
        const
      tag:
        mutable #for cache/lock/... impl detail, not affect conceptual value
        uninitialized #for buffer in struct, non-init after constructor


  idea 4 c++?
    allow only loop/tail-recur/tail-mutual-recur
      to avoid call-stackoverflow
  idea 4 hs?
    f :: forall a,b,c => (a -> b) -> (c -> b)
    f @[a] @[b] ...
    a, b 的 次序问题:
      用户 显式 指定，则 无端 多出许多 本该一致 的 不兼容类型
      命名kwargs，也有类似问题，而 标识名 的 选择 也是个 问题
      默认 由系统 按某个规则 排序，则 一旦 类型 改变 修改实多
      其实 可用 seq<uint> 作为 kwargs, 自动生成
    f :: forall {a,0.0},{b,0.1,1.1},{c,1.0} => (a -> b) -> (c -> b)
    f @[0.1=xxx]
  idea 4 hs?
    def:[类型增删变体]
    正体/范体->变体
    datatype ==>> subdatatype
      比如：减少并联分支，成员类型 改成 子类型
    datatype ==>> superdatatype
      比如：增加并联分支，成员类型 改成 泛类型
    def variant xxx:
      on (T a b)::constructor = delete; #删
      on (T a b) += ... | ... ...; #增
      on (T a b)::constructor@[idx/attr] = ... #成员数据类型 的 增删

    子类型 当作 约束 用途:
      nonempty_list
        datatype list a = empty_list | cons a (list a)
        subdatatype nonempty_list a <: list a = cons a (list a)

      partial_ordering
        datatype partial_ordering = LT | EQ | GT | NA
        subdatatype total_ordering <: partial_ordering = LT | EQ | GT

      datatype bit = O | I
      subdatatype bitO <: bit = O
      datatype integer = zero | nonzero_integer {sign :: bit, little_endian_tail_bits :: list bit}
      subdatatype natural_integer <: integer = zero | nonzero_integer {sign :: bitO, little_endian_tail_bits :: list bit}
    泛类型 当作 增强 用途:
      抽象语法树->具象语法树
      无糖规范官话具象语法树->加语法糖的方言具象语法树
      旧版本语法树->后顾性兼容的增强型新版本语法树

  idea from c++.__FILE__/__LINE__/__FUNC__ ?
    how to access src info?
    def:[how_to_access_src_info]
      caller env detect
      caller env forwarding
  idea from py?
    混合使用，统一使用协议
    +=
      就地修改？mutable
      构建新值？immutable
    统一:
      返回 带新值的对象 #不确定是 新对象 还是 旧对象
      不再使用旧对象 #因为 不确定是 带新值 还是 带旧值


  构造器-匹配-区别-私有
    公开构造器
      检查约束，抛出异常
      变换参数，调用 私有构造器
    私有构造器===在线构造器
      ==>> 公开匹配器
      ==>> 别名匹配器
    标准构造器
      用于 == 测试: 每个等价类 产生 结构相同的 标准构造器树
    读写构造器
      即可对 参数进行相当程度的 标准化
      也必须 调用 公开构造器 以 检查约束
  静态多态/模版匹配 vs 动态多态/hs-class-instance:
    静态多态/模版匹配:
      可用 静态约束 区分 特化模版
    动态多态/hs-class-instance:
      要么 不使用 约束，仅靠 类型构造器
      要么 约束区分 也要 作为 参数 输入，静态 或 动态

  idea 4 c++?
    from 字面常量
    近字面常量(全局静态只读 带 默认析构函数，即 什么也不做)
      特别是 指向近字面常量的指针 也可成为 近字面常量的数据成员
        支持 逻辑上的 循环引用
    像是 异常，可复制性+noexcept，通常 使用 避免 使用 动态内存
        struct My_error2 : std::runtime_error {
          const char∗ what() const noexcept { return "My_error2"; }
        };
  idea 4 c++?
    copy/move *  constructor/assigment
    copy assigment
      手写 太蠢
      可以 声明 哪些 成员不改(e.g. lock, container's allocator)，哪些直接 赋值 无异常(builtin-type, literal-type, POD)，哪些 要先 复制（有异常） 再统一批量swap（无异常）
  idea 4 c++?
    如何 将 重要数据及数据处理状态 同步更新到 持久性存储器？以便 掉电/异常 后 恢复（继续/回滚/...）？
    ?transaction? commit, continue, rollback
    ?permenent?

  idea 4 c++?
      def:[辅助函数与关联辅助开放空间]
      辅助函数 并不需要 friend 权限，没有 必要 成为 成员函数，但是 十分有用，也方便 遍历浏览，可不断添加，需要 概念上的支持，在 类空间 之外，在 命名空间 之内，一个中间层开放空间。需要 语法 支持，类似 成员函数 的 调用方式。
  idea 4 c++?
    pg395[410/1366] #Argument-Dependent Lookup(ADL)
      // 感觉不行！
      // 应该 提供一个注册用的命名空间，就像hs::class，用户 重载的函数namespace mine{f(){}} 自己用 namespace xxx_interface{using mine::f;} 注册进去
      // 模版函数 调用时: xxx_interface::f(...) 或 using namespace xxx_interface; (重载 运算符)
  idea 4 c++?
    『异常保证』
      『无异常保证』无异常 或 死（不返回）
      『强异常保证』异常 则 无修改
      『基本异常保证』异常 则 所有对象 可正常 析构
          //僵尸状态 伪合法状态
          //def:[构析不对称-僵尸状态)
          //构造函数 :: 未初始化 -> 合法状态
          //成员函数 :: 合法状态 -> 合法状态
          //移动构造/移动赋值-被动宾语 :: 合法状态 -> 僵尸状态
          //伪合法状态 = 合法状态 | 僵尸状态
          //析构函数 :: 伪合法状态 -> 未初始化
          //构造函数 析构函数 不对称
    『强-异常保证』的 修改多对象 的 实现: 临时变量+修改+批量swap
    问题在于 重复！
    事实上，修改 部分 只需要 使用『基本-异常保证』能正常析构即可。
      全用 『强-』会导致 大量 临时变量 在 多个 层次 出现，副本 浪费 空间，复制 浪费 时间
    解决方案:
      声明 某个 语句组 只需 『基本-』
      但这 需要 类似 const/non-const 成员函数 一样，区分出 两个版本，容易 出错（不一致）
  idea 4 c++?
    pass-by-value/reference
    template<typename T>
    struct PreferPassBy
    {
      constexpr static bool prefer_pass_by_reference_over_pass_by_value = true;
    };
    template<bool b, typename T, typename S>
    struct Choose;
    template<typename T, typename S>
    struct Choose<true, T, S> { using Type = T; };
    template<typename T, typename S>
    struct Choose<false, T, S> { using Type = S; };

    template<typename T>
    using PassBy = typename Choose<PreferPassBy<T>::prefer_pass_by_reference_over_pass_by_value, (const T&), T>::Type;
      def:[自动选择传值或传引用的元编程]
      see:[类型拆包]

    template<typename T>
    class X
    {
      void add(PassBy<T>);
    };

  idea 4 c++?
    def:[外部虚函数表的开放性]
    面向数据hs互斥并联 vs 面向对象c++虚函数
      面向数据:
        优:应用灵活（包括 case...of/typeid()+dynamic_cast）
          特别是 跨分支/跨子类 应用: 小于
        缺:封闭空间，分支固化
      面向对象:
        缺:应用预设（虚函数），而且 止于 自身，不能 跨子类
        优:开放空间，子类 可 自由添加
    通常 类作者 不可能 预见 将来 所有应用，虚函数 不可能 涵盖所有应用。
    如果 数据 增加 并联分支，所有 应用 都要 修改
    解决方案:
      开放 虚函数！
      某个 应用函数 可以 声明 需要 那个基类 的 哪些 外部虚函数。
      一旦 使用 此应用函数，则要求 所有 具象子类 都要 实现 这些 外部虚函数。
      但 类作者 没空，所以 由第三方来负责实现。
      外部虚函数 只有 最低权限，即 只能 接触 基类的公开成员。
        但 类 的 外部虚函数表 是开放的，直到 链接 成功 组装成 可执行文件后，外部虚函数表 才 算是 确定下来。
      外挂接口内联版？至于数据，则相当于 各个并联分支独立成为一个类型
        see:[类型增删变体]
  idea 4 c++?
    protected member: derived_class T can inly access baseclass protected member when baseclass obj is a subobj of T(or derived_class of T)
  idea 4 c++?
    operator new 为何没有 对齐 信息 输入？
    operator delete[] 为何可以有 长度 信息 输入？
      void∗ operator new(siz e_t);
      void operator delete(void∗, siz e_t);
      void∗ operator new[](siz e_t);
      void operator delete[](void∗, siz e_t);
  idea 4 c++?
    def:[覆盖源自数据成员的虚函数]
      private baseclass is just an impl detail, why can override private baseclass virtual function but cannot override data member virtual function? we extend the data member with other siblings and filling pure virtual function to make it concrete class from abstract class.
      better, we can have many non-ambiguous data members with diff override instead of at most one private baseclass.
      override ==>> this.this is the enclosing class to access extended data.
        java inner class???
            c++lambda-expr [this](){}
            引用 分类:
              引用 命名变量（或 整个 调用栈帧（含self））#py
              引用 对象#传引用:[&](){}
              引用 当前值#传值:[=](){}
        diff: the derived_class bing to the only one data member, not used another where, i.e. [exists xxx: this is this.this.xxx][this - this.this === constexpr]
          #当然，也可 模版化，数据成员名 作为 参数，该成员 的 类型 就是 正在 定义的 类。
  idea 4 c++?
    外挂构造函数===外部委托构造函数
      为何？
        type_traits 可以 解决很多 成员函数（包括 析构函数） 包装，唯独 构造函数 例外
        要使用 type_traits 作为需求说明 将受到极大限制
      实现:
        X~f(args...){
          alignas(X) buffer[sizeof(X)]; //uninitialized
          ::new(buffer) X(args...);
          X& x = *static_cast<X*>(buffer)
        }
        其实，使用 继承 也没差
        struct Y:public X{
          Y(...);
        };
        Y y;
        X& x = y;
    分支构造:
      to-def X x where
        if ...:
          X x;
        else:
          X x;
    空枚举类型:
      enum clasa uninitialized{};
      uninitialized* vs void* vs char* vs uint8_t*

  idea 4 c++?
    from others/book/The C++ Programming Language(4ed)(2013).txt
        * 模版的环境敏感型标识绑定，独立开发分离编译的两个库可能不相容，见下面 pg749[764/1366]，既然 依赖环境，那么 instantiation_point(类似goto标签，但 允许 存在于 命名空间 中)也当作为 模版参数
  idea 4 c++?
    外挂接口(重复 空基类带析构函数)+无用参数(参数化标识名)
        see:[参数化标识名]
        see:[[无用参数]]
      ？empty base optimization: 外挂接口+无用参数(参数化标识名)+虚基类？或 重复 空基类(带虚析构函数) 这种情形 究竟如何？
        empty-base optimization
        The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8).
        完全可行！
  idea 4 c++?
      外部注册:traits<category, T>:
        iterator_traits<T> = traits<Iterator, T>;
        allocator_traits<T> = traits<Allocator, T>;
        container_traits<T> = traits<Container, T>
  idea 4 c++?
    c++::std::unordered_map was bad designed!!!
      since Hash must know Pred/Eq, there are need not and should avoid the parameter Pred/Eq
      template<typename Key, 
          typename T, 
          typename Hash = hash<Key>, 
          typename Pred = std::equal_to<Key>, 
          typename Allocator = std::allocator<std::pair<const Key, T>>> 
      class unordered_map;




  my argparser
    see:
      e ../../python3_src/seed/recognize/CmdlinePrefixParser.py
    前缀:
      @选项 #后接一个参数
        @选项前缀-选项负载-选项负载... #复杂选项名 只定义前缀
      { 他命令选项转发 } #选项 需要 复杂的参数，比如 转发给 所依赖的命令
      !子命令
      ?查询
      +打开开关
      -关闭开关
      ？参数？
        =单参数
        ^=转义单参数 # ^{Uxxxx_xxxx}
        ？变量定义与引用？
          ？定义？
            ？let...in？where？
            %{xxx} =单参数
            %{xxx} %=模版单参数
          ？引用？
            %=模版单参数 vs =单参数
            %,模版单参数 vs ,单参数
            %:模版单参数 vs :单参数
          ？模版单参数？
            %% ==>> %
            %{xxx} ==>> 引用
        ？多参数？
          [ ,参数 ,参数 ...]
          [3 ,参数 :参数 :参数  ,参数 :参数 :参数 ... ]



=====
文本编辑器 我常用到的功能:
  #为何使用vim而不用 文本框式的文本编辑器
  #     当然 集成编辑环境 能提供 类/函数 声明/定义 的 列表 与 定位，但这算是 极其特化的功能
  意外崩溃后数据恢复/自动保存
  同时打开多个文件，快速切换
  词组补全，保持缩进，缩进多行#编程 省力
  正则表达式搜索替换（*,#）
  简便的行内定位（0,$,b,e,w,f查找字符,";",","）
  重复操作，设定重复数
  方便快捷的文本操作:复制粘贴删除撤销，行编辑(新建o，合并J，行首插入I行尾附加A...)，可视文本块编辑
  命令行复用，命令行窗口编辑（q:,q/）
  选择字符编码，选择字体优先序列
  语法高亮
  配色方案，字体大小
  查找字符的unicode值，特殊字符输入
  缩进的文本块的自动折叠 #fold

钢琴 邮箱
  from 煎蛋:无聊图 from 网络
  钢琴住了几个妖，邮箱住了几个魔，魑魅魍魉怎么它就这么多


校服-蓝天白云战袍

from 大国重工::第一百五十一章 你去哪我就去哪
  --“这一间，就咱们两个人吗？”--“恐怕没这样的好事吧！”
  调戏-孤男寡女共处一室
  私人空间-人所追求的资源中 独享的时空资源 实是非同一般，大概 比 生存繁衍、交流承传、社会认可（价值/功劳/尊重/地位） 稍差一筹

蟑螂会跳！不能慢慢按，必须拍！

无法压缩的量:
  质能守恒？
  熵
  信息熵
  在 针对给定问题的算法设计 这一领域:
    复杂度
  在 编程语言设计 这一领域:
    源代码长度
    目标代码长度
    运行耗时
    动态内存消耗
    语言支持（编译器/解释器/虚拟机，标准库）
    ---
    更多抽象层 ==>> 目标代码 剧增（模版实例化，内联函数） | 运行耗时 剧增（类型擦除，函数指针/虚函数）|动态内存消耗 剧增（更多动态堆上小对象）
    解决同一问题 ==>> 复杂方案 要么 直接 代码量 大 要么 依赖的库 ...库的实现方案 循环嵌套...，简单方案 要么 耗时间 要么 耗内存

e ../lots/NOTE/novel/史记_note.txt
史记
  ?
    神农氏
    蚩尤
    炎帝
    ...
    帝鸿氏->浑沌
    少皞氏->穷奇
    颛顼(zhuan1xu1)氏->梼杌(tao2wu4)
    缙云氏->饕餮(tao1tie4)
    --
    禹[夏后] 姒氏
    契[商] 子氏
    弃[周] 姬氏
  # [国号]
  少典->1黄帝公孙轩辕[有熊]->
    +玄嚣/青阳->蟜极(蟜jiao3)->3帝喾[高辛](八元)->4帝挚xxx不善->5帝尧放勋[陶唐]->丹朱
    +昌意->2帝颛顼[高阳](八恺)->
      +穷蝉->敬康->句望->桥牛->瞽叟(瞽gu3)->6帝舜重华/虞舜[有虞](十二牧)->商均
      +梼杌
      +鯀(gun)->7帝禹文命[夏后]
        #舜，禹 的 辈分 拉开太快太大！
===============
writing

方人
  攀比，人比人
  人与人之间 为何要对比？
  三人行必有我师焉

巨婴
  计件作坊变托管所
  我就是巨婴
为何禁止？
  恶性传染病（性病、新冠）、毒品、...如果研发出有效药对抗，不再有难以根治不可逆的严重伤害，仅相当于感冒酒精，是否还要忌讳禁止？
口碑:建立 变现 崽卖爷田心不疼(君子之泽五世而斩，二世而亡:秦朝、隋朝、民国) 愚公移山(众志成城，自力更生，团结专一，自强不息（与天斗，与人斗，与己斗，以阶级斗争为纲） vs 造不如买) 猫论（与时俱进，因地制宜，分散多变，厚德载物（厚德即厚人厚欲，满足人民日益增长的欲壑) vs 削足适履/刻舟求剑/古之糟粕/两个凡是）
  中庸:
    《论语：尧曰》：允执其中
  人存政举 人亡政息 只争朝夕
    背叛？革新？
  。
公私
  花费公家的钱引进的技术，当然要共享！
  罚酒三杯
    尸禄害政
    公事私办 变 人情/私怨
    公器私用 假公济私
    营私植党 公报私仇
    蠹民梗政 扛着红旗反革命
  义务权利
    我不是来参与建设的，我是来享受便利的。
  对待潜规则
    消极脱身 以待将来 因人成事
    鲜明抵制 公开斗争
    妥协退让 曲线办事 政以贿成 积极利用以便成为受益者
信息服务/情报服务
  需求发现
    主体 注册
      记录 工作领域，已掌握工艺，急需的工艺，不需要的工艺，可出售工艺
    某方 欠缺的工艺 = 所有他方 已掌握工艺 - 某方 的 工作领域，已掌握工艺
    某方 可能的新需求 = 某方 欠缺的工艺 - 某方 急需的工艺 - 某方 不需要的工艺
      ==>> 推送通知、接洽业务
教育
  +个人获取信息的能力
    阅读、搜索、交流/问答、鉴别真伪
  +信息平台
    遍历、搜索、在线交流/问答记录、权威鉴别真伪
  +个人基本生存技能
    锻炼身体保证健康、工作能力保证获取信息所需资金、保证生存:
      粮食储备、医疗、治安、战备
      工作机会
  +个人综合表达信息的能力
    书写、回答、综述、日志、计划/规划
  +个人志向/价值观(三观)？
信任 平庸 权利
  过于信任，长期不闻不问，放任自流，相信最终不负所望，如同毫无期待好不重视
  过于不信任，频繁检查，吹毛求疵
  一抓就死，一放就乱
  不是蠢就是坏
  是平庸的人太多？抓则能人被庸人压制，放则被淹没？
  是坏人太多？抓则严以待人，打压异己，扛着红旗反革命；放则宽以律己，胡作非为，倒行逆施，以权谋私，假公济私
冒险 与 殉道 的 区别是什么？
名利
  货币，一旦离开认可它的国度，便毫无意义；名声，一旦离开相互吹捧的圈子，便毫无意义。
有的人无视别人的困难，有的人故意凭空制造困难，到底谁负责监督？信息如何无分巨细地披露（来源、渠道、接受（人、时间、反馈），零隐私）？如何确保信息真实性？
回扣
  回扣当然要加在价格上，对方负责人有能力有胆量搅黄并以此索要回扣，理应为抬高的价格开绿灯。
诚信
  --你这人说话遮遮掩掩，我一发现疑点你就换一个说法，我还能不能相信你说的话？
  --见什么人说什么话。交浅则不言深，找个普通人能接受的说法糊弄一下，双方心知肚明即可。非要追问，已然失礼，继续糊弄也只是不想搞得太僵。
傲气
  一个领域里的牛人，有傲气也没啥，总比唯唯诺诺阿谀逢迎来得好，有一技之长却不能扬眉吐气，那样的社会一定压抑绝望的。
  要做就做到最好的傲气！这是交流的基础，是共同语言。
事业
  谁受惠？如何分配利益？允许使用哪些手段获利？谁接班？如何吸引？怎么培养？
离开
  --去那里
  --那里还不是这里？
  --其实只是想离开，离开熟悉的地方，离开认识的人，无人认识便是清净之地。
后悔？
  后悔？不存在的。比如说，现在有个妖怪要杀你报仇，问是什么仇什么怨，原来是粒稻谷得道，临死之前你可有悔意？
龙生九子
  赑屃，螭吻，蒲牢，狴犴，饕餮，趴蝮，睚眦，狻猊，椒图


登泰山而小天下
  饭是一口一口吃的，路是一步一步走的，哪来什么绝招捷径？不过前人的经验有助于少走弯路，开拓视野，从眼前的蝇营狗苟中挣脱而出，观百国春秋而明人世兴衰，岂能安于芸芸众生的平凡命运？
过犹不及
  自力更生？造不如买？任何思路一旦推衍至极端，基本上都会出问题。
该奖则奖，该收则收
  立功、帮忙，事后给好处是合理的，除非穷到给不出，只能口头感激。这两种情况，都合理。但要是说，义当如此，当奖不奖，当收不收，那才是 不宜不义。

知我罪我，患得患失
  出世之人 真的在乎么？言辞何用？荣辱何用？仁义何用？

--终于暴露了你傻逼的本质！--为什么要说『终于』？

结婚还要认证？
  看起来 更像是一场 长期交易，需要外部的强力约束。男方 保证提供充足资源，不得分流给其他女子；女方 保证生育孩童，不得与其他男子有染。
早熟
  农牧林业，早熟 增产？
  人类早熟 是否 与 野生动物 类似 可以 提高生存率？提高 社会生存能力？
  社会发展 是否 可从 早熟 获益？
  社会 是否 歧视/迫害 晚熟/弱智 儿童？
仓储不易
  食物 虫(蟑螂、米虫、蛀虫，保鲜袋 也能咬破)、霉(啥也挡不住)、鼠(什么都能咬破)
努力奋斗
  经过不懈努力艰苦奋斗，终于把自己的身体搞垮了。御使身体不以其道，作为奴隶主是不仁，作为自己又算什么？
小孩子
  --无所不能...毕竟是小孩，在他眼里偶像便是无所不能，但凡有点阅历也不至于如此。
  --小声点，你可把世上的脑残粉跟宗教信徒都骂进去了。

酷刑
  实用的 酷刑 可不是 拍脑袋 就能想出来的。要有视觉效果，要有想象上的冲击性，要能引起本能的恐惧，要有肉体难以承受之苦却又保持清醒不危及性命但又不能使人的耐受性越来越高，要能让人受刑后完全不敢回忆。真要花心思去设计酷刑，有这能耐有这水磨工夫还不如干点别的，毕竟酷刑只是手段，相比要达成的目标，实在不值。
打发时间
  并非兴趣爱好，只是打发时间
生而不同
  有的人需要鞭策才会用功，有的人需被期待才有方向，有的人需经苦难才明事理，有的人需要孤独才能安心。
层层压迫的稳定性
  在层层压迫的社会里，虽然大部分人都是受害者，却难以团结反抗，只因大部分人也是施害者。人们不去痛恨社会结构，而是痛恨自己没能站得更高。不论是追求自己现世更上一层楼、子孙更上一层楼，还是寄希望于来世投个好胎，这份压迫都无疑地在激发人们的积极性，社会整体而言反而是健康的。
法治亦人治
  法律规章，终究是人在执行。
  人们不愿做-大明诰？此一时彼一时，与时俱进。说一套做一套，潜规则黑社会。扔一本法典给猴子，猴群会怎样？
  人们做不到-规定选出一个人来完成所有生产劳动、开疆拓土保证每个人自由活动有无限资源空间，不与他人发生矛盾，其他人负责玩耍。这样一个完美社会如何？
  鸟儿在天上飞，其实不是正常状态，掉到地上才是。努力维护一个不自然的状态，与天斗，乃人道精髓。由弱肉强食的丛林飞往各得其所的大同天空，由人治飞向法治，飞翔只是一个过程，终点永远不会抵达，坠落是理所当然的结局。因为沉浸于想象中，而当看到现实而惊讶不满，只能说是弱智。

私有
  团体私有知识
  法不可轻传
  保障自身安全-防止他人利用这些知识反过来危害自身（了解能力局限、发现漏洞破绽、军备竞赛）
  满足自身发展的需求-每一份付出都期待收获，互惠互利关系才能长久，从这里得到知识，理应为这些知识的增加做出贡献。
  私有 到底 好不好？合不合理？
  大多数情况下，外部环境是弱肉强食，私有合理。
  但少数人为的强力组织显式地屏蔽掉弱肉强食法则，公有 才有其生存空间。

量变到质变
  单纯数量的堆积，加上漫长岁月的演化，甚至能够自成天地，诞生生灵，乃至仙神
  何必为了炼制法宝而穷搜天地？天地这个无尽藏就在眼前。
  要是能掌控天地似操控法宝般如臂使指，也算得道。这是神道。
育种
  灵根可遗传，高阶修士生育率低
  大量圈养有灵根的凡人
青出于蓝
  这份传承十分凶险，原主极其骄傲，既然留下传承，必然要求传人青出于蓝，功法修炼过程绝不会四平八稳，因为初创他自己肯定没练过。
既受其利则受其弊
  既然依靠家族得了好处，自然也要牺牲自己去维护家族利益。不遵守规矩的人，便要受到所有家族的讨伐，因为这些家族正是靠着这规矩才能长存。
  --凭什么要帮理不帮亲？真到了生死存亡的时候，会与家族共存的人是谁？是这些讲道理的人吗？错！只有我们！不计利益不计生死。--你说得对。那我们是否要自绝于正道，合家举族充作杀人越货的强盗？我们是否已做好举世皆敌的准备？
  压力平衡
    扩张-稳定时边界必定压力平衡
      1. 外对内压力-外部环境险恶
      2. 内对外压力-兵力物资密度
      3. 向心力-个人发展资源的政策倾斜造成的梯度

市恩
  物资充裕时怎么搞都无所谓，但却需顾及大灾大难。在灾难面前，是携手共抗，还是互相鱼肉？互助者人，相煎者亦人。囤积有形易腐之物，使人生不均之愤，不值。

凭什么让我独自承受灾难？
  雪灾，南侵/内战/剥夺老弱病残的口粮，死够人抢够粮
  人道法则 公平 患不均
  一方有难八方支援
    同一件事，可以有不同说法做法，不管好听难听，本质不改

开宗明义
  --（野路子蛊师）突破炼蛊瓶颈:不能繁殖只能靠斗蛊来产生强蛊？效率太低！寿命短？在正常的外部环境中存活时间短？太折腾！改！
  --伤人伤己，作为威慑性的战略武器和大量低成本制造的临时性战术武器，最重要的禁忌是:避免反噬。事实是这些所谓的缺点一点都不自然，明显是人为的。你一生的成就其实只是在突破前人布下的禁制。聪明却未及根本。

奢侈品
  --闪闪发光的珠宝？艳丽多彩的皮毛？哼，女人！
  --削铁如泥的宝刀？耐用顺手的工具？哼，男人！

保护 攻陷
  能挡住外部的风雨，难道还能插手内部的管理（内政外交:人事安排、管理制度、人际交往）？难道还能干预上下层的志向情感？

答谢
  虽然 没有成事的功劳，说不定还试图扒拉到自己碗里，但毕竟没有下死力气败事，这会儿来邀功请赏，当然得承这人情。
离
  混在一起没效率。要么 将混日子吃闲饭的赶走，要么 将有能力有志气的调走，要么 将大伙拉低到同一水准，要么 将大伙拉高到同一水准。
诈
  --（听着众人视死如归大义凛然的壮语，十分感动）好！接下来就是考核环节，本来应该暗中进行，但现在危机四伏...--等等、刚才是什么情况？！前几日暗地里的关于暗中考察的流言 其实是 骗我们去送死，对吧？！
考核
  择偶、选择官员...
  喜欢高颜值，便会整容；喜欢大胸细腰大屁股，便会垫垫束腰；喜欢长腿，便会穿短裙高跟鞋拉伸照片；喜欢蠢萌，便会伪装成傻白甜；喜欢感性，便会伪装成有爱心小动保；喜欢女人，便会伪装成女人；喜欢才学，便会伪装成高知；喜欢钱财，便会有名牌或冒牌货包装自己；喜欢成功，便会伪装成成功人士。
    外交无小事，就会有人 借皮搞优惠搞特权享受超国民待遇狐假虎威挟洋自重，出口转内销，曲线行使正当权利
    强调集体高于个人，多得是 假公济私
    喜欢讲套话讲原则，多得是 扛着红旗反革命
    不讲人情，鸟尽弓藏过河拆桥，，多得是 养寇自重
    劣币驱逐良币，道高一尺魔高一丈，谁能留存一目了然
    良币联盟抵制劣币？联盟最终也可能成为作恶的权威。顺昌逆亡，捆绑垄断策略作为加盟条件（产品价格设置下限乃至哄抬，电器寿命设定上限，旧版手机变慢，强迫用户更新换代）
  不论如何考核，终究只是形式套路，当不得真。漏洞、伪装、敲门砖、人脉、特权...，考核的意义很快会被无关紧要的东西替代，就如同前人珍而重之的礼仪会逐步失去含义剩下形式化为桎梏乃至凶刃。最终仍要看实际工作中的表现，不只眼前，更要放眼未来，当下与未来统一。可惜，一则职位有限，责任重大，政策久远，任职机会难得。二则对后世的影响当下是很难真切体会，想要盖棺论定都难。问题回到原点，如何开始？选谁上位？如何结束？孰优孰劣？从基层干起，任期足长。但 基层 同样是 竞争，考核期再长 也不见得 足够。
剑
  棍-兵器之祖
  刀-应用最广泛
  矛-低成本战阵用兵器
  弓-远程
    石
  剑-人文底蕴深厚-正直，忠诚，复仇

辩利 辩智
  智力 有其局限 见下面『天魂』/『终极目标』
  利 我 小大 近远 贱贵
    有利 必先 有我
      大我 小我
      激情之我 众念之我 当下之我、未来之我 子孙之我 亲族之我 国族之我 人类之我 信仰之我
    轻急缓重
    利益 有 远近
      短期利益 长期利益
    利益 有 贵贱
      正常的交易 之所以 能进行，是因为 对于买卖双方 需求不同，对 交易物 的 价值判断不同
      所谓 贵贱，因人而异
天
  这天乃是人道这片天！
    天听自我民听，天视自我民视 vs 天地不仁，以万物为刍狗
      天外有天，有好多重天，说的不是同一重天
      官府/朝廷/政府 - 这是一重天
      人道 - 一重天
      天道 - 一重天
      声张正义，当然只能靠人。天理昭昭，终究是要我们自己维护。
          从来就没有什么救世主也不靠神仙皇帝
          人道 不需要 来世
            恩怨-现世报
          人道 不需要 神
            替天行道
          人道 不需要 原罪
            --天下谁是无辜之人？--人道 才定罪，天道 无不可
          人道 不需要 前世
            天道酬勤
            我命由我不由天
            王侯将相宁有种乎！
    出世-脱离人道
      说得轻巧，其实哪有那么简单！传承 即是 人道 的 一大特征。记忆-交流-语言文字-记录-命名-定义-自己与自己交流-听听过去自己怎么说跟将来的自己说说当下的想法-当下不同念头之间的交流-众念国-可以将整个族群当作一个生物也可反过来将一个人看作一个生物聚落
      人道 以人命名，但 与人并无什么特别关系。只是因为是人在命名，并且认为人乃万物灵长，故有此称。
      人类远未将人道推衍至极，而众生也皆在人道上蹒跚前行。
      将所有生命视为一个整体也无不可。旨在不断磨砺壮大自己。
    逆天改命
    人道。 要你按时老死，你偏要长生久视？
    人道圣人，将道果融入人道之中？这也是外道法门，与 器修/剑修/符修/乐修/阵修/御兽驱虫/傀儡/驭鬼炼尸/化身惑众/神打召唤/香火神道/功德神道/山水神道/借势夺运/诅咒/体修/寿修/吉修/法修/空修/梦修/遁修/禁修/洞修/真修/劫修 差别不大。丹修用药，由外而内，打了个擦边球，亦算不得正统（内道法门）。
      别家传法，我宗传道，传的便是行侠仗义的道！--剑宗
      如果认为个人并非独立的存在，只是人道者大江大河的一个小小浪头，那修人道也不能算是外道法门。--逝者如斯夫，不舍昼夜
    神通不及天数-以人为本-道不远人
      科技发达若不关注民生
        医疗系统天下第一，但穷人病死用不起
        物资丰沛，狗豕食人食不知俭，路有饿殍不知发
        武器流通，民众生命却得不到保障
        律法繁浩，贼盗多起
    雷霆雨露俱是天恩
      龙生九子，子子不同。因为 龙不是生出来的，是磨砺中造就的。信仰认知 难以承传，父子乖离，愚公移山 的 想法太简单。子孙不会理所当然地接受祖先的控制，这既是灾难也是生机。--山与海之间
      天行健君子以自强不息。消灭了敌人还有远方更强的敌人，消灭了外部的敌人自己内部将来也会分裂，度过天灾还有未来更大的天灾，度过外加的灾劫自己的体量膨胀对资源不竭的索取将成为内生性的灾劫。
          人的最大敌人是自己，是自己无穷无尽的欲求，这是进步的动力，这是自毁的根源。理智告诉你，以阶级斗争为纲；感性告诉你，『人民日益增长的物质文化需求』是主要矛盾。理性 理所当然地 败退，因为 一切智慧 围绕 终极目标 运动。

    三魂:爽灵、胎光、幽精
      天魂-不灭真灵，终极目标，真，命。
        命者名也，所谓 真名，即是人生的终极目标，但大部分人主观上并不能觉悟自己的真名。人一生一世的活动、思考 就如同滚落的石子，『轨迹虽然复杂，但大势是趋向更低处』一般，是围绕着 自身的终极目标 的。
        为什么会有这种东西？比如说，故事里的角色，他们有自己的天魂，一切的思索行为会依此自行的发生，即使 故事 可有诸多版本，作者、读者、同文作者 必须 在某种程度上 体验到这一点共识，否则就不是故事 只是 文字白噪声，或者说 只两个偶然同名同姓的角色，他们的真名并不相同。只要真名相同，角色不论叫什么，是男是女，是人是仙是妖是鬼，是器灵是机器人是人工智能，读者都应该能认出来。
        天真--《庄子:渔父》『礼者，世俗之所为也；真者，所以受于天也，自然不可易也。故圣人法天贵真，不拘于俗。』。
        天魂不灭不易，是恒在的，并不是人出生时才产生的。具体类比，可比 数字、公设（前提假设，非真非假）、人设（人设为何不是作者创造的？简单地说，人作为一个信息处理器，并不能产生新信息，一切思维产物有其源自，质量能量信息守恒，有的只是表面形态上的流变）、某一句话某一句诗（诗句并不是诗人创作时才出现的，作为文字的某一排列组合，自然而然地存在着）
        真名 并无 时空属性，无 时间属性 即 恒在，无 空间属性 即 可重叠 多处出现（比如：3这个数，一堆沙子，随便3粒 可表达3，3堆沙子也是3）
      人魂-记忆，人生历程，社会关系，国功民劳，恩怨情仇，缘。用小说来打比方，则是 同一个角色 在 不同版本中的 经历。《三国演义》、《西游记》、《水浒传》都是同人小说。
      地魂-人之德（不是 个人的遗传信息，是 族类的遗传信息）。联系 三魂七魄，人之所以有人样的模版--人之德，人样子。
        德者，得也，子肖父，人肖德。用强类型编程语言来打比方，就是 地魂之于人 等如 类型之于对象。
        德 虽然 不仅仅只是 形体，但形体之德 肉眼可见 最好 理解。如果世上只有九个人，或缺左手，或缺右手，或缺左腿，或缺右腿，或盲，或聋，或哑，或六指，或两性人，试想 人之德 在形体上的表现 为何？
        肉眼不可见的：昆虫会变态，人类幼儿智力水平会随着年龄快速提升（修仙小说里灵兽成长自然进阶），人是群居动物...
    人道惑人: 寿，智，志
      寿:活物求生
      智:灵物因智
      志:志为智纲
        老:僵化，不接受新事物，不学习新知识，只因志向（人生终极目标/欲求）早定。
  面相-嫌丑爱美
    脸上长瘤/恶眼之相 面相不好命格不好 妨害至亲？
    这贼老天也忒嫌丑爱美
  树叶-寿命限制的根源
    人的生死如同树叶的茂凋，乃是人道意志的体现，什么文治武功都是臆想，该死的时候就会死，与奴隶贼寇无异。
    天地不仁，圣人不仁
  取长补短，分工合作，德配其位，人处其份，各展所长
    贵精？贵多？
      对集体而言，究竟是一个样样精通的人才更有利还是多个专业人才更有利？样样精通固然更容易打穿壁垒推陈出新，但毕竟生命有限，探索试验、交流教导、制造改进……诸般事务耗时永无止境，一个人终究是不如多个人对集体更有利。
      中底层贵多，顶层贵精
      一个师傅只收三两个徒弟，长年累月在实战中教导，这种模式的问题在于即使最理想的情况弟子个个成才，对于技艺的推广而言也极其缓慢。若是弟子不成气候、不收徒弟、不善教导，只怕传承断绝都有很大可能。
      普及初等教育，事实上是集体自身发展的需要，为顶级传承筛选接班人，并不是为了个人的发展。所以有人觉得九年义务教育很多内容用不上，学了浪费时间，只能说没看明白为何免学费还有奖学金，并不为你。
      待遇
        养猪场对猪可好了，分配对象，养育猪崽，包吃包住，免费医疗，打针吃药，补钙清洁...
        不允许自杀#百草枯、毒品、安眠药

青
  徒有人形罪
巨蚌
  这边界防御实是多余，浪费人力物力，最好磨灭。边界自在人心，并不因为我说磨灭便磨灭，也不因你说永存便永存。只能说同心同德是个长期目标，慢慢来不急。
功劳体系-缺陷
  战争 应该摆在哪里？
  要么不得一统，战乱不断，要么和平之后用进废退，纷乱再起，治乱循环
    巨兽启蒙，记史不宣，传承不灭，补足战乱缺陷
  为什么要接受挑战？他有什么资格挑战？凭啥要按战力评高低定权位？为什么不同要求偏要捆绑在一起？过去的传统就让它过去，我们现在分工看专长。
    你不正是靠战争胜利才地位巩固？勇武、智慧、名声、权势、财富，本来就是高度统一的，你这么强行拆分，全靠政策律法维护，毫无稳定性可言，混乱自此始。
  排资论辈
    德不配位，众议其非
    年少位高，究竟有何功劳？地位高更容易斩获大功，地位低只能小打小闹，还得分润些功劳给上级。资历深厚，功勋积累也多。排资论辈，难以避免。到底是死循环，还是正反馈，还得看看。
      人脉。慧眼识才，提拔后辈，水涨船高。功劳哪有可能一人包揽，但门生故旧满天下，也是一样的。
  功成何必在我？
  人的任何一个缺点都足以将其击倒。让人各得其所各展所长，谈何容易？
  你以为 功劳体系 是手段，但它其实是 目标。
世间无尽藏就在眼前，却还需去哪里争夺天材地宝？
玩游戏，玩数学，玩艺术，玩技术，埋头苦干，为民请命，舍身成仁，不为名利，有何稀奇？喜欢搂钱，说不定也只是喜欢存款额上涨，跟贴吧水经验一样。逍遥自在，不在别人口中。乐在其中，不足为外人道。
  --你竟然 将 游戏搂钱 与 殉道成仁 相提并论？
  --何止！赌博，嫉妒，旅游探险，争辩，极限运动跑步，仪式拜神，阅读八卦...
天部主杀务虚，地部主生务实，人部主导统御。
  天部:开疆，征伐，审判，法律，理论，实验，游戏，享乐，艺术，文化，历史，新闻
    不变:不跟风不从众不同流合污（比如：错别字、多音字发音不准）
    变易:智者乐水，天地不仁，优胜劣汰，文化-避免 削足适履/刻舟求剑，人体改造
  地部:生产，工艺，运输，教育，医疗，人事，销售
    不变:仁者乐山
    变易:和光同尘，与世浮沉，众乐乐不独乐乐
  人部:信仰，统筹，路线
剑修像邪修
  不贪生，夭折死于非命，无法想象躺在床上寿终正寝的样子:生死本是寻常事-邪教口号
  重杀不重养生，不畏因果业力:一剑斩之-天劫加重？那就炼更强的邪器
所有老师都希望学生聪明有天赋，面对愚顽没有进步的学生会暴躁崩溃。但是假如能自学成才无师自通，还要老师干嘛？
既然连遍知遍识都做不到，人自然便有亲疏远近，对不认识乃至于不知道存在与否的人，其死活又有何影响？自有亲近的人在乎。
合理
  合不合理，是人道范畴的概念，是人们对于耳闻目睹的事件与过往的经验心中确认的理论进行比较嵌入得出的结论。道就是道，无所谓合不合理。
  如果某理论与事实不符，该理论便不合理。哪个理？即是不合『实践是检验真理的唯一标准』这个理。但这个理本身合不合理呢？又该合什么理？人类目前恐怕还未探索到这一层次，或者说无此需求。
怎么高个子都躺下了？哦，原来现在我才是
五毒
  与其说火毒有生命，不如说一切生命尽属火毒
多少
  作一选择，自己得利一，众人各得利万。众人虽心知肚明，却不仅不分利，还要笑你蠢笑你穷，欺你辱你，如此抉择你作是不作？
  用进废退，和平时期，军备废弛，人才流失，军人地位卑下。
弱小
  被压迫剥削，仍不肯脱离，因为无法独自生存，只能抱团取暖，被迫害也只能忍受。

若不辜负你的信任，却是要辜负属下高升一步的期冀。信任？一文不值。帝王术又如何？凡事还是要讲规矩。
绝地？难道不是这些孑遗的最后家园吗？
祭祀
  香火成神？不，人人可为尧舜，祭祀有功之人其实祭祀的是心中愿为之洒血的正道，是表达效仿先贤自力更生的呼喊，是团结同志的宣传。若是变成祈求施舍的磕头虫，这祭祀不要也罢。
  人助，助人。又何必认脸？
重因不重果
  有罪无罪当依源头看

功德无量
  彩票主任 领奖，教 希冀不劳而获的穷鬼 做人，肃清歪风邪气，功德无量
  不怨天不尤人，只做该做的事，不计成败。
开挂反杀
  我看出来了，这故事是说，如果没金手指还不了刮没有贵人抬举不是大能转世背景深厚，就只能认命当咸鱼。
  青帝不是某个人，不是成功登顶的某些人，而是不因失败而退却、前赴后继的所有反抗者
  功成何必在我？
  为什么要按别人制订的规矩玩？不爽就直接掀桌子
  什么公子大少，什么宝物权柄，想不到你竟然还痴迷敌方的名利圈。人所定义，我若不认，屁都不是。什么你的我的，我若不认，连你的命都不属于你自己。
  小人-法天相地#idea from 蛊真人-幽魂分身小人族紫-仙蛊『大』
    --你为何不用法天相地？--为何用不了？[......我怎么变小了？...原来已经用了]
  公道自在人心，就算你能所有人闭嘴，难道众人心中就不鄙视你了？
  钱是我的钱，天灾是别人的天灾，别人才该出钱出力，我有众人无数年血汗铸就的堡垒，要死肯定是最后一个死。
  人口数量+人群密度==智慧基石
  和谈？是要把我的血肉论斤卖么？我不需要赔礼道歉。你砍我一刀，我还上十刀就行。
  抹杀人道功德-抛弃点歪的科技树，断绝传承，摧毁一切成果/造物/传奇/经典/技术/艺术-人贱物鄙，恨屋及乌-再造人间
      --何至于此！何至于此啊？！--一而再再而三，卑鄙无耻偏偏还得意洋洋，留下的也只是恶名污名，与其污染世间，不如断绝你们的一切
      另起炉灶才能正真超越。毕竟别人的技艺流传在外的只是皮毛，甚至有缺陷。
  青帝赐劫
    隳名屠圣
      抹杀 过去种种 及 未来无数可能
      唯有 超脱时间海 的 圣人 才有资格参战，为自己的生存甚至是诞生的可能性而战
        过去明王拳/未来明王拳
小惩大诫
  你以为别人会在乎，其实没人在乎，你以为后人会记得，但后人根本不了解。被害人，凶徒，皆无足轻重，所有人皆无足轻重。不过小小惩罚以示警告，严厉的惩罚对维护稳定的社会关系有害。奴隶、贱民，你所压迫的人，无论正义与否，不论是否弱小愚顽，终至暴动反抗。
私了
  民不举官不告？
  私了？
  若禁止私了，可具有可操作性？
  私了，无非威逼利诱。利诱，则钓鱼，虚假的受害者。威逼，则被自愿私了，不了了之，罪犯逍遥法外。无论何种情况，罪行得不到惩戒，依旧在继续，至于更甚。
  解决方案:消除过大的物质精神双重差距
痕印宗
  痕迹-不可能完全消除，不可能得不出有效信息，但，轻易的破坏可极大的提高得到特定有效信息的难度
  印象-由外而内制造赝品，以假乱真；窜改消息渠道，幻境迷人，乱人耳目；直接窜改性格/情绪/记忆/历史/推演结果
逼迫
  约定轮值戍守，拒绝加盟的人会被视为占别人便宜，会遭到围攻。这就是人道压迫。现在别人就在逼迫我。
    关我屁事？当然有关。恩将仇报，有违人道，惩奸除恶，路人有责
  行政上的欺骗是怎么产生的？
    明明我们抱团取暖，理应以诚相待
    指标层层加码，截止日期/产量/
    伤亡人数/损失财货...
    回扣/层层外包/...
    职位只升不降
投降
  不接受投降。你的加盟可以增加我们的实力？别开玩笑了。我们的力量才不是靠投机分子支撑。
修道非修心
  念头通达，意志坚定，修的是己道
    己道、神道 隶属 人道
    证据
      一服己，二服众
      由于技术手段不同、层次有高低，证据并不通用，过于简单容易伪造，过于高级无法理解

  了悟天道，天人合一
教你说人话
  --孽障（坐骑），会不会说人话？明明是除魔卫道，怎么说得我倒像是逐利蝇营之人？（鞭！）组织言辞再给我说一遍！--...--教你说人话真不容易。
压力-内卷
  孤儿寡母 被同族迫害？不是应该帮衬么？
  人口众多，社会生存压力大，弱小无力者自然是先崩塌。
  可早些动乱年代众志成城难道压力小了？
  那是压力太大不得不抱团取暖，现在压力不大不小...好吧，生存压力大但惩罚力度小...
  行了，别压力大压力小，
商
  垄断 生产
  垄断 渠道 # 武装二道贩子
  攫取利益 甩锅灾责
    通货膨胀
    污染转移+剪刀差

以战养战
  法宝炮弹
邪不胜正？不过是主流定义了『正』，是以左道旁门『邪』成了小众非主流的大口袋。而人数加长期稳定意味着力量。至于主流是啥，这可没有一定之规。
有用无用
  在有用无用之间...概率分布，个人随机应变？群体各异自由选择？
    分而治之，拉一批打一批
  人只有作为整体才有意义，个人只是树叶。
竞争-弱肉强食
  团体里面又有小团体抱团取暖，内部竞争烈度更弱，形成凝聚力。
  推恩令
    赢者通吃，富有是真，但只是个别人，因为担心均分后力量分散被淹没
    这又形成离心力
  小团体『对外一致』原则+『少数服从多数』原则+优势民主小团体序列==实现少数人控制多数人的民主反向控制
    2人小团体 决定 3人团体的对外策略
    2 -> 3 -> 5 -> 8 ....
    实现2人在民主制度下对8人的奴役
  补有余
    世家，窃据高位，票多资源倾斜，强推更多庸才，打压异己，窃据高位，死循环。

众念国
  幽冥界-众念国 外显
  神器 有灵无性 - 地域博大，难以一统
  小物件 反而容易诞生器灵，但提升质材，器灵有泯灭之危 - 扩张加速崩溃
外力
  我要的不是胜利，而是靠自己赢得的胜利。战争及其他一切形式的争斗，不过是仪式，判断德行的人道仪式。

斩红尘
  党争，站队，纠葛已深，如何断？与其让我对得起你，不如让你对不起我。得罪本派系太子党...，不容于各派系，自此脱身。

第一机缘体质-拉仇恨体质
  随便喜欢上一头母猪，该母猪也会立即成为炙手可热的大众情人。
  出门在外，必有肥羊打劫送人头


杠杆原理
  越长越软越容易弯曲，因为杠杆原理
官僚系统 设计
  各级部门/整个官僚系统 分成两部:
    世间部
      来源:任何人
      来源广，思路广，避免本本主义，接地气实践性高，满足大众权欲
    世外部
      来源:从婴儿选取，公开培养，无隐私无私财，没有移民外国的权利。
      执政知识更系统规范，避免世俗人情权财纠葛，有利于矫正歪风邪气
  共同:
    执政起，人生再无隐私
    从底层历练晋升
    #禁止按比例分配

明日黄花
  什么九纹金丹，不过渡河的舟筏，巨舰也罢牛皮也罢，纵使徒手凭河，只要过得河去皆是一样。既过河便是垃圾。

裹尸布
  炼尸的裹尸布 秒变 母猪赛貂蝉-香喷喷的 绫带类法宝

生死本是寻常事
  --这一路千里追杀，无数百姓皆因你而死！你算什么正道人士！
  --生死本是寻常事，看破自己的生死，更看破他人的生死。竟然企图用无辜路人的生死来拖延我的步伐？我只为除恶而来，岂能由你摆布！


因为太子需要对手，新皇帝上位需要自己的战功，改朝换代需要砍掉一半树林腾出空间，新班子需要血淋淋的投名状。
说聪明也未必，只是尽心尽力考虑众人的难处缓和矛盾罢了。

正道嘛，肯定占道理，就是没理也得掰成有理；邪道占便宜就是道理。

追名逐利没问题，只不过名利只是工具，关键是用来干嘛，要是将之当作人生目标，或用来享乐，向人炫耀，那就有点可笑。

你吃我，我吃你，自己吃自己

为难
  端午节前，同事派粽子，也不问我要不要，直接放下。
  若是问了，我便顺势拒绝。
  退回去？会得罪人
  吃下去？会被毒死
  悄悄扔？老来饿死-还是做个人渣，浪费粮食算了



档口
  晚上出门，无人留守，关风扇？要不要关灯？若关灯，必须要关门。不如假装有人在里面或附近或很快回来。
歌
  情歌，只有孤男寡女时，还功放情歌，听的人不尴尬，尴尬的是放的人。
二维码 打印 截屏放大移动 避开屏幕缺陷点防止屏幕太小 结果:只有打印的才行，放大移动无效

恭维
  --老板（没看我就一计件兼职打工仔吗），你做得好快（就我最慢房租都够呛）...
  --（同样的事发生了这么多次，我竟每次都无言以对，想来到底是自己情商低）


资格性测试，选拔性测试，自检性测试
  面向自己:
    自检性测试
  面向公众:
    证明能力达标，不限出线人数:
      资格性测试
    证明比别人强，限制出线人数:
      选拔性测试

===
存储文件分类
  书/标准=稳定+找回
  软件=稳定+更新+找回
  他人代码/网页=变动+找回
  我的代码/文档=变动+不可找回
  配置=稳定+更新+不可找回


核酸检测
  必须微信？
  没微信不是人？没手机不是人？


酵母的保存


面粉
  1.734 kg * 4.76 元/kg = 8.3 元
  20210523 蒸作 20 个馒头（1个留作酵头）
    ==>> 馒头 1.7两面粉/4毛/个


嘉5月
  擀面杖 4.5元
  红辣椒粉 4.5元/罐
  玉米粉 3元/斤
  豆皮 6.8元/斤
  面粉 2.8元/斤


安康多功能骨碟 1.2元/个 圆、圆角矩形
正宝简约牙签筒 1.5元/个 翻盖式，推拉门式
