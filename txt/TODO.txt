TODO:goto
writings:goto
explain:goto
当前桌面:goto
ideas:goto

view TODO3\[20220407].txt
view TODO3[20220407].txt
  search:
    #def__backup_cmds:goto
    #文本质量评估
    #TODO
    #DOING
    #writing
    #explain
    #？下载
    #待查
    #design
    #lang
    #意必固我

e ../../python3_src/自己的相关数据/on_working.txt
e ../../python3_src/自己的相关数据/on_working4grep.txt
e others/book/read.txt
  各书 的 阅读进度
e others/book/已读小说.txt
  读完 的 小说

download:
  https://librarygenesis.pro/#!
    入口
    libgen 镜像网址收集
    https://libgen.lc

  https://sci-hub.ru/
    只有 摘要？
https://www.computerhope.com/
  https://www.computerhope.com/jargon/u/uuid.htm
https://translate.google.cn/?sl=auto&tl=zh-CN&text=multiset&op=translate
https://cn.bing.com/search?q=define+mapping
  或 搜索『define mapping』
    再 点击 底部 『More definitions』展开所有隐藏解释

[
libgen 搜索模版
  #不用再每次搜索之后还要点击两次year以时间倒序排列
替换XXX:
https://libgen.lc/index.php?req=XXX&columns%5B%5D=t&columns%5B%5D=s&objects%5B%5D=f&objects%5B%5D=e&objects%5B%5D=s&objects%5B%5D=a&objects%5B%5D=p&objects%5B%5D=w&topics%5B%5D=l&topics%5B%5D=c&topics%5B%5D=f&topics%5B%5D=a&topics%5B%5D=m&topics%5B%5D=r&topics%5B%5D=s&res=25&filesuns=all&filesuns=all&curtab=f&order=year&ordermode=desc&filesuns=all&page=1
原网址:
https://libgen.lc/index.php?req=lua&columns%5B%5D=t&columns%5B%5D=s&objects%5B%5D=f&objects%5B%5D=e&objects%5B%5D=s&objects%5B%5D=a&objects%5B%5D=p&objects%5B%5D=w&topics%5B%5D=l&topics%5B%5D=c&topics%5B%5D=f&topics%5B%5D=a&topics%5B%5D=m&topics%5B%5D=r&topics%5B%5D=s&res=25&filesuns=all&filesuns=all&curtab=f&order=year&ordermode=desc&filesuns=all&page=3
https://libgen.lc/index.php?req=IRREDUCIBLE+POLYNOMIAL&columns%5B%5D=t&columns%5B%5D=s&objects%5B%5D=f&objects%5B%5D=e&objects%5B%5D=s&objects%5B%5D=a&objects%5B%5D=p&objects%5B%5D=w&topics%5B%5D=l&topics%5B%5D=c&topics%5B%5D=f&topics%5B%5D=a&topics%5B%5D=m&topics%5B%5D=r&topics%5B%5D=s&res=25&filesuns=all&order=year&ordermode=desc
?req=lua
?req=IRREDUCIBLE+POLYNOMIAL
&order=year&ordermode=desc
&page=3
]


view others/app/手机卡顿.txt
view others/app/手机自动关机重启掉电卡顿.txt
  [20220408] 占用空间大的APP的列表 以及 挑选出来的被删APP
  [[
[20220408]
  内部存储: 26.3 GB / 32.0 GB
  /sdcard/ 才 8.9G
  看来得删APP 共 15G
6.4G	/sdcard/0my_files
1.1G	/sdcard/autonavi 地图
353M	/sdcard/Android
186M	/sdcard/Download
156M	/sdcard/DraSticCN 模拟器
]]

133
0230
9373

[[[[[[[explain
e ./0explain.txt
nickname vs fullname
  #from https://docs.swift.org/swift-book/TheSwiftProgrammingLanguageSwift57.epub
[[
]]
[[
]]
[[
]]
[[
certificated adj. 合格的，取得执照的，有资格的，检验合格的
certificate n. 证明书，资格证书/执照，许可证 vt. 证明，给予 证明书/执照 (从而许可)

witness n. 目击者(eyewitness)，证人，证据，证物，证明，证言，见证人/连署人 vt/vi. ...
]]
[[
掉电 power down

"掉电,供电中断"英文翻译 fail power
"掉电中断"英文翻译 power failure interrupt
"关掉电机"英文翻译 turn off the power
"关掉电视"英文翻译 turn down the tv
"掉电恢复系统"英文翻译 power-fail recovery system

]]
[[
depicted
wlog = without loss of generality
CRT = Chinese remainder theorem

monic #多项式首项系数为一
[ˈmänik]
ADJECTIVE
mathematics
monic (adjective)
(of a polynomial) having the coefficient of the term of highest degree equal to one

https://cdict.net/q/monic
  monic:首一
首项系数为一
首一本原不可约多项式=monic primitive irreducible polynomial
]]
[[
解封
lift lockdown ，中文意思是“解除封锁”。 lift这个单词有“抬起，解除”的意思，而lockdown则有“防范禁闭”的意思，所以合起来可不就是“解封”的意思了。
]]

讫情尽意:『帝王之怒，不宜讫情尽意』

]]]]]]]explain


命令行cmd:
wget:
  cd /sdcard/0my_files/tmp/wget_/
  !mkdir /sdcard/0my_files/tmp/wget_/zxcs.me/
  cd /sdcard/0my_files/tmp/wget_/zxcs.me/

curl -L -C - -O https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.0/clang-14.0.0.src.tar.xz

view others/app/termux/apt_update__fail/\[details]\[20220430]20220427_fix_termux.py
    xargs -n 1 curl -O < /sdcard/Download/downs4termux/binary-all-index.html.urls.txt
    wget -r -l inf --no-remove-listing --no-parent -p -k -nc -N --no-use-server-timestamps -c --random-wait --wait=8 --tries=30 --limit-rate=200K --compression=auto -U "Mozilla/5.0 (iPhone; CPU iPhone OS 12_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.1.1 Mobile/15E148 Safari/604.1"    https://free.nchc.org.tw/osdn//storage/g/t/te/termux-old/zzzzzzzzzzzz-packages-21/ --reject-regex='[^?]*[?].*|(https://free.nchc.org.tw/osdn//storage/g/t/te/termux-old/zzzzzzzzzzzz-packages-21/|)(aarch64|i686|x86_64)(/.*)?' --accept-regex='(https://free.nchc.org.tw/osdn//storage/g/t/te/termux-old/zzzzzzzzzzzz-packages-21/|)(all|arm|dists)(/.*)?'



本地备份:
  见:
  view TODO3[20220407].txt
    search:
      #def__backup_cmds:goto
      view ../../python3_src/my_convention/backup_cmds.txt
上传github:
  g0,g1,g2,g3,g5,g6_,g7
    口令 改为 密钥: ghp_...
      g-h-p ??? git-hub-PAT(personal-access-token)
    edt-yxz-zzd

7z打包:
  view others/app/termux/tar_7zip.txt
  !mkdir  /sdcard/0my_files/tmp/out4zip/
  7z a  /sdcard/0my_files/tmp/out4zip/20220415敏感词.7z    /storage/emulated/0/Download/20220415敏感词/
  view ../../python3_src/raw_data/20220415敏感词.7z
    288K
tar
  man tar >> others/app/termux/tar_7zip.txt
  tar -x -f clang-14.0.0.src.tar.xz
   Overwrite control
       --skip-old-files
              Don't replace existing files when extracting, silently skip over
       -k, --keep-old-files
              Don't replace existing files when extracting.

       --keep-newer-files
              Don't replace existing files that are newer than their archive
              copies.


git 下载命令
[[
cd /sdcard/0my_files/tmp/git_/
https://github.com/zhansliu/writemdict/
git clone https://github.com/zhansliu/writemdict.git

https://gitee.com/xstudio/badwords
git clone https://gitee.com/xstudio/badwords.git
]]

def sketchy_check_stack(ops, stack, /):

[[[[[
writing
已还:20220318 欠房东1元1毛
20220408周五测核酸，电信卡29元月租
20220526周四晚 电信卡 坏掉，前几天也有一次出问题
20220527周五 到电信营业厅换卡:(广州电信卡+身份证)，+20元工本费，只能办理90元以上套餐，还是买新卡算了。
20220528周六 早 电饭煲 煮水坏了(前几天 烧水壶 坏了)；晚，于 宜万家li左 2元店 买 60元 带 蒸笼 电饭煲
20220530周一晚 于嘉乐源买烧水壶33元
20220601买50元电信手机卡29元/月租
20220605买1500元手机 『真我V11s 5G』
[[
oppo手机
设置->关于手机:
  手机名称:真我V11s 5G
  realme UI版本:V2.0
  处理器:天玑810 八核
  机身存储:128G
  认证信息:CMIT ID:2021CP10447
    RealMe重庆移动通信有限公司
    型号RMX3125
  版本信息:
    版本号:RMX3125_11_A.14
    基带版本:M_V3_P10,M_V3_P10
    内核版本:4.14.186+
    ColorOS版本:V11
  Android版本:11
    Android安全更新:20220405
  运行内存:4G+?1-3G#怎么感觉像是加了1G才4G
  型号RMX3125
  序列号:QO49S4OB5PW8OAZI
  开机累计时长:656:00:00#开机40天？？
]]
20220831黄码，到医院正门右侧免费检测，捅鼻孔
20220901:10:50已是 绿码


writings


[[来自 临时文件:长虹:txt/02_.py:终止日期20221103:复制过来后，小说摘记+TODO 移出，新增部分内容
理想？不，重点是群众路线。
    活人私人区别未必大，前一刻活着下一瞬死去，躯体还是那副躯体，可见就算依样画葫芦，把所有配件凑齐拼接精准，也未必得到相同效果。人世间的规章制度绝不能以为是纸面上设计，照抄照搬实无用处，因为它缺少了人们的理解与认同、遵循且维护。你将法律法规抄一份扔给猴群，它们会被改变么？
--路见不平可以拔刀相助；亲友乡里相爱相杀外人如何好插手？--对错还要看身份？--亲疏远近自有不同，世上最爱你的人自然是你的亲近之人，连他们都要害你，我不觉得有插手的立场。对错标准本不固定，因时因地因人而变。--
可靠吗？仅靠技术？术只是术，术会被术对抗蒙蔽误导。活人尚可被蒙骗，何况死物？人与人之间到底需要日积月累世代交好的信任。
    只考虑满足人定的检测标准，不在乎标准设定的初衷。--杀良冒功
    构陷
--定罪？刀架脖子上，要不要防守反击？--『架』是多远？一里？千里？总不好别人探矿，你就当作被刀架脖子？
黄
    史料-虚幻动荡世界中唯一的真实，人类唯一掌有的珍宝。
        人们有意忘却恩怨，你又何故多事让他们记起？相濡以沫不如相忘于江湖。从前的事，就让他们随风而逝吧。
    天天折腾改革，只要不觉得是个事，仅是顺势而为，那便没事，天下无事。
    宁要面子不要感情:自古真情不待见，唯有体礼装门面
        #源自:网络名言:自古真情留不住，唯有套路得人心
    逆窥气运:生育子女会分裂并不断汲取双亲气运，气机纠缠红尘难断，故此修士不生育子嗣/断子绝孙。只是气运宗未从宣示气运之秘，外人实难知晓其中门道。投身人道，广育子孙，以窥气运流变。
        双修:无关其他:修道之人何来人性/我辈皆是无情人:今日方遇此异人，吾道成矣！

『我值得更好』，烦恼渐起；『境遇可能变糟』，忧怯沉身。不羡不畏，草木一生。

古代文学共同创作，当下编程开源项目，其实差不多一个意思，只是古代版本分支控制方面比较弱。

一种香气可以诱人，万种香气只能烦人。红花还需绿叶衬，美女扎堆的地方，就算是色中恶鬼也会厌弃的。

市场调控自由竞争？真要是自由竞争，必然垄断，进而不再自由；若是反垄断，则反垄断本身就是反市场反自由的。自由竞争，是一个无法维系自身存在的伪概念。

复仇的有效窗口期其实很短暂。短期内，仇家有自毁之劫，所谓『三十年河东三十年河西』，等你崛起，仇家大概率早没了。长期看，江山社稷有倾覆之危，阶级大洗牌，两代人后，甭管记不记仇，可能双方都没了。

众念国
    窥测人心，体察善恶--大独裁者，操纵主流心念，表达善意，掩盖一个拥有决断权的恶意念头。



山伯-山之长/山之霸-山的统治者-山神-河伯
    山长-1.唐﹑五代时对山居讲学者的敬称。如唐代刺史孙丘于阆州古台山置学舍，延尹恭初为山长;五代蒋维东隐居衡岳，受业者称蒋为山长。事见宋马永易《实宾录》卷十一。宋元时为官立书院置山长，讲学兼领院务;明清时改由地方聘请。清末改书院为学堂，山长之制乃废。 2.隐者之称。
    山伯-1.山神。传说琅琊王知远，初入茅山，师事陶弘景，因儿时损一童子吻，不得白日升天，年一百二十六卒，封少室山伯。见《谈宾录》。 2.称生长一百五十年的何首乌。
    河伯-中国神话人物。即“黄河水神”。又名冯夷。相传他在渡黄河时淹死，被天帝封为水神。曾娶妇害民，又使黄河泛滥。后化为白龙在水上游，被后羿射瞎了左眼。
    风伯、雨伯、海伯、水伯
    鬼伯、官伯、火伯
    社伯、市伯、诗伯
    岳伯-1.相传尧舜时四岳为四方诸侯之长;周有方伯为诸侯之长。后以"岳伯"泛称封疆大吏。
    庶伯-1.众伯。伯，古时管辖一方的长官。《书．酒诰》:"庶士有正越庶伯君子，其尔典听朕教。"孔传:"众伯。"一说为邦伯。
    主伯-1.古代指家长和长子。语本《诗．周颂．载芟》:"侯主侯伯，侯亚侯旅。"毛传:"主，家长也;伯，长子也;亚，仲叔也;旅，子弟也。"
    将伯-1.《诗．小雅．正月》:"将伯助予。"毛传:"将，请也;伯，长也。"孔颖达疏:"请长者助我。"后因以"将伯"称别人对自己的帮助或向人求助。
    州伯-1.古代一州诸侯之长。 2.一州之长。

    龙伯-1.指龙伯国的巨人。 2.喻指渔者。
    龙伯钓鳌-龙伯：传说中的国名；鳌：大龟。龙伯国的人钓起六条鳌。比喻非凡的事业。
    龙伯国-1.古代传说中的大人国。 2.近代亦借指凶狠的英国帝国主义。
    [[
伯bó
兄弟排行次序：伯仲（指兄弟的次第，喻事物不相上下）。
父亲的哥哥：伯伯。伯父。伯母。
对父辈戚友的尊称：老伯。世伯。
封建制度五等爵位的第三等：伯爵。
旧时对文章、道德足为表率者的尊称：“海内文章伯”。
姓。

伯
bǎi
〔大伯子〕丈夫的大哥。

伯
bà
古同“霸”，古代诸侯联盟的首领。

笔顺：丿丨丿丨乛一一

蝉联:连续不断；连续获得：爵位蝉联｜蝉联冠军。
蝉联往复:蝉联：连续相承。接连不断地反复重演。
蝉联蚕绪:蝉联：连续相承；绪：丝头。比喻连接相承。
    蝉chan2联蚕can2绪

长歌当哭:长歌：长声歌咏，也指写诗；当：当作。用长声歌咏或写诗文来代替痛哭，借以抒发心中的悲愤。
面壁九年:面壁：佛家语，指面对墙壁默坐静修。原指中国佛教禅宗始祖达摩在少林寺面壁静修了九年。后比喻在学习上下得功夫极深。
九年面壁:南朝梁普通年间，天竺僧菩提达磨泛海来华，是为禅宗初祖。达磨渡江后，止于嵩山少林寺，面壁坐禅，默然无语，凡九年。见晋法显《神僧传》。后以指一心参禅，或借指长期专注于某种学问或工作。
龙场悟道:王阳明
穷源朔流:比喻探究和追溯事物的原由。
告朔:①周代制度，天子于每年秋冬之交把下一年的历书颁发给诸侯：颁告朔于邦国。 ②指诸侯于每月朔日(夏历初一)向宗庙行祭告听政之礼；诸侯必每月告朔听政，因朝宗庙。
告朔饩羊:朔gu4饩xi4:原指鲁国自文公起不亲到祖庙告祭，只杀一只羊应付一下。后比喻照例应付，敷衍了事。
定朔:我国古代历法家以日﹑月黄经度相等的时刻定为朔。以这天为朔日，称定朔。定朔较平朔更为精确。南朝宋何承天首倡，唐初始采用。
改朔:1.变换朔日。指经过一个月。朔，农历初一。 2.更改正朔。借指改换朝代。
正朔:正zheng1:1.谓帝王新颁的历法。古代帝王易姓受命，必改正朔;故夏﹑殷﹑周﹑秦及汉初的正朔各不相同。自汉武帝后，直至现今的农历，都用夏制，即以建寅之月为岁首。 2.农历正月初一。
年号:皇帝纪年的名号。汉武帝始建年号，以公元前140年为建元元年。一个皇帝在位期间可用几个年号，但明、清两代，一个皇帝一般只用一个年号。年号一般为两个字，但也有四个或六个字的。
纪年:①记年代，如我国过去用干支纪年，从汉武帝到清末又兼用皇帝的年号纪年，公历纪年用传说的耶稣生年为第一年。 ②史书体裁之一，依照年月先后排列历史事实，如《竹书纪年》。

蕊珠经:1.道教经籍名。
蕊珠宫:1.亦省称"蕊宫"。 2.道教经典中所说的仙宫。
蕊女:1.蕊宫之女。仙女。
蕊榜:1.传说中道教学道升仙，列名蕊宫。后指科举考试中揭晓名第的榜示为"蕊榜"。
蕊简:1.指道教经籍。又名蕊书。
蕊苑:1.蕊宫之苑，仙苑。

景星:1.大星;德星;瑞星。古谓现于有道之国。
景星凤凰:传说太平之世才能见到景星和凤凰。后用以比喻美好的事物或杰出的人才。同“景星凤皇”。
    景星麟凤
十日并出:①古代神话传说天本有十个同时出现的太阳。 ②比喻暴乱并起。

民安物阜:阜fu4:阜：多。社会安定，物资丰富。形容太平盛世的景象。

于飞:飞;偕飞。于，语助词。
于飞之乐:于飞：比翼齐飞。比喻夫妻间亲密和谐。
燕于飞:《诗．邶风．燕燕》:"燕燕于飞，差池其羽。之子于归，远送于野。"诗中咏送别，以"燕燕于飞"起兴。后因以"燕于飞"为送别之典。
凤凰于飞:本指凤和凰相偕而飞。比喻夫妻和好恩爱。常用以祝人婚姻美满。:《诗-大雅-卷阿》:『凤凰于飞，翙翙其羽，亦集爰止。』

oracle:神谕
    oracle bone inscriptions 甲骨文

航天:①指人造卫星、宇宙飞船等在地球附近空间或太阳系空间飞行。 ②跟航天有关的：～技术丨～事业。
航空:①指飞机在空中飞行：～事业丨～公司丨民用～。 ②跟飞机飞行有关的：～信丨～母舰。

阐幽显微:阐：阐明；幽：幽深。讲明深奥和精微的道理。形容挖掘深，能启发人认识所未能认识的事物。
八姓:1.祝融之后的八姓﹐即己﹑董﹑彭﹑秃﹑妘﹑曹﹑斟﹑芈。 2.晋八姓﹐即栾﹑郄﹑胥﹑原﹑狐﹑续﹑庆﹑伯。 3.北魏八姓﹐即穆﹑陆﹑贺﹑刘﹑楼﹑干﹑嵇﹑尉。 4.五代八姓﹐即梁(朱氏)﹑唐(庄宗李氏;明帝出身沙陀民，姓氏不明;废帝王氏)﹑晋(石氏)﹑汉(刘氏)﹑周(太祖郭氏﹐世宗柴氏)的八姓。

圣母:1.君主时代对皇太后的尊称。 2.旧时对孔子母亲的尊称。 3.古代民间尊称有殊功于民的妇女。 4.古代对女神﹑女巫之称。 5.旧时各地多有圣母祠﹑圣母庙等。 6.基督教徒尊称耶稣之母马利亚。
娘娘:1.称母亲。 2.也称主妇或老年妇女。 3.称后妃。 4.称婆母。 5.祖母。 6.称女神。 7.方言。称父亲的姐妹。

起夜:指夜间起来小便。

诛（誅）
zhū
把罪人杀死：害民者诛。诛灭。诛锄。诛戮。伏诛。
责罚：诛意（不问罪行，只根据其用心讹定罪状）。口诛笔伐。
责求：诛求无已（一味索取，没有止境）。

戮lù
杀：戮尸。杀戮。
〔戮力〕合力，并力，如“戮戮同心”。
羞辱，侮辱：戮人（罪人）。戮民（受刑罚的人）。戮辱。戮笑（耻笑）。

绝（絶）
jué
断：绝种。绝缘。绝嗣。绝情。绝迹。断绝。杜绝。灭绝。空前绝后。
尽，穷尽：绝命。绝望。绝境。绝棋。气绝。
极，极端的：绝妙。绝密。绝壁。绝无仅有。
独特的，少有的，没有人能赶上的：绝色。绝技。绝伦。绝唱。绝代。
一定的，肯定的：绝对。绝然。
越过：“假舟楫者，非能水也，而绝江河。”
旧体诗的一种体裁：绝句。五绝。
续

陷xiàn
掉进，坠入，沉下：陷落。陷没。陷溺。陷于。陷入。
为捉野兽挖的坑：陷坑。陷阱。
凹进：双眼深陷。
设计害人：陷害。诬陷。陷人于罪。
攻破，占领：失陷。沦陷。
缺点：缺陷。


sou3xiny4
索性:索性:索性:索性:索性:索性:索性:索性:副词。表示直截了当，爽快：这些衣服既然你都喜欢，索性全买下罢。
所幸:

国无幸民:幸民：侥幸偷生的人。国家治理有方，人民勤于职守，安居乐业。
射幸数跌，不如审发:1.古代谚语。比喻侥幸求利而多次失败﹐不如审慎从事而一举成功。
幸草:1.谓车轮轧过的草。因其屈伏地面，不易燔烧，故云。

后稷:1.周之先祖。相传姜嫄践天帝足迹，怀孕生子，因曾弃而不养，故名之为"弃"。虞舜命为农官，教民耕稼，称为"后稷"。 2.古代农官名。

忖:
忖cǔn
揣度，思量：忖度。忖量。思忖。自忖。

囡nān
方言，小孩儿：小囡。阿囡。囡囡（对小孩儿的亲热称呼）。

吕望:1.即周初人吕尚。尚年老。隐于渔钓，文王出猎，遇于渭滨，与语大悦，曰:"吾太公望子久矣。"故号之曰太公望。后世亦称吕望。
姜尚:又叫“吕尚”、“姜子牙”，俗称“姜太公”。中国古代著名的贤相。曾帮助周文王治理国家，国力逐渐强大。后又帮助武王灭商，封于齐。是周朝齐国的始祖。周公东征时，成王命他征讨参加叛乱的东夷。
    ]]

一土王，二十王，二丄王，丅二王，工一王，干一王，三丨王
孤寡蛙，古危龟，骨歪怪，苦外快
瓷傲草
取名-道童:煽风、点火，添油、加醋，道听、途说
取名:范曾足、蔡刀乘，唐鸟奚
取名:呼噜噜、秃噜噜、叽里咕噜、哎呀呀
取名:既然女名多含花玉鸟，何不干脆就叫花玉鸟、兰瑶莺、#玥燕


且言紂王只因進香之後，看見女媧美貌，朝暮思想，寒暑盡忘，寢食俱廢，每見六院三宮，真如塵飯土羹，不堪諦視；終朝將此事不放心懷，鬱鬱不樂。
    --封神大劫，一切皆源于纣王妃后太丑，实乃罪大恶极。国之将亡，必有妖孽，都怪这些丑八怪。只叹两班文武漫天神佛，不及整容医院，徒然生灵涂炭。仔细一想，不是能力不足，实是思维局限，往后拜神不献祭，要献就献脑黑金！
封神榜:故堯、舜與民偕樂，以仁德化天下，不事干戈，不行殺伐，景星耀天，甘露下降，鳳凰止於庭，芝草生於野；民豐物阜，行人讓路，犬無吠聲，夜雨晝晴，稻生雙穗；此乃有道興隆之象也。今陛下若取近時之樂，則目眩多色，耳聽淫聲，沈湎酒色，游於苑圃，獵於山林，此乃無道敗亡之象也。
    --景星耀天-十日并出:航天器？太空堡垒？
大争之世，就是说僧多肉少，人口密度太大。小国寡民很好，只是人口增长不可避免，大争之世终究还是会降临，这就是杀劫，避无可避席卷众生的杀劫。仙人也不例外，犹如池塘中放养过多鱼苗，鱼苗一长大便不得不厮杀。万仙阵都能出现，可见封神一劫确实是针对截教而来的。
    战争或许可以避免，只是恐怕人们不愿意过戒律森严的日子，或者更准确地说祖祖辈辈生活在繁琐规矩中的人们不愿意再过戒律森严的日子(等级权限与晋升、资源调配、计划生育、延寿许可)，宁可时不时爆发动乱，整肃秩序。无序自由地发展，终究需要淬火。
燃灯:无情无义，实乃真正的修士，无怪成道。
--『来将通名！休要做了无名鬼！』对这话到底应不应？若是报出姓名，岂不是要做有名鬼？

誓言总有许多缺省的前提条件，若要反悔，自能找出许多众人认可的理由。誓言也好，契约也同，十分无谓，连违约责任的界定也无助益。
封神榜-集天下英才而灭之。申公豹、通天，这两人大有问题，乃是深藏不露的助攻。所谓有教无类，实是网罗筛选。万仙阵，聚而灭之。圣人万劫不灭，应当是刻意营造的谎言，否则，门人何益，至宝何用。后天既可成圣，必可毁之。欲盖弥彰，谎言之后就是真相。
多收弟子好上榜凑数。大家至少都已修炼了数十万年，怎么装作不相识？
协商妥协:赌注太重，我自忖不能接受失败的结果，以此看来料想你们也不能。此番赌斗本为了结恩怨，岂可再兴波澜？不如各退一步，减轻赌注，败者不至于心怀怨毒暗施诡计。
:心教:心外别无求，有内则有外，有心则有尘，有空则有文，有觉则有迷，有得则有失，圆满实有缺，究竟即空想，『一切唯心造』甚偏。
绝:绝境:援手妨碍、环境相克/灵气隔绝气运消减、复活妨碍
陷:穷困:移动妨碍、各种负面状态压制
戮:破防:破器、破法、破体、破运、破命
诛:诛心、诛志、
配角抢戏:姜子牙、孙悟空、诸葛亮
矮脚虎，武大郎，土行孙
时间地点很重要，是气氛的重要组成部分。为何不到宾馆，因为太安全太理直气壮。必须得是随时可能有熟人闯入撞破奸情的地方，营造出一种偷偷摸摸鬼鬼祟祟提心吊胆风声鹤唳草木皆兵的气氛。比如：女方娘家、办公室、...
崔莺莺约炮西厢记
目前:既然曾誓言不背地里，那就当面。酒醉、蒙面...
view ++enc=gbk /mnt/m_external_sd/000edt/0my_files/novel/9/《我为纣王之傲啸封神》（校对版全本）作者：点精灵.txt
『时日曷丧，予及汝偕亡。』--殉情？殉葬？但愿同年同月同日死，不离不弃，生死相随。这是广大百姓对夏桀的爱戴之语。只可惜造化弄人，情深不寿，天歼良人。
    『女子无才便是德』等若是说『世上并无无德无才的女子』，实乃对女性的溢美之词，太假了，令人难以接受。

劫难:节:蜕皮蜕壳搬迁改革分群
价值，并非天材地宝，而是劳动付出；权势，并非占用物资，而是使役众人。人的力量来源于人，人的权势来源于人，人的德行来源于人，人道到底是以人为本。阳春白雪孤芳自赏傲慢不群，将恐有亏。丢了脸面坏了规矩失了威信，德不配位，众议其非，实乃攸关死生的大事。
共工:共产工农:新中国国号为『工』/『新』王莽
道岂书中得，悟何缘人言。念经日夜固执痴，妙语解人误众生。

层层加码，往上孝敬，往下指标，连开个全校大会，老师班长也要层层提前聚集时间，实乃全国上下一心一意无时无地不在精心培养接班人--接班官僚。
全国抗疫，禁止举办大规模聚集活动，却三天两检，核酸检测大概令许多人首次体验到如此频繁的大规模聚集活动。
彩礼再高，也算明码标价，法律没有强迫人必须结婚，故非强卖，何来抱怨？难道是要强买？强扭的瓜不甜。
--未婚妻到底是什么神奇生物，感觉就像是退婚流专用道具。--退婚，很好。离婚，没错。遵纪守法，按章行事。为何恼火？--难不成是给男方戴绿帽？说不定身孕都快掩饰不住。--别说未婚，就算婚内出轨，又如何？离了好，大家好。--开玩笑，这不能忍！--(起争执，斗殴；当事人:绿帽+有喜)
弱肉强食，弱者是上天给予强者的奖励。



纪年:为何中国古代没有使用固定起始年的纪年法而是采用年号纪年或干支纪年？在地方割据多朝并立的时代，年号多，对准时间不易；大跨度计算时间间隔也不易。但计算时间间隔多出自精密科学的计算需要，比如：天文学。改朔、年号，实是出自确立帝王权威的政治需要，但对于人文社科类而言还是比较方便记忆的。
是以圣人处无为之事，行不言之教。万物作焉而不辞，生而不有，为而不恃，功成而弗居。夫唯不居，是以不去。
    有无相生:无为而有治，不言以成教
    不居功故不去:人心如流水，一切雕凿如落花，『不去』不在乎众人知晓代代铭记，而在于后世发展的影响，如同黄河改道变换地理，如同燧人氏生火影响深远而不在于其人其名其时其地。


仁-个人价值观；义-群体价值观
--输了？我竟然连说句场面话展示一下风度都做不到，原来我输不起。(不只输了比剑，更是多年来构建的自我形象彻底崩塌)--(流泪？哪来的巨婴)
--生命共享？双生诅咒？岂能阻我！杀！

生命的存在就是为了创造奇迹，若是平庸地活着，和死物便没有区别。


先让孩子们对学习充满厌弃，真是惊人的策略。
保护色:其实我只是装作很认真的样子，环境要求我们是什么颜色，我们就涂上什么颜色。
氪金战士
金坷垃
不敢不愿抑或不能？不敢即是不愿，不愿即是不能。
镜花水月一场空--人道大势，即非一人所能抗衡，亦非一代人所能左右。

律法自然是给平民准备的，违章行车受处罚，但是高等人需要自己开车吗？开车的，多是货车司机、出租车司机等。同样，杀人放火的事，高等人不会亲自下场做或有其他途径达成目的，做的人通常只能是合法报复无望的普通人。富贵者，既然合法杀人；贫贱者，只得以武犯禁。

刷怪得积分？老实说，类似秦国以战功封爵位的系统，很容易出问题，刷怪本身可能完全没有产出，甚至要倒贴资源。可将野怪当作某种形式的货币，而这种货币的发行并不受人控制，很容易发生通货膨胀，贬值到不如厕纸。强行维持，意味着重税，危急存亡之秋倒也合理。

一键升天挂:脱离了游戏世界，属性面板消失了？
开挂一键通关，完本撒花无需百字。可是缺少路人秀惊讶，造一批迷弟迷妹，没注水的文字没得灵魂。

帝号是死人专属的溢谥，活人只能称王。



有人指望荣耀不朽，有人指望功德不朽，有人指望意志不朽，有人指望制度不朽，有人指望人道不朽，皆是痴迷。


语言文字只是工具，堪用即可，花费太多时间精力在基础教育阶段上，实是浪费生命。读音准不准？字写得好不好看？加减乘除运算熟不熟练？记忆外文地名人名水果名？这到底教的什么鬼东西？
扫盲是扫盲，教育是教育，师傅领进门修行在个人，自学才是硬道理，关键是有没有适宜个人修行的环境。


我说避雷针，即是引雷针。

--我们门派又没养鸡，哪来的鸡汤？再说这是白开水。--『煲鸡汤要有鸡』，这是旧观念，吾宗不走寻常路，天尚可逆命尚可改，没有鸡照样煲鸡汤，你要相信这不是白开水。


仲裁--冻结整个战场，慢慢调查纠纷源起真相，理清是非，一万年过去了...


大梦宗vs痕印宗:
    惊醒！妈蛋！无辜却自认有罪！至死不察！真的就是被人强迫吃屎！不能忍，梦醒了再入，必要打爆你的狗头！

作为一个骗子、一个神棍，最重要的原则当然是维护社会和谐，喊打喊杀成何体统？
和平精英--日军在华进行长达八年的友好访问，帮助中国构建和谐社会，减少低端人口，繁荣经济，实乃和平精英。

生也无知，死也随机，本是常情，非要掌控，那就是病。

--朝廷就是最大的反派，是不是很有动力去推翻它？--原来是反派！我说怎么那么多人削尖脑袋往里钻，早知道我也...--让你拉人，反倒为丛驱鸟！--我怎知人们向往反派，这不正常！--正常的话要我们干嘛？
    --牲口可还身康体健？可还心情愉悦？可还听从指挥？可还努力劳作？可还努力产崽？
    --怎么人来演动物？--动物演员要价高，还是人便宜。我们以人为本，坚持要人不要畜生的招工原则！

果然是终身大事，不仅父母操心，连他妈作者读者都关心，不撒狗粮都不行。

夺舍--我杀了你儿子，未免麻烦，还是送你们一起上路吧。

建木是草还是树？当时尚无草和树。
    第一只筑巢的鸟未始可称为鸟。
    第一只生火的人未始可称为人。

我不寻仇，仇来寻我


--嘴长在别人身上，骂不骂是别人的事，与我何干？为什么要在意？--别人污蔑你羞辱你，导致众人鄙视你排挤你打击你，还能说无关？--事实是事实，并不因为人们的说法而改变。要么我确实有毛病，要么没有。别人所说，众人心中所信，要么与事实相符，要么不相符。若相符，不过重述而已，不存在污蔑羞辱，我怎可反驳？若不符，错在别人，着急的不该是我，难不成还要管教他人？--若是别人批评得在理，当道谢反省改正。若不在理，不予理会岂不是默认有错，误导众人？--人皆自以为是，是己之所是，非己之所非，己之所是乃彼之所非，己之所非乃彼之所是。是是非非，于人各异。我当真便错了么？我当真要驳正别人方可罢休么？

我们贫贱之家的特色就是矮矬穷丑蠢，你确定要与我们比较？


命苦
    --老夫人，您孙儿命苦，注定变成天下最穷之人，不如拜入老道门下，出世修行，不染红尘，免遭磨难。--只此一路？--不错！--我看未必！只要天下再无饥渴冻馁之人，何愁最穷？--你不信？--你不信？--(小小年纪便已找到自己的路么？)

卖女献妻--靠舐痈吮痔？
    舐痈吮痔:(shi4 yong1 shun3 zhi4):舐：舔；痈：毒疮；吮：聚拢嘴唇来吸。只为人舔吸疮痔上的脓血。比喻卑劣地奉承人。
    含血吮疮:吮：用嘴吸。用嘴把病人疮里的脓血吸出来。旧时形容将领关怀、爱护自己手下的士兵。

最强的防御，即是无人知道我的存在。

书籍被创作出来，就是给人看的，束之高阁、无人领会、无人看得下去，毫无用处，没有价值。

说你是多动症，你就是多动症，弱小，没有人权。

人口密度越大，人与人之间的距离越远。信息传播的速度越快，看到的糟心事儿越多，悲愤之情越炽。

大国宜处下？--道德经
    弱者制定规则，强者应当遵从。
黄-通过犯罪、战争来表达意见，天赋之权。世界很大，不要以自己的想象去推演。当所有人失去作恶之心，人类就已经灭亡。只知正确的路，则正确的路便是死路，无数年无数人犯下无数错误，只为博得一线生机。生存乃是至高美德，是一切行动的评判标准。
    麻烦来自于资源短缺，根源在于人口太多，自我阉割、自杀、战争都是降低人口的手段，是和谐社会的重要组成部分。严刑峻法，犯任何错误直接死刑立即执行，并株连灭门，也是很好的选择。

    不以结婚为目的的谈恋爱就是耍流氓？
        谈恋爱是为了结婚，结婚是为了生娃，生娃后要养育成材直至独立生活，...，同性结婚不是不行，只是合理性并不理所当然，需要一些条件，比如，不讲究性别的人工生育器。更进一步，若人工生育器能放宽亲代数量必须为二的约束，则单性繁殖、多人婚姻也合理。更进一步，若能放宽物种约束，则各种人兽婚姻人植婚姻也合理。更进一步，草天草地草空气也不是不可能。反之，若是人类实现永生，资源紧张，不再生娃，当然婚姻也将不复存在。同样，若养育后代变得艰难，人们也就不愿生娃，不婚人口比例就会上升。
    世界很大:踏遍千山万水，纵横九天十地。
        九州:类似前后左右东西南北，以我为中心建立的相对概念，无有穷尽
            灭而烬、微而幽之所--幽州
    作孽:为虎作伥是作孽，给干坏事的人擦屁股是作孽，给坏了规矩的人善后安抚受害者是作孽，减免安全措施不足所致伤残的医疗费用是作孽，收养被遗弃孩童是作孽，阻止别人复仇是作孽，劝架妨碍别人泄愤是作孽，...自以为造福，实则报复社会祸害子孙，一时的缓和就如同麻醉药只会默许伤害加剧。我劝你们善良！(wqnmsl==wqnm+nmsl)
    腐朽神奇、心境蒙尘(曾去往青帝法天象地留影之地，故知晓九天玄女来历，封印)
    无关？虽然此事确实与我无关，但我问你，如果受害者是我的人，你们会如何处置？或许你以为可以将我们逐个欺凌，当我们也没那么蠢，弱者制定规则强者应当遵守。
白-纯属虚构
    数量太多，立天地人三劫，屠戮众生。
黄-山野村夫
黑-邪教教主
青-土匪头子/九天玄女/外号:我不服-天上地下我不服
    圆极:
    极不信命==极其信命
    极其讲究==极其随性
    极其和善==极其凶残
    极其讲理==极其蛮横
    极其风趣==极其无趣
    极其勇敢==极其怯懦
    极其勤快==极其懒惰
    极其公正==极其偏袒
    极端拥护==极端反对
    极端重视==极端忽视
    ===
    速胜派就是投降派。
    对强者有多么卑躬屈膝，对弱者就有多么嚣张跋扈；锦上添花，必落井下石。
        舔狗薄幸，或者说，薄幸之人更愿意放下身段小心小意当舔狗；今日舔狗，明日负心汉--司马相如卓文君
        拉一批打一批，人人夸口的老好人是不存在的。
    死人当脊梁
        烈士吗，造假贴金，谁敢较真？人们质疑真实性，并非真的对某一事件起疑心，而是在生活中发现形形色色的言行不一，推而广之，祸及前辈，毕竟后辈靠着福荫作妖，推倒这些灵牌，显然是正确操作。指桑骂槐，人们口中所说的话，与实际上传递的信息，差距很大，到底不是就事论事，这才是许多议题争论不休的根本原因。不是抬杠，不只不满，是仇恨，是漠视，是假装不知道。人们越是刨根问底追究真相，说明越不在乎真相。
    同一:不可避免的伴随现象，或者说，一体的多个侧面。
        信息就是质能，信息就是时空。气运...
炎
    搜索:悔弓箭枝木材产地:广度优先(大尺度地域横跨时间开销)+采样渐深+材质属性梯度
        类比:在蛋糕仓库里搜索特定口味的蛋糕



天道对乐宗产生的反噬:青:乐宗的人劫
    气运宗:气运连锁，任一门人身兼整宗气运，一败则阖宗灭门，只是宗门气运十分强盛，故而战无不胜。正因无敌，必为人忌惮联手对付，反噬之伟力愚俗可料，缘何如此不智冒此天险？正为此反噬耳！欲重现青帝覆灭乐宗时法天象地汇聚无穷气运之境况，一窥气运之极道究竟。
改名宗--逆天改命
欺天宗--痕印宗印派马甲


阳-一、简、精、秩序、主要矛盾
阴-多、繁、杂、混乱、非主要矛盾
原理:
  一元:守恒(惯性)
  二元:反噬(变化)
  五元:生克

反噬:--赐予我自由？太晚了，自由必由我亲手夺回。

皆为利来:理念不同的人，对利益的计算也不同。
大能转世，引导信众，这不就是托？
设计坑害他人，却没能反省自身处境，转眼被人坑害，也是怪事。

明日黄花、黄花晚节、黄花闺女--真是奇怪，意思不兼容啊
煎蛋无聊图:中秋团圆--中秋才员(月饼轮廓)
多音字、多义字、异体字，毫无存在的意义，每个字都该独立清晰，而不是依赖语境。『莫』『暮』『景』『影』，汉字的趋势本该如此，然而简体字疯狂合并汉字，除了合并异体字没毛病外，其余多是开历史倒车。
自由无限好，只是缺资源。
乞讨为生，人间留不住，绝对是真仙没错了。
--明明可以靠实力完成认证，为啥偏要托关系走后门？--身为邪道子弟，不走歪门邪道成何体统？

退潮后留下一些虾蟹螺贝不是很正常吗？大争之世，各种机缘浮现，成就无数天骄，不很正常么？

众生可屠，万类皆微！

若要看清水底的情况，就不该将水弄浑，因果沉重之人习不成推衍之术，干扰太大，这干扰来自观察者，当观察者强横到一定程度的时候，仅仅是注目都足够改变局面，自身的意志都能决定结果，推衍自然毫无意义。


天道生衍，庶出众物，人势富集，适者生存，探索大道，规划星辰
天道自然推衍，究竟有无诞生得窥大道的智慧生灵的可能？

这是要逆天--上天一定欠了你很多钱

--天予弗取必受其咎。--真的吗？那我们就不要了。

功劳体系
    耕田的牛，驮人的马，看家的狗，打鸣的公鸡，不杀不吃，不以血脉远近区别对待。
    那像人的猿猴呢？
    不是一个体系的，纵然是人，也是亡我之心不死的敌人、蒙昧未开化的野蛮人、肮脏邪恶的异端、低等卑贱的牛羊。
    资质好潜力大 不如 修为高，修为高 不如 功劳大贡献多。毕竟之所以抬举资质好的人，也只是因为未来修为高的可能性大；之所以尊重修为高的人，也只是因为有能力作出重大贡献。

反正都要走，白来这一趟

--恭喜你荣获赌神称号！--我从未下注一赌，哪来的赌神称号？--由于你高超的赌技卓越的目光，短短几天获益便超过万千赌徒，『赌神称号』实至名归。


婴儿歌:跨过深渊，攀上高峰，悬落峭壁，勇往直前，...


如是
    如是我闻
    我见青山多妩媚
        显然，『妩媚』就是对糙老爷们的形容。
        将心比心
            将心比心，我从来没仔细打量过别人的衣着打扮，想来别人也从未在乎过我的打扮，何必浪费时间在外表上？
            世上谁还不是又蠢又坏又弱小？


生存的依凭:真是奇怪，我连活着的依仗都没有，是怎么活到现在的？又如何能够继续活下去？更像是被圈养的牲畜，一无所有地活着。

男人的嘴骗人的鬼。走后门。奸商，营销...
    男女关系、官民关系、买卖关系，都是相互惯出来的，它们的样子，正是你的培养，不要抱怨。


偷吃成狗
    占便宜？得到就是失去，从前狼偷吃人类的牲畜、垃圾，偷着偷着就变成了家养的狗，它得到很多，也失去很多。
强干弱枝，打压异己，阻碍交流，保持优势以限制发展为手段，得失难说。
得到就是失去，鱼与熊掌不可兼得，高朋满座则失独享闲暇的自在。
    既享其利，则受其弊。
    大树之下，树苗难成。得到一门修炼法门，很可能妨碍自己从全然不同的角度开辟途径。文明的碰撞，乃至于学习模仿，都可能导致多样性的未来消失。
    《道德经-第十一章》:三十辐，共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。
    因为一无所有所以造反？一无所有，是一种想象；岁月静好，也是一种想象。斗争宣传的需要，是相信，不是真相。
        对与错，分两种。一种是真假，一种是认同。真与假、信与不信，这是不同的。简并的可能性、并行的确定性，无关事实，只是不同的解释，只关乎信念。
            觉醒宿慧vs夺舍


农夫是庄稼，牧民亦牛羊
胜人者力，胜己者强
    仪式是最没用意义的，战胜对手何必经过比斗然后才知道？既然需要证明，说明心中不自信，即使取胜也只是侥幸。与其追求打败一个个对手，不如追求超越昨日的旧我。
年度傻逼争霸赛-谁人勇夺桂冠？
    [[
    粪治:谓施肥治田。
    大道横陈寻常见，粪里淘金韵味深。
        重大历史事件--茅坑悟道、助道狗屎
            占着茅坑十年拉不出屎，眼见一野狗天天拉屎炫耀，蹲坑十载终于悟道，惊天地泣鬼神，妖魔鬼怪辟易万里，人畜绝迹。
            #仿:九年面壁、龙场悟道
            #
        『屎文化』传承自上古，是优秀的文化遗产，我们后辈子孙当努力发扬光大！发粪涂墙！光前裕后！流芳千古！
        屎尿屁:崩屎大王，泄尿大王，亮屁大王
            起夜魔君:尿裤子
                #取名:鹅围子/绝缘子/尿裤子/挨头子/挨板子/吃板子/矮矬子/被褡子/爱面子/暗门子/样板子/下绊子/使绊子/光膀子/钢镚子/拔钉子/拔罐子/菜帮子/匍阶子/竹筒子/花绑子/熬月子/坐月子/八辈子/半辈子/下辈子/上辈子/手把子/扛把子/拜把子/花架子/照镜子/败家子/摆架子/摆摊子/摆样子/打摆子/掰腕子/白鼻子/白刀子/白帽子/高帽子/眼珠子/半吊子/半拉子/肉包子/菜包子/猪鼻子/竹箅子/竹篦子/驳面子/蒜辫子/揪辫子/使君子/兵油子/卜算子/采莲子/笔杆子/枪杆子/掺沙子/表蒙子/好小子/病秧子/狗腿子/碰钉子/出岔子/插杠子/八杆子/夜猫子/陈谷子/采桑子/看场子/个锤子/下馆子/出点子/抽冷子/出疹子/出份子/随份子/
                #   二流子/流荡子/浪荡子/兵痞子/兵油子/
                    卿本佳人/亲本家人
                    /沧浪子/不住子/步虚子/餐霞子/参牟子(重瞳/斗鸡眼？)/巢居者/
            斗转星移:为了真爱，转移攻击到自身，你的份我拉了！#致敬:你放的屁算我的
        拉屎放屁，人生真意！人=造粪机
            --大家小心了，我要开始放屁了！--好！好一条光明磊落的汉子！抵制悄眯眯放屁！不让人在没有做好心理准备的情况下遭受毒害！
            公然放屁怎么了？我还公然拉屎呢！朝廷还公然逼人吃屎啊！
        小仙女:我摊牌了，我从不拉屎放屁，虽然，我依旧感谢父母生下没有屁眼的我。
            --纵然不能为『粪文化』这一伟大的永恒事业添砖加瓦，但请不要灰心丧气，其余虽是鸡毛蒜皮的杂务，却也需人处理，行业不分贵贱，我们不会歧视你的！关爱残障人人有责！
    挑粪大比
        挑粪大师手工挑粪，绝对没有使用机械，纯手工绿色无污染，让您拉得放心、拉得舒心！挑粪大师倾情打造，至尊厕所，天骄专享，引领时尚，为无量众生膜拜！
    彩头:一坨印着天下第一名牌的狗屎--茅坑悟道圣物的仿品
        神奇！真是太神奇了！前一刻还是坨臭不可闻的狗屎，但只是印章落下，便闪闪发光，甩上枝头变成坨凤凰屎，大师妙手化腐朽为神奇，匪夷所思！恐怖如斯！这臭气，摇身一变，成了流芳千古的臭味，闻一闻精神抖擞，身体倍棒吃嘛嘛香！活死人肉白骨，包治百病，实乃杀人越货居家必备！当这场小小赛事的彩头，真是纡尊降贵！各位选手当真令人钦羡！
    彩头:清心安神对抗心魔-修行辅助至宝，甚至可以辅佑国运--『不妖碧莲』-出淤泥而不染，濯清涟而不妖。
        中华传统美食--开塞露
        此物只应天上有--百草哭--救苦救难大慈大悲，使人脱离苦海--朝廷以为使奴隶幸福美满是违法的，遂封杀之。
        中央帝国护国祥瑞--三鹿仙粉--头大聪明
    彩头:当奴隶的机会。
        --少年，本地有三大帮派，快来加入吧！...不加入门派吗？单打独斗可是很辛苦的，会遭遇诸多不解非议嘲讽歧视排挤刁难。
        丐帮
            凭本事挣钱，提供他人发扬爱心的素材，共同构建和谐社会。
            我们贩卖的商品是『吉利话』『人气』『爱心成就勋章』
            佛门化缘，庄周渴水，儒生谒官，大家都是叫花子
                所谓佛法，其实就是精神胜利法。无视实际，空想自豪，以为『大丈夫』实则可悲至极。
                国破家亡(慕容复?)，只能靠精神胜利法安慰臣下，一起要饭。
        奴门
            学成文武艺，竞争当奴隶。
            习得一身技/练就歌舞艺，抢签卖身契。
            立志成大器，先学搞关系/拍马屁。
            吃不到葡萄说葡萄酸，嘲讽我们的都是求为奴隶而不得、心怀怨望的人。
            考试的目的是什么？若是他人强加的考核，怎么应付过去都行，串通作弊实属正常；若是自己检验知识掌握的程度，则无需为难，不必备考，也无需奖惩。竟然演变成父母、学校、政府、商家的大型军演，搞得乌烟瘴气莫名其妙。为何而学？被迫而学；学些什么？任凭安排；知行合一？应付考试！--古之学者，为己；今之学者，为人。
        躺派
            吾辈当自强，夜夜当新娘。
            化身为栋梁，躺着也飞翔。
            --什么？这挂还得手动开？开什么玩笑？！这么麻烦，和拼命努力的勤快人有啥区别？！我只想躺赢！手眼脑都是不存在的！
            睡觉时、失眠时、特别是工作时，才能认真地思考严肃的问题，闲暇时间及其他时间脑子瘫痪，人生在此时没有被定义，仿佛游荡的鬼魂，可见i工作时间是人生最宝贵的时间之一，应该不遗余力地提高其占比。
            努力奴隶
            『努力』是多么虚妄的人造概念，阳光空气水温度无数苛刻条件下人类才能活在地表薄薄一层的一小块区域，哪怕距离人类生存空间最近的地下、海底、南极，也是生存禁地。说白了跟粪坑里的蛆虫一样，生存全靠老天爷赏饭吃，明明是躺在矿上全赖于此却偏偏说什么努力，搞得好像凭本事活着似的。蛆虫躺着就能活，人也一样，如若不然，肯定是人口太多。我只愿躺着，活不下去就当为减少人口做贡献。
                --这就是『领袖』？我以为带头啃草就很过分，没料到还有带头吃屎的，我果然孤陋。
            没有灵魂的打工人--工作时间，是由别人的意志在支配身体，或者说，出卖肉体使用时间。打工人没有灵魂。
                相信是私情，责任是公义，还是得按章行事。
                社保、高价房产、贷款...，种种举措，旨在将人焊死在岗位上，诚惶诚恐不敢离职，战战兢兢看人脸色，人形而非人，徒有人形。比如教师，担心开除公职，只能照本宣科，不论规定合不合理、适不适用具体情况，真莫得感情。
                艺人、天王巨星，也是打工人，没啥不同，就只是个印章画皮提线木偶，没有灵魂。
                鱼与熊掌:官僚个人魅力信誉权威vs制度严谨权力制衡监督，两者不可兼得，制度越健全森繁，公务人员越像打工人，说的话越不管用，越发没有人性。类似美国总统出国达成的共识协议，回国后被国会否决。


    无耻啊无耻！这首诗的原貌是…。大家都看到千年前有个无耻之徒剽窃我的大作，更可恨的是乱改，好好一首诗给改得面目全非，欺世盗名，享誉千年，我，原作者，要控诉他，揭穿他的真面目…

    空间戒指...你说的是这个轮胎/呼啦圈？
    系统任务:无条件维护师长尊严，镇压弟子言行
    大白猪-情定三生始乱终弃:--拜托，你再白富美，也只是一头母猪，看清楚点，我是人，种族都不同！--变成人，就嫌弃人家，呜呜...小蹄蹄锤你... #不要卸妆，白珠！
    腐鼠-竞拍争夺-还渔翁觊觎，白给都不要！那可是 三年高考五年模拟/舐痈吮痔的机会！争着抢着出卖自己。
        一本《三年高考五年模拟》出现在异世界，无人看懂的神秘字符，被人认定为天书，夺得者孤注一掷废寝忘食苦心钻研，
        近距离接触，一股淡淡的少女幽香扑面而来……是洗发水和沐浴露的味道。--from:煌煌天道无上剑宗::第一百二十八章 外形
    只见一少女走来，年芳二八呃至九九，脸上有两眼一鼻，长着一张人脸，体态也像人。
    灭世大魔头--威压村西幼儿园的独裁统治者
    门派等级认证--走后门很合理
    --怎会是如此彬彬有礼的人？--你没见刚才的嘴脸，现在赢了自然『有礼』。
    炸弹人--受到虐待，寿命缩短乃至自爆。
    口臭倾人城，脚臭倾人国
    顶级封号:傻逼，挂逼，怂逼，阴逼/音逼(bgm)，苟逼/狗逼，逼逼，...
        苟，就是正义，苟，就是永生。苟，就是胜利。
        我就是挂就是我
        众人皆笑我，但我偏要证明，即使是开挂，也同样能走上巅峰，一拳打爆你们这些努力怪！
            口中说着努力奋斗，背地里偷偷开挂；口里说着公平正义，背地里靠更大的权势碾压；…
        开挂不过是钻空子，而我却是漏洞本身！就算你是挂逼，今天我也要你身死道消。
    公平:
        据说能裁定善恶对错的神器，其实只是作出随机判定，一半概率全杀，四分之一概率杀被告，四分之一概率杀原告。为何可以维持秩序，构建和谐？只因为公平。当死亡公平，生命价值等同，连无能狂怒报复社会都被公平正视，世人岂敢讥诮岂能漠视？

    通货膨胀:若演习不提醒『这是演习』，则非演习需要强调『这不是演习』
    一个组织存在的意义是什么？总不能只是天天拉人入伙。是搞传销搂钱，是抱团取暖，还是联盟搞垄断，总得有个明确的目标。
        养成流:第一强宗，第一强国，意义在哪？活着只是为了活着，变强只是为了变强，长生只是为了长生。
            不进则退，一切努力只为留在原地/保持原样。
    盲操作:
        莫非要盲炒菜？！厉害厉害！
        莫非要盲放屁？！
    --快...放...下...我...--深陷重围我亦不弃！--(别抓着我甩来甩去！)
    --不仅亏了里子，还丢了面子。得了便宜，别人还要在背地里管你叫狗大户。--是不是冤大头有什么关系？我会向上向上一直往上走，些许蝇头微利不值得低头一看。
    反对歧视秃子、地中海！影视作品中常常出现秃子打手、秃子反派、秃子黑社会、秃子不良少年、地中海小丑！故意丑化秃子！用心险恶！还常伴随着歧视纹身！企业招聘员工甚至会以此为由明目张胆歧视秃子、歧视纹身！我们需要一个秃联！断发纹身，本是南越地区的传统文化，是重要的文化遗产，有的人挟洋自重，制造人民内部矛盾，歧视各种优良传统，歧视狗肉！歧视秃子！歧视纹身！
    掩臭液！从屎里提炼出来的的精华，有机黄褐色，纯天然无污染！集齐万千臭味于一身，浓缩高度浓缩再再极限浓缩！效果显著！不论你的口臭如何熏天，不论你的脚臭如何倾城，不论你的腋臭如何倾国，轻轻一喷，尽掩体臭！品质保证，绝对在旁人察觉到你身上的体臭之前将其迷得晕头转向，不能自拔，自此以后告别嫌弃的目光！掩臭液，居家旅行杀人灭口必备良药！

    原谅绿--被逼或被瞒着吃屎，自然还无需被苛责，但你一脸高兴真香，甚至还蛊惑他人品尝，甚至于不允许别人批评，甚至于要求大众鼓励支持赞美，这就过分了。
    救世主之名:--救世主！你一定是作神派来的救世主！拯救了我们的大英雄，请问你是不是弱智？--抱歉，我是傻逼。--你欺骗我？救世主名为弱智，不是蠢蛋、白痴、糊涂、二愣子、智障、脑残、痴甚…也不是傻逼！胆敢冒充救世主，罪无可恕！

    虚情假意，影帝飙戏，人人如此，真心能值几毛钱？#唯有套路得人心
    心心念念分猪肉，猪肉一斤多少钱？
        一斤百六十钱？
    奇葩:『走咗啦』、『吃了饭上路』，因为忌讳不吉利的字眼，硬生生用别的正常词汇替代，导致原先正常的话都会产生歧义误解不满。这些看似正常的黑话，要是听者不理解，说了等于没说，甚至可能更糟，既然不能传达意思，则无意义；要是听者也懂，也还不是脱裤子放屁，直接说『死』字有何区别？
    这就是经典的攀比炫富环节吗？赶快开始你们的表演吧，我很期待装逼反被操的打脸大逆转桥段！
    我老爹比令尊更显赫，我老公比你丈夫更优秀，我儿比令郎更出色，你拿什么和我比？
    欲望诅咒--对着图像、石像、牛羊、树木等发情。
    生死一剑:--我终于做到了，胜而不伤。(一剑斩断对手武道，虽然没有受伤，但功力尽失，自高空坠落，摔成肉酱)
    --身家十二块两毛钱的你，没有资格和坐拥二十元七毛的我对话！
    --这哪里是我们普通人能干的？并非做了了不起的事才成为了不起的人，而是只有了不起的人才能做成了不起的事。此子不简单！必是傻逼转世！恐怕不止上辈子，上上辈子也是傻逼，傻气深重，恐怖如斯！我们太机智太，完全不敢尝试。只有拥有傻逼之心的人，才能倾尽所有无怨无悔永远践行朴素平凡的道理，不计成败。傻逼之心，这是何等天赋！非吾等凡俗所能望其项背。
    --竟然为了这么微薄的工资拼命，我算是知道人命值多少钱。
    --大陆？这明明是个村子！还世界大战呢，明明是村民械斗争水渠。
    --搞得我以为要拜堂，原来是拜师。
    --不必厚此薄彼，一种是尝试，另一种也是尝试，实践中或许会根据成本等实用因素分出高低，甚至完全摒弃一种，但本质到底都是一样的，人类乃至所有生命的整个存在，就是一次伟大的尝试。
        正源于邪，邪归于正。
    --成仙有毁天灭地之能？我要毁天灭地作甚？
    --成功了，他终于做到了！以前总是会切到手指，如今已经多久没有受伤了？功夫不负有心人，他终于做到一心二用，一边切菜一边发呆！
    --虽对手很强，但我觉得应对很容易。只有拔剑挡住，再立刻反击，就能击败对手，十分简单。要是我的手能跟上眼睛就好了。

    --恐吓无效，咋办？好比作势拍向苍蝇蟑螂，苍蝇蟑螂不逃，难道真要拍下去？看着眼前小鬼淡定偷吃，浑然不顾主人家一路怒喝赶来，也不知咋整。
    无下卑者
    草圣:一句话不离『草』字
        --不能生育何故结婚？难道是见得别人放屁自个便也要憋出屁来？--说的也是，又如，为何无端爱慕美色，对面容斤斤计较，明明操的不是脸。
        瑜伽-挨草功法
        性vs伪
        伪圣:
            人为伪
            人为皆天成
            作为首领，人们并不在乎你的真性，只在意你的作为是否符合主流想象中的首领形象。磨去棱角，翦除爪牙，泯灭个性，矫饰为圣，天真成兽。
                --沐猴而冠，变成圣兽？
    --你明明说过『先天之物不可毁』！--我没有，我说的是『后天所成，后天可毁』
    ]]

『百年修得同船渡，千年修得共枕眠』一眼看上去，似乎有毛病，站街女怎么说？大概就是生生世世都和同一批人深入友好交流？
--你不是很喜欢做菜吗？经营餐饮不正是你的理想？怎么又要转行？--理想和理想是不同的，以前是觉得无缘航天业，如今既然有一丝机会，自然要倾尽余生。
圣贤？不事耕织生产，却衣食无忧，良人奸人？
    人间无道出圣贤
探索是探索、集成是集成、教授是教授、研发是研发，好为人师也没什么，只要不是扭曲事实胡说八道就行，也不必要求为人师者要多高造诣。
徇私枉法:既然无法通过正大光明的途径解决问题，人们就会诉诸私刑。

恶骂泥坑国
你拿着的这把...就是你的承道之器证道之宝？
是是，观众、公证处、...，统统都要换成我们的人。

神奇:玄幻小说终究是人写的，还是得讲科学道理，现实可不需要。随随便便一堆杂乱无序的化学反应，就能够让一团有机物维持自己的结构，修补缺损，还能复制自身，甚至在复制过程中微调以更好适应环境。突然就有了感觉器官以及配套的神经系统，能看能听能嗅，能光合作用，能游能跑能飞，会猎食会伪装，会反省会交流，生火畜牧农耕修仙问道。生命、感知、思考，这才是真正的逆天崛起型爽文，真正的脑洞大开瞎编乱写，相信时下流行的科普观点的人，与千百年前的相信神仙妖魔天庭地狱的人相比起来，只怕更迷信更愚昧。毕竟封建迷信再怎么不合理，相较而言却更平实朴素可信，时下观点太过魔幻，当不得真。
升米恩:容忍别人发展，但是发展起来后只怕就该要嫌弃生存空间狭小了。
    门当户对:假设甲方对乙方有恩，甲方有所求，乙方答不答应？若生争执，又该如何摆正心态地位？假设甲方有能力提携乙方，甲方该不该伸手？身份相差太多，之间长久相处，必不可能平等，理当提前规避这种局面。
炼精化气，炼气化神，修仙短命，就像火箭升空，剧烈地燃烧自我，上不着天下不着地，变不成星辰变烟火。
    一条路是死路，另一条路也是死路，你怎么选？
    血食天下:炼化自身精气，当然短命，但若炼化外物，比如他人精气又如何？草木吸纳日精月华，牛羊草食，虎豹血食，帝王牧民成神，修仙者以万物为碳，邪道？正道！
劳动改造，对精神病无效，所以被精神病打了也是白挨打。谁不害怕？


和光同尘:既然言行不一卑鄙无耻是常态，何必激愤？不如与俗同流，合群表演，亦是人生乐事。
藏得太好，别人固然难以发现，只是必然对外界信息的获取不足，只怕连自己藏身处是否被发现也不晓得。

既然在意胜负，就当尊重规则；既不尊重规则，何必在乎胜负？

--我好歹摆明了身份，你扮猪吃老虎，你不守道上规矩！
--虽然不入三甲，却绝对能被列入前十！--到底有几个第十？

疯狂？我不得不如此。
    --现在就动手！...你会后悔的。以弱胜强？不，待会儿，会有更多潜在的敌人过来，这也是对方还不发难的原由，说到底，要怎么安排你还得大伙商量，独自解决你过后将解释不清楚。怀璧之罪，哪怕只是有嫌疑，立刻动手，先灭一个，威慑余者，方有生机！

树木难以移动，动物种群也会长期滞留一地，少有真正意义上的迁移，更多的是分株式的扩张。适宜的居所谁会遗弃？

--这本小说里广...--(植入广告)--...告也忒多。卧槽！不能等...--(植入广告)--...我一句话说完整吗！

赞美作神？既然我们都是作神的意志体现、提线木偶，那岂不是作神自吹自擂给自个看？挺自恋的。再说，不信作神、诋毁作神，亦是出自作神的意志，再正常不过，何罪之有？看来罪源自于某些人私定的规矩，以私定的规矩判作神的意志有罪，原来大伙是同道！


人兴奋就会手舞足蹈，人激动就会高声呼啸，本来只是自然而然，如今被冠以舞蹈歌曲艺术之名，毁誉如影随形，反使人束手束脚低声细语，永失天真。何以自此？人之害，莫过于人。
    沉默不是艺术，因为艺术源自爆炸。
别人请帮忙的叫帮忙，自个凑趣强行帮忙叫帮倒忙。
政党:个人，势单力孤，行为难测；组织，利益纠葛深，顽固不化。

修为境界提升，对天地大道的理解更深，带动悟性灵根资质全面提升。入门资质高，只相当于初期便有更高境界的资质，但并不会水涨船高，境界提升后就扯平了。
寿元增长-拉橡皮筋式-只有剩余的寿元按比例增长--只剩一天的命，就算寿元翻倍，也只有两天。
楼观派:不断建楼，不断拆楼重返平地，重新选址，重打地基，重构蓝图。
    --又是打了小的来老的的扮猪吃老虎套路，反派到底有多蠢？...不行，太嚣张了，必须给他点颜色看看！
    动摇仙子:于己不断重塑根基，重塑之前自当彻底摧毁，于人则是摧残对方的信念道基，毁灭即是新生，赐劫法模仿天地人三劫中的天劫，是引导弟子的法门。

门规
    不能合乎门规守则，默认自动退出门派
        :门派离心力大，没有戒律惩罚
    禁铺张浪费
        :万恶淫为首
    事无不可对人说
        :生活区、工作区、通道、一切公共场合，开放并永久存储监控录像录音


邪道功法--将修炼过程中乃至施展中需付出的代价转嫁给别人去承担。--天才的构想，血腥的具现。


三国时期，杀伐过重，人口凋零，为防止这种情况再次发生，研究高阶武者参与战争。三国之后，武者更注重个人修行，不再轻涉纠纷。
    练武既然无用武之地，为什么练？


你这是典型的自我意识过重，放宽心，就算你整日整夜在荒无人烟的地方闲逛，也绝对不会有人贩子来拐卖你，不会有挖肾的来放倒你。倒是该警惕信用卡和财路。



辞，达意而已，你既能听懂不就行了？为何要抠字眼较真？

腌制熟肉后，肉质一改硬韧而变松软，骨肉脱离。

--当初人少情况特殊，下厨就由我包办，现在门派发展起来，也该轮值分担，不能只逮着我一个薅羊毛。--那就民主投票表决吧！

大道独行
    上天可以赐予你至高的资质、无敌的气运、惊天的出身，自然可能在某一天统统褫夺。由天才沦为废物，由心想事成转眼诸事不顺，由高贵而成贫贱，由年富力强渐至年老体衰。我依然故我否？失去，不曾拥有怎会失去？
    人道也是道，非得区分天道人道，只怕未可见真。本当万道归一，偏偏走到孑然一身，...

天材地宝:--凭什么人类吃了就会死？--撑死。
在投降和血战之间疯狂摇摆，最残暴的敌人秒变最怂，最怂的秒变最凶恶，实是因为这两种人根本就是同一种人。
后宫图:虽然已经收集了三千美娇娘，但还缺少一个太监，请主人屈就。

死去的钞票--它们并没有死去，只是在流动。
我连生我养我父母的死活，都不在乎，会在乎你的感受？

婚礼-你可愿意
    你可愿意，成为奴隶，勤快听话，任劳任怨，任由对方规划你的人生，上贡所得，乞讨过活？
    你可愿意，乖乖听话，陪做各种不知所谓的事，争着表演形式主义的仪式
    你可愿意，
    你可愿意，
    你可愿意，


潮流时尚 过时 大三件小三件，有屋有田，有车有房，，为何众人代代追逐明日黄花迷途不悟？

不结盟也得搞好周边关系，邻居遭灾受难难道便袖手旁观？条件允许的话，还是得援手一二。结盟了不还是得自力更生，不能老拖后腿，也不能放弃观察思考。结不结盟都差不多


肚子不适-强行打嗝，排出肠胃胀气

不许人间见白头
    英雄莫问出处-英雄莫问归途-于谦怎么死的？戚继光怎么死的？
    土嚣，休承暗，皮焚西



力量，到底是成为我作为一个人的工具，还是使我超越人成为非人的要素？我终要作出选择。

生命并非只有胜利才有意义，失败也无妨。
文娱作品到底只是消遣时间的东西，问题是人们为何有这么多时间浪费在这方面？或者说，人哪来那么多垃圾时间？人们已对人生失去所有期望了吗？道途断绝，为什么？为什么还能安安静静若无其事岁月静好？


喜欢台风，让台风来得更猛烈些吧！


一曲灭杀心--无法再杀人？这到底是生病了，还是病治好了！



地球是一颗小石头
    石头可以生火，石头可以开花，石头可以诞生万千生灵。


海禁
    封禁，可能只是在搞垄断。


体味有异，自己难察，用用香水，虽欲盖弥彰，至少安心，也算合理。
造谣诬蔑、文过饰非，钳制言论，众人都知道有问题，有大问题，但不知详情，难以互通有无，道听途说也难辨真伪。
地下交易哪来的保障？诚信？追讨？仲裁？
  破坏黑市:地上的卡片、墙上的电话(美女上门、办假证、收车分)，警方参与发布虚假黑市信息，打击黑市顾客...


首席:①最尊贵的席位：坐首席｜第一排是首席。 ②职位、级别最高的：首席代表｜首席裁判。
chief n. 首领 adj. =main 首要的
    首席代表:chief delegate/representative
    首席法官:chief justice/judge
lead vt vi n adj
    首席工程师:lead engineer


xxxxxxxxx

]]
[[[
找死之道
    死神之约--见到我就注定你形神具灭。
    东方无知找死佛



剑宗->贱宗
    信仰崩溃之后


肯定会走到你前面？差一步就是差很远。听着眼前老者的溢美之词，心想恐怕对方年轻时也正处在自己当前的位置。


杀富济贫，听起来有点理亏，站不稳。上了剩余价值，凸显阶级矛盾，一下子就理直气壮起来，对于壮大革命队伍十分关键。可见说什么怎么说，之于人，就如朝三暮四，之于猴。


期望，对未来的预测，甚至可能比生存现状，更影响人的心态。革命年代，团结一心，相信理想必然实现；改开年代，不想生娃，相信生来只能当房奴。

光之响应--互动型法术

气球压力平衡
    狮子搏兔？鬼扯！只有处于危亡险境的弱势方才会别无他选孤注一掷。强势方对手多，还得顾忌逼得太紧致使众多弱势方联合起来对抗。培养接班人，也需要在资源受限的情境下进行磨砺与竞争。
    何不食肉糜？
        --既然缺水，为何不迁徙到水系丰富的区域？--迁徙你妈逼！你当这世界还有宜居的无主之地？！--压力...向往宜居带，人口膨胀往外推。


    杀生不死
        不限制人口，只是资源丰寡反复，兴衰更替；限制人口，人类灭亡指日可待。
        运动会消耗能量，生物趋向偷懒，但是运动减少，身体毛病更多，只因生物皆有额定功率，大部分都不低(除了树懒之流)，达不到就要出故障。



投降？伪装？亡灵/蚂蚁 既然以数量取胜，那就伪装成敌方，伪装成环境，成为不被攻击的被无视的存在。


呼风唤雨、召唤陨石 之类的法术，显然受临时环境状态影响极大，威力波动幅度大。当然，观测环境预测威力再决定用不用，何时何地用，能降低随机性。



我就是真理
    --智者无情，谁最冷酷无情，谁智力最高！--？等等，且不说『智者无情』对不对，就算是真的，那也得不出『无情者智高』的结论吧？--大伙看看，都什么时候了，你不忧心忡忡火急火燎，居然还有闲情逸致揪着不知所谓的话题不放，鬼扯一通，到底是有多没心没肺？毫无人性的家伙！



世界很大 之 风俗各异 格格不入
    待客以平常，客人以随意处vs待客以珍爱，客人以慎重处
    外交矛盾


你以为是另类、是变异，其实不是，很普通，只是比例少，被观察到的概率低。



离坚白
    你以为针锋相对，非此即彼，其实风马牛不相及，说的是两个不搭边的情形。一方坚持说石头是白色的，另一方坚持说石头是硬的，互不相让，拼命诋毁对方。我完全不知道你们在争论啥。
    一切人文皆为生存服务。若是视死如归能使族群更好的繁衍下去，勇敢无畏就是高尚的品德；反之，对怯懦苟且顶礼膜拜，同样理所当然。名为实之宾，万变不离其宗，纷繁复杂的表象尚不足依凭，更何况是据表象而生发的论断？


学而不思
    博闻强记的人，反而更容易被过时的观点误导、被繁杂的事例迷惑，多，仅仅只是多是不够的。





-----
疯狂
    巅峰已过，三十许的扛把子已经看到越来越虚弱的自己，被手下撕成碎片，如同当年自己所做的一切。杀戮、扩张、不管是不是敌人甚至自己，都死吧！

天人无知 之后
    --智慧生命！我终于创造出了智慧！我是神。。。--竟然是这样的，本以为泯灭无知，谁知化身亿万，成为各种奇怪的生物。


心慈手软
    此情此景与当初何其相似？只不过昔为鱼肉，今为刀俎。当年大师兄发现我修行的机密，却放过我，我原以为是他误解了其中潜力。而今生死大劫逼近，方才明白，当年大师兄崛起，已被师傅盯上，难有幸理，留下我说不定还能给他报仇。眼前求饶之人，渐渐与曾经的自己重叠，后来我灭师成就金丹，眼前之人会如何？目光轻轻略过放他一马。

愉快的旅程
    --这是什么花？
    --没见过！
    --这是什么草？
    --不知道！
    --这是什么树？
    --不认识！
    ...什么河？什么山？什么鱼？什么鸟？什么人？什么鬼？
    ...
    --真是愉快的旅程！
    --？？？
    ...
    --（只想让你明白，纵然隐瞒得再好，我已发现了真正的你，此乃人生乐事，可惜却也是我生命最后的自由时光。自此以往，我将非我）


断根
    如果是这样的修真界...不要也罢。
    走我的路，让别人无路可走。
    ---
    大道独行
        终究是要分道扬镳的，幼年情分少年同志如何比得上当下的师门如何敌得过阶级利益？

误我多年
    这些年来，在修真界碰的头破血流，只因为相信大部分正道门派必定如师门一般正直热心，兜兜转转许多年也没能请到帮助自己报灭派之仇的势力，大派小门皆无动于衷，...
    你也配姓赵？
        --没有凌驾众生碾压一切的实力，凭什么自称正派？--原来连正派都算不上...

金丹不见面
    大道根基，不朽金丹，相逢即是劫难。

信任是无畏是勇气，不是盲目愚蠢。

明明是四处游荡逍遥自在的算命先生，最后却成了一派老祖，真是人间惨剧。


即使易如反掌，我需要一个出手的理由，说动自己，也信服旁人。世间琐事万万千千，此一事又有何不同，偏要我出手？

作弊者大对决
    --作弊的获胜者在心中讥讽你--关我屁事--你还要按规矩赐福？钻你定下的规矩的漏洞，将要骗取你的恩惠却还不领情蔑视你 我都看不下去！--关你屁事

大抵被视作私人财产，与牛羊无异，你以为自己在养家糊口，其实只是下蛋公鸡产奶公牛，牲畜的经济产出谈不上付出奉献，正因为搞不清自身定位，才会导致家庭矛盾多发。

不加劝
    把他们当作一个屁就是了，难道还去闻闻香不香？

自称百年老店，价值却比不上地皮十年来的增值，到底哪来的傲气？

半大的小孩，还真是没点惹人讨厌的自觉。这个时期即非懵懂无知，偏又不够稳重，成事不足败事有余，没经过社会毒打，太想当然，做起恶来毫无底线，难以预料。

祭祖
    这样的场合下思索这样的事情，恐怕有对先祖不敬的嫌疑，当下收敛心思诚心祷告:先祖不要与小丫头一般见识！--祭炼山河::第0180章 祭祖日
    --不至于，不至于...(透视神魂，旁观技术指导手册)怎么花样比我当年还少？难怪几十代后只有区区不足百万族人，都是些不干人事的不肖子孙。

官迷和赌徒有何区别？

逆天轮 无相功
    --复盘无数次，为何才首次发现此人？必须重点关注...(不可挽留地淡忘)



魔体反噬？修为境界不能高于肉身境界？不能忍。
    血脉、宝物，一切外物实有害修行。临死之前，统统废弃。夕死可矣。


可以失信于天下人，不可失信于自己。
修真的一万种死法


你骂谁娘炮？！...咦？我本来就是...


灵气衰竭<<==万物为炭


剑魔
    #没有买卖就没有杀害
    --小女生而先天有缺，我将她带到这个世间，便有责任照顾她，给她一个完整的人生。
    ...
    --何必株连无辜？
    --为虎作伥，天下谁是无辜之人？

--我就是你说的那个『名字很难听，该不会是拿双亲姓氏拼凑的吧？相当凑活』的家伙。--你不要自卑，父母没文化的锅不必强行背。

于平地起风暴，处逆境如良机，临巅峰而更进。


人道杀伐
    既然拼天道拼不过，那只能从人道入手了。神道是人道的分支，可借由神坛与信徒将之强行捆绑拖累...
    你在跟我说话？

断子绝孙
    后裔出世会分割气运，成长还会不断汲取。
    有的生物生完卵就可以死了。哺乳类动物麻烦点，还得将娃拉扯大，后代一能独立，也就可以死了。
    人道并不需要个体长生，长生不死的老东西占据太多生存空间，将不会有新生代降生。
    人道并不需要和平，固化的利益集团...

师兄你死的好惨
    我又死了？
    --捧？--你记得重复我话里最后一个词就行
        --咱是有背景的人--背景！
    健忘
        作证
            你谁啊？不认识！
            ...
            修行嘛怎么能受外界影响，怪我咯

和谐世界
    和平精英
    祝你全家和谐。祝你全家女性荣登公主皇后之位，...
    和谐你全家，和平你国
    我一定会爱了你！
    亲亲抱抱

界神人虫
    肠子
    两口:进口+出口
    界=无进无出
    神=无进有出
    人=有进有出
    虫=有进无出
    ##
    相对性概念:神上有神，虫下有虫

吃草-炎
    拓展生存空间，丰富食物来源，降低依赖高度，生存更有保障。
    第三层楼什么情况下会塌陷？低层房间崩毁少量没问题，但不论第一第二层，任一层全毁，第三层也别想要幸免。
    让我们吃草？！
    虫子个体弱小，但作为一个族群，并不。若有一天人畜灭亡，而虫子仍在，我不感到惊讶。什么是强大什么是弱小，谁强大谁弱小，可不是我们自以为是说了就算。
法天象地:
    身融天地
    气运界视图:聚拢气运，成就气运巨人


路，都一样，没有更快的路，没有更方便的路。坦途嫌长，险径也远，漫漫长路，谁说快意？

人品、品人，吃人，吃人者的评点。

身具大气运，可当作幸存者的想象，也可当作未来对过去的干涉。过去影响未来，未来自然也会反作用于过去--反噬原理。从前往后看，天选之人；从后往前看，自选之人。
    危亡时刻，是否有坚持公平公正的必要？
        --失去未来，现在便无意义。
        --现在不保，没有未来。

黄白-过犹不及
    是除恶务尽，防范于未然，还是等到罪行出现，证据确凿再判刑？是欲加之罪何患无辞的莫须有，还是坐看杀人放火我自闲情逸致井井有条？

惨剧-我不甘
    --(看着眼前的人间炼狱)有怨？--我自无穷蛊虫尸海中诞生，我与天下医道强者相抗而不夭，生来便遭奴役驱使，未得片刻自由喘息，未享一瞬安宁闲暇，历经磨难愈战愈强，怎可甘心与宿主同亡！天道不公！为何负我！--确实是惨剧，只是世间太多，也就不算什么事了。


傻逼神拳
    --天下傻气共一石，我独占十六斗，诸君倒欠九斗！--是你是你就是你！原来你就是生命之光智慧之源！
    --退~~！化~~！！返祖！--啊！变成了猿人！智力-3，力量+9，敏捷+15！--我长毛了，也变强了。
    大家好！我是走后门进入终审的权大大，...
    --是高贵的智障一族！纯血的！

    绝杀吴姐
    妈蛋神
    相机行事
    万人奇迹
    逗天一乐，笑口常开
    蛋是，秃然，我变聪明了
    --啊！赞美作神！作神您放的屁香极了流芳百世！作神您拉的屎比黄金更闪眼更不朽！--放肆！该死的异端！作神绝不可能拉屎放屁！--那他要屁眼何用？--作神没有屁眼！！

    茅房之神/厕所所长
        --大道横陈，世间最大的宝藏就在眼前唾手可得，劳劳碌碌所求何事？--也在这阴暗狭小的牢房中？--道在屎溺之中。
        --目光所及，日月星辰，这方天地只是一具尸体。你们这些蛆虫为汲取到的一点点营养而沾沾自喜，自以为了悟大道，何其卑微。活着的时候也未必如何，死后更是只留存糟粕，得到越多失去越多。

    香水是为了掩盖身体散发出来的的恶臭，可想而知用了香水的人体味如何。天天变脸换装的美人，到底也是在掩饰不能见人的真相。

龙生九子，龙是生不出龙的，或者说，龙不是生出来的。

--你们一群开挂作弊的家伙，说什么『要努力』？！--这其实是本讽刺小说不是励志小说，没毛病
    修真小说 即是 非修真小说，没有金手指开挂作弊、没有高贵血脉激发非凡潜力，没有通天背景保驾护航、没有逆天气运瞪谁谁怀孕，狗尾巴草变不成水稻。


未逢一败
    败了又如何？会死？

什么最重要
    活着:一切人造之物:评价标准、信仰坚持、工具智慧、展望想象，皆只为『活着』
    薪火相传
    不朽意志

做选择的，是术；不做选择的，是道。

人道 之 神道:
    三代:
        第一代:不以神道为根基，神道力量只是因众人膜拜香火缠身偶然获得的
        第二代:神道生灵，因信仰而诞生的生命，与第一代相同之处在于，两者都是非自觉的神道修行者，不同之处是第二代完全以神道为根基
        第三代:自觉的神道修行者，以神道立道，研究前两代的特点，自觉探索神道，不断尝试各种可能，信徒对他们而言与牲畜无异，只是财富象征力量凭证实验耗材。



泰山府君-慧-以直为剑
    临终审判
    结草衔环，含沙射影
    有恩报恩，有仇报仇，不待他人/来世
    以执念强留鬼魂，自己动手
    vs 轮回地府
        孟婆汤，前尘皆忘
        一世情一世毕，不拖泥带水，缘合性空
        面朝大海，春暖花开

    这是是本严肃的搞笑小说，请大家不要太认真。
即使是敌人，我也绝不食言。难道告诉盟友与下属，欺骗是被允许的，甚至被赞美并提倡？
    用来对付敌人的手段，理所当然地会被用来对付『自己人』。


--真假也是相对的，并非绝对。对于虚构的角色而言，其所在的虚构世界就是真实的，而我们所谓真实的东西恰恰是虚假不实的。假合者，假不假你说了不算。

大道独行
    良师益友洞天福地皆不足为凭。
    一切例外由青帝承包。
        大道独行？vs众小人集合体
        以力证道:量变成质变
静止不变，是一种死亡；不断变换不断前行，是另一种。

能够生存是因为自身强大，之所以死去却是由于不讲道理。讲道理不能活命，但不讲会死。


概率问题:毁灭易于创建。好的形态少，坏的形态多。

萧墙:①当门而立的小墙：引至萧墙间，见一姥垂白上偻，即娃母也。 ②比喻内部：萧墙衅起｜兵起萧墙，非国之利。




]]]

--师傅的衣服果然镇得住场子
...
--(开门，满地衣物)孩子们乱扔的...




https://user.guancha.cn/wap/content?id=789324&s=fwzxhfbt
丹东袭警案舆论翻车，这很值得深思和举一反三
和气四海得貂蝉
06-23 15:18来自江苏省
现在大家都很懂，一碰就要倒，假摔不但在球场，深圳停车位争议，一碰就倒，不碰也倒，有了标准示范。丹东警察有碰到女子，但不足与让她倒地，但女子乘势倒了，老父亲是老实人，不懂其中的妙处，以为女儿被欺负，情急之下挥手击打警察，警察也乘势倒地，连警察居然也想靠倒地来得到舆论的支持，是我们这个社会的悲哀。


https://user.guancha.cn/wap/content?id=807239&s=fwzxhfbt
为什么西方给老百姓发钱，中国不?
乌鸦校尉
马克思的批评则更为直接：一个有基本收入的社会，没有可能给工人支付高薪。
说到这儿，大家应该很明白了，西方国家现阶段推行的UBI政策，大部分都是想用UBI替换掉现有的福利政策，为政府节省开支的同时，还能让资本家拓宽自己的商业版图，并且进一步压低工人的工资。


糯米 煮粥 好吃。

北帮老面馒头？北方老面馒头


不要太认真，记得扔掉。

擅长？生命中一半的时间在睡觉，另一半时间想方设法偷懒，没错了，我最擅长的就是睡觉。




允许自杀就该允许吸毒。不允许吸毒就更不可能允许自杀。


比较-好运符
  --你最好保佑进入之后不会碰到我！--祝你心想事成！
  --你这好运符一点用也没有，以前逮谁谁中，现在反而错失了！--...
  举实例证明 抽烟喝酒 更长寿(林彪|毛泽东|邓小平？)。那么反之，结果如何呢？


某某宗首徒，连个性化的称谓都没有，怕是要完。

争斗是生命的一部分，沉迷学术也是。我曾因此被人赦免，如今我也会饶恕你。

特等功
  这么了不起，这么高难度，根本不是人能达成，我一直都不信，直到遇见猪一样的队友，才明白，一切惊天地泣鬼神的功绩真的有人能成就，只不过未必在己方阵营。



个人闭门造车，国家闭关锁国，看起来效果不好，然而不论如何着重强调『多样性、开放、交流共享』，将整个地球当作一个小村子来看，依然单质化严重、孤独、封闭，就连战争艺术都如此贫乏无趣，缺乏想象力。

想象-输出永远基于输入-信息不增--？信息守恒？
  想象中的外星人，要么有手有脚有翅膀，再不然有触手。


反驳
    要么是，要么不是。若是，反驳什么？难道要反驳真相？若不是，又何须反驳？难道还要为他人的认知操心？难道还要路人可怜主持公道？

龙，并非血脉传承。它看起来像条蛇，实际上就是。但说它是潜龙，也没错。从来没有人发现过潜龙，你可以说伪装得好，但换一种说法，再卑微的生物也拥有进化成龙的潜力。
种族血脉越强，桎梏也越强。天赋也可能成为天花板，出道即巅峰。


青-圆极
    大俗大雅，物极必反
    极炎剧寒，彻明九幽

神的忠实信徒
    让我想起古代一些笑话。或说要有历史，或说要重视教育。可惜，一切美好的景愿皆可歪曲。
    要先有历史，精怪谣言神话传说泛滥，比没有历史还要糟糕。
    教育，若以顺从听话不得质疑为目标，还不如没有。
    --可是像你这样人不人鬼不鬼的垃圾货色，凭什么大言不惭！还质疑？自以为聪明，笔给你你自己书写经典好了，还用得着学习？

人尽敌国
    一言不合，晋鄙就被信陵君弄死。手握大军又如何？不敌匹夫一怒。身份敏感，就算自己人也得提防。


本来只是家务事，一旦外力干涉，味道就变了。

此疆尔界
    本来无一物
        被污染了，怎么办？消解掉，无物即无尘。

预言中的人
    不，你不是。...恣意暴虐...现在的你...才是。

被奴役者便卑贱么？役人者便尊贵么？漫漫长路，谁是主角谁是配角，可不好说。个人注定渺小，唯有集体体现存在感，个人的丰功伟绩即使万世流传，那也是作为集体记忆的一部分。

生物性破坏--人类 无孔不入，无物不侵
    树木-刀斧之灾

受命于天既寿永昌
    与传说一模一样，肯定是假的。传说本就是凭空捏造以讹传讹添油加醋的故事，赝品越是严格依照传言描述的样子制造，便越是错得离谱。
    谁造谣最有利？皇室。

想看跳舞？看看当下流行些什么舞蹈。不会哎，但耍猴我熟，要不来个蛇舞版耍猴？机械舞版耍猴？

坑爹
  竟然还敢炫耀！？本以为是鬼鬼祟祟的地老鼠，谁知已然是明火执仗的劫掠！
  --宁可真实，而为人唾骂；不愿虚伪，而受人尊重。
  --实诚者不得好死乎？非也，罪不在实诚，实诚也不能抵罪。


说什么脱离，你绝对不是神的子民，现在不是，以前也不可能是！神的忠实信徒没有这么博学睿智以至于质疑经师的教训，你这可恶的异教徒，竟敢反串！


言行不一，重表面仪式无视本质
  佛教-诵经拜佛，以声色求
  共产党-处处体现官僚特权
  自由主义-烧杀抢掠，自由只是挂在嘴边的用来糊弄人的武器

游戏
  更高的领悟对法术更深地分解，按需尝试组合出新法术，(基础不同，目标不同，优化也不同，没有最好的法术)...失败概率，失败反噬


无忌
  血脉检验，只允许自己的后人通过？稍微更改逻辑回路，反转判断结果。不用谢！
  难过那么多先人有来无回...


诞生智慧，由赤裸裸地焚田而猎，改为轮休，使用大网眼的网罗，进而圈养，培育新品种，关心健康问题...
反同即深柜，积德则重孽。
  不作孽，无原罪，无需忏悔，不必积德。杀生吃肉，没毛病。天天放生，行善积德，到底是造了多大的孽！

楼观
  从一丝不苟打地基，苦苦压制境界，到快上快下，鸟瞰全景，试一切错，穷尽所有可能，走从未想过的路。
  九重宫阙从头观

不讲道理？只是不符合你的自以为的道理罢了。
信息共享的程度与信息传递的速度，决定一个组织的体量上限。

取名:贤命长，陶仁贤；茅窖醇

A-既然复活他，为何又要杀死他？
B-失败了，复活的那个东西不是他。
A-我看那就是真实的他，只是不符合你的期望罢了，你要的只是听话的奴隶。
C-是也不是，众念国再兴，既可以说是继承者，也可以说没关系。



说什么把命还给他的傻话。你的困惑其实来自他人。明明是仇敌(废掉你儿子)，却偏要救你，使你陷入恩怨两难的境地。别人的错，凭什么要你来背？

大势力
    大势力如果集中资源捧一个人，那确实可怕。但人均上来说，就全然不同。
    压力平衡
        内部压力平衡
        边界压力平衡
    再强势的势力，也会在不断膨胀下，与周遭小势力达成边界力量平衡
    地盘越大，守军越分散，单位面积上的力量越弱。
    资源越多，生活越优越，出生率越高，外来人口越多，人口增长越快，人口越多，人均资源越少，
    科技水平提高，生活水平只能沾光几代人。
    上古黄金岁月想来确实是有的，只是后人体验不到。

天资过人，无师自通-王八拳，疯魔棍法，乱披风剑法



干一行恨一行
  卖毒品的不吸毒
  开赌场的不赌博
  开餐馆的不下馆子/官员吃特供食品

殉葬品
  唯一的神？它死了。
  胡说！创世神怎么会死？！
  你们只是殉葬品


历史悠久
  靠什么？当然不是人才辈出。有高潮就有低潮，没有一个势力可以在任何时代胜过任何势力。靠的必然是欺软怕硬，该跪就跪。外表有多骄傲，内心就有多卑贱。

交流 犯错
  打做好准备面对自己的愚蠢和愤怒吗？
  打做好准备面对别人的愚蠢和愤怒吗？

失误/不小心
  过于谨慎，只走别人走过的正确的路，固然安全，结果符合期望，但不会有新发现，不会有进步。一个好学生，应当具有好奇心，冒险探索精神，而不是满足于在书的小河里游泳。
  既然对自己的出生毫无规划，又何必对自己的死亡多所设计？
  自杀(消极的畜群免疫，作死的游戏活动)/杀人(主动的侵略，屠杀)，杀生不死，种群的生存规律与社会约束个人行为的礼法迥然不同。



黄-借道
  从未来借来人/物/知识
  天人无知-为什么我会醒来？为什么穿越？
  --等等，你说的难道是我？原来我的穿越并非偶然。


历史有用否？粗糙的类推，符合实际情况否？
  庄周-刻舟求剑/古之糟粕-
  韩非-五蠹:守株待兔-讥循先王之道者-世异则事异，事异则备变
    赏功罚过，功高盖主，武者作乱，五代十国终于以文抑武。
  --
  史记-太史公自序-推崇 春秋


傅斯年-春秋策-诸子-『庄子-天下篇』:
  突然觉得，百家争鸣，也不一定就是思想大爆炸，可能只是书写记录的工具演进，廉价易用，所以相比此前时代，存世言论显得多罢了。
  类似的，佛教也并非自释迦摩尼始，只不过他的弟子恰好是使用新工具的第一批人，『如是我闻』的记录更多而已。
  各种思想源远流长，人类其实未必有多少创新进步。

认命
  『认命』是因为站着的收益小于躺平，反正都是唯利是图斤斤计较患得患失，『认命』即是『不认命』。

青帝
  资源-人善假于物，故此能掌握超越自身的力量。但优点就是缺点，凭恃外物难免患得患失，忧虑资源匮乏，费心费力谋夺资源，嫌贫爱富，自私自利，大迷不觉，战祸频仍，。。。

损人不利己-哄抬物价
  旧势力不能接纳他，外部势力扶植他是将之当成傀儡。简单来说，当前仅有的两个买方开价极低，我们可以去帮忙喊喊价，就当给贫困户送温暖。


错误
  一是方向错，一是操之过急。

取法乎上--适得其反，一旦失败，自弃，无底线
强者就像核武，只能用来威慑起保护作用，一旦主动进攻，别人也不会再有顾忌，越有价值的东西越先被摧毁。


刻舟求剑
  人口增长好不好？
  入侵他国坏不坏？
  无条件地要求杀人偿命？
  任何问题不能脱离实际情况来讨论。
  自卫杀人、见义勇为、执行死刑、警匪交火、军队作战，死人怎么算？交通事故，医疗事故，...
  以百姓利益为重来评判，侵略无道之国也可能是拔诸水火登于衽席。
  古代语境下，人口增长意味着安居乐业，健康长寿，政通人和。
  现代语境下就比较微妙，国家现代化，卫生医疗条件改善，婴儿存活率高，平均寿命长，食物廉价，人口增长极快。以埃及为例，斗地主分田地，提供人民币2分钱一张的能管一顿饭的廉价大饼，人口暴涨，但政策没有长期规划，十分糟糕，即使不断垦荒，耕地也无法承载过量人口，粮食极度依赖进口。可见，人口有隐形的软上限，一旦超过，人与人之间的资源矛盾将不可调和。


众念国
  神笔马良-无中生有？
    其实是 灵性赋予，不是没有代价
    从 众念国 的角度看，就是 开垦荒地，迁徙民众。。短期内 殖民地独立性不高，亲近。同时 短期内 国力下降，若是 过于频繁，呕心沥血，亡国可期。
优待有功之人
  有学问本身没有功劳，但人们期待他们的表现，所以优待，福及学生乃至小孩。
  有的学问功利性不强，但后世可能发现现实功用




仁智勇 三种品性虽然不可分离，但 仁者、智者、勇者 所做所为 却不相同。重点是 价值观不同，同样的场景，同样的彻悟，不同的道路。

  不屈不争，宠辱不惊，遗世独立，没有舞台没有他人
  随波逐流，和光同尘，迁就世界，上了舞台便入戏
  人定胜天，逆天改命，让世界适应自己，就算扮演角色也不能践踏自己的底线

残、病、丑、穷、贱、懒、坏、蠢


生存法则
  没人倾听你的倡议。自己去做，或可引来同好。存在而非发声。

害怕被抛弃？为何如此卑微？这不是正常的人际关系。
  感谢？感谢农夫种植出美味多汁的水果，感谢食品厂生产干净卫生合格的食物，感谢医生药到病除，感谢官员断案公正无私，这是病。

外物
  心法口诀也是外物。指望它清心宁神？
  血统天赋也是外物。指望它超凡脱俗？


一治一乱
  乱世怎么来的？总不能无缘无故凭空冒出来。根源自然在于乱世之前。这么一看，所谓治世就很有问题。治世乱世，只是表象。治世之下，有人获益有人吃亏，有人享福有人受苦，有人作恶有人含冤，不正不公，压制矛盾。治世养蛊，乱世断罪，治世既得利益集团粉饰治世，引导价值观，桎梏大众思维视角。

第一个
  爱得死去活来，只是因为接触的异性少。要多出门多交往，优秀的人遍地都是。阅尽世情，便会彻悟，只有修仙才是出路，什么情啊爱啊，虚无缥缈没前途。

仰慕的人、敬佩的人、想要成为的人、喜爱的人、欣赏的人...不仅可能是不同类型，甚至可能截然相反。

--它为何发笑？--没见过世面，少见多怪，大家不要怼它，要像包容智障一样包容它。


正极则邪
  人至察则无徒

刻舟求剑
  『非我族类其心必异』，是之非之，不问实际，皆是刻舟求剑。
  兄弟阋墙，同室操戈，有斯时。
  族类杀伐，屠戮无算，有斯时。


除非人类死光，从此不再创造新字符，否则，有上限的编码字符集，像unicode，注定无法包含所有字符。本来字符集规模就该无限制。字符的内存表达确实是个难点。可以这样:立即字符 或 大整数指针。靠指针空闲比特位区分。

形近字:
  入人曰日，待侯侍候


无数极品装备？为何爆出这么多？捡起来是成就无敌，还是落得眼前下场？




遗迹废墟:
  数据只增不删，最多是在废墟上重建，但历史一直存在。




三千世缘尽:爱情蛊-消耗缘份，相见不相识，永远路人，路人围观，事不关己，各扫门前雪。

覆巢之下焉有完卵？
  屠戮无算，只为杀你救世--曹操


没头脑是我，不高兴是我，何必排斥？何必困扰？天有不测风云，人也非人自个的私有物，观察自己的喜怒哀乐上窜下跳的表演，也不用太投入。
  又蠢又坏，又穷又懒，讨厌这样不合群的自己？喜欢这样天真蒙昧的自己？
  自重自爱，自暴自弃，都是我，不必强求一致，反反复复，方生方死，人的观点于事实而言无足轻重。
  无端地: 多疑 猜忌 仇视 蔑视 嫉恨

龙虾经过亿万年进化，几十年的打拼攒肉，只为怕是餐盘，你竟然还挑三拣四！

鱼与熊掌
  学识是个人的努力，美貌是上天的钟爱，你说那样更难得更可贵？




名:
  『--每月一日，物稀则贵，小别新婚。保持距离，尊重自生。--每月一日，避免天天劳碌，还有大把时间搞外遇，何乐不为？』
  --小枝小节，未现其要。
  --人各不同：灭世创世，坚韧不拔；破门自立，才能出众；修饰点缀，安全方便。岂有甘愿寄人篱下仰人鼻息者？已然，非不愿实不能。『何不食肉糜』，纯属废话。

  『--卖主只有你，你不要着急。--买主只有你，你不要着急。』
  --玩弄众人于鼓掌之间，这样的言辞虽非废话，却也有害。
  --既然舍得其父曝尸，已说明其子之贵贱轻重，怎能说是我在玩弄？为何人们偏爱虚假厌恶真实？葬礼无论如何都要嚎丧，仿佛在戏台上表演，嚎的人观礼的人都知道是表演，人们不喜真情流露，这又有何好处？



全系最差
  --总有人垫底
  --你是样样垫底！

大梦宗
  大梦谁先觉
  幽-天人无知-再醒-为道日损屡屡失败-建立大梦宗-探索无尽世界
  相互发现:大梦宗vs痕印宗，大战以至于为世人察觉两宗的存在。


人道-传承为重
  黄帝
  ===
  --有了传承，才能突破个人局限，拥有无限可能。纵使人人蠢笨如猪，千万年积累，照样飞天遁地。要有传承，必先有历史；要有历史，需有文字、风者。立巨头--『史官』。
  ===
  --希望从轻发落，虽则罪孽深重，但顾念其先祖披荆斩棘，开拓生存空间，累世承传，人族煊赫有赖此辈，乃人族支柱之一，未可轻易绝嗣。
  --是指恃强凌弱么？赏功罚过，功过不相抵。有功已赏，有过必惩。论罪当族灭，保护即是伤害，勿复求情。
  --人道，传承为重，余者皆轻。功过得失不过一时，众人高兴也好不满也罢，如声散落无痕。刑罚亦不过是维护人道传承的工具，岂能以众人好恶为准？已灭一族，再灭岂可？人道乌存？
  --罪罚不相当，莫非是纵容？杀人者人恒杀之，夷人族者人夷之。若不严惩，人人自危，争相效仿，流害无穷。
  --能禁绝否？我看不能。今日有此，昨日已有，来日再有。即使以灭族重惩，收效恐微，不如另议。

人都一样，人皆平凡
  为五斗米折腰，汲汲钻营，并不更庸俗。
  为民请命，功利千秋，也不更浮夸。
  只是所求不同，大仁大义也罢灭绝人性也罢，人还是人，并无不同。



小说
  老妈曾是天下第一美人，是什么鬼设定？类似，老婆未婚妻之类，统统都是妓女？

  不知所起，不知所终
    没有主线任务中心思想
    随时断更太监




这是心病，不是残疾。消费品也分必需、奢侈。在乎你外形的人，不在乎你；在乎你的人，不在乎你的外貌。



黄赌毒
  合法化？因为地下交易更不规范危害更大？合法化后还能收税创收节约警力利国利民？这不就是议罪银？若是一切罪行皆可以罚金揭过，想必也可减少各种明争暗斗打击报复，黑社会团伙黑保护伞没有存在的意义，前途一片光明。
  ===
  善恶
    『杀人全家成人，奴役孩童及其后裔』与『灭人满门鸡犬不留』相比谁更仁慈？如果允许翻案复仇，岂非逼着凶手斩尽杀绝？实在应该将凶手供起来，歌颂他高抬贵手的品行，足以为万世楷模。

  侵占你家园，屠你父母乡亲，奴役你兄弟姐妹，压榨你剥削你，赏你口饭吃，你当感激涕零，不杀之恩也是恩，不要不识好歹，包吃包住，恩同再造。牢记仇恨的人不幸，懂得感恩的人过得更好，不要盯着过去，要和仇敌之后共创美好未来。

傻逼神拳:
  --作者不公，以愚凌贤！我不服！为何精明计较偏要倒霉吃亏，糊涂蠢蛋偏偏顺风顺水？我意不屈我志不改！纵晓作者偏心，偏要逆作而行！我不信，这世间万千作品你能一手遮天，一生成败不过一隅得失，尚贤尚愚岂能由你！
  ---
  乱披风剑法、疯魔棍法、王八拳

诸事太顺，屈打成招
  诸事顺心，当需警惕。
  有屈打成招，自以为意料之中。
  有处处高歌，自以为太平盛世。
    敌人糖衣炮弹掌控价值观提供便利搭桥牵线
    公仆阿谀奉承大放卫星
    亲友美言或是照顾脸面或是灯下黑或是行外话。
  没有发现问题，才是最大的问题。不知道自己自大自满，才是真的傲慢。

牺牲-多数暴政
  当少数派有异议，而现实只能一刀切选择一方时，会怎样？哪方更强，便会压倒对方。
  抗疫，围封。要么，放任自流，要么，处处严防日日死守。没有折中方案。
  --我年富力强，区区感冒何能惧我？
  --我有钱有势，花钱能治好的病也算病？
  --我怕麻烦怕不自由怕穷，就是不怕死，活着很累很难受，请不要再指手画脚！
  --死亡率怎么低，还没车祸让我惊心，轮到谁算谁倒霉，怕个球！
  --有人怕死，关我屁事！为何要强迫我为别人的癖好做出牺牲？人生有很多重要的事情，娱乐、闲逛、发呆，人生的意义就在于此！牺牲？谁自愿谁去，别代表我！



无数次，幻想拥有超凡力量之后，会如何造福人类，但最终难免大肆屠杀。终究无法相信和和美美，世上必有憎恨我的人，世上必有我不能容忍之人，无法想象没有纷争的世界。我亦不能相信隔离开便能各过各的再不相干，世界很大不能全知，世界很小无处立锥。
只是弱小，若我强大，世人当晓我的残忍邪恶。

就事论事
  --就事论事，没必要针对人。某类错误，虽然不是人人会犯，但人人会犯这类那类的错。别人之道或许确实是很有问题，但谁也未必更高明。
  --针对人，是因为成本。粗筛的成本，公议的成本，专家组队深入考察的成本。


小孩子 频繁无端干嚎 似是不满又似要引起重视
我 经常没由来地疑虑怨怒，莫名其妙，想来大概是老妈带娃的方式不对。

云养猫、云玩家，云游天下？

敏感词违禁词:
  只是字与字的组合而已，能有什么力量？纸老虎都不怕的。

  为何对现实失望？一切都在高速变化，或者说迅速失效过时腐朽。感觉所谓真实的东西，没有一点价值。反而古籍经典，人们细心装裱，仿佛那些死去的言论虚拟的世界，才是永恒无价之宝。真实？虚妄？我都怀疑自己分没分清过。逝水无痕，没有一点点熟悉的感觉，世界是新的，我找不到位置放置手脚，我想我该死了，我，老了，再也提不起兴趣。




煎蛋评论:
  台下都是请来的演员
  没有演员
  演员在开会

最后一句话？
  大意是，你做好做坏，都和我没关系了，自己能承受就行。


小偷小摸，不一定是穷人，虽穷但有自己的活计及清楚相应的消费水平。反倒是，人前衣冠楚楚，虚荣心强，强撑门面，人有我也要有，一旦入不敷出，习惯又无法即时调整，就比较难说了。



质疑真理
  守护贞操--至少那里还是处女地。
  习以为常，赖为凭仗，视逾性命，...



梁祝
  --为什么魔改得面目全非？--悲剧不再是悲剧，人们无法产生共鸣，这是时代的进步！--也可能是退步。

]]]]]


[[[
TODO
太麻烦不值得

ideas:[遗传算法 控制 遗传算法]即[种群竞争+种内个体竞争]，种群竞争级遗传算法 的 个体数据 是 (种内个体竞争级遗传算法的参数+所有种内个体数据)


画画用Krita，修图嵌字用Gimp，做Logo用Inkscape
  只找到Krita#F_Droid
Lua
  termux 已安装
Rust
  termux 已安装
DONE:book of: Rust
  view others/book/lang-Rust-20220624.txt
DONE:book of: Lua
  view /sdcard/0my_files/book/lang/lua/lang-Lua-20220626.txt


[[
TODO
    电子推理发器 价格
    tcp复制book/
    NTT数论变换
        枚举 素数模 M
        2-split 推广到 其他分裂
        置换:将输入的次序置换为FFT所需
view others/数学/FFT_DFT_NTT.txt
view ../../python3_src/nn_ns/math_nn/__todo_NTT.py
view ../../python3_src/nn_ns/math_nn/convolution.py
e ../../python3_src/nn_ns/math_nn/DFT/NTT.py

[[临时:当前桌面:20220822:
e TODO.txt
  #整数分解相关内容未完成
e others/数学/整数分解/factorint.txt
  #整数分解相关内容未完成
e others/app/termux/ftp/ftpd_lftp_tcpsvd.txt
  #复制book/math/到 长虹手机，看论文
e ../../python3_src/nn_ns/math_nn/DFT/NTT.py
临时:当前桌面:20220831:++
e others/数学/prime\ in\ spec\ form.txt
e others/数学/divmod加速.txt
临时:当前桌面:20220910:++
e ../../python3_src/seed/math/floor_ceil.py
  floor_kth_root_ <<== floor_kth_root__bisearch_
临时:当前桌面:20220918:++
e script/seed.math.floor_ceil-floor_kth_root_--E-flbQ.py
e script/min_add_ver2.py
  等价归类:
    割点:乘法拆分:乘法交换律
    出度为1的点可省略:加法交换律
    混合？比如:m*n+1 #不算: (a*b)*c+(a*b)==(a*b)*(c+1)
      局部串并联两端分割
  等价归类后的加法链表达:
临时:当前桌面:20220921:++
e script/min_add_ver3.py

pruning
backtrack
backtrace
ant colony optimisation
  蚁群算法？
genetic algorithm vs evolutionary algorithm
  遗传算法？

py.type: bits, array&mapping
  e ../../python3_src/seed/types/BitList.py

临时:当前桌面:20221026:
e script/min_add_ver3.py
e script/min_add_ver2.py
e others/app/termux/setup4realme/termux-setup.txt
e others/数学/最小加法链.txt
e TODO.txt
e TODO_www.txt
以前未完成的，见上面
  e others/数学/整数分解/factorint.txt
  e others/app/termux/ftp/ftpd_lftp_tcpsvd.txt
  e script/seed.math.floor_ceil-floor_kth_root_--E-flbQ.py
  ...

[煎蛋评论:
图:小丧:如何避免被炒
ron:学土木学会计，因为ai不能进监狱
#11054837
蛋友8fb0b6ba1dc1b8:@ron 再朋克点，为什么要学会计，学土木，我直接去坐牢，省去中间环节
]

idea:加密:密文类似程序:以某个整数问题的第几个最小解作为某一轮某一块的密钥。
idea:游戏:人物属性:修为值:是一生修行积累的体现，当各具特色，由一表达式代表。表达式最大长度由等级决定，表达式内容则由玩家自选，但也非完全自由，每次升级只能更改几个字符。
idea:游戏:属性值=表达式，升级后，允许玩家拓展表达式的长度，或修改表达式中不超指定数量的字符，如果结果不是合法表达式，则算走火入魔。
idea:游戏:技能互斥，属性互斥==>>不存在大圆满的集齐状态，存在无数极大值
  #有依赖，DAG；有互斥，多个无法并存

师傅领进门，修行在个人:开宗明义:辨明是非，就像在漫无标识的大海沙漠中穿行，须得认清方向:生命的意义何在？生存？完美？若是完美，何谓完美？让自己去适应变换无常的外界，还是改造外界来满足不变的自我？
认知的边界:井底之蛙:无论井外是如何辽阔壮丽的天地，人终究不能出井，一切认知只能在虚拟的世界中打转，就如数学，看似广袤无垠，实则万古不变死气沉沉，局限早已注定。

任人唯贤:坐地分赃，利益均沾，拉拢每一代的优秀人才

九流宾客:先秦到汉初有法、名、墨、儒、道、阴阳、纵横、杂、农九种学术流派。指上中下各品的人才和各种人物。
截教
劫教

八流:1.指渭﹑汉﹑洛﹑泾﹑汝﹑泗﹑沔﹑沃八水。
本末源流:源：水源。流：从水源向下游流去的水。比喻事物的主次、始末、先后。
虫流:1.春秋齐桓公不听管仲的话﹐任用竖刁﹐专权乱政。桓公死﹐诸子争立﹐陈尸三月不收﹐尸虫流出户外。事见《韩非子．十过》。后因以"虫流"为死不得葬的典实。
火耕流种:古代一种原始的耕种方式。先用火烧去杂草，然后引水播种。犹言火耕水耨。
控制流计算机:按指令的顺序来驱动操作的电子计算机。通常分串行控制流计算机和并行控制流计算机。机内的数据是否参加运算依赖于当时所执行的指令是否需要而定。其程序执行的速度比数据流计算机慢得多。
数据流计算机:由数据来驱动操作的电子计算机。机内所存储的程序指令不需顺序执行，当所需的操作数据完备时就立即执行。当多个操作同时满足条件时，它们可并行执行而不受程序指令顺序的限制，从而大大提高了计算机的运行速度。
坎止流行:遇坎而止，乘流则行。比喻依据环境的逆顺确定进退行止。
鳞集仰流:如鱼群迎向上流。比喻人心归向。
流憩:1.步游或稍事休息。
流失生:指中途辍学的没有完成义务教育学业的学生。
末俗流弊:末俗：末世的不良风气；流弊：相袭而成的弊端。末世的衰败习气和各种弊端。比喻末世动乱年代的不良社会风气。
迅电流光:比喻光阴像电光迅速地消逝。

源-墟
起-讫
归墟:1.亦作"归虚"。 2.传说为海中无底之谷，谓众水汇聚之处。《列子．汤问》:"渤海之东，不知几亿万里﹐有大壑焉﹐实惟无底之谷﹐其下无底﹐名曰归墟。"张湛注:"归墟﹐或作归塘。"明李东阳《初预郊坛分献得南海》诗:"归虚下有通灵地﹐广利中含济物功。"后喻事物的终结﹑归宿。
华屋丘墟/华屋秋墟:壮丽的建筑化为土丘。比喻兴亡盛衰的迅速。
拘墟之见:拘：拘守；墟：指所居住的地方。原指井底之蛙受所处空间的限制，只能看到一点天空。现多用来形容狭镒短浅的见识。

矩阵乘法链？结合律
平板电脑？价格
]]

]]
]]


[[
『梨花带雨』=>『带』:发现『带』字组词能力强=>收集辞海词目，通过组词数量评估单字常用性。

天子？有没有可能是句读出错？比如：『天/子辛』
小月王，怎么会是个『情』字，明明是个『琑』字。
    suo琑义未详。
    笔顺：一一丨一丨丶丿丨乛一一
上古八大姓、『男女』==>>姓、文字 现世时，当是 母系社会。


金灵圣母、三霄娘娘，圣母、娘娘，有何区别？
?后羿是不是大羿？后是皇天后土的后还是前后的后？后稷？
阿奴？是阿囡吧？
姜尚吕望，莫非是姜姓吕氏？鲁迅周树人？
老板娘，到底是老板他娘、老板老婆，还是老板本身。王母娘娘，这个称呼也十分迷人。
周-抑商-无尺寸之功

TODO:
    多证据->本原根
    NTT使用CRT于多项式系数
    用纯粹CRT实现快速乘法
        制表:快速拓展到 更多模
        PRIMES[:N] 制表O(>N**3) matrix<N,N; int(num_bits==log2(II(PRIMES[:N])))>








ls ~/../usr/lib/python3.8/decimal.py
/data/data/com.termux/files/home/../usr/lib/python3.8/decimal.py
/data/data/com.termux/files/usr/lib/python3.8/decimal.py
cp ~/../usr/lib/python3.8/decimal.py ~/tmp/
cp ~/../usr/lib/python3.8/_pydecimal.py ~/tmp/
cp ~/../usr/lib/python3.10/_pydecimal.py ~/my_tmp/

view /sdcard/0my_files/tmp/decimal.py
view /sdcard/0my_files/tmp/_pydecimal.py
/def ln\>
/def log10\>
/def logb\>
/def _div_nearest\>
/def _ilog\>
/def __pow__\>
/def _power_exact\>
e ../../python3_src/seed/math/floor_ceil.py


xxxxxxxxx

]]
弱类型===开放的并联分支(show/read--repr/eval 不可控，需要 前瞻兼容的 全宇宙统一的 包路径 注册管理)
强类型===封闭的并联分支(show/read--repr/eval 可控)


编程语言
  需明确 面向人 还是 面向机器
  比如: 无用代码
    函数里 声明/定义 的 数据类型，却没有被使用
    不可及的语句: 返回语句/死循环/调用不返回函数 之后 的 语句，分支条件总是『非』的分支语句
    ---
    面向人的编程语言:禁止无用代码，或 需要 手动标明每一个无用语句
    面向机器的编程语言:允许无用代码，或有局部允许无用代码的设置能力
  比如:排版
    面向人的编程语言:可以 强调缩进，可以 短语句块 无结尾标记 而 长语句块 要求 结尾标记 #end-while/def#xml
    面向机器的编程语言:自由风格，允许全部代码语句一行写完，语句块结尾标记越简单越通用则对代码生成器越友好。
  面向人:强调约束
    人手写更容易出错，尽量在编译期排错
    中心化集中化 控制
      比如:haskell开头显式import/expor
      比如:c++类定义的 访问控制区声明标签:public/private
    缺省值，更简洁更少的表达更少出错
    不允许局部作用域变量名遮蔽外层变量名
    ?允许局部作用域变量名遮蔽同层变量名
    『太长』限制:标识/单行文本/函数体语句总量/源代码嵌套深度(比如:c++模版 递归深度，内嵌函数的内嵌深度...)/rust不允许打印太长的元组
  面向机器:强调自由
    生成器算法只要没错，生成的代码就没错；但如果目标代码语言约束过多，生成器为满足这些约束将会更复杂更容易出错。
    流式分散 控制
      比如:java全路径隐式import
      比如:java成员函数的 访问控制前缀public/private
    显式设置参数，避免缺省值
      推断/提取 信息(帮助/注释/缺省值/...) 提供给 高层，编译期层层上传
    允许局部作用域变量名遮蔽外层变量名
    ?不允许局部作用域变量名遮蔽同层变量名
    没有『太长』限制

只有 虚函数 以及 特权成员函数 需要绑定
  非虚且无特权成员函数(调用其他成员函数 实现功能) 可以随时注入，使用时 像其他自由函数一样 显式引入/或 打包引入...
  ---
  构造函数/析构函数？
  特权构造函数、析构函数 需要捆绑
  无特权构造函数(委托其他构造函数 实现功能) 可以随时注入，使用时 像其他自由函数一样 显式引入/或 打包引入...





e others/数学/编程/rust/rust内存管理.txt
[[[ ]]]


龙场悟道-王阳明

遍地哀鸿满城血，无非一念救苍生
  《七律·忆重庆谈判》毛泽东
剑锋临喉无处避，莫如鏖战换新天
  --BV12Y411J773评论from:leon1982xp
为有牺牲多壮志，敢叫日月换新天
  《七律·到韶山》毛泽东

[
《七律·忆重庆谈判》毛泽东

有田有地皆吾主，无法无天是为民。
重庆有官皆墨吏，延安无土不黄金。
炸桥挖路为团结，夺地争城是斗争。
遍地哀鸿满城血，无非一念救苍生。
]

北欧简约莫尔条纹倒影动态反射镜面咖啡杯子
  杯子+托盘，旋转，杯上倒影是鸟挥翅膀

view others/数学/不可约多项式/irreducible_polynomial.txt
view others/数学/整数分解/factorint.txt
e /storage/emulated/0/0my_files/git_repos/txt_phone/txt/script/平方差分解法的增加新模零开销的必要条件.py
e others/数学/整数分解/我的撞运气整数分解法.txt
e others/数学/整数分解/素数/safe_prime.txt
https://primes.utm.edu/primes/
  II. Background information
    + How do you prove large numbers are prime?
https://primes.utm.edu/prove/
  https://primes.utm.edu/prove/prove3_1.html
https://primes.utm.edu/prove/prove3_2.html
https://primes.utm.edu/prove/prove3_3.html
    极佳
[[[
https://primes.utm.edu/prove/
来自:https://primes.utm.edu/primes/
  II. Background information
    + How do you prove large numbers are prime?
===
Finding primes & proving primality
Table of Contents	Primality Proving Icon
Home > Primality Proving > Contents
Do you need to know how to find primes or prove a large numbers primality?  Then you have come to the right place!  If you are new to these pages you should begin with the introduction.  Otherwise here is the table of contents, start where you would like:

  + Introduction
  + The Quick Tests for Small Numbers and Probable Primes
    + Finding Very Small Primes
    + Fermat, Probable-Primality and Pseudoprimes
    + Strong Probable-Primality and a Practical Test
  + The Classical Tests
    + N-1 Tests (and Pepin's Test for Fermats)
    + N+1 Tests (and the Lucas-Lehmer Test for Mersennes)
    + A Combined Test -- and more
  + The General Purpose Tests
    + Neoclassical Tests, especially APR and APR-CL
    + Using Elliptic Curves, especially the ECPP Test
    + A Polynomial Time Algorithm
  + Conclusion and Suggestions
  + Partially Annotated References
There is also a version of these pages as one (very long) page.  This long version is made by merging the smaller documents, so some of the links may not work correctly, but it should be fine for a printed version.
  https://primes.utm.edu/prove/merged.html

[ next page | previous page ]
The Prime Pages © Chris Caldwell <caldwell AT utm.edu>
===
https://primes.utm.edu/prove/merged.html
wget 'https://primes.utm.edu/prove/merged.html' -O 'primes.utm.edu..prove..merged.html'
  84KB
mv ~/download/wget_/'primes.utm.edu..prove..merged.html' ~/my_txt/others/数学/整数分解/素数/
view others/数学/整数分解/素数/primes.utm.edu..prove..merged.html
当下只有『Privacy_Browser』APP能够浏览 本地网页
  content://com.simplemobiletools.filemanager.pro.provider/external_files/storage/emulated/0/0my_files/git_repos/txt_phone/txt/others/%E6%95%B0%E5%AD%A6/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/%E7%B4%A0%E6%95%B0/primes.utm.edu..prove..merged.html
    无法访问？只能通过『文件管理器』访问？
  file:///storage/emulated/0/0my_files/git_repos/txt_phone/txt/others/%E6%95%B0%E5%AD%A6/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3/%E7%B4%A0%E6%95%B0/primes.utm.edu..prove..merged.html
    net::ERR_ACCESS_DENIED
  content://media/external/file/255422
    路径怎么来的？
  content://media/external/file/255422
    稳定？看来不是 临时PIPE之类的标识
    休眠后无法打开，但通过 文件管理器 打开后，就可以了

  [[
  [n <- [2..]]:
    #n is a strong probable-prime base a
    [is_SPRP_base_ a n =[def]= [s:=max_power_of_base_as_factor_of_(2, n-1)][d := (n-1)///2**s][[a**d %n ==1]or[?[r <- [0..<s]] -> [(a**d%n)**(2**r)==n-1]]]]

  [
  ###
  If n < 1373653 is a both 2 and 3-SPRP, then n is prime [PSW80].
  If n < 25326001 is a 2, 3 and 5-SPRP, then n is prime [PSW80].
  If n < 25000000000 is a 2, 3, 5 and 7-SPRP, then either n = 3215031751 or n is prime [PSW80]. (This is actually true for n < 118670087467 [Jaeschke93].)
  If n < 2152302898747 is a 2, 3, 5, 7 and 11-SPRP, then n is prime [Jaeschke93].
  If n < 3474749660383 is a 2, 3, 5, 7, 11 and 13-SPRP, then n is prime [Jaeschke93].
  If n < 341550071728321 is a 2, 3, 5, 7, 11, 13 and 17-SPRP, then n is prime [Jaeschke93].
  ###
  If n < 9080191 is a both 31 and 73-SPRP, then n is prime.
  If n < 4759123141 is a 2, 7 and 61-SPRP, then n is prime.
  ###
  If n < 170584961 is a 350 and 3958281543-SPRP, then n is prime.
  If n < 75792980677 is a 2, 379215, and 457083754-SPRP, then n is prime.
  If n < 21652684502221 is a 2, 1215, 34862, and 574237825-SPRP, then n is prime.
  ###
  It has been proven ([Monier80] and [Rabin80]) that the strong probable primality test is wrong no more than 1/4th of the time (3 out of 4 numbers which pass it will be prime).
  Probability[is_prime n](num_rounds) = 1-1/4**num_rounds
  ###
  Miller's Test [Miller76]: If the extended Riemann hypothesis is true, then if n is an a-SPRP for all integers a with 1 < a < 2(log n)**2, then n is prime.
  [[n <- [2..]] -> [extended_Riemann_hypothesis] -> [@[a<-[2..<2*(ln n)**2]] -> [is_SPRP_base_ a n]] -> [is_prime n]]
  ###
  ]

  #正整数素性判定
  # (n-1) test
  [@[u <- [2..]] -> [?[a <- [1..<u]] -> [[a**(u-1)%u==1][@[p<-all_prime_factors_of(u-1)] -> [a**((u-1)///p)%u=!=1]]]] -> [is_prime u]]
  #同一个a<u> --> 拆成多个a<u,p>
  [@[u <- [2..]] -> [@[p<-all_prime_factors_of(u-1)] -> [?[a <- [1..<u]] -> [[a**(u-1)%u==1][a**((u-1)///p)%u=!=1]]]] -> [is_prime u]]
    [[#如何合并a<u,p>为a<u>？
      #copy from: view ./others/数学/不可约多项式/irreducible_polynomial.txt
    [@[p<-all_prime_factors_of(u-1)] -> [order_mod<u>(a<u,p>)%p**max_height_of_prime_power_(p,u-1) == 0]]
    [@[p<-all_prime_factors_of(u-1)] -> [
      [(u-1)%order_mod<u>(a<u,p>) == 0]
      [e4a<u,p> := max_height_of_prime_power_(p;u-1)]
      [p_pow4a<u,p> := p**e4a<u,p>]
      [max_height_of_prime_power_(p;order_mod<u>(a<u,p>)) == e4a<u,p>]
      [order_mod<u>(a<u,p>**((u-1)///p_pow4a<u,p>)) == p_pow4a<u,p>]
      ]]
    [a<u> := II (a<u,p>**((u-1)///p_pow4a<u,p>)) {p<-all_prime_factors_of(u-1)} % u]
      [[proof:
      @[p<-all_prime_factors_of(u-1)]:
        [a<u>**((u-1)///p) %u
          == (II (a<u,q>**((u-1)///p_pow4a<u,q>)) {q<-all_prime_factors_of(u-1)} % u)**((u-1)///p) %u
          == (II (a<u,q>**((u-1)///p_pow4a<u,q>))**((u-1)///p) %u {q<-all_prime_factors_of(u-1)} % u)
          == (II (a<u,q>**((u-1)///p_pow4a<u,q> * (u-1)///p %(u-1)[#指数这里『%(u-1)』是因为[(u-1)%order_mod<u>(a<u,p>) == 0]。无需 证明u是素数#])) %u {q<-all_prime_factors_of(u-1)} % u)
          == (II ([q==p]+[q=!=p])*(a<u,q>**((u-1)///p_pow4a<u,q> * (u-1)///p %(u-1)) %u) {q<-all_prime_factors_of(u-1)} % u)
            [[
            [e_fill<u,q,p> := ((u-1)///p_pow4a<u,q> * (u-1)///p %(u-1))]
            * [q==p]:
              [gcd((u-1)///p_pow4a<u,p> * (u-1)///p, (u-1)) == (u-1)///p]
              [e_fill<u,q,p>
              == ((u-1)///p_pow4a<u,p> * (u-1)///p %(u-1))
              =[?k4e_fill<u,p> <-[1..<p]]= k4e_fill<u,p> * (u-1)///p
              ]
              [a<u,q>**e_fill<u,q,p> %u == a<u,q>**(k4e_fill<u,p> * (u-1)///p) %u =!= 1]

            * [q=!=p]:
              [e_fill<u,q,p>
              == ((u-1)///p_pow4a<u,q>///p * p * (u-1)///p %(u-1))
              == ((u-1)///p_pow4a<u,q>///p * (u-1) %(u-1))
              == 0
              ]
              [a<u,q>**e_fill<u,q,p> %u == 1]
            ]]
          == (II ([q==p]*(a<u,q>**e_fill<u,q,p> %u) + [q=!=p]*1) {q<-all_prime_factors_of(u-1)} % u)
          == (a<u,p>**e_fill<u,p,p> %u)
          == a<u,p>**(k4e_fill<u,p> * (u-1)///p) %u
          =!= 1
        ]
        [a<u>**((u-1)///p) %u =!= 1]
      ]]
    ]]
  #
  #Pocklington's Theorem (1914):  Let n-1 = q**k * R where q is a prime which does not divide R.  If there is an integer a such that a**(n-1) ≡ 1 (mod n) and gcd(a**((n-1)/q)-1,n) = 1, then each prime factor p of n has the form q**k * r + 1.
  [@[u <- [2..]] -> @[p <- all_prime_factors_of(u-1)] -> [k := max_power_of_base_as_factor_of_(p,u-1)] -> @[a <- [1..]] -> [a**(u-1) %u ==1] -> [gcd(a**((u-1)///p)-1, u) ==1] -> @[q<-all_prime_factors_of(u)] -> [max_power_of_base_as_factor_of_(p, q-1) >= k]]
    [proof:
      [m := order_mod(q;a) = min{i <-[1..] | [a**i %q ==1]}]
      [(q-1) %m ==0]

      !![a**(u-1) %u ==1]
      [a**(u-1) %q ==1]
      [(u-1)%m ==0]

      !![gcd(a**((u-1)///p)-1, u) ==1]
      [gcd(a**((u-1)///p)-1, q) ==1]
      [a**((u-1)///p) %q =!= 1]
      [(u-1)///p %m =!=0]
      !![(u-1)%m ==0]
      [max_power_of_base_as_factor_of_(p, m) == max_power_of_base_as_factor_of_(p, u-1) == k]
      !![(q-1) %m ==0]
      [max_power_of_base_as_factor_of_(p, q-1) >= max_power_of_base_as_factor_of_(p, m) == k]
    ]
  ...
  [@[u <- [2..]] -> @[F,R <- [1..]] -> [u-1 == F*R] -> [F > R] -> [gcd(F,R) ==1] -> @[a <- [1..<u]] -> [a**(u-1)%u==1] -> [@[p<-all_prime_factors_of(F)] -> [gcd(u, a**((u-1)///p) -1) ==1]] -> [is_prime u]]
    # (Notice that different a's can be used for each prime q.)  Theorem 2 can be improved even more: if F<R, but either every factor of R is greater than sqrt(R/F); or n<2F3, R=rF+s, 0<s<F, and r is odd or s2-4r is not a square; then n is prime.  If you are interested in these theorems, then it is well worth going to the source: [BLS75].
  #a<u> ---> a<u,p>
  [@[u <- [2..]] -> @[F,R <- [1..]] -> [u-1 == F*R] -> [F > R] -> [gcd(F,R) ==1] -> [@[p<-all_prime_factors_of(F)] -> ?[a <- [1..<u]] -> [[a**(u-1)%u==1][gcd(u, a**((u-1)///p) -1) ==1]]] -> [is_prime u]]
    #特化推论:
    [@[h <- [1..]] -> @[k <- [1..]] -> @[p<-all_primes] -> [h < p**k] -> [n := h*p**k +1] -> @[a<-[1..]] -> [gcd(n, a**((n-1)///p) -1) ==1] -> [is_prime n]]
    [@[h <- [1..]] -> @[k <- [1..]] -> [h < 2**k] -> [n := h*2**k +1] -> @[a<-[1..]] -> [a**((n-1)///2) %n ==-1] -> [is_prime n]]
    [n <- [0..]]:
      [Fermat_number n =[def]= 2**(2**n) +1]
    #Pepin's Test (1877)
    [[n <- [0..]] -> [[is_prime (Fermat_number n)] <-> [3**((Fermat_number n -1)/2) =[%Fermat_number n]= Jacobi_symbol(Fermat_number n, 3) == -1]]]
  ###我重述:
  [@[u <- [2..]] -> @[F,R <- [1..]] -> [u-1 == F*R] -> [@[p<-all_prime_factors_of(F)] -> ?[a <- [1..<u]] -> [[a**(u-1)%u==1][gcd(u, a**((u-1)///p) -1) ==1]]] -> @[q<-all_prime_factors_of(u)] -> [(q-1)%F == 0]]
    # [not$ is_prime u]:
    #   [u >= (F+1)**2 == F*(F+2) +1][R >= F+2]
    #   [h <- [1..]][@[i<-[1..<h]] -> [not$ is_prime (i*F+1)]]:
    #       [u >= (h*F+1)**2 == F*h*(h*F+2) +1][R >= h*(h*F+2)]
  [@[u <- [2..]] -> @[F,R <- [1..]] -> [u-1 == F*R] -> @[h <- [1..]] -> [@[i<-[1..<h]] -> [not$ is_prime (i*F+1)]] -> [R < h**2*F+2*h] -> [@[p<-all_prime_factors_of(F)] -> ?[a <- [1..<u]] -> [[a**(u-1)%u==1][gcd(u, a**((u-1)///p) -1) ==1]]] -> [is_prime u]]
    #特例:[h==1]:
      [@[u <- [2..]] -> @[F,R <- [1..]] -> [u-1 == F*R] -> [R < F+2] -> [@[p<-all_prime_factors_of(F)] -> ?[a <- [1..<u]] -> [[a**(u-1)%u==1][gcd(u, a**((u-1)///p) -1) ==1]]] -> [is_prime u]]

  #我:
  [@[u <- [2..]] -> @[F,R <- [1..]] -> [u-1 == F*R] -> [gcd(F,R)==1] -> [?[a <- [1..<u]] -> [[a**(u-1)%u==1][gcd(u, a**((u-1)///R) -1) ==1]]] -> [
    [@[q<-all_prime_factors_of(u)] -> [
      [gcd(q-1,R) > 1]
      [?[p<-all_prime_factors_of(R)] -> [(q-1)%p==0]]
      [@[B<-[2..]] -> [@[p<-all_prime_factors_of(R)] -> [p >= B]] -> [q>=B+1]]
      ]]
    [#[n<(B+1)**2]这个要求使得下面毫无意义
      [@[B<-[2..]] -> [@[p<-all_prime_factors_of(R)] -> [p >= B]] -> [n<(B+1)**2] -> [is_prime u]]
      ]
    ]]
    [proof:
      [m := order_mod(q;a) = min{i <-[1..] | [a**i %q ==1]}]
      [(q-1) %m ==0]

      !![a**(u-1) %u ==1]
      [a**(u-1) %q ==1]
      [(u-1)%m ==0]

      !![gcd(a**((u-1)///R)-1, u) ==1]
      [gcd(a**((u-1)///R)-1, q) ==1]
      [a**((u-1)///R) %q =!= 1]
      [(u-1)///R %m =!=0]
      [gcd((u-1)///R,m) < m]
      !![u-1 == F*R]
      [gcd(F,m) < m]
      !![u-1 == F*R]
      !![gcd(F,R)==1]
      [gcd(u-1,m)==gcd(F,m)*gcd(R,m)]
      [gcd(R,m) == gcd(u-1,m)///gcd(F,m)]
      !![(u-1)%m ==0]
      [gcd(u-1,m)==m]
      !![gcd(F,m) < m]
      [gcd(R,m) == gcd(u-1,m)///gcd(F,m) > 1]
      !![(q-1) %m ==0]
      [gcd(q-1,R) >= gcd(m,R) > 1]
    ]
  #减少计算量:
    #1:
    [b<p> := a<p>**((n-1)///(2*p)) % n]
    [b<p> =!= n-1]
    [b<p>**p %n == n-1] #复用[a<p1>==a<p2>]，则此步可省
    #2:多次gcd -> 一次gcd
    [gcd(n, II a<p[i]>**((n-1)///p[i]) -1 {p[i]}) =!=1]
  #######
  # (n+1) test
  see also:
    #view others/数学/Lucas-Lehmer\ primality\ test/Lucas-Lehmer\ primality\ test.txt
    view others/数学/整数分解/factorint.txt

#copy from:view others/数学/整数分解/factorint.txt::LucasSequence相关
TODO:copy
  ]]
https://primes.utm.edu/glossary/page.php?sort=JacobiSymbol

.,$s/content:[/][/]media[/]/https:\/\/primes.utm.edu\//g
https://primes.utm.edu/external/references/refs.cgi/Williams78
Williams78
H. C. Williams, "Primality testing on a computer," Ars Combin., 5 (1978) 127--185.  MR 80d:10002 [A survey of the classical primality tests.]
wget 'https://www.ams.org/mcom/1978-32-143/S0025-5718-1978-0476625-0/S0025-5718-1978-0476625-0.pdf' -O 'Primality testing on a computer(1978)(Williams).pdf'
已下载

https://primes.utm.edu/external/references/refs.cgi/Williams98
Williams98
H. C. Williams, Édouard Lucas and primality testing, Canadian Math. Soc. Series of Monographs and Adv. Texts Vol, 22, John Wiley \& Sons, 1998.  New York, NY, pp. x+525, ISBN 0-471-14852-0. MR 2000b:11139 (Annotation available)
https://libgen.ee/book_86581965
wget 'https://libgen.rocks/get.php?md5=cf1442d3f874b61b880ee88101f9e213&key=VQE1PWKA9CCQO0MU' -O 'Edouard Lucas and primality testing(1998)(Williams).pdf'
已下载


https://primes.utm.edu/references/refs.cgi/APR83
APR83
L. M. Adleman, C. Pomerance and R. S. Rumely, "On distinguishing prime numbers from composite numbers," Ann. Math., 117:1 (1983) 173--206.  MR 84e:10008 [The first of the modern primality tests.]
已下载

https://primes.utm.edu/references/refs.cgi/CL84
CL84
H. Cohen and Lenstra, Jr., H. W., "Primality testing and Jacobi sums," Math. Comp., 42 (1984) 297--330.  MR 86g:11078 [APRT-CL test introduced.]
已下载

https://primes.utm.edu/references/refs.cgi/CL87
CL87
H. Cohen and A. K. Lenstra, "Implementation of a new primality test," Math. Comp., 48 (1987) 103--121.  MR 88c:11080 [APRT-CL test implemented.]
已下载

https://primes.utm.edu/references/refs.cgi/Mihailescu98
Mihailescu98
P. Mihailescu, Cyclotomy primality proving -- recent developments.  In "Proceedings of the III Applied Number Theory Seminar, ANTS III, Portland, Oregon 1998," Lecture Notes in Computer Science Vol, 1423, 1998.  pp. 95--110, MR 2000j:11195
Cyclotomy primality proving -- recent developments(1998)(Mihailescu).pdf
搜索:Mihailescu。查看1998前后
https://libgen.ee/book_15227248
wget 'https://libgen.rocks/get.php?md5=8ed816eb441785423dfac4cc489539ea&key=JAASW4PFQH9ZLKF4' -O 'Recent developments in primality proving(1999)(Mihailescu).pdf'
已下载

https://primes.utm.edu/references/refs.cgi/BH90
BH90
W. Bosma and M. P. van der Hulst, Faster primality testing.  In "Advances in Cryptology--EUROCRYPT '89 Proceedings," J. J. Quisquater and J. Vandewalle editors, Springer-Verlag, 1990.  pp. 652--656,
Faster primality testing(1990)(Bosma).pdf
已下载

https://primes.utm.edu/references/refs.cgi/BLS75
  J. Brillhart, D. H. Lehmer and J. L. Selfridge, "New primality criteria and factorizations of 2m ± 1," Math. Comp., 29 (1975) 620--647.  MR 52:5546 [The article for the classical (n2 -1) primality tests. Table errata in [Brillhart1982]]
wget -c 'https://www.ams.org/journals/mcom/1975-29-130/S0025-5718-1975-0384673-1/S0025-5718-1975-0384673-1.pdf' -O 'New primality criteria and factorizations of 2^m ± 1(1975)(Brillhart).pdf'
已下载

https://primes.utm.edu/references/refs.cgi/Ribenboim95
  # 数据列表:[n<?][n is {???}-SPRP] -> [is_prime n]
  #     Strong probable-primality
  #
  P. Ribenboim, The new book of prime number records, 3rd edition, Springer-Verlag, 1995.  New York, NY, pp. xxiv+541, ISBN 0-387-94457-5. MR 96k:11112 [An excellent resource for those with some college mathematics. Basically a Guinness Book of World Records for primes with much of the relevant mathematics. The extensive bibliography is seventy-five pages.]
https://libgen.lc/edition.php?id=135789101
wget 'http://62.182.86.140/main/11000/d46c0428209914a6acfaede707854241/Paulo%20Ribenboim%20-%20The%20new%20book%20of%20prime%20number%20records-Springer%20%281996%29.djvu' -O 'The new book of prime number records(3ed)(1996)(Ribenboim).djvu'



https://primes.utm.edu/references/refs.cgi/Bernstein1998b
  #determining if the number is a perfect power, can be done in essentially linear time [Bernstein1998b].
  D. Berstein, "Detecting perfect powers in essentially linear time," Math. Comp., 67:223 (1998) 1253--1283.  Available from http://cr.yp.to/papers.html.  MR 98j:11121 (Abstract available)
wget 'http://cr.yp.to/papers/powers-19971106-retypeset20220326.pdf' -O 'Detecting perfect powers in essentially linear time(1998)(Berstein).pdf'

[[
Jacobi symbol
https://www.planetmath.org/CalculatingTheJacobiSymbol
https://brilliant.org/wiki/jacobi-symbol/

The Jacobi symbol is a generalization of the Legendre symbol. Introduced by Jacobi in 1837, it is of theoretical interest in modular arithmetic and other branches of number theory, but its main use is in computational number theory, especially primality testing and integer factorization; these in turn are important in cryptography.

The Jacobi symbol is a generalization of the Legendre symbol, which can be used to simplify computations involving quadratic residues. It shares many of the properties of the Legendre symbol, and can be used to state and prove an extended version of the law of quadratic reciprocity.

[is_prime p]:
  [Legendre_symbol(p,a) =[def]= if [@x. [(x**2 -a)%p =!= 0]] then -1 else +1]
[m > 0][m%2==1]:
  [Jacobi_symbol(m,a) =[def]= II Legendre_symbol(p, a)**max_power_of_base_as_factor_of_(p,m) {p <- all_prime_factors_of(m)}]
  ###
  [Jacobi_symbol(m,a) ==
    if [gcd(a,m) =!= 1] then 0 else
    if [not$ 0 < a < m] then Jacobi_symbol(m,a%m) else
    if [a==2] then (-1)**((m**2-1)/8) else
      # Jacobi_symbol(m,2) = [m%8 <- {1,7}](+1) + [m%8 <- {3,5}](-1)
    if [a%2==0] then let [a == 2**e * b][b%2==1] in Jacobi_symbol(m,2)**(e%2) * Jacobi_symbol(m, b) else
    # [a%2==1][0 < a < m][gcd(a,m)==1]
    (-1)**((a-1)*(m-1)/4) * Jacobi_symbol(a,m)
  ]

###
The Legendre symbol measures whether a is a square mod p. Unfortunately, the Jacobi symbol does not retain this property:
  If gcd(a,m)=1 and a is a square mod m, where m is an odd positive integer, then Jacobi_symbol(m,a)=1; but the converse is not true.
    Jacobi_symbol(9,2) = Jacobi_symbol(3,2)**2 = (-1)**2 = 1
    Jacobi_symbol(35,3) = Jacobi_symbol(5,3)*Jacobi_symbol(7,3) = (-1)*(-1) = 1

[m > 0][m%2==1]:
  [a=[%m]=b]:
    [Jacobi_symbol(m,a) == Jacobi_symbol(m,b)]

  #completely multiplicative function
  [Jacobi_symbol(m, a*b) == Jacobi_symbol(m,a)*Jacobi_symbol(m,b)]

  [n > 0][n%2==1]:
    [Jacobi_symbol(m*n, a) == Jacobi_symbol(m,a)*Jacobi_symbol(n,a)]

  [n > 0][n%2==1][gcd(m,n)==1]:
    [Jacobi_symbol(m,n)*Jacobi_symbol(n,m) == (-1)**((m-1)/2) * (-1)**((n-1)/2)]
    # 比Legendre_symbol(m,n)计算更方便，无需完全分解n

  [Jacobi_symbol(m,-1) = (-1)**((m-1)/2)]
    # =1 <==> [m%4 == 1]
    # 4k+1型 素数p:  z**2=[%p]=-1, p=x**2+y**2, (x+y*j) = u*gcd(p, z+1*j), u <- {+1,-1,+j,-j}
  [Jacobi_symbol(m,2) = (-1)**((m**2-1)/8)]
    # =1 <==> [m%8 ≡ ±1]

#Euler's criterion
[is_prime p][a%p =!= 0]:
  [Legendre_symbol(p,a) =[%p]= a**((p-1)/2)]
gives a criterion for primality:
  [m > 0][m%2==1]:
    [gcd(a,m)==1][[Jacobi_symbol(m,a) =![%m]!= a**((m-1)/2)] -> [not$ is_prime m]]
  It is not hard to show that if m is composite, then at least half the positive a less than m that are coprime to m satisfy this condition. Choosing random values of a k times leads to a probability of (1/2**k) that none of the random values are witnesses to the compositeness of m in this way. This probabilistic primality test is called the Solovay-Strassen primality test, and is quite efficient in practice.
  One interesting feature of the test is that it can be used to prove that numbers are composite without explicitly determining a nontrivial factor.

]]
]]]

[[[logarithm
log(x)=?=log<b=2/e/10>(x)
ln(x) = log<e>(x)
lg(x) = log<10>(x) 或 log<2>(x)
lb(x) = log<2>(x)
缺省的底是10或e或2
===
[[
https://math.stackexchange.com/questions/293783/when-log-is-written-without-a-base-is-the-equation-normally-referring-to-log-ba

Mathematics
When log is written without a base, is the equation normally referring to log base 10 or natural log?
Asked 9 years, 5 months ago
Modified 6 months ago
Viewed 74k times

48


13
For example, this question presents the equation

$$\omega(n) < \frac{\log n}{\log \log n} + 1.4573 \frac{\log n}{(\log \log n)^{2}},$$

but I'm not entirely sure if this is referring to log base $10$ or the natural logarithm.

notation
logarithms
Share
Cite
Follow
edited Apr 13, 2017 at 12:20
user avatar
CommunityBot
1
asked Feb 3, 2013 at 17:30
user avatar
john smith
48311 gold badge44 silver badges55 bronze badges
12
The formula you quote is from Number Theory. So for sure base $e$. – 
André Nicolas
 Feb 3, 2013 at 17:37
Add a comment
6 Answers
Sorted by:

Highest score (default)

86

In mathematics, $\log n$ is most often taken to be the natural logarithm. The notation $\ln(x)$ not seen frequently past multivariable calculus, since the logarithm base $10$ finds relatively little use.

This Wikipedia page gives a classification of where each definition, that is base $2$, $e$ and $10$, are used:

$\log (x)$ refers to $\log_2 (x)$ in computer science and information theory.

$\log(x)$ refers to $\log_e(x)$ or the natural logrithm in mathematical analysis, physics, chemistry, statistics, economics, and some engineering fields.

$\log(x)$ refers to $\log_{10}(x)$ in various engineering fields, logarithm tables, and handheld calculators.

Share
Cite
Follow
edited Jun 12, 2020 at 10:38
user avatar
CommunityBot
1
answered Feb 3, 2013 at 17:33
user avatar
Eric Naslund
70k1111 gold badges166166 silver badges260260 bronze badges
9
Some computer-science types use $\mathop{lg}$ for $\log_2$ – 
vonbrand
 Feb 3, 2013 at 19:13
4
I've often seen lb for log2 (i.e. log binary) – 
wim
 Feb 3, 2013 at 23:15
8
To add on this, in terms of computational complexity all the bases are the same as they differ by a constant. So it's actually irrelevant which base you chose for your logarithm in the aforementioned question (about the prime numbers). – 
Asaf Karagila
♦
 Feb 4, 2013 at 0:21 
3
The second term in the original expression has a log divided by the square of a log, so the base is relevant. – 
DJohnM
 Feb 4, 2013 at 2:06
3
@wim Yes. That's the ISO 31-11 standard (lb for base 2, ln for $e$, lg for 10). – 
Mechanical snail
 Feb 4, 2013 at 8:21
Show 3 more comments

17

Depending on the subject, it can be base $10$, base $e$, or base $2$. Base $2$ is common in computer science. Base $10$ is popular in engineering (think decibels). I would take this to be base $e$

Share
Cite
Follow
answered Feb 3, 2013 at 17:34
user avatar
Ross Millikan
363k2727 gold badges242242 silver badges432432 bronze badges
9
Oh, this new generation. For us old-timers, who grew up with slide rules and logarithm tables, $\log$ was $\log_{10}$ by default. $\ln$ was used only in the weird formulas used by mathematicians, to be translated into $\log_{10}$ as soon as possible [Chemical engineer by training, in the '70s]. – 
vonbrand
 Feb 3, 2013 at 19:17
3
Base 10 also shows up reasonably often in the less mathy sciences. (vonbrand's comment generally describes the kind of fields where it might be used - if they think math is weird, there's a good chance they use base 10.) – 
Cascabel
 Feb 3, 2013 at 20:45 
Add a comment

11

In some cases, "$\log$" can refer to a logarithm with an indefinite base.

Suppose we're taking the logarithm (base $b$, where $b>0$ is constant) of some variable. Recall the identity

$$\log_b(x) = \frac{\log_c(x)}{\log_c(b)}$$

The base-$b$ logarithm can be expressed as a constant factor times the logarithm to any other base $c>0$. In some domains, particularly asymptotic analysis, we don't care about constant factors—which means that it doesn't matter what base we pick. So we can unambiguously write $Θ(\log(n))$ without specifying the base.

(This does not apply to the specific usage in the question, which is about an upper bound for all $n$. Obviously constant factors matter there.)

Share
Cite
Follow
answered Feb 4, 2013 at 8:32
user avatar
Mechanical snail
23111 silver badge1111 bronze badges
Add a comment

0

If you come from a computer science background, then:

log(x) = log$_{10}$(x)
ln(x) = log$_{e}$(x)
lg(x) = log$_{2}$(x)
If a computer scientist is using log(x) with a base that is not 10, then he/she will usually point it out clearly.

Share
Cite
Follow
answered Apr 13, 2021 at 19:31
user avatar
stackoverflowuser2010
91311 gold badge88 silver badges1818 bronze badges
Add a comment

0

In many programming languages, log is the natural logarithm. There are often variants for log2 and log10.

Checked in C, C++, Java, JavaScript, R, Python

Share
Cite
Follow
answered Dec 28, 2021 at 21:17
user avatar
David Gilbertson
10111 bronze badge
Add a comment

-1

Generally it is bad practice to write logarithms without the base especially if the context hasn't been sufficiently set up. If a base is to be implied, then it is better to use one of the variants, such as $ln()$ for base $e$, $lg()$ for base $2$, etc.

But there is literature out there that violates the above rule, so yes, you'll need to infer the base from the context.

Having said that, there are cases when a missing base is intentional and acceptable, implying that it is applicable regardless of what the base is. For instance, when I say:

$$log_{2}(10) = log(10)/log(2)$$

and you notice that the base is omitted in the RHS, it means that it is applicable to any base in the RHS (of course, as long as the same base is used in both numerator and denominator).

To me, that is the only acceptable case when one can omit the base.

Share
Cite
Follow
answered Apr 15, 2021 at 5:13
user avatar
vharihar
2922 bronze badges
Add a comment
Your Answer
]]
===
https://www.math10.com/en/algebra/logarithm-log-ln-lg.html
There are standard notation of logarithms if the base is 10 or e.

log<10>(b) is denoted by lg b
log<e>(b) is denoted by log b or ln b

===
The logarithm, or log, is the inverse of the mathematical operation of exponentiation. This means that the log of a number is the number that a fixed base has to be raised to in order to yield the number. Conventionally, log implies that base 10 is being used, though the base can technically be anything. When the base is e, ln is usually written, rather than loge. log2, the binary logarithm, is another base that is typically used with logarithms. If, for example:

x = b**y; then y = log<b>(x); where b is the base

Each of the mentioned bases is typically used in different applications. Base 10 is commonly used in science and engineering, base e in math and physics, and base 2 in computer science.
]]]


[[[[[[[
Pollard p-1 method and Lenstra elliptic curve factorization algorithm
  ???[N = p**2 * q**3]??? 这些分解法 还有用吗？

The sum of any three colinear points in E is zero.
  椭圆曲线上的 共线的 三点 相加(交换群加法) 为零(无穷远点)。
  同点/重根:
    A+B+C==O
    2*B+C==O
    3*C==O
    #要求:域特征 不为 2或3
为何 是 椭圆曲线？
  群乘法涉及3个值，通过3个根联系起来，==>>三次多项式
  https://blog.csdn.net/mmphhh/article/details/123296805
  wget 'https://blog.csdn.net/mmphhh/article/details/123296805' -O '椭圆曲线：椭圆曲线是怎么来的？_Lytain2022.html'
why is Elliptic curve?
  https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography

  https://math.stackexchange.com/questions/853089/why-is-it-called-elliptic-curve
    https://www.unf.edu/~ddreibel/mas4932/elliptic-integrals.pdf
      Why are They Called “Elliptic” Curves?
    wget 'https://www.unf.edu/~ddreibel/mas4932/elliptic-integrals.pdf' -O 'elliptic-integrals[Why are They Called Elliptic Curves].pdf'
    http://www.math.rochester.edu/people/faculty/doug/mypapers/wayne1.pdf
      https://people.math.rochester.edu/faculty/doug/mypapers/wayne1.pdf
      wget 'https://people.math.rochester.edu/faculty/doug/mypapers/wayne1.pdf' -O 'Elliptic curves-- what they are, why they are called elliptic, and why topologists like them(2007)(Doug Ravenel)[ppt].pdf'

  https://www.math.brown.edu/johsilve/Presentations/WyomingEllipticCurve.pdf
  wget 'https://www.math.brown.edu/johsilve/Presentations/WyomingEllipticCurve.pdf' -O 'An Introduction to the Theory of Elliptic Curves(2006)(Silverman).pdf'
    非常好！
    [[
  椭圆曲线分解 不要求 (p-1)  是 B-smooth
  而是 要求 |Elliptic_Curve(%GF(p))|  是 B-smooth:
    Suppose that there is a prime p dividing N for which the number of points in E(GF[p]) is B-smooth.
    The advantage of Lenstra’s Elliptic Curve Algorithm over Pollard’s p − 1 Algorithm is the introduction of many finite groups E(GF[p]) with many different orders.
    The fact that the running time depends on the smallest prime divisor of N makes Lenstra’s algorithm especially good for factoring “random” numbers, but it is slower than sieve methods for “RSA-type” numbers N = pq.
    ===
    More precisely, choose an elliptic curve modulo N and a point on the curve[#反过来，先有点S与系数a 再求 系数b#]: [E : y**2= x**3+ a*x + b,a,b ∈ Z/NZ,S ∈ E(Z/NZ)].
    Suppose that there is a prime p dividing N for which the number of points in E(GF[p]) is B-smooth.
    Then there is a good chance that during the computation of (LCM(1,2,...,B)S mod N)[#LCM(1,2,...,B)?我觉得应该改成II p**2**ceil_log2(floor_log<p>(N)){p<-primes_lt(B+1)} 确保p的指数足够大#], some inverse ((x2−x1)**−1 mod N)[#两点的加法-计算过两点直线斜率-inv_mod-失败即分解#] will not exist, yielding [gcd(x2− x1,N) = p].
    ]]

搜索:p-1 与 椭圆曲线 整数分解法Lenstra factoring algorithm
  Pollard's p-1 method
  Lenstra's elliptic curve factorization algorithm
    The Lenstra's elliptic curve factorization (LEF) algorithm is a problem to factor a composite number N that is a modulus to define an elliptic curve over it, namely E mod N. The LEF method considered as the third fastest algorithm comparing to multiple polynomial quadratic and general number field sieves algorithms


  view others/数学/整数分解/factorint.txt

  https://www.cs.purdue.edu/homes/ssw/cs355/2009f.pdf
  https://www.cs.purdue.edu/homes/ssw/cs655/2009f.pdf
  Factoring Algorithms Pollard’s p-1 Method
  wget 'https://www.cs.purdue.edu/homes/ssw/cs655/2009f.pdf' -O 'Factoring Algorithms--Pollard p-1 Method,Quadratic Sieve Method,Index Calculus(2009)(Purdue University).pdf'
    61KB
    Factoring Algorithms:
      * Pollard’s p − 1 Method
      * Quadratic Sieve Method
      * Discrete Logarithms via Index Calculus
    ===
    quadratic sieve algorithm O(e**sqrt(ln(N) * ln(ln(N))))
      [@[C1,C2 :: PositiveReal] -> ?[N0 :: uint] -> @[N <- [N0..]] -> [ln(N)**C1 < e**sqrt(ln(N) * ln(ln(N))) < N**C2]]

  https://www.math.uchicago.edu/~may/REU2014/REUPapers/Parker.pdf
  ELLIPTIC CURVES AND LENSTRA’S FACTORIZATION ALGORITHM
  wget 'https://www.math.uchicago.edu/~may/REU2014/REUPapers/Parker.pdf' -O 'ELLIPTIC CURVES AND LENSTRA_S FACTORIZATION ALGORITHM(2014)(PARKER).pdf' --no-check-certificate
    215KB
    好！
    前提:[N%2=!=0][N%3=!=0][@[i <-[2..=floor_log2(N)]] -> [not$ pow_nth_root(N,i) <- uint]][@a,P.x,P.y<-[2..<N]][b:=P.y**2-P.x**3-a*P.x][gcd(N,4*a**3+27*b**2)==1][E(ZZ%N,a,b)==[y**2=x**3+a*x+b]]
      #nonsingular curve:[gcd(N,4*a**3+27*b**2)==1]
      #Elliptic_Curve over ZZ%N: E(ZZ%N,a,b)
    终止条件:求f(B)*P==>>求(P+Q)时，[P=!=-Q]==>>求 直线PQ斜率==>>求inv_mod<N>([P=!=-Q][P=!=Q](P.x-Q.x) + [P=!=-Q][P==Q](2*P.y))，inv_mod不存在 即 分解(若gcd为N，则减小f(B)再尝试，否则 成功分解)
      f(B) =? lcm(1..=B)
      f(B) =? II p**floor_log<p>(N) {p<-primes_lt(B+1)}
    Hasse-Weil Bound: [p + 1 − 2√p ≤ len(E(GF[P])) ≤ p + 1 + 2√p]
      失败，则更换 椭圆曲线 E，期待 len(E(GF[P])) 是 B-smooth

  https://sites.math.washington.edu/~morrow/336_16/2016papers/thomas.pdf
  Lenstra Elliptic Curve Factorization
  wget 'https://sites.math.washington.edu/~morrow/336_16/2016papers/thomas.pdf' -O 'Lenstra Elliptic Curve Factorization(2016)(Thomas Browning).pdf'
    172KB
    Asymptotically it is only the third fastest integer factorization algorithm known (beaten by the Quadratic Sieve and the General Number Field Sieve).
    [O(General Number Field Sieve) < O(Quadratic Sieve) < O(Lenstra Elliptic Curve Factorization)]
    待搜索:
      Williams’ p + 1 algorithm
      General Number Field Sieve
      [[
General Number Field Sieve
In number theory, the general number field sieve (GNFS) is the most efficient classical algorithm known for factoring integers larger than 10¹⁰⁰. Heuristically, its complexity for factoring an integer n (consisting of ⌊log₂ n⌋ + 1 bits) is of the form exp((∛(64/9)+o(1))(lnn)¹/³(lnlnn)²/³)=Lₙ[1/3,∛(64/9)] (in L-notation), where ln is the natural logarithm. It is a generalization of the special number field sieve: while the latter can only factor numbers of a certain special form, the general number field sieve can factor any number apart from prime powers (which are trivial to factor by taking roots).


https://vtechworks.lib.vt.edu/bitstream/handle/10919/36618/etd.pdf
An Introduction to the General Number Field Sieve
wget 'https://vtechworks.lib.vt.edu/bitstream/handle/10919/36618/etd.pdf' -O 'An Introduction to the General Number Field Sieve(1998)(Matthew).pdf'

https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf
A Beginner’s Guide To The General Number Field Sieve
wget 'https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf' -O 'A Beginner_s Guide To The General Number Field Sieve(after2002)(Michael).pdf'

http://sjbyrnes.com/math129-finalpaper.pdf
The Number Field Sieve
wget 'http://sjbyrnes.com/math129-finalpaper.pdf' -O 'The Number Field Sieve(2005)(Byrnes).pdf'

https://github.com/MathSquared/general-number-field-sieve
  This project depends on Victor Shoup's NTL and CMake, and is written in C++11.

      ]]


  https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/Lenstra87.pdf
  Factoring integers with elliptic curves
  wget 'https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/Lenstra87.pdf' -O 'Factoring integers with elliptic curves(1987)(LENSTRA).pdf'
    1.35MB 原论文

  https://hernandez.ku.edu/601/CP4-elliptic-curves.pdf
  Math component: Elliptic curves and Lenstra’s Algorithm
  wget 'https://hernandez.ku.edu/601/CP4-elliptic-curves.pdf' -O 'Math component--Elliptic curves and Lenstra_s Algorithm(简要大纲).pdf'
    148KB

  https://github.com/delta003/lenstra_algorithm
    https://github.com/delta003/lenstra_algorithm/blob/master/lenstra.py
    wget 'https://github.com/delta003/lenstra_algorithm/blob/master/lenstra.py' -O 'github.com-delta003-lenstra.py.html'
    view /storage/emulated/0/Download/wget_/github.com-delta003-lenstra.py

  https://www.math.mcgill.ca/darmon/courses/05-06/usra/charest.pdf
  Pollard’s p-1 and Lenstra’s factoring algorithms
  wget 'https://www.math.mcgill.ca/darmon/courses/05-06/usra/charest.pdf' -O 'Pollard_s p-1 and Lenstra_s factoring algorithms(2005)(Charest).pdf'
    188KB 非常详细
    [[
Contents 
1 Pollard’s p-1 algorithm..........................3 
1.1 General idea of the algorithm..................3 
1.2 The steps of the algorithm....................4 
1.3 Conditions of success of the algorithm..............5 
1.4 Efficiency of the algorithm....................5 
1.5 Possible improvements of the algorithm.............10 
2 Lenstra’s algorithm using elliptic curves..........................11
2.1 Elliptic curves...........................11 
2.2 General idea of the algorithm..................14 
2.3 The steps of the algorithm....................15 
2.4 Conditions of success of the algorithm..............15 
2.5 Efficiency of the algorithm....................16 
2.6 Possible improvements of the algorithm.............19
    ]]
Natual Logarithm Base e 自然对数底
natural base e
2.71828182845904523536...
>>> e=2.71828182845904523536
>>> e**e
15.154262241479259

[[[
https://math.stackexchange.com/questions/3527401/why-is-the-pollards-p-1-method-not-efficient-for-some-numbers
Why is the pollard's (p-1)-Method not efficient for some numbers?
===

Mathematics
Why is the pollard's (p-1)-Method not efficient for some numbers?
Asked 2 years, 5 months ago
Modified 2 years, 5 months ago
Viewed 515 times

1


1
I have an algorithm for the method, where the idea is to choose a random number $a$, and then a bound $B$. Then we find $k=\prod_{\substack{p\in\mathbb{P}\\ p^{e}\leq B}}p^e$ and calculate $\gcd(a^k-1,n)$. And if this is not $1$ or $n$ (the number to be factorized), then we found a divisor. For some numbers this method won't work, for example for $n=132193=163\cdot 811$. But I don't have a concrete explanation why the method doesn't work for that number. I thought it might have to do with the fact that in this case, $p-1$ would be:
$162=2\cdot 3^4$
or $810=2\cdot 3^4 \cdot 5$
in both cases I get a small prime number ($3$) but with a large exponent, so I think that might difficult the selection of the bound $B$, but I don't know exactly how or why...
Could someone help me clarify this doubt? Thank you

number-theory
algorithms
factoring
Share
Cite
Follow
edited Jan 29, 2020 at 20:02
user avatar
Daniel Fischer
200k1818 gold badges250250 silver badges375375 bronze badges
asked Jan 29, 2020 at 19:57
user avatar
M-S-R
33511 silver badge99 bronze badges
In what sense does the method not work for that $n$? If you happen to pick $a = 17$ (which is a cube modulo $163$ but not modulo $811$) and $27 \leqslant B < 81$, then you get the factor $163$. – 
Daniel Fischer
 Jan 29, 2020 at 20:31
Well, that is exactly what I'm trying to find out. I guess the choice of $a$ you made is one of the very few that work – 
M-S-R
 Jan 29, 2020 at 20:38
Few, but probably not very few. Yes, it was deliberately chosen to work. So you want to know why the method works (comparatively) badly for that $n$ (and a number of others)? – 
Daniel Fischer
 Jan 29, 2020 at 20:43
Yes, exactly. In the problem formulation it says that for this specific number one would "need much luck" to factorize $132193$ with the pollard p-1 method... – 
M-S-R
 Jan 29, 2020 at 21:10 
Unless one knows the factorisation, then one can easily find parameters $a$ and $B$ for which the method will succeed. I need to look up how $B$ is picked in the algorithm, that influences how much luck one would need. – 
Daniel Fischer
 Jan 29, 2020 at 21:14
Show 1 more comment
1 Answer
Sorted by:

Highest score (default)

1

The reason why Pollard's $p-1$-method doesn't work well for $n = 163\cdot 811$ is that the largest prime power dividing $163-1$ is the same as the largest prime power that divides $811-1$. Thus in this example $p-1$ and $q-1$ both become $B$-powersmooth for the same $B$.

Generally, the idea of the algorithm is that a prime factor $p$ of $n$ will divide $a^k - 1$ (where $a$ is coprime to $n$) if $k$ is a multiple of $p-1$, but usually a prime factor $q$ of $n$ will not divide it if $k$ is not a multiple of $q-1$. Of course for some $a$, $q$ will nevertheless divide $a^k - 1$, but for that to happen $a$ must be a $\frac{q-1}{\gcd(k,q-1)}$-th power residue modulo $q$, and there aren't too many such.

Since the exponent $k$ is defined as the product of all prime powers $\leqslant B$, all prime factors $p$ of $n$ for which $p-1$ is $B$-powersmooth will divide $a^k - 1$ for all $a$ coprime to $n$, and the prime factors $q$ of $n$ for which $q-1$ is not $B$-powersmooth will only rarely divide $a^k-1$.

Thus when for a squarefree $n = p_1\cdot \ldots \cdot p_r$ all the $p_{\rho}-1$ have the same largest prime power divisor $q^m$, the algorithm can only find a nontrivial divisor of $n$ when $B < q^m$, and the chosen base $a$ is a suitable power residue modulo some but not all of the $p_{\rho}$. (If $n$ is not squarefree, then for a prime $p$ with $p^2 \mid n$ it's likely that $p \mid a^k - 1$ but $p^2 \nmid a^k-1$ for $B \geqslant q^m$, so we'd get a nontrivial factor with high[ish] probability even if $q^m$ is the maximal prime power divisor of all $p_{\rho}-1$.)

If the largest prime power dividing $p_{\rho}-1$ is not the same for all $\rho$, then a value of $B$ between the smallest and the largest of these maximal prime power divisors will find a factor with high probability.

If one executes the algorithm with a fixed $a$ and increments $B$ (starting with $B \geqslant 5$, say) for $n = 163\cdot 811$, one needs a bit of luck to choose an $a$ that is a cubic (or ninth power, or $27^{\text{th}}$ power) residue modulo one of the factors but not the other. One can reduce the amount of luck needed by using several $a$ for each $B$. This of course multiplies the work by the number of bases one tries. A strategy that avoids that multiplication is to execute the algorithm with a fixed base $a$, and when $\gcd(a^k-1,n) = n$ for $k = k(B)$ but $\gcd(a^k-1,n) = 1$ for $k = k(B-1)$, then it's likely that $B$ is the largest prime power dividing each of the $p_{\rho}-1$, say $B = q^m$, and trying several other bases for $k(B-1) = k(B)/q$ has decent chances to find a factor. Since the probability that a randomly chosen number is a $q^{\text{th}}$ power residue modulo a prime $p \equiv 1 \pmod{q}$ is roughly $1/q$, if being a $q^{\text{th}}$ power residue modulo different such primes is independent, the probability of finding a base that is a $q^{\text{th}}$ power residue modulo one of two prime factors is about $\frac{2q-1}{q^2}$. Then we would expect to find a factor within about $q$ tries. If $q$ is large, that's bad, but for small $q$ it's feasible. (Of course there's still luck needed, but we have a guesstimate how much luck we need. However, if our guess that $B$ was the largest prime power divisor of all the $p_{\rho}$ was wrong, our guesstimate may be quite wrong too.)

Share
Cite
Follow
answered Jan 29, 2020 at 22:17
user avatar
Daniel Fischer
200k1818 gold badges250250 silver badges375375 bronze badges
Add a comment
Your Answer
]]]
[[
生日悖论birthday paradox
  1/2 概率发生碰撞 所需数量为O(sqrt(N))
    365==>>23
  N==>>n
  不发生碰撞的概率<N>(n) = N/N * (N-1)/N * ... * (N-n+1)/N <= 1-expected_probability
  Permutation<N>(n) <= N**n * (1-expected_probability)
  近似算法:不发生碰撞的概率<N>(n) ~= ((N-1)/N)**Combination<N>(2)
    每一对 不碰撞的 概率是 ((N-1)/N)
    共有 N*(N-1)/2 对
]]
[[[
wget 'https://github.com/delta003/lenstra_algorithm/blob/master/lenstra.py' -O 'github.com-delta003-lenstra.py.html'
===
import argparse
from random import randint
from fractions import gcd
# Sieve of Eratosthenes
def primes(n):
    b = [True] * (n + 1)
    ps = []
    for p in xrange(2, n + 1):
      if b[p]:
        ps.append(p)
      for i in xrange(p, n + 1, p):
        b[i] = False
    return ps
# Finds modular inverse
# Returns inverse, unused helper and gcd
def modular_inv(a, b):
    if b == 0:
      return 1, 0, a
    q, r = divmod(a, b)
    x, y, g = modular_inv(b, r)
    return y, x - q * y, g
# Addition in Elliptic curve modulo m space
def elliptic_add(p, q, a, b, m):
    # If one point is infinity, return other one
    if p[2] == 0: return q
    if q[2] == 0: return p
    if p[0] == q[0]:
      if (p[1] + q[1]) % m == 0:
        return 0, 1, 0 # Infinity
      num = (3 * p[0] * p[0] + a) % m
      denom = (2 * p[1]) % m
    else:
      num = (q[1] - p[1]) % m
      denom = (q[0] - p[0]) % m
    inv, _, g = modular_inv(denom, m)
    # Unable to find inverse, arithmetic breaks
    if g > 1:
      return 0, 0, denom # Failure
    z = (num * inv * num * inv - p[0] - q[0]) % m
    return z, (num * inv * (p[0] - z) - p[1]) % m, 1
# Multiplication (repeated addition and doubling)
def elliptic_mul(k, p, a, b, m):
    r = (0, 1, 0) # Infinity
    while k > 0:
      # p is failure, return it
      if p[2] > 1:
        return p
      if k % 2 == 1:
        r = elliptic_add(p, r, a, b, m)
      k = k // 2
      p = elliptic_add(p, p, a, b, m)
    return r
# Lenstra's algorithm for factoring
# Limit specifies the amount of work permitted
def lenstra(n, limit):
    g = n
    while g == n:
      # Randomized x and y
      q = randint(0, n - 1), randint(0, n - 1), 1
      # Randomized curve coefficient a, computed b
      a = randint(0, n - 1)
      b = (q[1] * q[1] - q[0] * q[0] * q[0] - a * q[0]) % n
      g = gcd(4 * a * a * a + 27 * b * b, n) # singularity check
      # If we got lucky, return lucky factor
      if g > 1:
        #我:bug: g==n
        if 1: if g==n:continue
        return g
      # increase k step by step until lcm(1, ..., limit)
      for p in primes(limit):
        pp = p
        while pp < limit:
          q = elliptic_mul(p, q, a, b, n)
          # Elliptic arithmetic breaks
          if q[2] > 1:
            return gcd(q[2], n)
          pp = p * pp
    return False
# Command line tool
def main():
  parser = argparse.ArgumentParser(description = 'Process arguments')
  parser.add_argument('--n', type = int,
    help = 'number to factor')
  parser.add_argument('--limit', type = int, default = 1000,
    help = 'work limit (default = 1000)')
  args = parser.parse_args()
  print lenstra(args.n, args.limit)
if __name__ == '__main__':
  main()
]]]
[[[
https://crypto.stackexchange.com/questions/1190/why-is-elliptic-curve-cryptography-not-widely-used-compared-to-rsa
===
Cryptography
Why is elliptic curve cryptography not widely used, compared to RSA?
Asked 10 years, 8 months ago
Modified 2 years ago
Viewed 118k times

173


124
I recently ran across elliptic curve crypto-systems:

An Introduction to the Theory of Elliptic Curves (Brown University)
Elliptic Curve Cryptography (Wikipedia)
Performance analysis of identity management in the Session Initiation Protocol (SIP) (IEEE)
Overview of Elliptic Curve Cryptosystems. (RSA.com)
It seemed to me to be great alternative to RSA as the de-facto cryptosystems to be used in banking and financial systems and in the public key infrastructure for certificates, but is not used! If someone can explain why this is not done, it would be very helpful. A comparison between traditional RSA and an elliptic curve cryptology would be helpful.

To begin with:

Advantage of RSA:

Well established.
Advantages of elliptic curve:

Shorter keys are as strong as long key for RSA (see the IEEE paper)
Low on CPU consumption.
Low on memory usage.
rsa
public-key
elliptic-curves
computational-complexity-theory
Share
Improve this question
Follow
edited Jul 6, 2020 at 8:54
user avatar
R1w
1,86633 gold badges1818 silver badges4343 bronze badges
asked Nov 15, 2011 at 6:19
user avatar
Vineet Menon
1,91533 gold badges1313 silver badges1010 bronze badges
Excellent answers. Regarding adoption of EC, implementation has always been an issue. However, openssl (from 0.9.8) and lately openssh (from openssh 5.7) have elliptic curve built into them, so we should see greater adoption in future. – 
Raghavendra
 Jul 9, 2012 at 18:03
3
@SmitJohnth: 'RSA' faster than 'ECC'? How's that? The lower CPU consumption and lower memory consumption of ECC doesn't automatically translate to a faster algorithm? – 
Vineet Menon
 May 5, 2013 at 13:04
1
@VineetMenon crypto.stackexchange.com/questions/1190/… RSA can use very short public key. This wouldn't word with DH-based ciphers, used with ECC. – 
Smit Johnth
 May 5, 2013 at 13:32 
2
One additional minor advantage for RSA is that it is believed it will hold up better against a quantum computer compared to ECC. I don't think that ever causes anyone to choose RSA over ECC though. – 
Lie Ryan
 Jun 10, 2017 at 14:34 
1
@LieRyan, interesting.. more at Why is ECC more vulnerable than RSA in a post-quantum world? – 
Vineet Menon
 Jun 12, 2017 at 4:43 
Show 4 more comments
4 Answers
Sorted by:

Highest score (default)

155

RSA was there first. That's actually enough for explaining its preeminence. RSA was first published in 1978 and the PKCS#1 standard (which explains exactly how RSA should be used, with unambiguous specification of which byte goes where) has been publicly and freely available since 1993. The idea of using elliptic curves for cryptography came to be in 1985, and relevant standards have existed since the late 1990s. Also, both RSA and elliptic curves have been covered by patents, but the RSA patents have expired in 2000, while some elliptic curve patents are still alive.

One perceived, historical advantage of RSA is that RSA is two algorithms, one for encryption and one for signatures, that could both use the same key and the same core implementation. But this is not a real advantage because it is usually a bad idea to use the same key for both encryption and signatures. Also, you can mathematically use the same private key for ECDH (key exchange) and for ECDSA (signatures), so that's really not an "advantage" of RSA over EC at all.

Another advantage of RSA is that its mathematics are somewhat simpler than those involved for elliptic curves, so many engineers feel that they "understand" RSA more than elliptic curves; again, a fallacious argument, since implementation of cryptographic algorithms is fraught with subtle details and best left to professionals -- and there is no need to understand the internal mathematics of a library to simply use it (we could make this argument semi-valid by pointing out that RSA relies on the hardness of factorization, which has been studied for 2500 years, whereas discrete logarithm on elliptic curves can only sport about 25 years of research).

The only scientifically established advantaged of RSA over elliptic curves cryptography is that public key operations (e.g. signature verification, as opposed to signature generation) are faster with RSA. But public-key operations are rarely a bottleneck, and we are talking about 8000 ECDSA verifications per second, vs 20000 RSA verifications per second.

An additional interoperability issue is that elliptic-curve operations can be made over curves of distinct types, and can be widely optimized if you stick to a specific curve known when the code was written. There is no security issue in using the same curve for many distinct people with distinct key pairs. But it means that most implementations will only support two or three specific curves. NIST has defined 15 standard curves. However, in practice, many implementations only support two of them, P-256 and P-384, because that's what is recommended by NSA (under the name "suite B")(a notorious example is NSS, the cryptography library used by the Firefox Web browser for SSL).

There are two ANSI standards for elliptic curves, X9.62 for signatures (partially redundant with FIPS 186-3, but much more detailed), and X9.63 for asymmetric encryption.

So there is a lot of political push for the adoption of elliptic curves in cryptography, by both academic researchers and institutional organizations. But inertia of the firmly entrenched RSA will take time to defeat. Also, the perceived mathematical complexity, and the potential legal risks related to patents, still hinder wide acceptance of elliptic curves.

(To your list, you can add "key generation time": generating a new key pair for ECDH or ECDSA is widely faster than generating a new RSA key pair.)

Share
Improve this answer
Follow
edited Oct 1, 2017 at 16:33
user avatar
fgrieu♦
124k1111 gold badges267267 silver badges518518 bronze badges
answered Nov 15, 2011 at 15:29
user avatar
Thomas Pornin
84.7k1616 gold badges233233 silver badges309309 bronze badges
10
For me the primary selling point of RSA is that it doesn't leak the private key if your PRNG happens to be badly seeded while signing. While it's possible to avoid this issue, most implementations don't. – 
CodesInChaos
 Apr 18, 2012 at 12:33
14
You can implement RSA from scratch in about 50 lines of python. Try doing that with elliptic curves. Laziness was certainly part of the reason RC4 became so widespread. I think it's true of RSA too! – 
Simon Johnson
 Jul 10, 2012 at 11:04 
4
@curious: I can quote myself. But you can also make benchmarks (with OpenSSL, try openssl speed rsa2048 ecdsap224). – 
Thomas Pornin
 Mar 3, 2013 at 13:34
4
That's because the operation is not exactly the same. With RSA, signature verification uses the public exponent, which can be very short (with RSA, the public exponent typical length is 16 bits, while the privat exponent is as large as the modulus). This gives a huge boost to public key operations in RSA. There's no analog with elliptic curves. – 
Thomas Pornin
 Mar 3, 2013 at 16:53
1
I have a question. I heard that cipher texts encrypted with RSA can possible give hints about the public key used (identify who did or did not encrypt that message) while elliptic curves do not have this weakness. Is this true? – 
Xeoncross
 Jul 9, 2013 at 16:25 
Show 7 more comments

38

This is mostly a supplement to @ThomasPornin's answer, not a complete answer on its own (but too long to fit in a comment).

ECC uses a finite field, so even though elliptical curves themselves are relatively new, most of the math involved in taking a discrete logarithm over the field is much older. In fact, most of the algorithms used are relatively minor variants of factoring algorithms.

The real question (and one that's still open, AFAIK) is whether discrete logarithms over an elliptical curve have the same "smoothness" property as you use in the sieve-based algorithms for factoring the product of large primes. If elliptical curves aren't "smooth" (and quite a few mathematicians seem convinced they're not) then the sieve-style factoring algorithms can't be adapted to taking discrete logarithms over elliptical curves. If they are smooth (and a fair number of other mathematicians seem convinced this is likely to be true), however, the sieve-style algorithms could be adapted. This would be a significant "break" against ECC -- you'd need to increase key sizes substantially to maintain security (probably not to quite as large as RSA for equivalent security, but fairly close).

What this all comes down to is one thing: it's not nearly so clear-cut a difference as 2500 years vs. a few decades. If anything, almost the opposite is actually true: variants of most of the older factoring algorithms can be used to find discrete logarithms over elliptical curves. What does not apply (at least based on present knowledge) to elliptical curves is the research of the last few decades or so into sieve-based algorithms.

As far as the patent situation goes, I think the situation is much more clear than @poncho implies. Yes, Certicom holds some patents (120 currently, though not all of them are on ECC), but what is or isn't covered by those patents has been quite clear for years. Their patents cover some specific ways to optimize ECC, but definitely do not cover ECC itself. In fact, the patents themselves have a "Field of the Invention" (or, in some, "Background of the invention") section that tells you about what was known before the patent, and these have a fairly complete explanation of how to use ECC for both encryption and signatures. For example, see US Patent Number 6,141,420, which has quite a decent explanation of the math involved in elliptical curves, and how to implement ElGamal with elliptical curves -- all in the description of what was known prior to the patent.

Share
Improve this answer
Follow
edited Apr 13, 2017 at 12:48
user avatar
CommunityBot
1
answered Nov 15, 2011 at 16:11
user avatar
Jerry Coffin
1,1141111 silver badges1414 bronze badges
1
Blackberry and Certicom claim over 300 patents in the arena, IIRC. See, for example, the NSA Sublicense FAQ at The National Security Agency’s ECC License Agreement with Certicom Corp. Certicom and Blackberry also claim to have patents that cover what CAs need to issue certificates with elliptic curves (perhaps implementation related?). See, for example, Certicom's IPR Licensing Contributions to the IETF's IKE, SSL, TLS, CMS, and S/MIME. – 
user10496
 Dec 26, 2013 at 4:44 
Add a comment

23

Part of the reason is trust; RSA has been around longer than EC, and people feel they understand it, and they trust it more (and in security, this is important). It's also easier to implement.

However, I believe that a bigger concern (at least for major companies) is the fear of being sued; there's a small company called Certicom that holds a number of EC-related patents, and has threatened to sue anyone who might infringe on their patents (and, of course, without there being any clear definition of what those patents actually cover). They have sued Sony (and eventually settled out of court).

The bottom line: for quite a while, it was just easier for companies to stick with RSA/DH, rather then either pay Certicom or take the legal risk.

Lately, things have shifted; people have figured out they can implement EC using things that can be documented to predate the Certicom patents (and hence are immune to lawsuit); it appears that more common use of Elliptic Curves is not that far away.

Share
Improve this answer
Follow
answered Nov 15, 2011 at 15:25
user avatar
poncho
133k1010 gold badges209209 silver badges336336 bronze badges
3
since you are talking about implementations, wiki says there are open source implementation available in openSSH and others. So, as a programmer if I'm prompted to use that; will it do harm to me or my firm? I guess not!! – 
Vineet Menon
 Nov 15, 2011 at 18:42
At PGP we had implementations of EC in the SDK, but they were stripped on compile specifically due to the patent issue. It's not the core implementations that you have to worry about, it's all of the performance aspects and implementation details that are encumbered. – 
MrEvil
 Jun 10, 2013 at 15:58
Add a comment

10

You forgot to mention one additional advantage of elliptic curves: the generation of keys is much faster than with RSA.

In europe, many government smart card solutions are now based on ECC:

The european electronic pass ports
The Austrian card
The German ID card
The new German health insurance card
Share
Improve this answer
Follow
answered Oct 3, 2015 at 21:09
user27950
2
To whom It may concern, the german ID card does use Brainpool P256r. – 
hdev
 Dec 7, 2016 at 9:18
2
didn't someone prove that the brainpool "r" curves were not, in fact, random... except maybe the 512r? – 
Erik Aronesty
 Sep 11, 2018 at 21:10
Add a comment
]]]
]]]]]]]


e /storage/emulated/0/0my_files/tmp/xxx/auto/myBookShelf.json
  替换『/storage/72A2-151D/000edt/0my_files/novel/』
  为『/storage/emulated/0/20220614_copy5sd__0my_files/novel/』
  ##『/storage/emulated/0/0my_files/novel/』
  %s/\/storage\/72A2-151D\/000edt\/0my_files\/novel\//\/storage\/emulated\/0\/20220614_copy5sd__0my_files\/novel\//g
  %s/\/storage\/72A2-151D\/000edt\/0my_files\/book_txt\//\/storage\/emulated\/0\/20220614_copy5sd__0my_files\/book_txt\//g

e /storage/emulated/0/0my_files/tmp/xxx/auto/myBookShelf.json
!mv /storage/emulated/0/0my_files/tmp/xxx/auto/myBookShelf.json /storage/emulated/0/0my_files/tmp/xxx/auto/20220723-myBookShelf.json /storage/emulated/0/0my_files/tmp/xxx/auto/20220723-修改后-myBookShelf.json /storage/emulated/0/0my_files/tmp/xxx/
  长按『阅读』桌面图标->应用信息->:
    ->强行停止
    ->存储占用->清除数据
  修改『/0my_files/tmp/xxx/myBookShelf.json』
  打开『阅读APP』->右侧栏:恢复->选路径『/0my_files/tmp/xxx/』




TODO:generating function ~ 有理分式 ~ 展开式 ~ 多项式 除法 ...
  view others/数学/递推/一元有理分式-转化为-递推公式.txt




e others/数学/编程/永恒代码/原貌字符串.txt
e ../lots/NOTE/pseudo_period_of_word/note4pseudo_period_of_word.txt
e script/bifix.py
e ../../python3_src/seed/text/unicode/group_chars_by_block_and_general_category.py
  移位加密 - 路径名
    只针对字母，不加密符号。。。
  同一编码区，同一gc，的 相邻字符 组成一个 移动块。
e ../../python3_src/seed/algo/closure.py

e others/app/termux/setup4realme/termux-setup.txt
  Android 打开本地网页
  欧路词典 ...
  www.eudic.net 安卓版 完整词典 -> 手机 eudb_en
./0未整理复制粘贴文本/6未整理复制粘贴文本.txt
    链接: https://pan.baidu.com/s/1ugzkQCVv8PrHL4601AvMaw
    密码: 1me4
.../txt_phone/txt $ ls -1hs ~/20220614_copy5sd__0my_files/unzip/eudb_en/
total 159M
 79M 1317108648.eudb
 23M 1522017926.eudb
172K 1922908499.eudb
 19M 20017.eudb
 11M 315772229.eudb
4.2M 375916128.eudb
 25M 99569493.eudb
view script/欧路词典.py
cd /sdcard/20220614_copy5sd__0my_files/unzip/eudb_en/
.../unzip/eudb_en $ for i in $(ls) ; do echo $i ; py $my_txt/script/欧路词典.py readline    -b 1046   -n '"@"'    -i  $i ; done
1317108648.eudb
1046 '汉语大辞典'
1522017926.eudb
1046 '新世纪汉英科技大词典'
1922908499.eudb
1046 '计算机词汇'
20017.eudb
1046 'r'
315772229.eudb
1046 '中华成语大词典'
375916128.eudb
1046 '现代汉语词典'
99569493.eudb
1046 '新世纪英汉科技大词典'
.../unzip/eudb_en $

  [[
.../txt_phone/txt $ grep '欧路' -r . -l
./TODO.txt
./TODO2.txt
./TODO3[20220407].txt
./0未整理复制粘贴文本/6未整理复制粘贴文本.txt
./others/app/app.txt
./others/app/app_data_path.txt
./others/app/手机卡顿.txt
./others/app/手机自动关机重启掉电卡顿.txt
./others/app/termux/setup4realme/termux-setup.txt
./others/app/usage/some_app_usage.txt
./script/info_tri_planar_graphs.py
./script/欧路词典.py
.../txt_phone/txt $ grep 'eudb_en' -r . -l
./TODO2.txt
./0未整理复制粘贴文本/6未整理复制粘贴文本.txt
./others/app/app_data_path.txt
./others/app/termux/setup4realme/termux-setup.txt
./script/欧路词典.py
.../txt_phone/txt $
.../txt_phone/txt $ grep '新世纪' -r . -l
./script/欧路词典.py
  ]]

查 话费余额/清单
  『详单查询』
    https://gd.189.cn/TS/new/login.html?loginOldUri=/TS/myhome/query/xiangdan_chaxun.html#/?cmpid=cpb-fwdt-cx-ylcx-xdcx
    短信 0.1元/条

view others/数学/编程/python/Python_interpreter--CPython.txt



ops = type_ctor+tmpl_args
ops+obj hash
  ops.mk_hash_wrapper
  ops.hash
  ops.eq
  obj {cache {ops:(hash, weakref<hash_wrapper>}}
bind ops+obj
bind ops+ctx
  ops 有 语境
  interpreter也有自己的语境
  help==>>语境关键词 深度收集 #并支持类似的 深度收集 框架，向前兼容
bind ops+ctx+obj
  ops immutable
  ctx mutable?
  obj opaque
public symbol
  get('pkg.mod', 'attr....get_tmay_descript', spec--hashable--repr-literal_eval_able)->public symbol
    if cache:
      raise or return sym
    import pkg...mod as M
    tm = M.attr...get_tmay_descript(spec)
    if not tm:
      set cache err
    else:
      mk new public symbol
      set cache sym
    recur...
DONE:
  page_rank 添加一个 虚拟节点，与其他节点 双向 连通所有节点，保证 有进有出 动态平衡存在，重点是 没有 不连通分量，有向图强连通分量唯一，保证 解唯一，虚拟点 不 参与 概率分配。

view ../../python3_src/seed/algo/page_rank.py
    mk_pseudo_mapping_opss
    之前肯定有！重构代码！！
view ../../python3_src/nn_ns/app/crypt/involution/InvolutoryCipher.py
  from seed.seq_tools.seq_as_mapping import SeqAsMapping
  from seed.mapping_tools.mapping_as_seq import MappingAsSeq
TODO:
  不允许嵌套但允许内嵌原貌字符串的通用单点转义方案
  e ../../python3_src/自己的相关数据/on_working.txt
  e ../../python3_src/seed/seq_tools/escape_schemes/universal_single_point_escape_scheme__enable_raw_text__disable_recur.py
TODO:备份:浏览器收藏；阅读APP记录；当前编辑中未完成的代码文件
  ===编辑中的代码:
  e ../../python3_src/seed/seq_tools/lsls52ls.py
      bisearch 替代数组
  e ../../python3_src/seed/math/matrix/solve_matrix.py
    线性规划/不等式组/凸包切割
  e ../../python3_src/nn_ns/app/crypt/involution/InvolutoryCipher.py
    填充...
  e ../../python3_src/seed/seq_tools/escape_schemes/universal_single_point_escape_scheme__enable_raw_text__disable_recur.py
    结束串 合格判定
  ===论文:下载地址
  e /sdcard/0my_files/book/math/linear_programming/
    --> 复制到:view others/book/linear_programming.txt
  ===阅读APP
  view /storage/emulated/0/0my_files/tmp/xxx/阅读app备份json/\[20211017]阅读app备份json/myBookShelf.json
  view others/app/备份app配置信息/阅读app备份json-delta\[20220315]\[20211017].zip
  view others/app/备份app配置信息/阅读app备份json-delta\[20220604]\[20220315].zip
  ===备份:公历农历节气对照表？
  view /sdcard/0my_files/tmp/out4py/农历/农历.py.打印公历农历日期对照表.out.txt
    view script/农历/农历.py.打印公历农历日期对照表.out.txt.zip
      已备份！
  ===备份:知轩藏书-小说列表自建页面？
  !mv /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/saved_sortss/sorts\[20220420]/zxcs-sorts-37-39-42[20220420].zip script/download_zxcs_novel/zips/
  view script/download_zxcs_novel/merge_link_iinfos_and_scores.py
  view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/saved_sortss/sorts\[20220420]/42.scored.html
    xxx view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.scored.html
    xxx file:///sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.scored.html
  === org.mozilla.firefox如何导出导入收藏夹？
  [[
https://android.stackexchange.com/questions/171240/export-firefox-for-android-bookmarks-to-html-file
As of 2019, Firefox for Android has no built-in support for exporting bookmarks. However there are some workarounds/alternatives: According to the "Chosen Solution" on the Firefox Support Forum, use Firefox Sync for Android to transparently move bookmarks across devices.
  好恶心！有一不干人事的蠢货！
  ]]
[[2022手机价格
[
https://zhuanlan.zhihu.com/p/429282569
realmeQ3s

    处理器：骁龙778G
    屏幕：6.6英寸，LCD，144Hz
    摄像头：4800w主摄+黑白镜头+微距镜头

realme 真我Q3s 骁龙778G 5G 144Hz变帧屏 5000mAh大
京东
¥1199.00
去购买

优点：

    搭载骁龙778G处理器，在高分辨率下玩王者荣耀，半小时平均帧数是47帧，有时候打团会降到35帧左右，千元机主流表现水平。续航能力好，5000mAh的大电池容量，玩一个小时的游戏耗电15%左右，不玩游戏可以撑一整天，没有续航焦虑。电量完全充满需要65分钟。屏幕是LCD屏，支持144hz的高刷新率，支持7档智能变帧，但是由于应用适配问题，使用起来会有割裂感，建议全局144hz。

缺点：使用转子马达。
]
[
https://zhuanlan.zhihu.com/p/95806258
[
Redmi Note 11 4G（综合产品力最强4G百元机）
Redmi Note 11 4G 4GB+128GB 梦幻晴空
京东
¥969.00
去购买​

推荐指数：⭐️⭐️⭐️⭐️⭐️

优势：

    外观设计、机身轻薄，配色挺漂亮；Helio G88处理器，同价位性能很不错；90Hz三档变速刷新率屏幕，在百元机中比较少见；5000万像素三摄，超广角、微距等拍照功能较全面；支持红外遥控、立体声双扬声器；支持18W有线快充，标配22.5W充电器；5000mAh超大容量电池带来长续航；

不足：

    采用eMMC5.1闪存规格；

点评：

Redmi Note 11 4G是当前小米旗下1000元以内综合产品力最强的一款4G入门机。

与另外几款入门级4G手机相比，Redmi Note 11 4G不仅拥有性能更强的处理器、90Hz刷新率屏幕，而且在具备5000mAh大电池的基础上拥有比较轻薄的机身，181g的机身重量在千元机中手感很不错。

另外，Redmi Note 11 4G的外观设计做得很不错，晴空、白色、黑色三款配色在百元机中都比较出彩，是当前非常值得入手的一款产品。
]
[

Redmi Note11 SE（综合产品力最强的5G百元机）
Redmi Note11SE 4GB+128GB 暗影黑
京东
¥1099
去购买​
【定金100抵200 享6重好礼】红米Note 11 SE
天猫
¥999.00
去购买​

推荐指数：⭐️⭐️⭐️⭐️⭐️

优势：

    天玑700，百元机中性能好；90Hz四档变速刷新率，触控流畅；5000mAh大电池带来长续航；

不足：

    同价位无明显不足；

点评：

Redmi Note11 SE本质上是Redmi Note 10 5G这款千元机的套娃机。

Redmi Note 10 5G虽然是Redmi Note 9 5G的迭代机型，但是除了屏幕刷新率升级到90Hz和机身更轻薄以外，在处理器性能、相机、扬声器等方面其实是缩水的，综合产品力不如Redmi Note 9 5G。尤其在Redmi Note 11 5G发布之后，产品力更是相对偏弱，在1000-1500价位竞争力比较一般。

所以，小米将Redmi Note 10 5G换了个壳、改个名字、降低了100块钱售价就成了Redmi Note11 SE。

那么降价之后的Redmi Note11 SE顿时就成为1000元以内性能最强的小米机型，瞬间变得值得选购了。

在999元价位，Redmi Note11 SE拥有天玑700处理器、1080p高刷屏幕、18W快充、5000mAh大电池以及相对轻薄的机身，是一款性价比颇高的5G入门级手机。

不过只建议选购4GB+128GB版本，因为8GB+128GB版本同价位竞争力一般。

]
[
realme Q3s（1500以内价位性能最强的手机）
realme Q3s 8+128GB 星云色
京东
¥1419
去购买​

推荐指数：⭐️⭐️⭐️⭐️⭐️

优势：

    星光纹理设计，外观比较漂亮；高通骁龙778G处理器，同价位性能最强；7档144Hz智能变速刷新率屏幕，兼顾屏幕流畅与低功耗；电竞级VC液冷散热系统，同价位散热不错；30W有线快充，同价位充电速度较快；5000mAh大电池带来长续航；

不足：

    塑料机身；不支持NFC；后置相机缺乏超广角镜头；

点评：

原本realme Q3就是1500-2000价位产品力最强的机型之一，如今升级到realme Q3s之后产品力更上一层楼。

相对于realme Q3，relame Q3s主要升级了三点：

    处理器升级，从高通骁龙750G升级为高通骁龙778G，后者这款处理器常见于1500-2000价位机型；屏幕升级，120Hz高刷屏升级为144Hz变速高刷屏；手感升级，机身厚度从8.8mm降为8.5mm，手感更好一些。

总体来说，realme Q3s不仅是一款性能超强的机型，而且是屏幕、续航、外观兼顾的产品，在1000-1500价位非常值得选购。
]
]
]]
[[[[[
TODO:线性不等式组 解方程。。。
  solve linear inequality algorithm source code
  linear programming线性规划
    我的算法:切割凸包
      face_idx->ordered[vertex]
        {face:{vtx:vtx}}
          仅限于？三维？
      vertex_idx->ordered[face_idx]
        {vtx:{face:face}}
      vertex_idx->point/coor
      #vertex_idx->ordered[edge_idx]
      #edge_idx -> {vertex_idx, vertex_idx}
      E+2=V+F
      F:切面数
      M:不等式的数目
      N:变量囗数目(标准/非负)
      F <= M
      V0 = 原点+各维无穷原点=1+N
      V <= V0 -1+N
    另:证明无解:
      等式方程组:
        行的线性组合 得 左零=右非零
      不等式组:
        大于等于零行*正系数+小于等于零的行*负系数 < 0
[[我的算法:切割凸包
自造词:单锥simplex(k+1个端点的k-convex_hull), 延伸空间span_space, 次平面hyperplane(比主空间低一维的延伸空间), 主空间space(相对于hyperplane而言, RR**d), facet次切面(k-convex_hull的低一维外表面, 是(k-1)-convex_hull)
凸包convex_hull
  m-vertices
  k-convex_hull k维凸包，即 m个端点的延伸空间 k维
  d维 实数 主空间, d>=k
k-simplex共有k+1个端点/0-face，k+1个facet/(k-1)-face, C(k+1,k-i)个 i-face
  i-face 是 i-convex_hull
  k-simplex 的 i-face 是 i-simplex
k-convex_hull的k个共点facet的交点是 端点
k-convex_hull的k-1个共边facet的交边是 棱边


* [d>k]:
  如果d>k,则 重立坐标系，令d'=k
* [d==k]:
  记录 当前凸包 的 以下信息:
    vtc = 所有端点
    edges = 所有棱边
    facets = 所有次切面
    edge2vtc = 棱边的所有端点#==2#棱边的表达
    facet2法向量 = facet2linear_equality = 次切面的表达#(d+1)个系数, 坐标向量变量=d个实数变量
    facet2inequality_signs # 标准化系数，防重复，重复时 不等号 可能不同，多个并存
    vtc2point = 端点的坐标#端点的表达#坐标向量=d个实数

    facet2vtc = 次切面的所有端点#>=k
    vtx2facets = 端点的所有次切面#==k
    vtx2edges = 端点的所有棱边#>=k
    edge2facets = 棱边的所有次切面#==k-1
  ##约束:==大概率降维;</>/<=/>=大概率不降维;!=无影响
  #以下不考虑==,!=
  TODO:
  次平面 是否 重复？
    若已出现过，则 考虑 约束/不等号 是否 更改，更新 信息
  次平面 切割 凸包 所得 新凸包:
    + 新增端点 为 次平面 与 旧棱边的交点
      通过 判断 棱边的两个端点 关于 次平面 线性函数的求值结果 的 正负符号 是否 相反(零 再说)
        [次平面上的向量 * 法向量 == 0]
        [次平面上的点 * 法向量 == 常量K]
        [这里假设 所有不等式 都是『>=』]
        则[保留的旧端点 * 法向量 >= 常量K]
        则[删除的旧端点 * 法向量 < 常量K]
    + 新增棱边 为 次平面上的棱边
      穷举C(新增端点数,2) 再 判断 此两端点u,v的连线是否是 棱边:
        棱边 是 至少(k-1)个 次切面 的 共线
        所以 len(vtx2facets[v]/-\vtx2facets[u])>=k-1
    - 删除旧端点(<0)
    + 更新旧端点(==0) vtx2facets[v]+=curr_facet
    - 删除旧棱边(两端点均被删;<0) #只要有一个端点不被删，即保留
    - 更新旧棱边(相交==>>端点改变)

]]
[[凸包
  D = 空间维数
  点 :: [Real]{len=D}
  M = len(点集)
  N = len(凸包端点集)
  ====
  难题零 任意非唯一拆分凸包为单锥: 凸包端点集 -> {单锥端点集} #结果非唯一
    m-vertices k-convex_hull -> {k-simplex}{len=m-k}
  ====
  ### 难题一 求凸包端点集: 点集 -> 凸包端点集
  难题一 求凸包端点集: 点集 -> (凸包端点到分割面系数, 点到凸组合系数)
    [凸包端点集 <= 点集]
    [@点 <- 点集\-\凸包端点集. [难题二(点,凸包端点集)===Right _]]
    [@点 <- 凸包端点集. [难题二(点,凸包端点集\-\{点})===Left _]]
  ====
  难题二 内外判定证明: 点 -> 凸包端点集 -> Either 分割面系数<D> 凸组合系数<N>
    分割面系数 :: [Real%1]{len=D}
      @凸包端点. [内积(凸包端点 - 点, 分割面系数) > 0]
    凸组合系数 :: [Real]{len=N}
      ## 凸组合 = 凸组合(凸组合系数, sorted(凸包端点集)) =[def]= 矩阵(sorted(凸包端点集))*向量(凸组合系数)
      [凸组合 === 点][sum 凸组合系数 === 1][min 凸组合系数 >= 0]
      ###需要 线性规划？
      #分割面系数 <<== [X:slack] X.>0 && A*X.>b 无目标函数，只求任意解
      #     改求 距离, 最短距离？找出 由凸包外的点 指向 凸包上距其最近的点 的 这条射线，则 凸包任意点 在此射线上的投影 只能 处于 最近点 外侧
      #     分解为 多个 k-simplex
      #         ??找出 facet 再求 最近点??
      #         见下面:计算点到单锥距离的最近点
      #     xxx 二次方程？奇异矩阵？偏导？
      #凸组合系数 <<== [X==凸组合系数] X.>=0 && A'*X==b' <<== X.>0 && A''*X.>b'' 无目标函数，只求任意解
      #     可以 将 k-convex_hull<N> 分割成 (N-k)个 k-simplex
      #     simplex 生成空间内部点 线性组合 解 唯一(判断 唯一的 线性组合系数 是否为 凸组合系数 容易)，生成空间外部点 无解
  ====
  问题三 两端点是否相邻: 两端点->凸包端点集->Either (端点,凸组合系数<N-1>) 分割面系数<D>
    输出-端点 <- 输入-两端点 |<=| 凸包端点集
    凸组合系数<N-1> 用于组合除了 输出-端点  的其余端点，结果为 输入-两端点 的 中点
    分割面系数<D> 分隔 输入-两端点 与 其余端点
    ###即：判断 输入-两端点 的 中点 是否在 凸包内部 <==> 中点 是否在 (凸包\-\输入两端点其一)内部

]]
[[
face? 各维切面？
simplex? 多维三角单锥体？
  k-simplex in RR**d, -1<=k<=d
    d维实数欧几里得空间
  k-simplex <- convex k-polytype
  k-simplex is a k-polytype formed by the convex hull of (k+1) points in RR**d, d>=k
  ===
  number of i-faces of k-simplex is C(k+1,k-i)===C(k+1, i+1)
    ##i.e. choose (k-i) from total (k+1) facets
    #   i-face is intersection of (k-i) facets
    #   i-face is i-simplex
    #   all faces form a lattice
    #
    1 k-face is the k-simplex itself
    1 -1-face is the empty set of vertex
    k+1 (k-1)-faces/facets
    k+1 0-faces/vertices
    C(k+1,2) (k-2)-faces/ridges
    C(k+1,2) 1-faces/edges
standard perturbation techniques?
  the line L through the origin spanned by a is an admissible shelling line for P. This assumption is justified since admissibility of the shelling line can be simulated using standard perturbation techniques.


k-simplex 的 (k+1)个facet 将 k维空间 分割成 (2**(k+1)-1) 个 块。假设块内的点 可以 见到 i个facet(不被其他facet挡住)，则 这样的块共有C(k+1,i)个，i<-[1..=k+1]; i=/=0; i===k+1时，唯一的块即是k-simplex的内部
计算点到单锥距离的最近点
  #自造词:单锥simplex, 次平面hyperplane
  外部点u到k-simplex的距离的计算:
    * [k==0]:
        点到点的距离，直接计算
    * [k>0]:
      * [u不在 k-simplex的延伸空间内]:
        求点z，分解uv为 两个正交分量: uz, zv
          [uz+zv=uv]
            令 uz=uv-zv
          [@x<-f端点集. [xv*uz=0=xv*(uv-zv)]] #正交
            d new vars, k new equalities
            d >= k, 是 点坐标系统的维数
          [?C::mx<k,1>. [(x-v) | x<-f端点集]*C == zv] #共面
            k new vars, d new equalities
          ==>> (d+k)vars, (d+k) equalities
        [uz 是否为 零向量] 决定 [u在不在 k-simplex的延伸空间内]
        问题转化为 [z到k-simplex的距离 且 z在k-simplex的延伸空间内]

      * [u在 k-simplex的延伸空间内]:
        从k-simplex的(k+1)个端点中排除一个v，由剩下的k个端点确定一个facet, f.
        判断 u,v,f的位置关系:
          * u在f的延伸空间内
          * f对于u可见，即 线段uv 穿过f的延伸空间
          * f对于u不可见，即 线段uv 不穿过f的延伸空间
          ###如何计算？
            以v为原点，以f的k个端点为 单位长度的轴向量，构建坐标系统，得到 k维空间RR**k
            f的延伸空间 是 新空间内 的 次平面(？自造词)，由于 端点 坐标 是 echo_mx<k,k>[:,i]，f的延伸空间 可表达为 [k-sum x[i] {i<-[1..=k]}===0]
                !!次平面 总是将 空间(仅高出次平面1维) 分成3部分: [===0],[>0],[<0]
            记 lhs<X> = k-sum x[i] {i<-[1..=k]}
            [f的延伸空间 === {X | [lhs<X>===0]}]
            [lhs<v> > 0]
            根据lhs<u>与0的大小关系，可知u,v,f的位置关系

        如果『u在f的延伸空间内』，则 这样的 f只有一个，问题转化为 u 到 (k-1)-simplex f 的距离计算(降维)
        否则 问题转化为 u到 所有对于u可见的f的交集『某一维face』(即 排除所有相应的端点v) 的 距离，假设 可见的f共有w个，w<-[1..=k],则 该face(not facet)是一个(k-w)-simplex (必定降维，可能一步到位直接成端点)
]]
[[[
[[
https://www.researchgate.net/publication/258121773_A_Simple_Algorithm_for_Convex_Hull_Determination_in_High_Dimensions
    Algorithm: Determining an approximation convex hull based on a user defined threshold
    近似算法 无用

[4] V. Bayer, “Survey of Algorithms for the Convex Hull Problem”, Department of Computer Science, Oregon State University, 1999.
]]
[[
n**(d/2)
  n - num_vertices
  d - num_dimensios
https://libgen.lc/edition.php?id=13339536
  https://link.springer.com/article/10.1007/BF02573985
    An optimal convex hull algorithm in any fixed dimension (1993)(Chazelle)[nlogn+n^(d//2)].pdf
ls /sdcard/Download/Chazelle1993_Article_AnOptimalConvexHullAlgorithmIn.pdf
!mv /sdcard/Download/Chazelle1993_Article_AnOptimalConvexHullAlgorithmIn.pdf  '/sdcard/0my_files/book/math/linear_programming/An optimal convex hull algorithm in any fixed dimension (1993)(Chazelle)[nlogn+n^floor_half(d)].pdf'
view /sdcard/0my_files/book/math/linear_programming/An optimal convex hull algorithm in any fixed dimension (1993)(Chazelle)[nlogn+n^floor_half(d)].pdf
  20. Seidel, R. Constructing higher-dimensional convex hulls at logarithmic cost per face, Proc. 18th Annual ACM Syrup. on Theory of Computing, 1986, pp. 404-413.
    https://doi.org/10.1145/12130.12172
      https://dl.acm.org/doi/10.1145/12130.12172
        https://dl.acm.org/doi/pdf/10.1145/12130.12172

!mv /sdcard/Download/12130.12172.pdf  '/sdcard/0my_files/book/math/linear_programming/Constructing higher-dimensional convex hulls at logarithmic cost per face (1986)(Seidel)[m^2+Flogm].pdf'
  very good!
  很多清晰的基础的定义与基础事实
]]
[[
http://www.math.louisville.edu/~ewa/m107/chapter5.pdf
  good!!!
!mkdir /sdcard/0my_files/book/math/linear_programming/
!mv /sdcard/Download/chapter5.pdf  /sdcard/0my_files/book/math/linear_programming/[LP]linear_programming[Simplex-Method][Big-M-Method].pdf
view /sdcard/0my_files/book/math/linear_programming/[LP]linear_programming[Simplex-Method][Big-M-Method].pdf

[
The Simplex Method:
  Maximization with < constraints
  The Simplex Tableau
  When are we finished? ！！流程图！！
  [[
[!Start!] Write standard max problem in standard form ; Initial Simplex Tableau
  -> <?end1?>
<?end1?> negative indicators?
  No -> [Stop! Optimal solution]
  Yes -> [!select pivot column!]
          -> <?end2?>
<?end2?> positive elements in pivot column?
  No -> [Stop! No solution]
  Yes -> [!Select pivot perform pivot operation!]
          -> <?end1?>
  ]]

The Dual Problem
  Minimization with >= Constraints
Mixed Problems
  The Big M Method
  Modified Problem
  Big M, slack, surplus, artificial variables
  Minimization using Big M

]
[
SUMMARY
(Type, Constraints, Right side constants, coeff. of objective function, Solution method)

(Max, <, nonnegative, any, Simplex + slack)
(Min, >, any, nonnegative, dual + above)
(Max, Mixed (<,>,=), nonnegative, any,,modified with slack+surplus+artificial)
(Min, Mixed (<,>,=), nonnegative, any, Max negative of objective)
]
]]
]]]
[[[
[[
https://www.geeksforgeeks.org/simplex-algorithm-tabular-method/

Simplex Algorithm – Tabular Method

    Difficulty Level : Expert
    Last Updated : 16 May, 2020

Simplex Algorithm is a well-known optimization technique in Linear Programming.
The general form of an LPP (Linear Programming Problem) is
Max/Min Z = c^tX s.t. AX \leq b X \geq 0

Example: Let’s consider the following maximization problem.
Max x_1 + x_2 s.t. x_1 + x_2 + x4 = 8 2x_1 + x_2 + x_3 = 10
Initial construction steps :

    Build your matrix A. A will contain the coefficients of the constraints.
    Matrix b will contain the amount of resources.
    And matrix c will contain the coefficients of objective function or cost.

For the above problem –
Matrix A – At Iteration 0

At Iteration 0

Explanation of table-
B : Basis and contains the basic variables. Simplex algorithm starts with those variables which form an indentity matrix. In the above eg x4 and x3 forms a 2×2 identity matrix.
CB : Its the coefficients of the basic variables in the objective function. The objective functions doesn’t contain x4 and x3, so these are 0.
XB : The number of resources or we can say the RHS of the constraints.
yi : The complete Matrix A.

Simplex Algorithm
1. Start with the initial basis associated with identity matrix.
2. Calculate the relative profits.

For MAX problem-
If all the relative profits are less than or equal to 0, then the current basis is the optimal one. STOP.
Else continue to 3.

For MIN problem
If all the relative profits are greater than or equal to 0, then the current basis is the optimal one. STOP.
Else continue to 3.

3. Find the column corresponding to max relative profit. Say column k has the max
Rel. profit. So xk will enter the basis.

4. Perform a min ratio test to determine which variable will leave the basis.
    min ratio test:  XBr/y_{rk} = min\{XB_i/y_{ik}\}
Index of the min element i.e 'r' will determine the leaving variable.
The basic variable at index r, will leave the basis.
NOTE: Min ratio test is always performed on positive elements.

5. It's evident that the entered variable will not form an identity matrix, so
we will have to perform row operations to make it identity again.
Find the pivot element. The element at index (r, k) will be the pivot element and
row r will be the pivot row.

6. Divide the rth row by pivot to make it 1. And subtract c*(rth row) from other
rows to make them 0, where c is the coefficient required to make that row 0.

Table at Iteration 1

Table at iteration 1

Calculation of relative profits – (Cj – Zj), where Cj is the coefficient in Z and Zj is yi*CB
C1 – Z1 = 1 – (1*0 + 2*0)
C2 – Z2 = 1 – (1*0 + 1*0)
C3 – Z3 = 0 – (0*0 + 1*0)
C4 – Z4 = 0 – (1*0 + 0*0)

So Relative profits are- 1, 1, 0, 0 (As shown in the table)
Clearly not all the relative profits are less or equal to 0. So will perform the next iteration.
Determination of entering variable and leaving variable.
Max relative profit 1 at index 1. So x1 will enter the basis.
min ratio test: XBr/y_{rk} = min\{8/1, 10/2\}
Min of (8, 5) is 5 which is at index 2. So x3 will leave the basis.

Since x1 entered perform required row operations to make an identity matrix.

Pivot index = [2, 4]
Pivot element = 2

Divide the 2nd row by pivot element i.e 2 to make it 1.
And subtract 1*R2 from R1 to make it 0
See the next table.

Table At Iteration 2

Table at iteration 2

Relative profits = 0, 1/2, -1/2, 0
Pivot index = [1, 5]
Pivot element = 1/2
Perform necessary row operations.
See next table

Table At iteration 3

Relative profits = 0, 0, 0, -1
Since all relative profits are less than or equal to 0. So optimality is reached.
This will be the final simplex table and the optimal one.
Value of Z at optimality = 6*1 + 2*1 = 8

Following cases can occur while performing this algorithm.

    Case 1 – Unbounded Solution
    If the column corresponding to the max relative profit contains only non-positive real numbers then we won’t be able to perform the min ratio test. Therefore it is reported as unbounded solution.
    Case 2 – Alternate Solution
    If at any iteration any one of the non-basic variable’s relative profit comes out to be 0, then it contains alternate solutions. Many optimal solutions will exist.

Example 2
The above example was an equality case where we were able to find the initial basis. Now we will perform simplex on an example where there is no identity forming.
MAX 2x_1 + 5x_2 s.t. x_1 + x_2 \leq 6 x_2 \leq 3 x_1 + 2x_2 \leq 9
Convert the above problem into standard form i.e
MAX 2x_1 + 5x_2 s.t. x_1 + x_2 + x_3 = 6 x_2 + x_4 = 3 x_1 + 2x_2 + x_5 = 9
where x3, x4 and x5 are slack variables. These will form identity and hence the initial basis.
Table at Iteration 0

Table at iteration 0

Now continuing as the previous example.
Table at iteration 1

Table at iteration 1

Relative profits = 2, 5, 0, 0, 0
Pivot Index = [2, 5]
Pivot element = 1

Table at Iteration 2

Table at iteration 2

Relative Profits = 2, 0, 0, -5, 0
Pivot Index = [1, 4]
Pivot Element = 1

Table at iteration 3

Table at iteration 3

Relative profits = 0, 0, 0, -2, -3, 0
Since all relative profits are less than equal to 0. Optimality is reached.
This is the final simplex table and the optimal one.
Value of Z at optimality = 3*2 + 3*5 + 0*0 = 21

Code Implementation of Simplex Algorithm
import numpy as np
from fractions import Fraction # so that numbers are not displayed in decimal.

print("\n                 ****SiMplex Algorithm ****\n\n")

# inputs

# A will contain the coefficients of the constraints
A = np.array([[1, 1, 0, 1], [2, 1, 1, 0]])
# b will contain the amount of resources
b = np.array([8, 10])
# c will contain coefficients of objective function Z
c = np.array([1, 1, 0, 0])

# B will contain the basic variables that make identity matrix
cb = np.array(c[3])
B = np.array([[3], [2]])
 # cb contains their corresponding coefficients in Z
cb = np.vstack((cb, c[2]))
xb = np.transpose([b])
# combine matrices B and cb
table = np.hstack((B, cb))
table = np.hstack((table, xb))
# combine matrices B, cb and xb
# finally combine matrix A to form the complete simplex table
table = np.hstack((table, A))
# change the type of table to float
table = np.array(table, dtype ='float')
# inputs end

# if min problem, make this var 1
MIN = 0

print("Table at itr = 0")
print("B \tCB \tXB \ty1 \ty2 \ty3 \ty4")
for row in table:
    for el in row:
                # limit the denominator under 100
        print(Fraction(str(el)).limit_denominator(100), end ='\t')
    print()
print()
print("Simplex Working....")

# when optimality reached it will be made 1
reached = 0
itr = 1
unbounded = 0
alternate = 0

while reached == 0:

    print("Iteration: ", end =' ')
    print(itr)
    print("B \tCB \tXB \ty1 \ty2 \ty3 \ty4")
    for row in table:
        for el in row:
            print(Fraction(str(el)).limit_denominator(100), end ='\t')
        print()

    # calculate Relative profits-> cj - zj for non-basics
    i = 0
    rel_prof = []
    while i<len(A[0]):
        rel_prof.append(c[i] - np.sum(table[:, 1]*table[:, 3 + i]))
        i = i + 1

    print("rel profit: ", end =" ")
    for profit in rel_prof:
        print(Fraction(str(profit)).limit_denominator(100), end =", ")
    print()
    i = 0

    b_var = table[:, 0]
    # checking for alternate solution
    while i<len(A[0]):
        j = 0
        present = 0
        while j<len(b_var):
            if int(b_var[j]) == i:
                present = 1
                break;
            j+= 1
        if present == 0:
            if rel_prof[i] == 0:
                alternate = 1
                print("Case of Alternate found")
                # print(i, end =" ")
        i+= 1
    print()
    flag = 0
    for profit in rel_prof:
        if profit>0:
            flag = 1
            break
        # if all relative profits <= 0
    if flag == 0:
        print("All profits are <= 0, optimality reached")
        reached = 1
        break

    # kth var will enter the basis
    k = rel_prof.index(max(rel_prof))
    min = 99999
    i = 0;
    r = -1
    # min ratio test (only positive values)
    while i<len(table):
        if (table[:, 2][i]>0 and table[:, 3 + k][i]>0):
            val = table[:, 2][i]/table[:, 3 + k][i]
            if val<min:
                min = val
                r = i     # leaving variable
        i+= 1

        # if no min ratio test was performed
    if r ==-1:
        unbounded = 1
        print("Case of Unbounded")
        break

    print("pivot element index:", end =' ')
    print(np.array([r, 3 + k]))

    pivot = table[r][3 + k]
    print("pivot element: ", end =" ")
    print(Fraction(pivot).limit_denominator(100))

        # perform row operations
    # divide the pivot row with the pivot element
    table[r, 2:len(table[0])] = table[
            r, 2:len(table[0])] / pivot

    # do row operation on other rows
    i = 0
    while i<len(table):
        if i != r:
            table[i, 2:len(table[0])] = table[i,
                 2:len(table[0])] - table[i][3 + k] *
                 table[r, 2:len(table[0])]
        i += 1


    # assign the new basic variable
    table[r][0] = k
    table[r][1] = c[k]

    print()
    print()
    itr+= 1


print()

print("***************************************************************")
if unbounded == 1:
    print("UNBOUNDED LPP")
    exit()
if alternate == 1:
    print("ALTERNATE Solution")

print("optimal table:")
print("B \tCB \tXB \ty1 \ty2 \ty3 \ty4")
for row in table:
    for el in row:
        print(Fraction(str(el)).limit_denominator(100), end ='\t')
    print()
print()
print("value of Z at optimality: ", end =" ")

basis = []
i = 0
sum = 0
while i<len(table):
    sum += c[int(table[i][0])]*table[i][2]
    temp = "x"+str(int(table[i][0])+1)
    basis.append(temp)
    i+= 1
# if MIN problem make z negative
if MIN == 1:
    print(-Fraction(str(sum)).limit_denominator(100))
else:
    print(Fraction(str(sum)).limit_denominator(100))
print("Final Basis: ", end =" ")
print(basis)

print("Simplex Finished...")
print()

For the above just plug in the required values and you will get a detailed step by step solution of your LPP by the simplex algorithm.

]]
[[
https://optimization.cbe.cornell.edu/index.php?title=Simplex_algorithm


Simplex algorithm
Jump to navigation
Jump to search

Author: Guoqing Hu (SysEn 6800 Fall 2020)
Contents

    1 Introduction
    2 Algorithmic Discussion
    3 Numerical Example
    4 Application
        4.1 Mathematical Problem
        4.2 Industrial Application
    5 Conclusion
    6 References

Introduction

Simplex algorithm (or Simplex method) is a widely-used algorithm to solve the Linear Programming(LP) optimization problems. The simplex algorithm can be thought of as one of the elementary steps for solving the inequality problem, since many of those will be converted to LP and solved via Simplex algorithm.[1] Simplex algorithm has been proposed by George Dantzig, initiated from the idea of step by step downgrade to one of the vertices on the convex polyhedral.[2] "Simplex" could be possibly referred to as the top vertex on the simplicial cone which is the geometric illustration of the constraints within LP problems.[3]
Algorithmic Discussion

There are two theorems in LP:

    The feasible region for an LP problem is a convex set (Every linear equation's second derivative is 0, implying the monotonicity of the trend). Therefore, if an LP has an optimal solution, there must be an extreme point of the feasible region that is optimal
    For an LP optimization problem, there is only one extreme point of the LP's feasible region regarding every basic feasible solution. Plus, there will be a minimum of one basic feasible solution corresponding to every extreme point in the feasible region.[4]

Geometric Illustration of LP problem

Based on the two theorems above, the geometric illustration of the LP problem could be depicted. Each line of this polyhedral will be the boundary of the LP constraints, in which every vertex will be the extreme points according to the theorem. The simplex method is the way to adjust the nonbasic variables to travel to different vertex till the optimum solution is found.[5]

Consider the following expression as the general linear programming problem standard form:

max ∑ i = 1 n c i x i {\displaystyle \max \sum _{i=1}^{n}c_{i}x_{i}} {\displaystyle \max \sum _{i=1}^{n}c_{i}x_{i}}

With the following constraints:

s . t . ∑ j = 1 n a i j x j ≤ b i i = 1 , 2 , . . . , m x j ≥ 0 j = 1 , 2 , . . . , n {\displaystyle {\begin{aligned}s.t.\quad \sum _{j=1}^{n}a_{ij}x_{j}&\leq b_{i}\quad i=1,2,...,m\\x_{j}&\geq 0\quad j=1,2,...,n\end{aligned}}} {\displaystyle {\begin{aligned}s.t.\quad \sum _{j=1}^{n}a_{ij}x_{j}&\leq b_{i}\quad i=1,2,...,m\\x_{j}&\geq 0\quad j=1,2,...,n\end{aligned}}}

The first step of the simplex method is to add slack variables and symbols which represent the objective functions:

ϕ = ∑ i = 1 n c i x i z i = b i − ∑ j = 1 n a i j x j i = 1 , 2 , . . . , m {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\z_{i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{j}\quad i=1,2,...,m\end{aligned}}} {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\z_{i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{j}\quad i=1,2,...,m\end{aligned}}}

The new introduced slack variables may be confused with the original values. Therefore, it will be convenient to add those slack variables z i {\displaystyle z_{i}} {\displaystyle z_{i}} to the end of the list of x-variables with the following expression:

ϕ = ∑ i = 1 n c i x i x n + i = b i − ∑ j = 1 n a i j x i j i = 1 , 2 , . . . , m {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\x_{n+i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{ij}\quad i=1,2,...,m\end{aligned}}} {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\x_{n+i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{ij}\quad i=1,2,...,m\end{aligned}}}

With the progression of simplex method, the starting dictionary (which is the equations above) switches between the dictionaries in seeking for optimal values. Every dictionary will have m basic variables which form the feasible area, as well as n non-basic variables which compose the objective function. Afterward, the dictionary function will be written in the form of:








              ϕ
              = ϕ ¯ + ∑ j = 1 n c j ¯ x j


              x i
              = b i ¯ − ∑ j = 1 n a i j ¯ x i j i = 1 , 2 , . . . , n + m





    {\displaystyle {\begin{aligned}\phi &={\bar {\phi }}+\sum _{j=1}^{n}{\bar {c_{j}}}x_{j}\\x_{i}&={\bar {b_{i}}}-\sum _{j=1}^{n}{\bar {a_{ij}}}x_{ij}\quad i=1,2,...,n+m\end{aligned}}}

{\displaystyle {\begin{aligned}\phi &={\bar {\phi }}+\sum _{j=1}^{n}{\bar {c_{j}}}x_{j}\\x_{i}&={\bar {b_{i}}}-\sum _{j=1}^{n}{\bar {a_{ij}}}x_{ij}\quad i=1,2,...,n+m\end{aligned}}}

Where the variables with bar suggest that those corresponding values will change accordingly with the progression of the simplex method. The observation could be made that there will specifically one variable goes from non-basic to basic and another acts oppositely. This kind of variable is referred to as the entering variable. Under the goal of increasing ϕ {\displaystyle \phi } {\displaystyle \phi }, the entering variables are selected from the set {1,2,...,n}. As long as there are no repetitive entering variables can be selected, the optimal values will be found. The decision of which entering variable should be selected at first place should be made based on the consideration that there usually are multiple constraints (n>1). For the Simplex algorithm, the coefficient with the least value is preferred since the major objective is maximization.

The leaving variables are defined as which go from basic to non-basic. The reason of their existence is to ensure the non-negativity of those basic variables. Once the entering variables are determined, the corresponding leaving variables will change accordingly from the equation below:

x i = b i ¯ − a i k ¯ x k i ϵ { 1 , 2 , . . . , n + m } {\displaystyle x_{i}={\bar {b_{i}}}-{\bar {a_{ik}}}x_{k}\quad i\,\epsilon \,\{1,2,...,n+m\}} {\displaystyle x_{i}={\bar {b_{i}}}-{\bar {a_{ik}}}x_{k}\quad i\,\epsilon \,\{1,2,...,n+m\}}

Since the non-negativity of entering variables should be ensured, the following inequality can be derived:

b i ¯ − a i ¯ x k ≥ 0 i ϵ { 1 , 2 , . . . , n + m } {\displaystyle {\bar {b_{i}}}-{\bar {a_{i}}}x_{k}\geq 0\quad i\,\epsilon \,\{1,2,...,n+m\}} {\displaystyle {\bar {b_{i}}}-{\bar {a_{i}}}x_{k}\geq 0\quad i\,\epsilon \,\{1,2,...,n+m\}}

Where x k {\displaystyle x_{k}} {\displaystyle x_{k}} is immutable. The minimum x i {\displaystyle x_{i}} {\displaystyle x_{i}} should be zero to get the minimum value since this cannot be negative. Therefore, the following equation should be derived:

x k = b i ¯ a i k ¯ {\displaystyle x_{k}={\frac {\bar {b_{i}}}{\bar {a_{ik}}}}} {\displaystyle x_{k}={\frac {\bar {b_{i}}}{\bar {a_{ik}}}}}

Due to the nonnegativity of all variables, the value of x k {\displaystyle x_{k}} {\displaystyle x_{k}} should be raised to the largest of all of those values calculated from above equation. Hence, the following equation can be derived:

x k = min a i k ¯ > 0 b i ¯ a i k ¯ i = 1 , 2 , . . . , n + m {\displaystyle x_{k}=\min _{{\bar {a_{ik}}}>0}\,{\frac {\bar {b_{i}}}{\bar {a_{ik}}}}\quad i=1,2,...,n+m} {\displaystyle x_{k}=\min _{{\bar {a_{ik}}}>0}\,{\frac {\bar {b_{i}}}{\bar {a_{ik}}}}\quad i=1,2,...,n+m}

Once the leaving-basic and entering-nonbasic variables are chosen, reasonable row operation should be conducted to switch from the current dictionary to the new dictionary, as this step is called pivot.[4]

As in the pivot process, the coefficient for the selected pivot element should be one, meaning the reciprocal of this coefficient should be multiplied to every element within this row. Afterward, multiplying this specific row with corresponding coefficients and adding this to different rows, one should get 0 values for all other entries in this pivot element's column.

If there are any negative variables after the pivot process, one should continue finding the pivot element by repeating the process above. At once there are no more negative values for basic and non-basic variables. The optimal solution is found.[6][7]
Numerical Example

Considering the following numerical example to gain better understanding:

max 4 x 1 + x 2 + 4 x 3 {\displaystyle \max {4x_{1}+x_{2}+4x_{3}}} {\displaystyle \max {4x_{1}+x_{2}+4x_{3}}}

with the following constraints:

2 x 1 + x 2 + x 3 ≤ 2 x 1 + 2 x 2 + 3 x 3 ≤ 4 2 x 1 + 2 x 2 + x 3 ≤ 8 x 1 , x 2 , x 3 ≥ 0 {\displaystyle {\begin{aligned}2x_{1}+x_{2}+x_{3}&\leq 2\\x_{1}+2x_{2}+3x_{3}&\leq 4\\2x_{1}+2x_{2}+x_{3}&\leq 8\\x_{1},x_{2},x_{3}&\geq 0\end{aligned}}} {\displaystyle {\begin{aligned}2x_{1}+x_{2}+x_{3}&\leq 2\\x_{1}+2x_{2}+3x_{3}&\leq 4\\2x_{1}+2x_{2}+x_{3}&\leq 8\\x_{1},x_{2},x_{3}&\geq 0\end{aligned}}}

With adding slack variables to get the following equations:

z − 4 x 1 − x 2 − 4 x 3 = 0 2 x 1 + x 2 + x 3 + s 1 = 2 x 1 + 2 x 2 + 3 x 3 + s 2 = 4 2 x 1 + 2 x 2 + x 3 + s 3 = 8 x 1 , x 2 , x 3 , s 1 , s 2 , s 3 ≥ 0 {\displaystyle {\begin{aligned}z-4x_{1}-x_{2}-4x_{3}&=0\\2x_{1}+x_{2}+x_{3}+s_{1}&=2\\x_{1}+2x_{2}+3x_{3}+s_{2}&=4\\2x_{1}+2x_{2}+x_{3}+s_{3}&=8\\x_{1},x_{2},x_{3},s_{1},s_{2},s_{3}&\geq 0\end{aligned}}} {\displaystyle {\begin{aligned}z-4x_{1}-x_{2}-4x_{3}&=0\\2x_{1}+x_{2}+x_{3}+s_{1}&=2\\x_{1}+2x_{2}+3x_{3}+s_{2}&=4\\2x_{1}+2x_{2}+x_{3}+s_{3}&=8\\x_{1},x_{2},x_{3},s_{1},s_{2},s_{3}&\geq 0\end{aligned}}}


The simplex tableau can be derived as following:

x 1 x 2 x 3 s 1 s 2 s 3 z b 2 1 1 1 0 0 0 2 1 2 3 0 1 0 0 4 2 2 1 0 0 1 0 8 − 4 − 1 − 4 0 0 0 1 0 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 2&1&1&1&0&0&0&2\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 2&1&1&1&0&0&0&2\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}}

In the last row, the column with the smallest value should be selected. Although there are two smallest values, the result will be the same no matter of which one is selected first. For this solution, the first column is selected. After the least coefficient is found, the pivot process will be conducted by searching for the coefficient b i x 1 {\displaystyle {\frac {b_{i}}{x_{1}}}} {\displaystyle {\frac {b_{i}}{x_{1}}}}. Since the coefficient in the first row is 1 and 4 for the second row, the first row should be pivoted. And following tableau can be created:

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.5 0.5 0.5 0 0 0 1 1 2 3 0 1 0 0 4 2 2 1 0 0 1 0 8 − 4 − 1 − 4 0 0 0 1 0 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}}

By performing the row operation still every other rows (other than first row) in column 1 are zeroes:

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.5 0.5 0.5 0 0 0 1 0 1.5 2.5 − 0.5 1 0 0 3 0 1 0 − 1 0 1 0 6 0 1 − 2 2 0 0 1 4 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&1.5&2.5&-0.5&1&0&0&3\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&1.5&2.5&-0.5&1&0&0&3\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}}

Because there is one negative value in last row, the same processes should be performed again. The smallest value in the last row is in the third column. And in the third column, the second row has the smallest coefficients of b i x 3 {\displaystyle {\frac {b_{i}}{x_{3}}}} {\displaystyle {\frac {b_{i}}{x_{3}}}} which is 1.2. Thus, the second row will be selected for pivoting. The simplex tableau is the following:

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.5 0.5 0.5 0 0 0 1 0 0.6 1 − 0.2 0.4 0 0 1.2 0 1 0 − 1 0 1 0 6 0 1 − 2 2 0 0 1 4 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}}

By performing the row operation to make other columns 0's, the following could be derived

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.2 0 0.6 − 0.2 0 0 0.4 0 0.6 1 − 0.2 0.4 0 0 1.2 0 − 0.1 0 0.2 0.6 − 1 0 − 4.2 0 2.2 0 1.6 0.8 0 1 6.4 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.2&0&0.6&-0.2&0&0&0.4\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&-0.1&0&0.2&0.6&-1&0&-4.2\\\hline 0&2.2&0&1.6&0.8&0&1&6.4\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.2&0&0.6&-0.2&0&0&0.4\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&-0.1&0&0.2&0.6&-1&0&-4.2\\\hline 0&2.2&0&1.6&0.8&0&1&6.4\end{array}}}

There is no need to further conduct calculation since all values in the last row are non-negative. From the tableau above, x 1 {\displaystyle x_{1}} {\displaystyle x_{1}}, x 3 {\displaystyle x_{3}} {\displaystyle x_{3}} and z {\displaystyle z} {\displaystyle z} are basic variables since all rows in their columns are 0's except one row is 1.Therefore, the optimal solution will be x 1 = 0.4 {\displaystyle x_{1}=0.4} {\displaystyle x_{1}=0.4}, x 2 = 0 {\displaystyle x_{2}=0} {\displaystyle x_{2}=0}, x 3 = 1.2 {\displaystyle x_{3}=1.2} {\displaystyle x_{3}=1.2}, achieving the maximum value: z = 6.4 {\displaystyle z=6.4} {\displaystyle z=6.4}
Application

The simplex method can be used in many programming problems since those will be converted to LP (Linear Programming) and solved by the simplex method. Besides the mathematical application, much other industrial planning will use this method to maximize the profits or minimize the resources needed.
Mathematical Problem

The simplex method is commonly used in many programming problems. Due to the heavy load of computation on the non-linear problem, many non-linear programming(NLP) problems cannot be solved effectively. Consequently, many NLP will rely on the LP solver, namely the simplex method, to do some of the work in finding the solution (for instance, the upper or lower bound of the feasible solution), or in many cases, those NLP will be wholly linearized to LP and solved from the simplex method.[1] Other than solving the problems, simplex method can also be used reliably to support the LP's solution from other theorem, for instance the Farkas' theorem in which Simplex method proves the suggested feasible solutions.[1] Besides solving the problems, the Simplex method can also enlighten the scholars with the ways of solving other problems, for instance, Quadratic Programming (QP).[8] For some QP problems, they have linear constraints to the variables which can be solved analogous to the idea of the Simplex method.
Industrial Application

The industries from different fields will use the simplex method to plan under the constraints. With considering that it is usually the case that the constraints or tradeoffs and desired outcomes are linearly related to the controllable variables, many people will develop the models to solve the LP problem via the simplex method, for instance, the agricultural and economic problems

Farmers usually need to rationally allocate the existed resources to obtain the maximum profits. The potential constraints are raised from multiple perspectives including policy restriction, budget concerns as well as farmland area. Farmers may incline to use the simplex-method-based model to have a better plan, as those constraints may be constant in many scenarios and the profits are usually linearly related to the farm production, thereby forming the LP problem. Currently, there is an existing plant-model that can accept inputs such as price, farm production, and return the optimal plan to maximize the profits with given information.[9]

Besides agricultural purposes, the Simplex method can also be used by enterprises to make profits. The rational sale-strategy will be indispensable to the successful practice of marketing. Since there are so many enterprises international wide, the marketing strategy from enamelware is selected for illustration. After widely collecting the data of the quality of varied products manufactured, cost of each and popularity among the customers, the company may need to determine which kind of products well worth the investment and continue making profits as well as which won't. Considering the cost and profit factors are linearly dependent on the production, economists will suggest an LP model that can be solved via the simplex method.[10]

The above professional fields are only the tips of the iceberg to the simplex method application. Many other fields will use this method since the LP problem is gaining popularity in recent days and the simplex method plays a crucial role in solving those problems.
Conclusion

It is indisputable to acknowledge the influence of the Simplex method to programming, as this method won the 'National Medal of Science' to its inventor, George Dantzig.[11] Not only for its wide usage in the mathematic models and industrial manufacture, but the Simplex method also provides a new perspective in solving the inequality problems. As its contribution to the programming substantially boosts the advancement of the current technology and economy from making the optimal plan with the constraints. Nowadays, with the development of technology and economics, the Simplex method is substituted with some more advanced solvers which can solve the problems with faster speed and handle a larger amount of constraints and variables, but this innovative method marks the creativity at that age and continuously offer the inspiration to the upcoming challenges.
References

Linear complementarity, linear and nonlinear programming Internet Edition.
Dantzig, G. B. (1987, May). Origins of the simplex method.
Strang, G. (1987). Karmarkar’s algorithm and its place in applied mathematics. The Mathematical Intelligencer, 9(2), 4-10. doi:10.1007/bf03025891.
Vanderbei, R. J. (2000). Linear programming: Foundations and extensions. Boston: Kluwer.
Sakarovitch M. (1983) Geometric Interpretation of the Simplex Method. In: Thomas J.B. (eds) Linear Programming. Springer Texts in Electrical Engineering. Springer, New York, NY. https://doi.org/10.1007/978-1-4757-4106-3_8
Evar D. Nering and Albert W. Tucker, 1993, Linear Programs and Related Problems, Academic Press. (elementary)
Robert J. Vanderbei, Linear Programming: Foundations and Extensions, 3rd ed., International Series in Operations Research & Management Science, Vol. 114, Springer Verlag, 2008. ISBN 978-0-387-74387-5.
Wolfe, P. (1959). The simplex method for quadratic programming. Econometrica, 27(3), 382. doi:10.2307/1909468
Hua, W. (1998). Application of the revised simplex method to the farm planning model.
Nikitenko, A. V. (1996). Economic analysis of the potential use of a simplex method in designing the sales strategy of an enamelware enterprise. Glass and Ceramics, 53(12), 367-369. doi:10.1007/bf01129674.

    Cottle, R., Johnson, E. and Wets, R. (2007). George B. Dantzig (1914–2005). Notices Amer. Math. Soc. 54, 344–362.

Navigation menu

    Log in
    Request account

    Page
    Discussion

    Read
    View source
    View history

Search

    Textbook Home
    About This Text
    Wiki Editing Help
    Feedback (2021)
    Feedback (2020)
    Recent Changes

Tools

    What links here
    Related changes
    Special pages
    Printable version
    Permanent link
    Page information

    This page was last edited on 5 October 2021, at 08:26.

    Privacy policy
    About Cornell University Computational Optimization Open Textbook - Optimization Wiki
    Disclaimers

    Powered by MediaWiki
]]
[[Simplex algorithm
https://google.github.io/or-tools/cpp_linear/linear__solver_8h.html
  https://google.github.io/or-tools/cpp_linear/linear__solver_8h_source.html

Google OR-Tools 9.3
C++ Reference

    Algorithms
    CP-SAT
    Graph
    Routing
    Linear solver

C++ Reference: Linear solver
Toggle main menu visibility
Classes | Namespaces | Functions | Variables
linear_solver.h File Reference
Detailed Description

A C++ wrapper that provides a simple and unified interface to several linear programming and mixed integer programming solvers: GLOP, GLPK, CLP, CBC, and SCIP.

The wrapper can also be used in Java, C#, and Python via SWIG.

What is Linear Programming?

In mathematics, linear programming (LP) is a technique for optimization of a linear objective function, subject to linear equality and linear inequality constraints. Informally, linear programming determines the way to achieve the best outcome (such as maximum profit or lowest cost) in a given mathematical model and given some list of requirements represented as linear equations.

The most widely used technique for solving a linear program is the Simplex algorithm, devised by George Dantzig in 1947. It performs very well on most instances, for which its running time is polynomial. A lot of effort has been put into improving the algorithm and its implementation. As a byproduct, it has however been shown that one can always construct problems that take exponential time for the Simplex algorithm to solve. Research has thus focused on trying to find a polynomial algorithm for linear programming, or to prove that linear programming is indeed polynomial.

Leonid Khachiyan first exhibited in 1979 a weakly polynomial algorithm for linear programming. "Weakly polynomial" means that the running time of the algorithm is in O(P(n) * 2^p) where P(n) is a polynomial of the size of the problem, and p is the precision of computations expressed in number of bits. With a fixed-precision, floating-point-based implementation, a weakly polynomial algorithm will thus run in polynomial time. No implementation of Khachiyan's algorithm has proved efficient, but a larger breakthrough in the field came in 1984 when Narendra Karmarkar introduced a new interior point method for solving linear programming problems. Interior point algorithms have proved efficient on very large linear programs.

Check Wikipedia for more detail: http://en.wikipedia.org/wiki/Linear_programming

Example of a Linear Program

maximize: 3x + y subject to: 1.5 x + 2 y <= 12 0 <= x <= 3 0 <= y <= 5

A linear program has: 1) a linear objective function 2) linear constraints that can be equalities or inequalities 3) bounds on variables that can be positive, negative, finite or infinite.

What is Mixed Integer Programming?

Here, the constraints and the objective are still linear but there are additional integrality requirements for variables. If all variables are required to take integer values, then the problem is called an integer program (IP). In most cases, only some variables are required to be integer and the rest of the variables are continuous: this is called a mixed integer program (MIP). IPs and MIPs are generally NP-hard.

Integer variables can be used to model discrete decisions (build a datacenter in city A or city B), logical relationships (only place machines in datacenter A if we have decided to build datacenter A) and approximate non-linear functions with piecewise linear functions (for example, the cost of machines as a function of how many machines are bought, or the latency of a server as a function of its load).

How to use the wrapper

The user builds the model and solves it through the MPSolver class, then queries the solution through the MPSolver, MPVariable and MPConstraint classes. To be able to query a solution, you need the following:

    A solution exists: MPSolver::Solve has been called and a solution has been found.
    The model has not been modified since the last time MPSolver::Solve was called. Otherwise, the solution obtained before the model modification may not longer be feasible or optimal.

See also
    ../examples/linear_programming.cc for a simple LP example.
    ../examples/integer_programming.cc for a simple MIP example.

All methods cannot be called successfully in all cases. For example: you cannot query a solution when no solution exists, you cannot query a reduced cost value (which makes sense only on continuous problems) on a discrete problem. When a method is called in an unsuitable context, it aborts with a LOG(FATAL). TODO(user): handle failures gracefully.

For developers: How the wrapper works

MPSolver stores a representation of the model (variables, constraints and objective) in its own data structures and a pointer to a MPSolverInterface that wraps the underlying solver (GLOP, CBC, CLP, GLPK, or SCIP) that does the actual work. The underlying solver also keeps a representation of the model in its own data structures. The model representations in MPSolver and in the underlying solver are kept in sync by the 'extraction' mechanism: synchronously for some changes and asynchronously (when MPSolver::Solve is called) for others. Synchronicity depends on the modification applied and on the underlying solver.

Definition in file linear_solver.h.

Go to the source code of this file.
Classes
class  	MPSolver
 	This mathematical programming (MP) solver class is the main class though which users build and solve problems. More...

class  	MPObjective
 	A class to express a linear objective. More...

class  	MPVariable
 	The class for variables of a Mathematical Programming (MP) model. More...

class  	MPConstraint
 	The class for constraints of a Mathematical Programming (MP) model. More...

class  	MPSolverParameters
 	This class stores parameter settings for LP and MIP solvers. More...

class  	MPSolverInterface

Namespaces
namespace  	operations_research

Functions
 	ABSL_DECLARE_FLAG (bool, linear_solver_enable_verbose_output)

bool 	SolverTypeIsMip (MPModelRequest::SolverType solver_type)

bool 	SolverTypeIsMip (MPSolver::OptimizationProblemType solver_type)

const absl::string_view 	ToString (MPSolver::OptimizationProblemType optimization_problem_type)

std::ostream & 	operator<< (std::ostream &os, MPSolver::OptimizationProblemType optimization_problem_type)

std::ostream & 	operator<< (std::ostream &os, MPSolver::ResultStatus status)

bool 	AbslParseFlag (absl::string_view text, MPSolver::OptimizationProblemType *solver_type, std::string *error)

std::string 	AbslUnparseFlag (MPSolver::OptimizationProblemType solver_type)

bool 	MPSolverResponseStatusIsRpcError (MPSolverResponseStatus status)

Variables
constexpr double 	kDefaultPrimalTolerance = 1e-07

Function Documentation
ABSL_DECLARE_FLAG 	( 	bool  	,
		linear_solver_enable_verbose_output  	
	) 		

]]
]]]
]]]]]
DONE:
e ../../python3_src/seed/math/matrix/solve_matrix.py
  matrix:solve
    unify-std row:
      coeff *= ??
    pivot below column nonzreos
      which?


[[
语法:
  码流多个层次
  缓存cfg运算结果
    无副作用函数
    语境无关
    指导裁剪 缓存的码流
  句法符号: 功能=识别+生成
  检查符号: 功能=检查局部变量locals

  码流 -> 树
  树 -> 受限通用数据类型
    基本数据类型:
      没有内建类型
      真值类型-并不需要，直接使用case of 而非 if-else
      整数类型 用 List<Digit>表达
      Monad?表达 出错
        字符串 用于 io？
          List<List<Hex>>
      其他都是:Disjoint_Union互斥并联
        可移植？类似 集合
          T a b = T1 a | T2 b
          S b = (T _ b) .T2 b? | S0
        缓存属性:
          Tree a = Leaf a | Fork [Tree a]@children {sz::UInt}{sz=f children}
          公开可读，可不读，按名读取(向后兼容，随时可以新增缓存属性！)
          构造时 不能赋值！自动生
            序列化时，不显示
            因为 表达成 构造表达式的样子，而构造表达式并不包含缓存属性
      IO:
        输出至 外部哪些 数据类型？
          List v <-> Array<v>
          List v <-> Set<v>
          List (k, v) <-> Lookup<k,v> #eq? bool? class?
          List<List<Hex> > <-> 字符串
          整数#真值? 0/1? 外部弱类型，内部有类型指引，可以正确转为
          没有 元组？不够通用
    区分:惰性求值，勤性求值
      惰性求值-如何实现-无循环引用:
        使用 内部时间戳！
          使用 惰性表达式 时:
            生成一个时间戳t0，用以递归约束 内部子表达式构造时间
            可以引用任何 固实勤性表达式
            只能引用 构造时间t>t0的 惰性表达式/或/半固实构造(自身时间戳=所有子表达式时间戳的最小值)
                ??既然 半固实没有产生 新的时间戳，那到底哪个构造产生新的时间戳？
        或者:用户显式提供 一个 rank 以 对 惰性表达式 分层
        或者:使用 依赖于 类型的rank
        或者:使用 依赖于 模块包的rank
          A模块依赖B 意味着 A有可能 使用 B类型构造器，因此 无法从参数上 看出是否 发生 类型循环
            只有没有 发生类型循环，就不会出现 循环引用
          没有类型循环的一个充分条件是:
            类型T 定义于 模块A
            类型S 定义于 模块B
            T 的 子数据 是属于 类型S
              ==>> A头文件 依赖于 B头文件
              ==>> B头文件 不依赖于 A头文件
              因此 如果 S的对象实例 引用 类型T，则 该类型 必然 是 通过 类型参数 直接 传递，而非 另行 构造(因为 没有 T的构造器)
            可见，出现 循环引用，必然 是 同一模块中的 一组 循环引用 类型(没有子类型...)+可修改性(包括 惰性求值 在内:惰性表达式闭包)！！！
              高阶类型参数，也可能传递 类型构造器，造成循环，这其实是 循环类型的实现细节(隐参数)...
              相似的结构:分形？
    xxx 局部并行裸指针循环?
      bug:其实就是：
        obj{
        .x = f<raw obj>(...)
        .y = f<raw obj>(...)
        }
      !!! 类似
        x = f x
        y = f z
        z = f y
        等，惰性表达式 其实 就已经 产生了 循环引用！！
          f x 是 一个 包含 x的对象！
        除非 即时传参 即时运算，
          即：f x 是 lambda x: f x
          但 这样一来，很多计算都重复了！
  ===
  子类:只允许 并联分支 减少，不允许 增加 串联分量 (除了 缓存属性)
    序列化/反序列化 等 等价变换中，信息损失
  ===
  其实 不需要 完整的类型定义，只需要 类型构造器 声明 就 可以了
  函数 也 不需要 定义，只要 声明 就可以了
  唯一的表达式 就是 函数调用，能够 匹配类型就可以了
    具体实现 由 运行库 或 用户 提供！
  构造器 也是 函数
  解析 复杂 字面值，可仿 C++带单位字面值
    其实就是 函数+字符串
    看来 字符串 少不了要 内建
  注意:句法符号 是 函数
    也有 输入输出
      输入:模版参数
      输出:解析结果
      中间变量:可选命名序列/属性语法？

  ===
  命名(可选):
    并联分支:
      ; = x {
        | w
        | expr
        | [ ... ]
        | = y [ ... ]
        | { ... }
        | = z { ... }
      }
      优先: 『/』替代『|』
    串联分量:
      ; = x [
        , w
        , expr
        , [ ... ]
        , = y [ ... ]
        , { ... }
        , = z { ... }
      ]
  ===
  模版
    ; = x(...) ...
  ===
  局部私有命名空间"where"
  ===
  自举？
    精简版-->>复杂版

]]


[[
view others/数学/编程/术语/控控非门CCNOT--Toffoli门.txt

===

Yaoyun Shi发现只用Toffoli门加上单比特的Hadamard 门就可以构造出任意的量子电路。

这个结论有可以用下面这句话概括：量子计算超越经典计算的地方就在于多了单比特的Hadamard门，或者说所有的量子计算算法不过就是经典计算机加上Hadamard门。
]]



cmake 之类 的 自动生成 的 中间文件，应该 独立 配置 一个 属性文件(本文件.(虚拟修改时刻+hash) / + 所有[依赖文件.(相对路径+虚拟修改时刻+hash)] #本文件.虚拟修改时刻=1+max(所有[依赖文件.虚拟修改时刻], default=-1)#)
  独立于 文件系统 的 好处是：解压/复制/移动，权限不足 等等 问题 不再


cross-?-compiler
  executable<host_exec_lang> :: script_lang -> source_code_lang -> exec_lang_id -> exec_lang<exec_lang_id>
  executable<host_exec_lang>(script8compiler, source_code, name4target_exec_lang) -> executable<target_exec_lang>

语法-语言:
  命名空间
    ==>>export
      ???export until some-a-ancestor-X
        在X之下 的 所有包 可见
        强调向上传递，避免 错误定位
      export to some-a-pkg-X
        在X之下 的 所有包 可见

    ==>>import
    铁律:import 的 所有对象名 必须是 固定不变的集合
      显式枚举
      隐式计算 的前提是 所有输入 固定不变
        即 锚定 头文件 的 特定版本
    禁止:
      from xxx import *
      import xxx (*)
      #why?多个输出也会冲突！除非只有一条输出指令 或者 引入包自己 声明 命名规则(比如：正则表达式，版本演进，接口只增不减，约束只强不弱(命名规则 不断 缩减 许可的命名空间))并限定版本下限、或者 本地 就地 声明 转发的标识过滤规则（版本演进，过滤规则 不断弱化，允许越来越大的转发空间），或者 锚定 版本(反正，新版本 必须 声明 所覆盖 的 所有旧版本==>>整个历史无缺无漏)
      #     有意义吗？版本下限 其实 就是 唯一的约束，新版本的新接口，用户事实上看不到！！所以锚定 版本全部引入是合理的，锚定的是 头文件/接口文件 版本，而非 源文件/具化实现
      #bug:但 允许 全部 向外转发:
      #bug:export from xxx (*)
      #bug:重点在于: 只要内部使用，就必须显式声明
        ?(？即使使用 限定词前缀？)
        import xxx as X (x)
        X.x
        import xxx as X (*)？？行不行？
          可以，反正命名无冲突，且只要 包内容 立即可见，完全可以反推（除非是 头文件，而且 还没用上，既然 只在 源文件 中 使用，头文件不用，头文件 便不该 引入，减少依赖；源文件 可 自动生成 的 requirements需求文件/依赖？）
          requirements vs dependencies

编译器自举:
  逆推 则是 语言 不断剥离复杂特性，形成一序列缩水语言子集
  ===
  最初的编译器 只能使用 某个平台上的 某种固有语言 来实现
    机器语言/汇编语言
    这个 最初的编译器 代码量 应该尽量小
      适合 在任何新机器上 直接使用 汇编语言 实现
      只做一件事: 将 某种高级语言 翻译成 汇编语言
      即 实现 文本文件 的 翻译
        文本文件 -> 文本文件
      弱类型 脚本语言
      数据 不可修改(父节点 必需 在 子节点 构造 之后 才能 构造)，但 对象/公开共享节点 允许 多个拥有者/父节点，使用 用户不可见 的 可修改 引用计数 以实现 内存自动管理/无需垃圾回收
        循环引用 只能 使用 私有独占的裸指针 私有子引用=(父节点/独占拥有者，私有子裸指针)
      使用 用户不可见 不可修改 的 类指针 以 区分 公开共享节点/私有独占节点
      ===
      底层构造，更高层不可见:
        第一，指针/计数器
              #指针下限>=字节
              #?机器字?可以用指针替代?用作 引用计数#因为 引用 来自于 其他地址，数量不超过指针表达范围
              #?单字符?除非 预设固定字符集，这样一来，字符数量固定，但如果使用机器字表达字符，则 隐含了 对 机器字 的 下限要求
        ??第二，整块字节串??#似乎没有用武之地
        第三，内存管理
        第四，底层元组=四指针大小(类指针/不可修改，引用计数/可修改，左节点/不可修改，右节点/不可修改)
          带不带长度？
          ===
          大整数.最低位.底层元组=四指针大小(类指针/不可修改，引用计数/可修改，低位计数/不可修改，高位节点/不可修改)
          大整数.非最低位.底层元组=四指针大小(低位计数{*3}/不可修改，高位节点/不可修改)
          ####第四，底层元组=四指针大小(引用计数/可修改，类指针/不可修改，子树节点数/不可修改，左节点/不可修改，右节点/不可修改)
      高层构造:
        第一，读写 本地 二进制文件
        第二，通用容器
              底层元组
              ==>>中层短元组
              ==>>以下节点
              序列finger_tree
                序列.树节点(?深度?，整树节点数，左翼{深度-1}{n,m}，中间子树{深度+1}，右翼{深度}{n,m})
                序列.树.翼节点(?深度?, 翼节点{深度-1}{p,q})
                序列.树.翼节点{深度=-1}===序列.树.叶节点(元素)
              序列==>>高层长元组/高层数组...有序集合/有序词典
                带不带长度？
        第三，大整数操作
              ==>>弱类型，与其他类型区分开来，内部完全私有，再无需 引用计数
              <<==序列<计数器>
                #除法 受限制，除数 在 字节 范围？比特位右移？
        第四，字符串操作
              #未来的字符数量没有上限，只能使用大整数
              <<==序列<自然数><<==序列<大整数>
              类似 Haskell:
                []
                Char:Str
              唯一的 空字符串:
                字符串.唯一空元组=(#再次使用 类指针#)
        第五，限制 字符集 及 编码方案，字符串编解码
        第六，语言 表达 应该是 易于 解析 的 通用数据 表达形式
              甚至于 指定 编码:
                比如：采用 6(7*)6 或 (7*)7 动态字节编码
              指定 区分 关键词：
                自然数 是 普通字符/用户数据
                负数 是 转义字符/保留字符/特殊字符/关键字/带外信息
              二进制文件
                ==>> 序列<大整数>===含带外信息的字符串
                ==>> 序列<(负字符串，正字符串)>
                ==>> (允空正字符串，序列<(非空负字符串，非空正字符串)>，允空负字符串)
        第七，使用 通用容器+基本数据类型(字符串+大整数) 实现 (数据 即 函数)通用函数/解释性脚本函数



反排版:
  从 已排版 的 多行多列/阵列 数据(带空位？) 中 提取数据
  该依照什么次序？
  若是 偶然性多列，行 并非 记录，类似『ls』输出多列文件名，则 应该 按 列 读取？
    不太对，输出/排版 也 可能 是 先填满当前行再换行 flow。但这样一来就无分列的必要。
  若是 每行记录一条数据，哪怕 有 空缺，也该 行优先。




https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf
  [分布式系统][共识协议]Paxos Made Simple.pdf
  view /mnt/m_external_sd/000edt/0my_files/book/并发/\[分布式系统]\[共识协议]Paxos\ Made\ Simple.pdf


标识/命名
  名称/译名 既重要也不重要
  统一形式 有助于 记忆
    译名 保持 同构，方便 自造词
    但 形式化 意味浓厚，自动造词 等于 随机命名，变成 行内黑话，是对 自然语言 直观易理解 的 背叛。
  重要:
    外行/入门 直观
    外行人 遇到问题 能够 直觉 与 该 名称 有关，进一步了解
  不重要:
    内行人是知道 是什么，有哪些特性，用在哪里



并行作用:
  单个 差量 作用于 单个 基量，没问题
  问题在于: 多个差量无优先次序地作用到多个基量融合上。
      缺失？覆盖？整合？删除？碰撞？
      首先是 输入状态判断
        某个 属性 于 各个差量 各个基量 中的 存在性
      其次是 输出状态检查
        怎样的输出才算合格？
      再次是 输入输出状态比照，更进一步检查
        怎样的修改才算合理？
      还有：给出 修改意见/指令
        根据 中间状态，给出 修改步骤
        是 继续循环 填充/修改，还是 中止(局部个人终止 vs 全局出错中止)？

  幂等差量作用:
    ##!!!幂等 注定 不可逆！！
    什么数据结构？怎样支持？
    词典/映射:
      针对预先指定 键值:
        删、新增、覆盖、整合/深入整合
      过滤/针对符合条件的 所有已存在 键值:
    集合:
      缺失则填充默认值
      存在则删除
    multiset/排序序列:
      绝对位置不重要，相对位置重要
      在指定的两元素间插入某些新元素(仅当不存在才插入)
      删除？
    数组/序列:
      ？矩阵？
      绝对位置重要，相对位置不重要
      深入元素
      尾部增删

    树:
      不相干分支独立更新，独占互斥
      ===节点构造器 到底 需不需要 静态类型/固化？
      注解/修饰==>>多重用途
        ==>>节点 拥有 多种视图
          ，比如应用A需要属性.a，应用B需要属性.b
            ==>> {.a{A}=1, .b{B}=2, .c{A,B}=3, .d{A}=4, .d{B}=5}
            应用A看到:过滤后的结果:{.a=1, .c=3, .d=4}
            应用B看到:过滤后的结果:{.b=2, .c=3, .d=5}
        ==>>节点不存在特定于应用的预先设计的构造器，只有最泛化的弱类型构造器
      ====
      ##??可是 全局约束 比如 id唯一性 如何表达？
      ##??有序 结构 中，给 元素 贴上 唯一id 作为 标签，供 外部 定位 而不因 增删元素 而 错失。
      ##    ==>>即使是 有序 结构，元素 也要 命名？问题是 不自然/太麻烦/无描述性质强调外延区别与内涵大纲的自动命名成为必然 导致难用
      ##        可用 补丁/锚定固址差量 来 渐进 按需命名
      ##    局部 唯一 命名 对于构成 路径 很重要
      ##    全局 唯一 命名 对于 在版本修订间 不断漂移 的 对象 #比如 在 向上路径 中 插入 新节点，所有 子节点 路径 改变
      树节点=史节点|野节点
      史节点=[无序可见性]树节点{无序修饰词}
      可见性=用途名#哪个应用会使用？#比较『feature:on='特性选择表达式'』
      修饰词=树节点
      野节点=丫节点|叶节点
      叶节点=内建基础数据类型
        真值/枚举/三态/四态，整数.../标志位集，字节串，字符串
        带单位？带解码方案？data_URI？
      丫节点=自定义丫节点|内建丫节点
      自定义丫节点=(伪构造器别名, 有序参数, 无名无序参数, 命名独占无序参数)
      内建丫节点=内建容器丫节点|内建运算丫节点|内建约束定义丫节点
      内建容器丫节点=自动有序(可选/optional/Maybe|单选/Either|空缺)|有序(元组|数组|多维阵列/张量|递增/排序？==>>相邻约束)|无序(集合|多选/词典映射|多重集合|多重多选|双射==>>无序阵列+列约束+行约束+记录集合约束)
      内建运算丫节点
        模版
        组合算子
        匿名函数
      内建约束定义丫节点
        定义数据类型#用于读取时动态自动检查


    到底都有哪些数据结构？
        逻辑-程序流程==>>真值
        计数、数组索引、地址指针、数学运算==>>自然数/整数/有理数/多项式(根)？
        码流/序列化/存储/阅读:字节串、字符串
        表达运算==>>组合算子/函数？
        语法树/高阶反省==>>树
        ===
        串联:元组、数组、正则表达式序列/空间重叠？
        并联:枚举量/单选vs标志位集/集合/多选、多选/词典映射(任意数量键值)、单选/互斥并联(单键词典)

幂等 注定 不可逆！！
  差量作用
    幂等 则 不可逆
    不幂等 则 不稳定、不可移植？
  ===差量 分类
  幂等差量
    终态判定，不可逆
    终态=limit (f**i)(始态) {i<-0..+oo}
  锚定固址差量=补丁
    可逆，由于 输入 只有一个允许值，必然可逆
    始态检查: 始态 是否是 指定值
  可移植差量
    始态检查: 始态 是否 符合 假设
    * 可逆可移植差量
      始态检查 包含 可逆性检查
补丁打到哪里？
    不可控，不可预测，否则可在设计阶段隔离开来，成为 参数 或 底层支持库API
    跨函数跨对象跨模块，跨越一切人为预设边界，散落各处



一切都是数据
  说到底，编程语言 也不过是 在 试图简化 抽象语法树 的 表达
  没有 声明式语言，没有 命令式语言
    Haskell IO 显然就是这样
  ===
  一切都是数据，但 更重要的是 类型/约束，即 数据 的 接口
    在得到实际数据之前 便知道 可以怎么使用，通常 数据 的 实际值 有很多可能
    弱类型+强约束==>>泛用性
      弱类型==>>通用函数可接受
      强约束==>>静态价值更高，更有用
    抽取分享信息: 提供 多层次变换函数，不断 弱化类型，通过增强静态约束，尽量减少信息损失

Haskell show/read
  [[
  show 无需 显示类型信息，显示了也没用，动态按需加载模块？静态链接的程序...
  read 必须 知道 完整的类型信息
    ==>> 不支持 子类
    如：[C <: B][ls :: [B]][ls含C的对象] ==>> [(read :: str->[B]) 并不能读取C对象]
    其实 最外派生类/子类 相当于 单选互斥并联 的 一个分支
      最糟糕的是 分支空间开放，未来或第三方 子类 无法 读取
  ]]
  [[
  ===
  读取read:
    要么 类似 json，指定一个 固定数据类型集合，只使用它们作为通用数据结构。
      data_obj :: 固定类型(外部静态依赖)
      外部静态依赖 意外着 恒定不变，旧解析器永不过时
    要么 动态导入模块与类型，则 所谓数据实际上 变成脚本，并且 需要 运行环境 恰好安装了该模块 或 能够自动收缩下载安装。
      外部动态依赖(file_type+version+import_stmts) + data_obj
      外部动态依赖 意味着 易扩展(支持版本更新、支持第三方扩展)，版本更新则旧解析器(或 运行期支持库)会过时失效，导入外部资源则离线情形数据失效。
    要么 独立自足(standalone/self-contained)，离线内嵌 所有 类型定义
      datatype_def_stmts + data_obj
      但 既然 与 解析器 的 预编译固有静态类型 不匹配，就只能是 弱类型/运行期检查模拟动态强类型
    ==>> 其实都一样，即 读取需预先指定类型
      区别在于:
        第一种情况:自由构造数据，或有 预设的固定约束
        第二种情况:只保留极小固定格式，其他内容的解析 允许引用未来特性(允许语法扩展、允许语义扩展)、允许引用外部资源
        第三种情况:包含 自定义约束 读取时 检查
    ===无忧扩展:别名
      alias
      ===可疑扩展:模版、运算
  ]]
  [[
  ===
  序列化show:
    多态:
      show :: legal_cls_set, __class__ => base_cls -> str
        在 固定的类型集合 下，填充 __class__ 至 base_cls 的 差距
      show :: legal_cls2identifier, __class__ => base_cls -> str
      show :: identifier4cls -> base_cls -> str
      show :: identifier4cls -> base_cls -> tail/str -> str
      read :: legal_cls_set => str -> base_cls
      read :: identifier2legal_cls => str -> (__class__<:)base_cls
      read :: identifier2legal_cls_reader => str -> ((__class__<:)base_cls, tail/str)

  ]]
  [[
  ]]
static_cast:
  newtype/alias
  类型参数 的 角色role
  子类？
  函数输入输出 的 角色 相当不同
  ===
  隐含约束？
    若只是 自由构造的数据自然无妨
    但类似 Haskell.Set 之类，通过 私有化/不导出 构造器，控制 构造，进而 实现 排序 约束。
    static_cast 可能导致乱序、逆序


cache:
  自动缓存 deep-immutable-lazy-property:
  幂等？
  比如:hash
  比如:deep-frozen/burn 初始化结束，禁止修改，深度冻结


迭代:流访问 树访问
  StateMonad
    自定义语境context
      非全局状态global/static/thread_local/nonlocal
    隐式传递implicit
      非显式参数parameter
    跨对象
      业务无关/隔离
      非对象指针this/self
  StateMonad:
    position:
      流访问：
        索引号+各低层地址
      树访问：
        路径
        部分拆解树
        更新操作:新半树+已访问旧半树+未访问旧半树
  就地异常处理:
    how = StateMonad::yield_where
    ===
    哪里where:
      where = StateMonad::position
    怎么处理how:
      * 中止
      * 忽略/替换...


分层树有向无环图:
  ##==>>文件系统:文件hard_link泛化至 部分文件夹(否则只能 symbol_link)
  DAG节点 赋值一个 偏序类型值
    约束:
      子节点.偏序类型值 ~<=~ 父节点.偏序类型值
      [子节点.偏序类型值 ~==~ 父节点.偏序类型值] <==> [父子 为 同层文件夹，不可使用 hard_link，即 子节点 只有 唯一父节点，即 同层文件夹 构成 一片 森林]
      [子节点.偏序类型值 ~<~ 父节点.偏序类型值] <==> [父子 为 不同层文件夹，可使用 hard_link，即 子节点 可有多个 父节点，即 子节点 相当于 文件，父节点 相当于 文件夹]
  真副本:写时复制
  真引用:读写共享同一对象






端午节
  view /sdcard/0my_files/tmp/out4py/农历/农历.py.打印公历农历日期对照表.out.txt

对称卷积?:
  输入输出的近期历史/完整历史？:
    y[n] = f(y[n-1]..y[n-p],x[n-1]..x[n-q]; x[n])
    可逆:x[n] = g(y[n-1]..y[n-p],x[n-1]..x[n-q]; y[n])

view others/数学/编程/差量编程-可逆计算-声明式语言.txt



编译器:
  bootstrap? 目标平台是？虚拟机？基础部件是什么？约束假设-内存并行假设？
  全局命名-局部命名--跨语言跨层次命名映射
  shell? 命令行？控制台？
    实现了计算，但关键是：输入输出，人机交互，组件组合

充电宝 使用
  https://zhuanlan.zhihu.com/p/378421765
  https://zhuanlan.zhihu.com/p/162140252
  接口类型
  快充协议
  100元内 小米，品胜，京造，绿联，罗马仕
村里-65元-龙奇？

2+3+5+7=17
2+3+5+7+11=28




xxxxxxx
https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf
  [分布式系统][共识协议]Paxos Made Simple.pdf
共识协议？
  其余宕机，突然 单机？
  连 参与者的数目 都不确定，如何 确认 大多数 的 数量？
    参与者 加入 作为一个事件 需要 申请批准，但 掉线宕机 却不需要。
  新参与者 试图申请加入，但其实只有自己？
  多个新参与者 独立起源初始化，多个系统 如何 互动 合并？
  连线中断，失联等效宕机，但 实际各自存活
    此后是 大陆隔离，独立演化，不再一致，没有共识
    还是 苦苦等待，停滞不前？


obj_cls_tower[obj, level, ...]
  level=0: as obj
  level=1: as cls<obj>
DONE:
  view ../../python3_src/seed/func_tools/recur5yield.py


CANCELLED:加密网页 第二版
  e ../../python3_src/自己的相关数据/on_working.txt

整理 通假字 生僻字
  view 0未整理复制粘贴文本/3未整理复制粘贴文本.txt
DONE: 整理 敏感词
  view /storage/emulated/0/Download/\[20220415]敏感词违禁词与形近字/unzip
  e /storage/emulated/0/Download/\[20220415]敏感词违禁词与形近字/parse_banned_words.py



歌曲下载:
  https://www.musicenc.com/?search
歌词 干了这杯酒 荣华富贵

下载:《汉语字典》相关
  https://www.52pojie.cn/thread-1203253-1-1.html
    https://pan.baidu.com/s/1qWBGsEg#/home/%2F/%2F
    view /sdcard/hugh.android/GuHanYu.apk

欧路词典文件格式



unicode 兼容字符 的 『原字符』属性名 是什么？

DONE:邓力群自述：十二个春秋
  view ++enc=gb18030 /sdcard/0my_files/book/邓力群自述：十二个春秋.txt


py merge folder



[设计]DAG:[
  类似 程序语句，靠 输入输出 参数 决定 拓扑偏序
  实际参数+虚拟参数
  实际节点+虚拟节点

  语句格式:
    『节点名:输入参数列表->输出参数列表』
      多个输入 以 实现AND
      多个输出 以 实现OR
      比如：节点X运行，当且仅当[(a&&b)||(c&&d)]

        A: ... -> a
        B: ... -> b
        C: ... -> c
        D: ... -> d
        $A_B: a b -> a_b__c_d
        $C_D: c d -> a_b__c_d
        X: a_b__c_d -> ...

]

[设计]可追踪性数据:[
  从哪来？输入/参考资料/底本
  做了哪些处理？步骤/生成数据的程序
  有怎样的要求/目的/约束/定义？规范/控制参数
  ===
  重点是：别人能否重现/复刻？别人能否判断所见数据符合规范声明与否？别人能否更正错误？别人能否推广输入范围？别人能否独立更新合并数据以使之不断进化壮大？
  ===
  比如：《说文解字》定义了『六书』，后人可以：
    + 依此类推，分类更多汉字
    + 判断《说文解字》自身的归类有没有出错
    + 根据『六书』归类的歧义程度，评价『六书』这个定义的好坏。
]


[设计]PTS lambda lang design:[
  数据 即是 函数 LocalRouter naive解释 类似 Lisp:
    (...)数据/函数
    [...]调用 #反身赋值 ls[:] = [...]
]

view ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_14_0_annex/unicode_ver14_0_UAX31_UAX38摘要.txt
  抽取 Unihan 中感兴趣的属性？




古籍？下载？


DONE:更新 外部存储器:
  密码
  歌
DONE:github? 搞定上传？
  view others/app/termux/github/GitHub不再支持密码验证解决方案-ver2.txt
DONE:文本质量评估？继续？
  e 文本质量评估.txt

DONE:汉字笔划 --> 4bit/8bit


[
doing:
e ../../python3_src/自己的相关数据/on_working.txt
e script/collect_hz_components.py
拆字:
  拆否？
    天，矢/知，广，之，鬼...
    呆果男
    ===
    点 视为 附加物
      其他单笔，如果接触其他部件，也视为 附加物，不拆出
      土士王玉主义互母舟
    部件 并非 稳定，一个 代表 多个，不断精细化归类
      月:月，青字底，肉月
      日:日，子曰，冒头
      火:火，火左旁，火底，四点水，
      木:木，木左旁，木底(带钩？)
      耳:耳，戢，左立耳，右立耳，取，最，聽
    不同地区，字形不同，部件不同
    字形有特别约束的，不拆:
      二三土士未末曰冃日
    字形排版复杂的，不拆:
      兔鬼包
  命名:
    例子减去其余部分:
      打丁==>>提手
    近似叠加+所在例子:
      口木刺==>>朿 #不是『束/呆/杏』
]


]]]


[[TODO 整理一下
[[[[[[[
目录
  e ./0未整理复制粘贴文本/0未整理复制粘贴文本.txt
  e 0未整理复制粘贴文本/1未整理复制粘贴文本.txt
  e 0未整理复制粘贴文本/2未整理复制粘贴文本.txt

======================
======================
======================
e ./0未整理复制粘贴文本/0未整理复制粘贴文本.txt
  [[
有大伪 出处？
？乐浪郡？->取名
?下载《老子想尔注》
?下载《云笈七签》《雲笈七籤》
?《春秋策：先秦诸子与史记评述》 第2章 诸子天人论导源 『兹为图以明五者之相关如下：』下面没有了。
  看来真是『图』，而非『文本』
孙子吴起列传-马陵？桂陵？-间隔 十年？十三年？-田忌？田朌？-襄陵？大梁？
  田忌+田朌
？郑公克段？
  郑伯克段于鄢
？商圣白圭？
?秦伯让王？秦伯/仲雍/季历 三兄弟，之父-古公亶父，季历之子-姬昌
  泰伯 非 秦伯
  无情对: 庄子*让王
?天民 真人

？歌词:爱恨情仇 人憔悴
  https://www.musicenc.com/?search
  口是心非 - 黄静美/尚雅
    https://www.musicenc.com/article/398290.html
  口是心非 - 童珺
    https://www.musicenc.com/article/1147455.html
  口是心非 - 丫蛋蛋（马启涵）&崔铭嘉
    https://www.musicenc.com/article/34866.html
  口是心非-张雨生#竟然是 国语版？
  口是心非 粤语版
    http://www.shiyinren.com/kw/antiserver.kuwo.cn/anti.s?rid=MUSIC_148624884&response=res&format=mp3|aac&type=convert_url&br=128kmp3&agent=iPhone&callback=getlink&jpcallback=getlink.mp3
      难听！
     口是心非（粤语版） (cover: 绝版雪碧) - 壹聲憂傷
     http://www.shiyinren.com/kw/antiserver.kuwo.cn/anti.s?rid=MUSIC_182229646&response=res&format=mp3|aac&type=convert_url&br=128kmp3&agent=iPhone&callback=getlink&jpcallback=getlink.mp3
永乐:
  纪纲 死期 与 (刘永福xx 而是:) 邱福？战败于北漠，孰先孰后？
    #拖后腿？
    #土木堡？

古代每户人家平均几人？
?毕竟空 胜义有
无印subtitle?
账户vs帐户
  帐户account 但 账户 似乎也行
起讫 qi3 qi4 开始+终结
  起迄
?servo n 伺服机构，随动系统
？一家 白藕 青叶 红莲


麻将规则
  麻将玩法 学习 入门

grep 与 字符 的unicode 转义？
  DONE
  e others/app/termux/grep/grep_regex_pattern_howto_escape_char.txt
  e others/app/termux/shell_string_howto_escape_char.txt

]]

!mkdir 0未整理复制粘贴文本
!mv 0未整理复制粘贴文本.txt 0未整理复制粘贴文本/
view 0未整理复制粘贴文本/0未整理复制粘贴文本.txt
e 0未整理复制粘贴文本/1未整理复制粘贴文本.txt
[[

py unicode 库？
  py lib parse unihan ?

unicode annex 下载
  下载 unicode标准+annex

unicode标准的中文版翻译？
  Unicode®标准英文术语翻译对照表及部分术语汇释
  Unicode Standard 译介尝试（一）・文种名、符号名与块名
  统一码 百度百科
]]


[[
e 0未整理复制粘贴文本/2未整理复制粘贴文本.txt
四角号码，仓颉码
]]



[[
e 0未整理复制粘贴文本/3未整理复制粘贴文本.txt
  在下面 搜索:已下载
收集 敏感词/屏蔽词 大全
形近字 近似字 替换字 大全
罕见字、罕用字、生僻字 大全
收集 形近字/易错字/错别字/混淆字 大全
古今字 通假字 大全
]]



[[
e 0未整理复制粘贴文本/4未整理复制粘贴文本.txt
六书
  象形
  指事
  会意
代词
量词
象声词/拟声词
叹词
虚词
语气词
助词
副词
连词
介词
汉语语法相关名词
偏旁部首大全
]]



[[

e 0未整理复制粘贴文本/5未整理复制粘贴文本.txt
文选
  绕梁三日
  纪昌学射
  九方皋相马

]]



[[
e 0未整理复制粘贴文本/6未整理复制粘贴文本.txt
止戈为武
  趾-行动-炫耀？
  止-平息？

我的termux故障:
  DONE:
    #err: view others/app/termux/apt_update_fail__solved.txt
    view others/app/termux/apt_update__fail/apt_update_fail__solved_ver2.txt

欧路词典文件格式
]]

TODO
]]]]]]]




[[[失败:
  www待查 无印subtitle? 毕竟空 胜义有，外挂/外接/内嵌/内接/内联

  =======
  外挂/外接/内嵌/内接/内联
    attach 附加
    embed 嵌入
  外挂 cheating program 作弊器  ##-英语点津 - China Daily
    plug
    plugin



?下载《论语疏证》杨树达
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语疏证》.txt
    #子罕第九 诸后缺失
?下载 老子他说
  view  /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-6/《老子他说》.txt
    共26章，也只解说了 道德经 前26章，似乎不全
?下载《云笈七签》《雲笈七籤》
?下载《春秋策：先秦诸子与史记评述》 第2章 诸子天人论导源 『兹为图以明五者之相关如下：』下面没有了。
view ++enc=gbk /mnt/m_external_sd/000edt/0my_files/novel/《逍遥小书生》（校对版全本）作者：荣小荣.txt
  一百多章后，尾丢头前插
  第91章~第120章 完全缺失
    第91章 我家小姐有请
    第120章 如仪视察



婚礼新娘跑路，份子钱咋整？
外挂接口？外挂 翻译 ？attachment?

四书五经，大学
搜你妹-->轻心搜？安装失败

天气晚来秋
  语法问题？
  [[我试试:
唐代王维的《山居秋暝》
空山新雨后，天气晚来秋。
明月松间照，清泉石上流。
竹喧归浣女，莲动下渔舟。
随意春芳歇，王孙自可留。

空山，新雨后的空山；天气，？？的天气。
  ]]


download: cppreference.com
  termux
  update clang c++20
  [[

apt update
  !!失败！！
apt upgrade clang

已解决:
  #err: view others/app/termux/apt_update_fail__solved.txt
  view others/app/termux/apt_update__fail/apt_update_fail__solved_ver2.txt

e 0未整理复制粘贴文本/clang.txt
]]






小说下载？
  e others/book/小说下载进程.txt
    view  /sdcard/0my_files/tmp/list_book_novel_txt.txt
  @20220417
]]]
]]

[[ ]]
[[ ]]
[[ ]]
[[ ]]
TODO










[[
https://f-droid.en.softonic.com/android
F-Droid 闭式商店
下载了 UserLAnd
]]








[[
DONE:邓力群自述：十二个春秋
  https://github.com/hankinghu/literature-books/master/邓力群自述：十二个春秋.txt
    ===
    svn ls https://github.com/hankinghu/literature-books/trunk/
      ok！
    $ cd ~/1tmp/svn_
    $ svn export https://github.com/hankinghu/literature-books/trunk/邓力群自述：十二个春秋.txt
      A    邓力群自述：十二个春秋.txt
      Export complete.
    mv 邓力群自述：十二个春秋.txt /sdcard/0my_files/book/
  view ++enc=gb18030 /sdcard/0my_files/book/邓力群自述：十二个春秋.txt
]]




[[[
范畴论 教科书
可计算性
e others/book/category-theory.txt
e others/book/computability.txt
  view /mnt/m_external_sd/000edt/0my_files/book/math/category\ theory/
  view /mnt/m_external_sd/000edt/0my_files/book/math/computability/

[[
ls /mnt/m_external_sd/000edt/0my_files/book/math/category\ theory/
'Abstract and concrete categories--the joy of cats(1990ed+2004update-web)(Adamek).pdf'
'Axiomatic Method and Category Theory (2014)(Andrei Rodin).pdf'
'Basic Category Theory (2014)(Leinster).pdf'
'Categorical Logic and Type Theory (1999)(Bart Jacobs).djvu'
'Categories for the Working Mathematician (2ed)(1998)(Mac Lane).pdf'
'Category Theory (2ed)(2010)(Steve Awodey).pdf'
'Category Theory for Computing Science (1995-rev20200423)(Michael Barr).pdf'
'Category Theory for Programmers (20181021)(v1.0.0-0-g41e0fc3)(Milewski).pdf'
'Category Theory for Programmers (20190812)(v1.3.0-0-g6bb0bc0)(Milewski).pdf'
'Category Theory for Scientists (dynamic-20130514).pdf'
'Category Theory for Scientists (static-20130205).pdf'
'Category Theory in Context (2014)(Emily).pdf'
'Conceptual Mathematics--A First Introduction to Categories (2ed)(2009)(Lawvere).pdf'
'Introduction to CATEGORY THEORY and CATEGORICAL LOGIC (Thomas Streicher).pdf'
'Introduction to Categories and Categorical Logic (Samson Abramsky)(2006-2011).pdf'
'Introduction to Categories and Categorical Logic (Samson Abramsky).pdf'
'Topoi--The Categorial Analysis of Logic (1983)(Robert Goldblatt).pdf'
'范畴论(2006)(贺伟)(书签+去水印).pdf'
]]
[[
ls /mnt/m_external_sd/000edt/0my_files/book/math/computability/
'Higher-Order Computability (2015)(Longley).pdf'
'Hilbert Tenth Problem--Intro to Logic,Number Theory,Computability (2019)(Murty).pdf'
'The Foundations of Computability Theory (2ed)(2020)(Borut).pdf'
'The Incomputable--Journeys Beyond the Turing Barrier (2017)(Cooper).pdf'
]]
]]]

[[
方人

人道 注重 集体，个人 需时刻关注 与其他人的关系，自己在社会中的位置
修天道者，不关心别人，不与别人比较，没有奖状/排行榜之类的东西。


“天道远，人道迩”，谚语，字面意思是天道悠远、人道切近，[3]典出《左传·昭公十八年》子产所言：“天道远，人道迩，非所及也，何以知之？”[2]

释义
天道：上天的意思的体现。人道：人事。迩：近。[1] 鲁昭公十八年（前524年，郑定公六年），包括郑国在内的多个诸侯国发生火灾。据《左传》记载，此前一年（前525年，郑定公五年），郑国人裨灶就曾经预言火灾的发生，并要求用瓘、斝、玉瓒祭神，子产不答应。[6] [4] [5] 这次火灾后，裨灶又说：“不采纳我的意见，郑国还要发生火灾。”郑国人请求采纳他的意见，子产不同意。子太叔说：“宝物是用来保护百姓的。如果有了火灾，国家差不多会灭亡。可以挽救灭亡，您爱惜它干什么？”子产说：“天道悠远，人道切近，两不相关。如何由天道而知人道？灶哪里懂得天道？这个人的话多了，难道不会偶尔也说中的？”于是就不给。后来也没有再发生火灾。[2]
出处
《左传·昭公十八年》：裨灶曰：“不用吾言，郑又将火。”子产不可。子大叔曰：“宝，以保民也。若有火，国几亡。可以救亡，子何爱焉？”子产曰：“天道远，人道迩，非所及也，何以知之？灶焉知天道？是亦多言矣，岂不或信？”遂不与，亦不复火。[2]

]]








[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
