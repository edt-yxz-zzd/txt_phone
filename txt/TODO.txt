TODO:goto
writings:goto
explain:goto


view TODO3\[20220407].txt
view TODO3[20220407].txt
  search:
    #def__backup_cmds:goto
    #文本质量评估
    #TODO
    #DOING
    #writing
    #explain
    #？下载
    #待查
    #design
    #lang
    #意必固我

e ../../python3_src/自己的相关数据/on_working.txt
e ../../python3_src/自己的相关数据/on_working4grep.txt
e others/book/read.txt
  各书 的 阅读进度
e others/book/已读小说.txt
  读完 的 小说

download:
  https://librarygenesis.pro/#!
    入口
    libgen 镜像网址收集
    https://libgen.lc

  https://sci-hub.ru/
    只有 摘要？
https://www.computerhope.com/
  https://www.computerhope.com/jargon/u/uuid.htm
https://translate.google.cn/?sl=auto&tl=zh-CN&text=multiset&op=translate
https://cn.bing.com/search?q=define+mapping
  或 搜索『define mapping』
    再 点击 底部 『More definitions』展开所有隐藏解释

[
libgen 搜索模版
  #不用再每次搜索之后还要点击两次year以时间倒序排列
替换XXX:
https://libgen.lc/index.php?req=XXX&columns%5B%5D=t&columns%5B%5D=s&objects%5B%5D=f&objects%5B%5D=e&objects%5B%5D=s&objects%5B%5D=a&objects%5B%5D=p&objects%5B%5D=w&topics%5B%5D=l&topics%5B%5D=c&topics%5B%5D=f&topics%5B%5D=a&topics%5B%5D=m&topics%5B%5D=r&topics%5B%5D=s&res=25&filesuns=all&filesuns=all&curtab=f&order=year&ordermode=desc&filesuns=all&page=1
原网址:
https://libgen.lc/index.php?req=lua&columns%5B%5D=t&columns%5B%5D=s&objects%5B%5D=f&objects%5B%5D=e&objects%5B%5D=s&objects%5B%5D=a&objects%5B%5D=p&objects%5B%5D=w&topics%5B%5D=l&topics%5B%5D=c&topics%5B%5D=f&topics%5B%5D=a&topics%5B%5D=m&topics%5B%5D=r&topics%5B%5D=s&res=25&filesuns=all&filesuns=all&curtab=f&order=year&ordermode=desc&filesuns=all&page=3
https://libgen.lc/index.php?req=IRREDUCIBLE+POLYNOMIAL&columns%5B%5D=t&columns%5B%5D=s&objects%5B%5D=f&objects%5B%5D=e&objects%5B%5D=s&objects%5B%5D=a&objects%5B%5D=p&objects%5B%5D=w&topics%5B%5D=l&topics%5B%5D=c&topics%5B%5D=f&topics%5B%5D=a&topics%5B%5D=m&topics%5B%5D=r&topics%5B%5D=s&res=25&filesuns=all&order=year&ordermode=desc
?req=lua
?req=IRREDUCIBLE+POLYNOMIAL
&order=year&ordermode=desc
&page=3
]


view others/app/手机卡顿.txt
view others/app/手机自动关机重启掉电卡顿.txt
  [20220408] 占用空间大的APP的列表 以及 挑选出来的被删APP
  [[
[20220408]
  内部存储: 26.3 GB / 32.0 GB
  /sdcard/ 才 8.9G
  看来得删APP 共 15G
6.4G	/sdcard/0my_files
1.1G	/sdcard/autonavi 地图
353M	/sdcard/Android
186M	/sdcard/Download
156M	/sdcard/DraSticCN 模拟器
]]

133
0230
9373

[[[[[[[explain
e ./0explain.txt
nickname vs fullname
  #from https://docs.swift.org/swift-book/TheSwiftProgrammingLanguageSwift57.epub
[[
]]
[[
]]
[[
]]
[[
certificated adj. 合格的，取得执照的，有资格的，检验合格的
certificate n. 证明书，资格证书/执照，许可证 vt. 证明，给予 证明书/执照 (从而许可)

witness n. 目击者(eyewitness)，证人，证据，证物，证明，证言，见证人/连署人 vt/vi. ...
]]
[[
掉电 power down

"掉电,供电中断"英文翻译 fail power
"掉电中断"英文翻译 power failure interrupt
"关掉电机"英文翻译 turn off the power
"关掉电视"英文翻译 turn down the tv
"掉电恢复系统"英文翻译 power-fail recovery system

]]
[[
depicted
wlog = without loss of generality
CRT = Chinese remainder theorem

monic #多项式首项系数为一
[ˈmänik]
ADJECTIVE
mathematics
monic (adjective)
(of a polynomial) having the coefficient of the term of highest degree equal to one

https://cdict.net/q/monic
  monic:首一
首项系数为一
首一本原不可约多项式=monic primitive irreducible polynomial
]]
[[
解封
lift lockdown ，中文意思是“解除封锁”。 lift这个单词有“抬起，解除”的意思，而lockdown则有“防范禁闭”的意思，所以合起来可不就是“解封”的意思了。
]]

]]]]]]]explain


命令行cmd:
wget:
  cd /sdcard/0my_files/tmp/wget_/
  !mkdir /sdcard/0my_files/tmp/wget_/zxcs.me/
  cd /sdcard/0my_files/tmp/wget_/zxcs.me/

curl -L -C - -O https://github.com/llvm/llvm-project/releases/download/llvmorg-14.0.0/clang-14.0.0.src.tar.xz

view others/app/termux/apt_update__fail/\[details]\[20220430]20220427_fix_termux.py
    xargs -n 1 curl -O < /sdcard/Download/downs4termux/binary-all-index.html.urls.txt
    wget -r -l inf --no-remove-listing --no-parent -p -k -nc -N --no-use-server-timestamps -c --random-wait --wait=8 --tries=30 --limit-rate=200K --compression=auto -U "Mozilla/5.0 (iPhone; CPU iPhone OS 12_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.1.1 Mobile/15E148 Safari/604.1"    https://free.nchc.org.tw/osdn//storage/g/t/te/termux-old/zzzzzzzzzzzz-packages-21/ --reject-regex='[^?]*[?].*|(https://free.nchc.org.tw/osdn//storage/g/t/te/termux-old/zzzzzzzzzzzz-packages-21/|)(aarch64|i686|x86_64)(/.*)?' --accept-regex='(https://free.nchc.org.tw/osdn//storage/g/t/te/termux-old/zzzzzzzzzzzz-packages-21/|)(all|arm|dists)(/.*)?'



本地备份:
  见:
  view TODO3[20220407].txt
    search:
      #def__backup_cmds:goto
      view ../../python3_src/my_convention/backup_cmds.txt
上传github:
  g0,g1,g2,g3,g5,g6_,g7
    口令 改为 密钥: ghp_...
      g-h-p ??? git-hub-PAT(personal-access-token)
    edt-yxz-zzd

7z打包:
  view others/app/termux/tar_7zip.txt
  !mkdir  /sdcard/0my_files/tmp/out4zip/
  7z a  /sdcard/0my_files/tmp/out4zip/20220415敏感词.7z    /storage/emulated/0/Download/20220415敏感词/
  view ../../python3_src/raw_data/20220415敏感词.7z
    288K
tar
  man tar >> others/app/termux/tar_7zip.txt
  tar -x -f clang-14.0.0.src.tar.xz
   Overwrite control
       --skip-old-files
              Don't replace existing files when extracting, silently skip over
       -k, --keep-old-files
              Don't replace existing files when extracting.

       --keep-newer-files
              Don't replace existing files that are newer than their archive
              copies.


git 下载命令
[[
cd /sdcard/0my_files/tmp/git_/
https://github.com/zhansliu/writemdict/
git clone https://github.com/zhansliu/writemdict.git

https://gitee.com/xstudio/badwords
git clone https://gitee.com/xstudio/badwords.git
]]

def sketchy_check_stack(ops, stack, /):

[[[[[
writing
已还:20220318 欠房东1元1毛
20220408周五测核酸，电信卡29元月租
20220526周四晚 电信卡 坏掉，前几天也有一次出问题
20220527周五 到电信营业厅换卡:(广州电信卡+身份证)，+20元工本费，只能办理90元以上套餐，还是买新卡算了。
20220528周六 早 电饭煲 煮水坏了(前几天 烧水壶 坏了)；晚，于 宜万家li左 2元店 买 60元 带 蒸笼 电饭煲
20220530周一晚 于嘉乐源买烧水壶33元
20220601买50元电信手机卡29元/月租
20220605买1500元手机 『真我V11s 5G』
[[
oppo手机
设置->关于手机:
  手机名称:真我V11s 5G
  realme UI版本:V2.0
  处理器:天玑810 八核
  机身存储:128G
  认证信息:CMIT ID:2021CP10447
    RealMe重庆移动通信有限公司
    型号RMX3125
  版本信息:
    版本号:RMX3125_11_A.14
    基带版本:M_V3_P10,M_V3_P10
    内核版本:4.14.186+
    ColorOS版本:V11
  Android版本:11
    Android安全更新:20220405
  运行内存:4G+?1-3G#怎么感觉像是加了1G才4G
  型号RMX3125
  序列号:QO49S4OB5PW8OAZI
  开机累计时长:656:00:00#开机40天？？
]]


writings

糯米 煮粥 好吃。

北帮老面馒头？


不要太认真，记得扔掉。

擅长？生命中一半的时间在睡觉，另一半时间想方设法偷懒，没错了，我最擅长的就是睡觉。




允许自杀就该允许吸毒。不允许吸毒就更不可能允许自杀。

--你最好保佑进入之后不会碰到我！--祝你心想事成！

争斗是生命的一部分，沉迷学术也是。我曾因此被人赦免，如今我也会饶恕你。

特等功
  这么了不起，这么高难度，根本不是人能达成，我一直都不信，直到遇见猪一样的队友，才明白，一切惊天地泣鬼神的功绩真的有人能成就，只不过未必在己方阵营。



个人闭门造车，国家闭关锁国，看起来效果不好，然而不论如何着重强调『多样性、开放、交流共享』，将整个地球当作一个小村子来看，依然单质化严重、孤独、封闭，就连战争艺术都如此贫乏无趣，缺乏想象力。

想象-输出永远基于输入-信息不增--？信息守恒？
  想象中的外星人，要么有手有脚有翅膀，再不然有触手。


反驳
    要么是，要么不是。若是，反驳什么？难道要反驳真相？若不是，又何须反驳？难道还要为他人的认知操心？难道还要路人可怜主持公道？

龙，并非血脉传承。它看起来像条蛇，实际上就是。但说它是潜龙，也没错。从来没有人发现过潜龙，你可以说伪装得好，但换一种说法，再卑微的生物也拥有进化成龙的潜力。
种族血脉越强，桎梏也越强。天赋也可能成为天花板，出道即巅峰。


青-圆极
    大俗大雅，物极必反
    极炎剧寒，彻明九幽

神的忠实信徒
    让我想起古代一些笑话。或说要有历史，或说要重视教育。可惜，一切美好的景愿皆可歪曲。
    要先有历史，精怪谣言神话传说泛滥，比没有历史还要糟糕。
    教育，若以顺从听话不得质疑为目标，还不如没有。
    --可是像你这样人不人鬼不鬼的垃圾货色，凭什么大言不惭！还质疑？自以为聪明，笔给你你自己书写经典好了，还用得着学习？

人尽敌国
    一言不合，晋鄙就被信陵君弄死。手握大军又如何？不敌匹夫一怒。身份敏感，就算自己人也得提防。


本来只是家务事，一旦外力干涉，味道就变了。

此疆尔界
    本来无一物
        被污染了，怎么办？消解掉，无物即无尘。

预言中的人
    不，你不是。...恣意暴虐...现在的你...才是。

被奴役者便卑贱么？役人者便尊贵么？漫漫长路，谁是主角谁是配角，可不好说。个人注定渺小，唯有集体体现存在感，个人的丰功伟绩即使万世流传，那也是作为集体记忆的一部分。

生物性破坏--人类 无孔不入，无物不侵
    树木-刀斧之灾

受命于天既寿永昌
    与传说一模一样，肯定是假的。传说本就是凭空捏造以讹传讹添油加醋的故事，赝品越是严格依照传言描述的样子制造，便越是错得离谱。
    谁造谣最有利？皇室。

想看跳舞？看看当下流行些什么舞蹈。不会哎，但耍猴我熟，要不来个蛇舞版耍猴？机械舞版耍猴？

坑爹
  竟然还敢炫耀！？本以为是鬼鬼祟祟的地老鼠，谁知已然是明火执仗的劫掠！
  --宁可真实，而为人唾骂；不愿虚伪，而受人尊重。
  --实诚者不得好死乎？非也，罪不在实诚，实诚也不能抵罪。


说什么脱离，你绝对不是神的子民，现在不是，以前也不可能是！神的忠实信徒没有这么博学睿智以至于质疑经师的教训，你这可恶的异教徒，竟敢反串！


言行不一，重表面仪式无视本质
  佛教-诵经拜佛，以声色求
  共产党-处处体现官僚特权
  自由主义-烧杀抢掠，自由只是挂在嘴边的用来糊弄人的武器

游戏
  更高的领悟对法术更深地分解，按需尝试组合出新法术，(基础不同，目标不同，优化也不同，没有最好的法术)...失败概率，失败反噬


无忌
  血脉检验，只允许自己的后人通过？稍微更改逻辑回路，反转判断结果。不用谢！
  难过那么多先人有来无回...


诞生智慧，由赤裸裸地焚田而猎，改为轮休，使用大网眼的网罗，进而圈养，培育新品种，关心健康问题...
反同即深柜，积德则重孽。
  不作孽，无原罪，无需忏悔，不必积德。杀生吃肉，没毛病。天天放生，行善积德，到底是造了多大的孽！

楼观
  从一丝不苟打地基，苦苦压制境界，到快上快下，鸟瞰全景，试一切错，穷尽所有可能，走从未想过的路。
  九重宫阙从头观

不讲道理？只是不符合你的自以为的道理罢了。
信息共享的程度与信息传递的速度，决定一个组织的体量上限。

取名:贤命长，陶仁贤；茅窖醇

A-既然复活他，为何又要杀死他？
B-失败了，复活的那个东西不是他。
A-我看那就是真实的他，只是不符合你的期望罢了，你要的只是听话的奴隶。
C-是也不是，众念国再兴，既可以说是继承者，也可以说没关系。



说什么把命还给他的傻话。你的困惑其实来自他人。明明是仇敌(废掉你儿子)，却偏要救你，使你陷入恩怨两难的境地。别人的错，凭什么要你来背？

大势力
    大势力如果集中资源捧一个人，那确实可怕。但人均上来说，就全然不同。
    压力平衡
        内部压力平衡
        边界压力平衡
    再强势的势力，也会在不断膨胀下，与周遭小势力达成边界力量平衡
    地盘越大，守军越分散，单位面积上的力量越弱。
    资源越多，生活越优越，出生率越高，外来人口越多，人口增长越快，人口越多，人均资源越少，
    科技水平提高，生活水平只能沾光几代人。
    上古黄金岁月想来确实是有的，只是后人体验不到。

天资过人，无师自通-王八拳，疯魔棍法，乱披风剑法



干一行恨一行
  卖毒品的不吸毒
  开赌场的不赌博
  开餐馆的不下馆子/官员吃特供食品

殉葬品
  唯一的神？它死了。
  胡说！创世神怎么会死？！
  你们只是殉葬品


历史悠久
  靠什么？当然不是人才辈出。有高潮就有低潮，没有一个势力可以在任何时代胜过任何势力。靠的必然是欺软怕硬，该跪就跪。外表有多骄傲，内心就有多卑贱。

交流 犯错
  打做好准备面对自己的愚蠢和愤怒吗？
  打做好准备面对别人的愚蠢和愤怒吗？

失误/不小心
  过于谨慎，只走别人走过的正确的路，固然安全，结果符合期望，但不会有新发现，不会有进步。一个好学生，应当具有好奇心，冒险探索精神，而不是满足于在书的小河里游泳。
  既然对自己的出生毫无规划，又何必对自己的死亡多所设计？
  自杀(消极的畜群免疫，作死的游戏活动)/杀人(主动的侵略，屠杀)，杀生不死，种群的生存规律与社会约束个人行为的礼法迥然不同。



黄-借道
  从未来借来人/物/知识
  天人无知-为什么我会醒来？为什么穿越？
  --等等，你说的难道是我？原来我的穿越并非偶然。


历史有用否？粗糙的类推，符合实际情况否？
  庄周-刻舟求剑/古之糟粕-
  韩非-五蠹:守株待兔-讥循先王之道者-世异则事异，事异则备变
    赏功罚过，功高盖主，武者作乱，五代十国终于以文抑武。
  --
  史记-太史公自序-推崇 春秋


傅斯年-春秋策-诸子-『庄子-天下篇』:
  突然觉得，百家争鸣，也不一定就是思想大爆炸，可能只是书写记录的工具演进，廉价易用，所以相比此前时代，存世言论显得多罢了。
  类似的，佛教也并非自释迦摩尼始，只不过他的弟子恰好是使用新工具的第一批人，『如是我闻』的记录更多而已。
  各种思想源远流长，人类其实未必有多少创新进步。

认命
  『认命』是因为站着的收益小于躺平，反正都是唯利是图斤斤计较患得患失，『认命』即是『不认命』。

青帝
  资源-人善假于物，故此能掌握超越自身的力量。但优点就是缺点，凭恃外物难免患得患失，忧虑资源匮乏，费心费力谋夺资源，嫌贫爱富，自私自利，大迷不觉，战祸频仍，。。。

损人不利己-哄抬物价
  旧势力不能接纳他，外部势力扶植他是将之当成傀儡。简单来说，当前仅有的两个买方开价极低，我们可以去帮忙喊喊价，就当给贫困户送温暖。


错误
  一是方向错，一是操之过急。

取法乎上--适得其反，一旦失败，自弃，无底线
强者就像核武，只能用来威慑起保护作用，一旦主动进攻，别人也不会再有顾忌，越有价值的东西越先被摧毁。


刻舟求剑
  人口增长好不好？
  入侵他国坏不坏？
  无条件地要求杀人偿命？
  任何问题不能脱离实际情况来讨论。
  自卫杀人、见义勇为、执行死刑、警匪交火、军队作战，死人怎么算？交通事故，医疗事故，...
  以百姓利益为重来评判，侵略无道之国也可能是拔诸水火登于衽席。
  古代语境下，人口增长意味着安居乐业，健康长寿，政通人和。
  现代语境下就比较微妙，国家现代化，卫生医疗条件改善，婴儿存活率高，平均寿命长，食物廉价，人口增长极快。以埃及为例，斗地主分田地，提供人民币2分钱一张的能管一顿饭的廉价大饼，人口暴涨，但政策没有长期规划，十分糟糕，即使不断垦荒，耕地也无法承载过量人口，粮食极度依赖进口。可见，人口有隐形的软上限，一旦超过，人与人之间的资源矛盾将不可调和。


众念国
  神笔马良-无中生有？
    其实是 灵性赋予，不是没有代价
    从 众念国 的角度看，就是 开垦荒地，迁徙民众。。短期内 殖民地独立性不高，亲近。同时 短期内 国力下降，若是 过于频繁，呕心沥血，亡国可期。
优待有功之人
  有学问本身没有功劳，但人们期待他们的表现，所以优待，福及学生乃至小孩。
  有的学问功利性不强，但后世可能发现现实功用




仁智勇 三种品性虽然不可分离，但 仁者、智者、勇者 所做所为 却不相同。重点是 价值观不同，同样的场景，同样的彻悟，不同的道路。

  不屈不争，宠辱不惊，遗世独立，没有舞台没有他人
  随波逐流，和光同尘，迁就世界，上了舞台便入戏
  人定胜天，逆天改命，让世界适应自己，就算扮演角色也不能践踏自己的底线

残、病、丑、穷、贱、懒、坏、蠢


生存法则
  没人倾听你的倡议。自己去做，或可引来同好。存在而非发声。

害怕被抛弃？为何如此卑微？这不是正常的人际关系。
  感谢？感谢农夫种植出美味多汁的水果，感谢食品厂生产干净卫生合格的食物，感谢医生药到病除，感谢官员断案公正无私，这是病。

外物
  心法口诀也是外物。指望它清心宁神？
  血统天赋也是外物。指望它超凡脱俗？


一治一乱
  乱世怎么来的？总不能无缘无故凭空冒出来。根源自然在于乱世之前。这么一看，所谓治世就很有问题。治世乱世，只是表象。治世之下，有人获益有人吃亏，有人享福有人受苦，有人作恶有人含冤，不正不公，压制矛盾。治世养蛊，乱世断罪，治世既得利益集团粉饰治世，引导价值观，桎梏大众思维视角。

第一个
  爱得死去活来，只是因为接触的异性少。要多出门多交往，优秀的人遍地都是。阅尽世情，便会彻悟，只有修仙才是出路，什么情啊爱啊，虚无缥缈没前途。

仰慕的人、敬佩的人、想要成为的人、喜爱的人、欣赏的人...不仅可能是不同类型，甚至可能截然相反。

--它为何发笑？--没见过世面，少见多怪，大家不要怼它，要像包容智障一样包容它。


正极则邪
  人至察则无徒

刻舟求剑
  『非我族类其心必异』，是之非之，不问实际，皆是刻舟求剑。
  兄弟阋墙，同室操戈，有斯时。
  族类杀伐，屠戮无算，有斯时。


除非人类死光，从此不再创造新字符，否则，有上限的编码字符集，像unicode，注定无法包含所有字符。本来字符集规模就该无限制。字符的内存表达确实是个难点。可以这样:立即字符 或 大整数指针。靠指针空闲比特位区分。

形近字:
  入人曰日，待侯侍候


无数极品装备？为何爆出这么多？捡起来是成就无敌，还是落得眼前下场？




遗迹废墟:
  数据只增不删，最多是在废墟上重建，但历史一直存在。




三千世缘尽:爱情蛊-消耗缘份，相见不相识，永远路人，路人围观，事不关己，各扫门前雪。

覆巢之下焉有完卵？
  屠戮无算，只为杀你救世--曹操


没头脑是我，不高兴是我，何必排斥？何必困扰？天有不测风云，人也非人自个的私有物，观察自己的喜怒哀乐上窜下跳的表演，也不用太投入。
  又蠢又坏，又穷又懒，讨厌这样不合群的自己？喜欢这样天真蒙昧的自己？
  自重自爱，自暴自弃，都是我，不必强求一致，反反复复，方生方死，人的观点于事实而言无足轻重。
  无端地: 多疑 猜忌 仇视 蔑视 嫉恨

龙虾经过亿万年进化，几十年的打拼攒肉，只为怕是餐盘，你竟然还挑三拣四！

鱼与熊掌
  学识是个人的努力，美貌是上天的钟爱，你说那样更难得更可贵？




名:
  『--每月一日，物稀则贵，小别新婚。保持距离，尊重自生。--每月一日，避免天天劳碌，还有大把时间搞外遇，何乐不为？』
  --小枝小节，未现其要。
  --人各不同：灭世创世，坚韧不拔；破门自立，才能出众；修饰点缀，安全方便。岂有甘愿寄人篱下仰人鼻息者？已然，非不愿实不能。『何不食肉糜』，纯属废话。

  『--卖主只有你，你不要着急。--买主只有你，你不要着急。』
  --玩弄众人于鼓掌之间，这样的言辞虽非废话，却也有害。
  --既然舍得其父曝尸，已说明其子之贵贱轻重，怎能说是我在玩弄？为何人们偏爱虚假厌恶真实？葬礼无论如何都要嚎丧，仿佛在戏台上表演，嚎的人观礼的人都知道是表演，人们不喜真情流露，这又有何好处？



全系最差
  --总有人垫底
  --你是样样垫底！

大梦宗
  大梦谁先觉
  幽-天人无知-再醒-为道日损屡屡失败-建立大梦宗-探索无尽世界
  相互发现:大梦宗vs痕印宗，大战以至于为世人察觉两宗的存在。


人道-传承为重
  黄帝
  ===
  --有了传承，才能突破个人局限，拥有无限可能。纵使人人蠢笨如猪，千万年积累，照样飞天遁地。要有传承，必先有历史；要有历史，需有文字、风者。立巨头--『史官』。
  ===
  --希望从轻发落，虽则罪孽深重，但顾念其先祖披荆斩棘，开拓生存空间，累世承传，人族煊赫有赖此辈，乃人族支柱之一，未可轻易绝嗣。
  --是指恃强凌弱么？赏功罚过，功过不相抵。有功已赏，有过必惩。论罪当族灭，保护即是伤害，勿复求情。
  --人道，传承为重，余者皆轻。功过得失不过一时，众人高兴也好不满也罢，如声散落无痕。刑罚亦不过是维护人道传承的工具，岂能以众人好恶为准？已灭一族，再灭岂可？人道乌存？
  --罪罚不相当，莫非是纵容？杀人者人恒杀之，夷人族者人夷之。若不严惩，人人自危，争相效仿，流害无穷。
  --能禁绝否？我看不能。今日有此，昨日已有，来日再有。即使以灭族重惩，收效恐微，不如另议。

人都一样，人皆平凡
  为五斗米折腰，汲汲钻营，并不更庸俗。
  为民请命，功利千秋，也不更浮夸。
  只是所求不同，大仁大义也罢灭绝人性也罢，人还是人，并无不同。



小说
  老妈曾是天下第一美人，是什么鬼设定？类似，老婆未婚妻之类，统统都是妓女？

  不知所起，不知所终
    没有主线任务中心思想
    随时断更太监




这是心病，不是残疾。消费品也分必需、奢侈。在乎你外形的人，不在乎你；在乎你的人，不在乎你的外貌。



黄赌毒
  合法化？因为地下交易更不规范危害更大？合法化后还能收税创收节约警力利国利民？这不就是议罪银？若是一切罪行皆可以罚金揭过，想必也可减少各种明争暗斗打击报复，黑社会团伙黑保护伞没有存在的意义，前途一片光明。
  ===
  善恶
    『杀人全家成人，奴役孩童及其后裔』与『灭人满门鸡犬不留』相比谁更仁慈？如果允许翻案复仇，岂非逼着凶手斩尽杀绝？实在应该将凶手供起来，歌颂他高抬贵手的品行，足以为万世楷模。

  侵占你家园，屠你父母乡亲，奴役你兄弟姐妹，压榨你剥削你，赏你口饭吃，你当感激涕零，不杀之恩也是恩，不要不识好歹，包吃包住，恩同再造。牢记仇恨的人不幸，懂得感恩的人过得更好，不要盯着过去，要和仇敌之后共创美好未来。

傻逼神拳:
  --作者不公，以愚凌贤！我不服！为何精明计较偏要倒霉吃亏，糊涂蠢蛋偏偏顺风顺水？我意不屈我志不改！纵晓作者偏心，偏要逆作而行！我不信，这世间万千作品你能一手遮天，一生成败不过一隅得失，尚贤尚愚岂能由你！
  ---
  乱披风剑法、疯魔棍法、王八拳

诸事太顺，屈打成招
  诸事顺心，当需警惕。
  有屈打成招，自以为意料之中。
  有处处高歌，自以为太平盛世。
    敌人糖衣炮弹掌控价值观提供便利搭桥牵线
    公仆阿谀奉承大放卫星
    亲友美言或是照顾脸面或是灯下黑或是行外话。
  没有发现问题，才是最大的问题。不知道自己自大自满，才是真的傲慢。

牺牲-多数暴政
  当少数派有异议，而现实只能一刀切选择一方时，会怎样？哪方更强，便会压倒对方。
  抗疫，围封。要么，放任自流，要么，处处严防日日死守。没有折中方案。
  --我年富力强，区区感冒何能惧我？
  --我有钱有势，花钱能治好的病也算病？
  --我怕麻烦怕不自由怕穷，就是不怕死，活着很累很难受，请不要再指手画脚！
  --死亡率怎么低，还没车祸让我惊心，轮到谁算谁倒霉，怕个球！
  --有人怕死，关我屁事！为何要强迫我为别人的癖好做出牺牲？人生有很多重要的事情，娱乐、闲逛、发呆，人生的意义就在于此！牺牲？谁自愿谁去，别代表我！



无数次，幻想拥有超凡力量之后，会如何造福人类，但最终难免大肆屠杀。终究无法相信和和美美，世上必有憎恨我的人，世上必有我不能容忍之人，无法想象没有纷争的世界。我亦不能相信隔离开便能各过各的再不相干，世界很大不能全知，世界很小无处立锥。
只是弱小，若我强大，世人当晓我的残忍邪恶。

就事论事
  --就事论事，没必要针对人。某类错误，虽然不是人人会犯，但人人会犯这类那类的错。别人之道或许确实是很有问题，但谁也未必更高明。
  --针对人，是因为成本。粗筛的成本，公议的成本，专家组队深入考察的成本。


小孩子 频繁无端干嚎 似是不满又似要引起重视
我 经常没由来地疑虑怨怒，莫名其妙，想来大概是老妈带娃的方式不对。

云养猫、云玩家，云游天下？

敏感词违禁词:
  只是字与字的组合而已，能有什么力量？纸老虎都不怕的。

  为何对现实失望？一切都在高速变化，或者说迅速失效过时腐朽。感觉所谓真实的东西，没有一点价值。反而古籍经典，人们细心装裱，仿佛那些死去的言论虚拟的世界，才是永恒无价之宝。真实？虚妄？我都怀疑自己分没分清过。逝水无痕，没有一点点熟悉的感觉，世界是新的，我找不到位置放置手脚，我想我该死了，我，老了，再也提不起兴趣。




煎蛋评论:
  台下都是请来的演员
  没有演员
  演员在开会

最后一句话？
  大意是，你做好做坏，都和我没关系了，自己能承受就行。


小偷小摸，不一定是穷人，虽穷但有自己的活计及清楚相应的消费水平。反倒是，人前衣冠楚楚，虚荣心强，强撑门面，人有我也要有，一旦入不敷出，习惯又无法即时调整，就比较难说了。



质疑真理
  守护贞操--至少那里还是处女地。
  习以为常，赖为凭仗，视逾性命，...



梁祝
  --为什么魔改得面目全非？--悲剧不再是悲剧，人们无法产生共鸣，这是时代的进步！--也可能是退步。

]]]]]


[[[
TODO
太麻烦不值得



画画用Krita，修图嵌字用Gimp，做Logo用Inkscape
  只找到Krita#F_Droid
Lua
  termux 已安装
Rust
  termux 已安装
DONE:book of: Rust
  view others/book/lang-Rust-20220624.txt
DONE:book of: Lua
  view /sdcard/0my_files/book/lang/lua/lang-Lua-20220626.txt



弱类型===开放的并联分支(show/read--repr/eval 不可控，需要 前瞻兼容的 全宇宙统一的 包路径 注册管理)
强类型===封闭的并联分支(show/read--repr/eval 可控)


编程语言
  需明确 面向人 还是 面向机器
  比如: 无用代码
    函数里 声明/定义 的 数据类型，却没有被使用
    不可及的语句: 返回语句/死循环/调用不返回函数 之后 的 语句，分支条件总是『非』的分支语句
    ---
    面向人的编程语言:禁止无用代码，或 需要 手动标明每一个无用语句
    面向机器的编程语言:允许无用代码，或有局部允许无用代码的设置能力
  比如:排版
    面向人的编程语言:可以 强调缩进，可以 短语句块 无结尾标记 而 长语句块 要求 结尾标记 #end-while/def#xml
    面向机器的编程语言:自由风格，允许全部代码语句一行写完，语句块结尾标记越简单越通用则对代码生成器越友好。
  面向人:强调约束
    人手写更容易出错，尽量在编译期排错
    中心化集中化 控制
      比如:haskell开头显式import/expor
      比如:c++类定义的 访问控制区声明标签:public/private
    缺省值，更简洁更少的表达更少出错
    不允许局部作用域变量名遮蔽外层变量名
    ?允许局部作用域变量名遮蔽同层变量名
    『太长』限制:标识/单行文本/函数体语句总量/源代码嵌套深度(比如:c++模版 递归深度，内嵌函数的内嵌深度...)/rust不允许打印太长的元组
  面向机器:强调自由
    生成器算法只要没错，生成的代码就没错；但如果目标代码语言约束过多，生成器为满足这些约束将会更复杂更容易出错。
    流式分散 控制
      比如:java全路径隐式import
      比如:java成员函数的 访问控制前缀public/private
    显式设置参数，避免缺省值
      推断/提取 信息(帮助/注释/缺省值/...) 提供给 高层，编译期层层上传
    允许局部作用域变量名遮蔽外层变量名
    ?不允许局部作用域变量名遮蔽同层变量名
    没有『太长』限制

只有 虚函数 以及 特权成员函数 需要绑定
  非虚且无特权成员函数(调用其他成员函数 实现功能) 可以随时注入，使用时 像其他自由函数一样 显式引入/或 打包引入...
  ---
  构造函数/析构函数？
  特权构造函数、析构函数 需要捆绑
  无特权构造函数(委托其他构造函数 实现功能) 可以随时注入，使用时 像其他自由函数一样 显式引入/或 打包引入...





e others/数学/编程/rust/rust内存管理.txt
[[[ ]]]


龙场悟道-王阳明

遍地哀鸿满城血，无非一念救苍生
  《七律·忆重庆谈判》毛泽东
剑锋临喉无处避，莫如鏖战换新天
  --BV12Y411J773评论from:leon1982xp
为有牺牲多壮志，敢叫日月换新天
  《七律·到韶山》毛泽东

[
《七律·忆重庆谈判》毛泽东

有田有地皆吾主，无法无天是为民。
重庆有官皆墨吏，延安无土不黄金。
炸桥挖路为团结，夺地争城是斗争。
遍地哀鸿满城血，无非一念救苍生。
]

北欧简约莫尔条纹倒影动态反射镜面咖啡杯子
  杯子+托盘，旋转，杯上倒影是鸟挥翅膀

[[[[[[[
!mv script/primitive_irreducible_polynomial.py script/gf__enumerate_primitive_irreducible_polynomials.py
  ##e script/primitive_irreducible_polynomial.py
e script/gf__enumerate_primitive_irreducible_polynomials.py

[[
ZZ[x]%p
  分解 (x**(p**m) - x)
  bug:???[(x**(p**(m+1)) - x)%(x**(p**m) - x) == 0]???
    #bug:???[(x**(p**(m+1)-1) - 1)%(x**(p**m-1) - 1) == 0]
    [(x**2**3-x)%(x**2**2-x) =!= 0] ==>> bug!!!

  [(x**(p**(m*n)) - x)%(x**(p**m) - x) == 0]
    <<== @x. [x**(p**m) = x] -> [x**(p**(m*n)) == (x**(p**m))**(p**(m*(n-1))) = (x)**(p**(m*(n-1))) == ... = (x)**(p**(m*1)) = x]
    即 所有 解 被包含 #两者 首项系数皆为1
    [m%n==0] <==> [GF(p**n) <= GF(p**m)]
      [GF(p**n) <= GF(p**m)]:
        <==> 存在以GF(p**n)元素为系数的多项式 f. 满足 [GF(p**n)[x]%f(x) ~=~ GF(p**m)]
        元素总数 两种表达 相等:
          [(p**n)**(degree f) == p**m]
          <==>> [n*degree f == m]
          <==>> [m%n==0]
  [[is_prime q] -> [GF(p**q) 只含 一个 真子域: GF(p)][不可约多项式中本原不可约多项式的比例极高]]


  [is_prime u =[def]= [[u <- [2..]][@[d<-[2..<u]] -> [u%d=!=0]]]]
  [all_primes =[def]= {p <- [1..] | [is_prime p]}]
  [is_semiprime m =[def]= [?[q0,q1 <- all_primes] -> [q0=!=q1] -> [m==q0*q1]]]
  [is_prime_power m =[def]= [?[q <- all_primes] -> ?[e <- [1..]] -> [m==q**e]]]

  定义:[all_prime_factors_of :: pint -> 2**all_primes]
    [all_prime_factors_of i =[def]= {p <- [1..=i] | [is_prime p]}]

  定义:[all_divisors_of :: pint -> {pint}]
    [all_divisors_of i =[def]= {d <- [1..=i] | [i%d==0]}]
  [all_coprimes_of N =[def]= {i<-[0..<N] | [gcd(i,N)==1]}]

  定义:[max_height_of_prime_power_ :: @[p <- all_primes] -> uint -> Either +oo uint]
    [max_height_of_prime_power_ p i =[def]= if i==0 then +oo else
      max{e <- [0..] | [i%p**e==0]}
      ]

  定义:[mu :: pint -> {-1,0,+1}]
    [mu i =[def]=
      let ps := (all_prime_factors_of i) in
      if [i =!= II ps]/或/[?[p<-all_primes] -> [i%p**2==0]] then 0 else
      #squarefree
      if len ps %2 == 0
      then +1 else -1
      ]
  定义:[sum_mu_mul :: Ring a => pint -> (pint -> a) -> a]
    [sum_mu_mul m f =[def]= sum~ mu(m/d)* f(d) ~{d <- all_divisors_of m}]
    [sum_mu_mul m f == sum~ mu(d)* f(m/d) ~{d <- all_divisors_of . II $ all_prime_factors_of m}]

  定义:[phi :: pint -> uint]
    [phi i =[def]= len {d <- [1..=i] | [gcd(d,i)==1]}]
    [phi i == i*II~ (1-1/p) ~{p<-all_prime_factors_of i}]


  ???不太确定???[is_primitive_factor_of d u =[def]= [u%d==0][mu d=!=0]]

  下面的主要公式有：[
    #首项系数为一的多项式总数囗公式
        #多项式一根求根所在不可约因子的根集的公式
        #根集求多项式囗公式
        #多项式不可约性判定囗公式
        #多项式强伪不可约性判定囗公式
        #多项式强伪不可约性蕴含不可约性所需的充分条件囗公式
    #首项系数为一的不可约多项式总数囗公式
        # 不可约多项式一根求根集囗公式
    #首项系数为一的本原不可约多项式总数囗公式
        # 本原不可约多项式一根求同次其他本原不可约多项式根集囗公式
            # 本原不可约多项式求同次其他本原不可约多项式囗公式 <<== 本原不可约多项式一根求同次其他本原不可约多项式根集囗公式+根集求多项式囗公式
        # 本原不可约多项式一根求同次非本原不可约多项式根集囗公式
            # 本原不可约多项式求同次非本原不可约多项式囗公式 <<== 本原不可约多项式一根求同次非本原不可约多项式根集囗公式+根集求多项式囗公式
  ]

  [%p][m::pint]:
    [GF(p**m) == roots_of (x**p**m - x)]

    [(可约+不可约)多项式 g][degree g==m]:
      [所有degree为m的 首项系数为一的 (可约+不可约)多项式 的 总数 == p**m]
          #首项系数为一的多项式总数囗公式

      !![(a+b)**p == a**p + b**p]
      [g(x)**p == g(x**p)]
      [@a. [g(a)==0] -> @[i<-[0..]] -> [g(a**p**i)==0]]
        #多项式一根求根所在不可约因子的根集的公式

      [let rs := roots_of g]
      [@[rs <- 2**GF(p**m)] -> [let g(z) == II {z-r | [r <- rs]}] -> [roots_of g == rs]]
        #根集求多项式囗公式

      [is_polynomial_irreducible__gf :: @[g :: Polynomial] -> Bool]
      [is_polynomial_irreducible__gf g =[def]= [[x**p**m =[%g(x)]=x][@[pd<-all_prime_factors_of m] -> [gcd(x**p**(m/pd)-x, g(x))==1]]]]
        #多项式不可约性判定囗公式
        #
        #40.4.1.2 Rabin’s test for irreducibility
        #   <<== wget 'https://www.jjj.de/fxt/fxtbook.pdf' -O 'fxtbook[Matters Computational][Algorithms for Programmers].pdf'
        #
        #注意: x**p**i %g {i<-1..=m} 必须 一个个 求出，共m个，不可避免
        #注意:y(x)**p = y(x**p)，所以 只需 先求出 x**(i*p) %g {i<-0..<m}，再 直接替换即可
        #注意:可先不进行gcd，若是 [{i<-[1..=m] | [x**p**i %g == x]} =!= {m}] 则 可约，若通过(还得 不含 整数解 才可被称为 强伪不可约性，注意:某些m值，强伪不可约性<==>不可约性)，才用gcd判断素性
        #注意:特殊类型的g(x)，比如下面的 最简模乘法囗公式 中的 (x**m+h0*x+f0)%p 低次数的模 很快(当 degree 被除数 <= 2*degree 模 -2 时)
        #
      # strong pseudo irreducible (SPI).
      [is_polynomial_strong_pseudo_irreducible__gf :: @[g :: Polynomial] -> Bool]
      [is_polynomial_strong_pseudo_irreducible__gf g =[def]= [@[i<-[1..=m]] -> [x**p**i =[%g(x)]=x] -> [i==m]]]
        #多项式强伪不可约性判定囗公式
      [[p==2]{#书中只关心2，未知可否泛化#} -> [m>=2]{#因为接着要求不含整数解#} -> [[@[a<-[0..<p]] -> [g(p) =!= 0]]or[gcd(x**p-x, g(x))==1]] -> [[is_prime_power m]or[is_semiprime m]or[?[q0,q1 <- all_primes] -> [q0=!=q1] -> ?[e <- [1..]] -> [m==q0*q1**e][q0 > (2**q1**e -2)/q1]]] -> [is_polynomial_strong_pseudo_irreducible__gf g] -> [is_polynomial_irreducible__gf g]]
        #多项式强伪不可约性蕴含不可约性所需的充分条件囗公式
        #
        #40.4.1.3 Testing for irreducibility without GCD computations
        #
        #下面只排除 前两个条件:[[is_prime_power m]or[is_semiprime m]]
        #       其中 44,52,... 满足 第三个条件
        #http://oeis.org/A102467
        #1, 12, 18, 20, 24, 28, 30, 36, 40, 42, 44, 45, 48, 50, 52, 54, 56, 60, 63, 66, 68, 70, 72, 75, 76, 78, 80, 84, 88, 90, 92, 96, 98, 99, 100, 102, 104, 105, 108, 110, 112, 114, 116, 117, 120, 124, 126, 130, 132, 135, 136, 138, 140, 144, 147, 148, 150, 152, 153, 154, 156 ...
        #These are the numbers which are neither prime powers (>1) nor semiprimes. - M. F. Hasler, Jan 31 2008

xxxxxxx:TODO

    #primitive 的 两种不同含义
    #primitive irreducible polynomial over GF =[def]= [x**? generate all but 0 %g(x)]
    #vs: primitive polynomial over ZZ/?domain? =[def]= [gcd(coeffs) == 1]



    [(本原+非本原)不可约多项式 h][degree h==m]:
      [GF(p**m) ~=~ ZZ[x]%p%h(x)]
        #the degree-m field generating irreducible polynomial
        #   ?次数为m的 域生成用的 不可约多项式?
        #
      [所有degree为m的 (本原+非本原)不可约多项式 的 根 的集合
        == {a <- GF(p**m) | [@[n <- [1..<m]] -> [m%n==0] -> [not$ a <- GF(p**n)]]}
        == {a <- GF(p**m) | [@[n <- [1..<m]] -> [m%n==0] -> [is_prime (m/n)] -> [not$ a <- GF(p**n)]]}
        == {a <- GF(p**m) | [@[n <- [1..<m]] -> [m%n==0] -> [is_prime (m/n)] -> [a**(p**n) =!= a]]}
        == {a <- GF(p**m) | [@[n <- [1..<m]] -> [a**(p**n) =!= a]]}
        ]
      [所有degree为m的 首项系数为一的 (本原+非本原)不可约多项式 的 总数
        == 所有degree为m的 首项系数为一的 (本原+非本原)不可约多项式 的 根 的集合 的规模/m
        # == p**m - sum~ p**n ~{...} + 补上重复删除的...
        == sum~ mu(m/d)* p**d ~{d <- all_divisors_of m}/m
        == sum_mu_mul m (p**) /m
          #首项系数为一的不可约多项式总数囗公式
        ]

      [@a. [h(a)==0]]:
        [@[n <- [1..<m]] -> [a**(p**n) =!= a]]
        [let rs := {a**(p**n) | [@n <- [0..<m]]}]
        [len rs == m]
          #???why???
          #!!非零元素 构成 乘法群
          #根的阶 整除 (p**m-1)
          #假设 根的阶 整除 (p**d-1)，d为m真因子
          #则 根**p**d=根，即 degree(gcd(h(x), x**p**d-x) <- [1..=d]
          #     h可约，矛盾
          #
        [roots_of h == rs]
      [@a. [h(a)==0] -> [roots_of h == {a**(p**n) | [@n <- [0..<m]]}]]
        # 不可约多项式一根求根集囗公式

    [本原不可约多项式 f][degree f==m]:
      # 定义: 本原不可约多项式 f <==> (f 根 为 非零乘法群 的 生成子)
      大前提[m>=1]
        [m==1]:
          [GF(p**m) ~=~ ZZ%p]
          [f x = x - i]where[i 是 ZZ%p\-\0 的 本原根/生成子]
          与[m>=2]的处理方式完全相同

      定义:[本原不可约多项式 f]
        <==> [@[a <- GF(p**m)] -> [f(a)==0] -> [GF(p**m)\-\{0} == {a**i | [@i <- [1..<p**m]]}]]
        <==> [@[d <- all_divisors_of(p**m-1)] -> [d=!=(p**m-1)] -> [x**d % f(x) =!= 1]]
        <==> [@[pd <- all_prime_factors_of(p**m-1)] -> [x**((p**m-1)/pd) % f(x) =!= 1]]

      [所有degree为m的 首项系数为一的 本原不可约多项式 的 总数
        == 所有degree为m的 首项系数为一的 本原不可约多项式 的 根 的集合 的规模/m
        == GF(p**m)非零元素 构成的 乘法群 的生成子 的规模/m
        == phi(p**m-1)/m
          #首项系数为一的本原不可约多项式总数囗公式
        ]
        #当 两者总数 相同时:
          #首项系数为一的本原不可约多项式总数囗公式
            lhs := phi(p**m-1)/m
          #首项系数为一的不可约多项式总数囗公式
            rhs := sum_mu_mul m (p**) /m
          ==>> ???
          不知道，但有一个 充分条件:
            [is_prime m]:
              rhs*m = sum ... {d=1,m} = p**m -p**1
            [is_prime (p**m-1)]:
              <==> [is_Mersenne_prime (p**m-1)]
              ==>> [p==2][is_prime m]
              lhs*m = p**m-2 = 2**m-2
              rhs*m = p**m -p**1 = 2**m-2
              lhs==rhs
            [is_Mersenne_prime (2**m-1)] -> [degree为m的不可约多项式皆本原不可约]
              #https://primes.utm.edu/mersenne/
              #https://www.mersenne.org/primes/
              [2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,2203,2281,3217,4253,4423,9689,9941,11213,19937,21701,23209,44497,86243,110503,132049,216091,756839,859433,1257787,1398269,2976221,3021377,6972593,13466917,20996011,24036583,25964951,30402457,32582657,37156667,42643801,43112609,57885161        ,74207281,77232917,82589933]
                #前48个位置固定，此后 可能有 新增的
              #view ../../python3_src/nn_ns/math_nn/numbers/Mersenne_exponents.py

            [is_prime_power m][let q**e := m][is_prime q][e>=2]:
              rhs*m = sum ... {d=m/q,m}
                = p**m -p**(m/q)
                = p**(m/q) *(p**(m-m/q)-1)
                = p**(m/q) *(p**phi(m)-1)
              lhs*m = phi(p**m -1)
                 = phi(p**(q**e) -1)
                 = phi(p**(q**(e-1) * q) -1)
                 = phi((p**(q**(e-1))) ** q -1)
                 = ???


      [@[a <- GF(p**m)] -> [f(a)==0] -> @[u <- [1..<p**m-1]] -> [not$ all_prime_factors_of(u) <= {p}]{#避开f的根集#} -> [gcd(u,p**m-1)==1]{#生成子#} -> [{(a**u)**(p**i) | [@i <- [0..<m]]} 是 其他 degree为m的 不等于f的 本原不可约多项式 的 根集]]
        # 本原不可约多项式一根求同次其他本原不可约多项式根集囗公式
        #
        # 本原不可约多项式求同次其他本原不可约多项式囗公式 <<== 本原不可约多项式一根求同次其他本原不可约多项式根集囗公式+根集求多项式囗公式
        #   ?对称多项式的基 之间的 转换
        #   ?如何由 根 求出 相应 对称多项式的基
        #       归纳法:
        #       m=1 -> 2    -> 3 ->...
        #       [n=1]:a0 -> a0+a1 -> a0+a1+a2 -> ...
        #       [n=2]:0 -> a0*a1 -> a0*a1 +(a0+a1)*a2 -> a0*a1 +(a0+a1)*a2 + (a0+a1+a2)*a3 -> ...
        #       [n=3]:0 -> 0 -> a0*a1*a2 -> a0*a1*a2 + (a0*a1 +(a0+a1)*a2)*a3 -> ...
        #   [sp(m,n) =[def]= sum~ II~ a[k] ~{k<-ks} ~{ks <- 2**{0..<m} | [len ks == n]}]
        #   [[not$ 0<=n<=m] -> [sp(m,n) == 0]]
        #   [0<=n<=m]:
        #       [[0==n<=m] -> [sp(m,n) == 1]]
        #       [[0<=n==m] -> [sp(m,n) == II~ a[k] ~{k<-[0..<m]}]]
        # [sp(m+1,n+1) == sp(m,n+1) + sp(m,n)*a[m]]
        #   这计算轨迹 等同于 直接展开 II (z-a[i] {i<-[0..<m]} 有什么意思？！
        #
      [@[a <- GF(p**m)] -> [f(a)==0] -> @[u <- [1..<p**m-1]] -> [gcd(u,p**m-1)=!=1]{#避开-生成子->非本原#} -> [@[pd <- all_prime_factors_of m] -> [(a**u)**(p**(m/pd)) =!= (a**u)]]{#不可约#} -> [{(a**u)**(p**i) | [@i <- [0..<m]]} 是 其他 degree为m的 非本原不可约多项式 的 根集]]
        # 本原不可约多项式一根求同次非本原不可约多项式根集囗公式
        #
        # 本原不可约多项式求同次非本原不可约多项式囗公式 <<== 本原不可约多项式一根求同次非本原不可约多项式根集囗公式+根集求多项式囗公式

  根的阶ro:
    [gcd(ro, p**m)==1]
    [本原不可约] <==> [ro==p**m-1]
    [非本原不可约] <==> [[ro<p**m-1][@[d<-all_divisors_of m] -> [(p**d-1)%ro==0] -> [d==m]]] <==> [[ro<p**m-1][@[pd<-all_prime_factors_of m] -> [(p**(m/pd)-1)%ro=!=0]]]
    [可约] <==> [???]



  [%2]:
    x**2-x = (x-0)(x-1)
    x**2**2-x = (x-0)(x-1)(x**2+x+1)
    x**2**3-x = (x-0)(x-1)(x**6+x**5+x**4+x**3+x**2+x+1)
      #GF(p**m) ~=~ ZZ[x]%f(m,x) ==>> 本原不可约多项式 次数 为 m
      # 非零乘法群 规模 == p**m-1 #除了0
      # 生成子 总数 = phi(非零乘法群 规模) = phi(p**m-1)
      # monic本原不可约多项式 总数 = 生成子 总数 / 本原不可约多项式 次数 = phi(p**m-1)/m
      #     monic #多项式首项系数为一
      #     ???[p=2]梅森素数[m=3] phi(2**3-1)=7-1=6没有影响
      #GF(2**3) ==>> phi(2**3-1)/3 = 2 个 次数为3的 monic本原不可约多项式
      = (x-0)(x-1)(x**3+x+1)(x**3+x**2+1)
  ==>> [(x**2**3-x)%(x**2**2-x) =!= 0]
    #即 GF(2**3)不包含GF(2**2)

  [%3]:
    x**3-x = (x-0)(x-1)(x-2)

GF(2**8)
  degree(f(x))==e
  f(x) is irreducible polynomials over ZZ%p
  GF(p**e) ~=~ ZZ[x]%p%f(x)
  primitive irreducible polynomials
    f(a)==0, 根a刚好是 ZZ[a]%p 的 生成子
    ZZ[a]%p ~=~ ZZ[x]%p%f(x)
  GF(2**8)总数:phi(2**8-1)/8 = phi(17*5*3)/8=(17-1)(5-1)(3-1)/8=16

CLASS OF IRREDUCIBLE POLYNOMIALS
]]

[[[[[
[[[
[[
On the irreducible factors of a polynomial II(2020)(Jakhar).pdf
===
https://libgen.lc/edition.php?id=88002035
wget 'https://libgen.rocks/get.php?md5=6bb69bef6ca7699da72d921c008d1d6e&key=UR0WGQYTBGD8RVVR' -O 'On the irreducible factors of a polynomial II(2020)(Jakhar).pdf'
===
On the irreducible factors of a polynomial(2019)(Jakhar).pdf
===
https://libgen.lc/edition.php?id=84927140
wget 'https://libgen.rocks/get.php?md5=9dd31c8fcfd93e4ad1191973b2a5b1d6&key=SNRSWSAK2RHTQJFG' -O 'On the irreducible factors of a polynomial(2019)(Jakhar).pdf'
  [[[
  ===
===
所有因子首项次数中的最大值的下限，有用，当下限是整式首项次数时，多项式不可分解
  #不是 所有因子首项次数的最小值的下限，不能 用来比较于 整式首项次数一半以上...
===
Eisenstein irreducibility criterion的泛化版:
[[f(x) <- ZZ[x]][ks == coeffs f(x)][f(x) == sum~ ks[i]*x**i ~{i <- [0..<len ks]}][len ks >= 3][is_prime p][e <- [2..<len ks]][ks[e]%p=!=0][@[i <- [0..<e]] -> [ks[i]%p==0]][ks[0]%p**2=!=0] -> [?g(x) <- ZZ[x]][f(x)%g(x)==0][degree g(x) >= e]]
[[f(x) <- ZZ[x]][ks == coeffs f(x)][f(x) == sum~ ks[i]*x**i ~{i <- [0..<len ks]}][len ks >= 3][is_prime p][m := len ks -1][ks[m]%p=!=0][@[i <- [0..<m]] -> [ks[i]%p==0]][w <- [0..<m//2]][ks[w]%p**2=!=0] -> [[?g(x) <- irreducible_factor_of_ ZZ[x] f(x)][degree g(x) >= m-w]]]
    # 根据下面的泛化版 更正
    #
    # [... -> [?g(x),h(x) <- ZZ[x]][f(x)==g(x)*h(x)][min(degree g(x), degree h(x)) <= w]]
    #g(x)，h(x)不可分解？
    #只能等于，还是 多于等于2个因子？
Eisenstein irreducibility criterion的上述泛化版的泛化版:
Dumas irreducibility criterion的泛化版: # <<==[e==len ks-1][k==0]
  Eisenstein irreducibility criterion是Dumas irreducibility criterion的特化版[pe_ 0 = 1]
[[f(x) <- ZZ[x]][ks == coeffs f(x)][f(x) == sum~ ks[i]*x**i ~{i <- [0..<len ks]}][len ks >= 3][is_prime p][pe_ := \ [i <- [0..<len ks]] -> if ks[i] == 0 then +oo else max {t <- [0..] | [k[i]%p**t==0]}][e <- [2..<len ks]][pe_ e ==0][k := min([0..<w], key=\ k-> ((pe_ k)/(e-k), k))][gcd(pe_ k, e-k)==1] -> [[?g(x) <- irreducible_factor_of_ ZZ[x] f(x)][degree g(x) >= e-k]][[?h(x) <- irreducible_factor_of_ (p-adic QQ%p)[x] f(x)][e >= degree h(x) >= e-k]]]
  #[前提:已有p,ks]: [pe_ i = max_height_of_prime_power_ p ks[i]]
  ===
  ]]]
]]
[[
The Effect of the Primitive Irreducible Polynomial on the Quality of Cryptographic Properties of Block Ciphers(2020)(Shaukat).pdf
===
https://libgen.lc/edition.php?id=90256537
wget 'https://libgen.rocks/get.php?md5=1f668a77dde4917c9e1ad42b74bf90de&key=1RFV6SXE3RD4QIMO' -O 'The Effect of the Primitive Irreducible Polynomial on the Quality of Cryptographic Properties of Block Ciphers(2020)(Shaukat).pdf'

]]
[[
A new class of irreducible pentanomials for polynomial-based multipliers in binary fields(2018)(Banegas).pdf
===
https://libgen.lc/edition.php?id=80617119
wget 'https://libgen.rocks/get.php?md5=8767c2154d445e0509cd041ba1add2bc&key=5SMGSILHT0AT9ID9' -O 'A new class of irreducible pentanomials for polynomial-based multipliers in binary fields(2018)(Banegas).pdf'
===
trinomial  三项式
pentanomial五项式
没有列出 三项式
  #很多degree没有 不可约 三项式
  # degree < 1000 似乎 只有 500多 degree的取值 有相应 不可约 三项式
  # 不可约三项式 最佳
  #     对于某些degree相应 不可约三项式 不存在时，才考虑 不可约五项式
  #
四项式 提都没提
    #似乎[%2]四项式 基本都是 可约？
    #应该说 非零系数总数为偶数的多项式 [%2]情形下 必然 被(x+1)整除
五项式 列出一些:
  #在degree超过某个值之后，皆有 相应的 不可约 五项式
  # 这就是 这篇论文 将重点放在 五项式 的 原因
  #
  # bug:根据下面的模版[m,m-c,b,c,0]{0<c<b<m-c} ==>> 任意degree>=4皆有 不可约五项式
  # 另外 由https://www.jjj.de/mathdata/all-irredpoly.txt 可得: 任意degree<-[4,5]的五项式 皆 不可约
  # view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/data/all-irredpoly.txt
    [[
        2,1,0


        3,1,0
        3,2,0


        4,1,0
        4,3,0
        # non-primitive:
        4,3,2,1,0


        5,2,0
        5,3,0
        5,3,2,1,0
        5,4,2,1,0
        5,4,3,1,0
        5,4,3,2,0


        6,1,0
        6,4,3,1,0
        6,5,0
        6,5,2,1,0
        6,5,3,2,0
        6,5,4,1,0
        # non-primitive:
        6,3,0
        6,4,2,1,0
        6,5,4,2,0
    ]]

  #     再根据下面的模版[m,b+1,b,b-1,0]{2<=b<=m/2-1}{m>=6} /或/[m,b+1,b,1,0]{2<=b<=m-2}{m>=4} 岂不是 任意degree>=4 [m,3,2,1,0]都 不可约？有毛病！！
  #         [6,3,2,1,0]可约！#没在all-irredpoly.txt 中出现
  #
  #原论文:『Table 5 lists all irreducible pen- tanomials of our family for degrees up to 1024;』『We leave as an open problem to mathematically characterize under which conditions our pentanomials are irreducible.』
  #     他妈的，搞了半天 都不是 不可约五项式，所以 没有 简单的 不可约多项式 生成模版？
  #
  # view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/data/pentanomial-primpoly.txt
  #     [72,10,9,3,0]
  #     [360,26,25,1,0] #m=360 的 最小 本原不可约多项式
  #
  [[！！！模版 用于mul_mod计算量研究 并不必然生成 不可约五项式！！！
GF(2)[x]:
首项 正负符号(余项皆正); 系数为1的项的次数
  %2 哪来的正负？
+;2b+c,b+c,b,c,0
  0<c<b
  3b > 2b+c=m > 2b ==>> m/3 < b < m/2
  m//3 < b < (m+1)//2
  m=2b+c>=2*2+1=5
  #这是 这篇论文 的 重点介绍的 五项式
-;m,b+1,b,b-1,0
  2<=b<=m/2-1
  m>=b+1 +1>=2+1 +1=4
  m>=2*(b+1)>=2*(2+1)>=6
-;m,b+1,b,1,0
  2<=b<=m-2
  m>=b+2>=2+2=4
-;m,m-c,b,c,0
  0<c<b<m-c
  m>=b+c+1>=2+1+1=4
-;m,a,b,c,0
  0<c<b<a<=m/2
  m>=2*a>=2*3==6
-;m,m-s,m-2s,,m-3s,0
  (m-1)/8<=s<=(m-1)/3
  3s+1 <= m <= 8s+1
  m > m-s
  s >= 1
    ==>> 8s+1 > 3(s+1)+1 即 s增长 覆盖 所有 [m >= 4] 没有 缺漏的m
  m >= 3s+1 >= 3*1+1 = 4
-;4c,3c,2c,c,0
  c=5**i
  0<=i
  m=4c=4*5**i>=4*5**0=4
并非不可约！！]]

depicted
wlog = without loss of generality

leading term 首项

reduction modulo f(m,x)
modular reduction


modular reduction的步骤:
  [%2]:
    ?[k <- [1..m-1]]. [f(m,x) = x**m + f_low(m-k,x)]
    [[f(m,x)=0] -> [x**m == f_low(m-k,x)]]
    g(w,x)%f(m,x) = if w < m then g(w,x) else
        let g_low(<=m-1,x)+g_high(w-m,x)*x**m := g(w,x)
            g_(w-k,x) := g_high(w-m,x)*f_low(m-k,x)
              #计算热点
        in  g_low(<=m-1,x)+ g_(w-k,x)%f(m,x)
          #recur: w -> (w-k)
          #recur-deepth / num-loops = ceil((w-m+1)/k) = (w-m+k)//k = (w-m)//k +1
    [g(w,x) == h0(<m,x)*h1(<m,x)]:
      [w <= 2m-2]
      [recur-deepth = (w-m)//k +1 <= (m-2)//k +1]
        #k = f(x)首项次数-次项次数
        #   (m-k)/m越小，循环次数越少
        #g_的求值步骤 与 f(x)的非零项数目 相关
        #   f(x)的非零项数目 越少，g_的计算 越快
        #所以 好的 f(x) 要求 次项次数/首项次数 小，非零项数目 少/(二项式？三项式？)
        #固定 f(x)模版，若 recur-deepth 足够小，可以 显式列出 计算公式，再根据 模版 特征 归并 重复性的计算。
  其实还可以这样[w<=2*m]:
    g(w,x)%f(m,x) = if w < m then g(w,x) else
        let g_low(<=m-1,x)+g_high(w-m,x)*x**m := g(w,x)
          #u,t >=0
          recur0 h(m-u,x) t = recur1 h(m-u,x)*x**min(u,t) (t-min(u,t))
            #shift to makeup x**m
          recur1 h(m_,x) t = if m_ < m then assert (t==0) h(m_,x) else recur2 h(m,x) t
            #halt?
          recur2 h(m,x) t = recur0 (h(m,x)-x**m +f_low(m-k,x)) t
              #recur&wrap
        in  g_low(<=m-1,x)+ recur0 g_high(w-m,x) m


]]
[[
polynomial basis multipliers for irreducible trinomials(2017)(Jiajun).pdf
===
https://libgen.lc/edition.php?id=70286084
wget 'https://libgen.rocks/get.php?md5=172822526c727ff32951c49abdc050db&key=RUHHVWYO7OULC8A8' -O 'polynomial basis multipliers for irreducible trinomials(2017)(Jiajun).pdf'
(q,r) := g/%f
g == q*f + r
[degree r < degree f][degree f + degree q == degree g]
[2*degree f > degree g]:
  [degree f >= 1]
  [degree q == degree g - degree f < degree f]
  [let f0 := f(0)]
  [g == q*(f-f0) +(r+q*f0)]
  [g/%(f-f0) == (q, r+q*f0)]
  [reducible f-f0]
  [let x**k * h(n,x) := f-f0][h0=h(0)=!=0][k+n==degree f=m]
  #CRT = Chinese remainder theorem
  [g%f ~ CRT(g%x**k, g%h)]
  [g//f ~ (g//x**k)//h(x)]
  [(q_,r_) := divmod-CRT(g, x**k, h(x))]
  [g%/f = (q, r) := (q_, r_-q_*f0)]

  [irreducible f]:
    ...
  [monic trinomial f]:
    [f(x) == x**(n+k) + h0*x**k + f0]
    [f-f0 == x**k*(x**n+h0)]
    [h(x) == (x**n+h0)]
    [inv_h0 := inv[%p](h0)]
    [n >= k]:
      [inv_h0*h(x) %x**k ==1]
      [inv_h0 == inv[%x**k](h(x))]
      [x**(n-k) *x**k %h(x) == -h0]
      [-inv_h0*x**(n-k) *x**k %h(x) == 1]
      [-inv_h0*x**(n-k) == inv[%h(x)](x**k)]
      #我一他零
      [我一他零<h(x); {x**k,}> = inv[%h(x)](x**k) *x**k = -inv_h0*x**n]
      [我一他零<x**k; {h(x),}> = inv[%x**k](h(x)) *h(x) = inv_h0*h(x)]
      [@g. [degree g < 2*degree f] -> [g(x)%x**k=gk(x)][g(x)%h(x)=gh(x)] -> [g(x)
        #源自 模乘法 a(x)*b(x)%f(x)
        #   转化为 a(x)*b(x)%h(x); a(x)*b(x)%(x**k)
        =[%f(x)]=gk(x)*inv_h0*h(x) + gh(x)*-inv_h0*x**n
        =[%f(x)]=inv_h0*(gk(x)*h(x) - gh(x)*x**n)
        =[%f(x)]=inv_h0*(gk(x)*(x**n+h0) - gh(x)*x**n)
        ][g(x)%f(x) == (gk(x) + inv_h0*x**n*(gk(x) - gh(x)))%f(x)]
        #degree gk < k <= n
        #degree gh < degree h == n
        =[%f(x)]=gk(x) + inv_h0*x**n*(gk(x) - gh(x))
          #degree rhs <= n+n-1 == 2*n-1
          #vs degree f == n+k
          #[k==n]: rhs%f == rhs
          #[k<n]: degree rhs <= 2n-1 >= degree f 无法比较
          #     最大[degree rhs==2n-1>=n+k==degree f]: 最高位折叠/替换(x**(n+k)=-(h0*x**k+f0)==>>???非并行，无法达到硬件时间最优
        ]

似乎可以:
[[最简模乘法囗公式:
[t>=0][degree f <= degree g <= 2*degree f -(t+1)][m==degree f]:
  [degree f >= (t+1)]
  [(q,r) := g/%f]
  [g == q*f + r]
  [degree r < degree f][degree f + degree q == degree g]
  [degree q = degree g % degree f = degree g - degree f <= degree f -(t+1)]
  [let ft(x) := f(x)%x**(t+1)]
  [degree ft <= t]
  [g == q*f + r == q*(f-ft) + (r+q*ft)]
  [degree (q*ft) = degree q + degree ft <= (degree f -(t+1)) +t == degree f -1]
  [degree (r + q*ft) <= max{degree r, degree(q*ft)} == degree f -1]
  [g%/(f-ft) == (q, r+q*ft)]
  [let (q_,r_) := g%/(f-ft)]
  [g%/f = (q,r) == (q_, r_ - q_*ft)]
  #注意:上面[t>=0]，下面[t>=1]
  [monic trinomial f][degree ft == t >= 1]:
    [f(x) == x**m + h0*x + f0]
    [m == degree f >= (t+1)]
    [g%/(f-ft) == g/%x**m == (high(m,g), low(m,g))]
    [g%/f == (q, r) == (q_, r_ - q_*ft) == (high(m,g), low(m,g) - high(m,g)*ft)]
      #完美！
      #最简模乘法囗公式
  模乘法 中 [g(x) = a(x)*b(x)，求g(x)%f(x)][degree a < m-1][degree b <= m-1][degree g <= 2*m-2]:
    #其实[t>1]也行，先高位折叠至[degree g <= 2*m -(t+1)]，最多折叠(t-1)位，串行耗时长
    [choose t==1]
    ==>>最佳模版: [m,1,0]
    [%2]情形:
      #https://www.jjj.de/mathdata/all-trinomial-irredpoly-short.txt
      #or:view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/data/all-lowblock-irredpoly-short.txt
      #view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/data/all-trinomial-irredpoly-short.txt
      # [m <= 399]:只有17个m相应 的 三项式 不可约
      #     不可约17:[2,3,4,  6,7,  9,15,22,28,30,46,60,63,127,153,172,303]
      #
      #view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/data/all-trinomial-primpoly-short.txt
      # [m <= 399]:只有11个m相应 的 三项式 本原不可约
      #     [2,3,4,  6,7,  -9,15,22,-28,-30,-46,60,63,127,153,-172,-303]
      #     本原不可约11:[2,3,4,  6,7,  15,22,60,63,127,153]
      #     非本原不可约6:[9,28,30,46,172,303]
      #
      # 每个 元素需要 m比特 来表达，如果 与 8bit字节 匹配，要求[m%8==0]
      #     但！[m%8==0] ==>> [三项式 可约]
      #     见下面:『三项式可约的充分条件』
      #     见下面:『任意次数的本原不可约五项式存在囗猜想』
      #         三项式 换成 五项式，模乘法 运算更慢
      #
      #
      #40.9.3 Irreducible trinomials of the form 1 + x**k+ x**m
      #   <<== wget 'https://www.jjj.de/fxt/fxtbook.pdf' -O 'fxtbook[Matters Computational][Algorithms for Programmers].pdf'
      #[[[m,1,0]不可约] -> A002475]
      #     A002475 /-\ [2..=34353] == [2, 3, 4, 6, 7, 9, 15, 22, 28, 30, 46, 60, 63, 127, 153, 172, 303, 471, 532, 865, 900, 1366, 2380, 3310, 4495, 6321, 7447, 10198, 11425, 21846, 24369, 27286, 28713, 32767, 34353]
      #
      #[[[m,1,0]本原不可约] -> A073639]
      #     A073639 /-\ [2..=4400] == [2, 3, 4, 6, 7, 15, 22, 60, 63, 127, 153, 471, 532, 865, 900, 1366]
      #
      #[[[m,2,0]不可约] -> A057460]
      #     A057460 /-\ [3..=57341] == [3, 5, 11, 21, 29, 35, 93, 123, 333, 845, 4125, 10437, 10469, 14211, 20307, 34115, 47283, 50621, 57341]
      #
      #[[[m,2,0]本原不可约] -> A074710]
      #     A074710 /-\ [3..=845] == [???]
      #
      #[[[m,3,0]不可约] -> A057461]
      #     A057461 /-\ [4..=1000] == [4, 5, 6, 7, 10, 12, 17, 18, 20, 25, 28, 31, 41, 52, 66, 130, 151, 180, 196, 503, 650, 761, 986]
      #
      #[[[m,3,0]本原不可约] -> ???]
      #     ??? /-\ [4..=400] == [4, 5, 7, 10, 17, 20, 25, 28, 31, 41, 52, 130, 151]
      #
      #[[[m,4,0]不可约] -> A057463]
      #     A057463 /-\ [5..=1000] == [7, 9, 15, 39, 57, 81, 105]
      #
      #[[[m,4,0]本原不可约] -> ???]
      #     ??? /-\ [5..=400] == [7, 9, 15, 39, 81]
      #
      #[[[m,5,0]不可约] -> A057474]
      #     A057474 /-\ [6..=1000] == [6, 9, 12, 14, 17, 20, 23, 44, 47, 63, 84, 129, 236, 278, 279, 297, 300, 647, 726, 737]
      #
      #[[[m,5,0]本原不可约] -> ???]
      #     ??? /-\ [6..=400] == [6, 9, 17, 23, 47, 63, 129, 236, 278, 279, 297]
      #

#40.9.3 Irreducible trinomials of the form 1 + x**k+ x**m 之前的片段:
[[三项式可约的充分条件
Regarding trinomials, there is a theorem by Swan (given in [327]): The trinomial x^n+x^k+1 over GF(2) has an even number of irreducible factors (and therefore is reducible) if 
0. n, k are even.
  [n%2==0==k%2]
  # !![x^(2n)+x^(2k)+1 == (x^n+x^k+1)**2]
1.  n is even, k is odd, n =!= 2k, and either nk/2 ≡ 0 mod 4 or nk/2 ≡ 1 mod 4, 
  [[n%2==0][k%2==1][n=!=2k][n*k%8 <-[0,2]]]
  # [n%8==0] ==>> 条件0/或/条件1
  # 即 degree=8n 的 三项式 [%2] 可约
  # 即 degree=8n 的 不可约三项式 [%2] 不存在
2.  n is odd, k is even and does not divide 2n, and n ≡ ±3 mod 8, 
  [[n%2==1][k%2==0][2n%k=!=0][n%8 <-[3,5]]]
3.  ???bug??? n is even, k is odd and does divide 2n, and n ≡ ±1 mod 8, 
  ???bug??? [[n%2==0][k%2==1][2n%k==0][n%8 <-[1,7]]]
  我认为应该是:[[n%2==1][k%2==0][2n%k==0][n%8 <-[1,7]]]
4.  any of the above holds for k replaced by n − k (that is, for the reciprocal trinomial).
    [x^n+x^k+1 与 x^n+x^(n-k)+1 的 分解 相似，因子一一对应，都是 反转关系]
]]
40.9.4 Irreducible trinomials of the form 1 + x^d+ x^(k*d) 
[[三项式不可约的充分条件
[@i,j <- [0..]]:
  1+x**(3**i)+x**(2*3**i)
  1+x**(7**i)+x**(3*7**i)
  1+x**(3**i*5**j)+x**(4*3**i*5**j)
  皆不可约
]]

40.9.5 Primitive pentanomials
  For all degrees n ≥ 5 an irreducible (and primitive) pentanomial seems to exist, but this has not been proved so far. 
  # 任意次数的本原不可约五项式存在囗猜想


]]

]]
[[
A Chinese Remainder Theorem Approach to Bit-Parallel GF(2^n) Polynomial Basis Multipliers for Irreducible Trinomials(2016)(Haining).pdf
===
https://libgen.lc/edition.php?id=47328508
wget 'https://libgen.rocks/get.php?md5=063c4bea334b9105ddfc082075f5b2cd&key=DCU18XUYR9UH454A' -O 'A Chinese Remainder Theorem Approach to Bit-Parallel GF(2^n) Polynomial Basis Multipliers for Irreducible Trinomials(2016)(Haining).pdf'
引言极佳
vs:
  quadratic formula
    ~ schoolbook methods
  subquadratic formula
    ~ Karatsuba formulae
    ~ Chinese Remainder Theorem (CRT)
        同余方程组参数 [?[n :: pint] -> ?[fm, fr :: @[i <- [0..<n]] -> Polynomial] -> [[@[i <- [0..<n]] -> [degree fr[i] < degree fm[i]]][@[i,j <- [0..<n]] -> [i<j] -> [gcd(fm[i], fm[j])==1]]]]
          求g 满足 @i.[g%fm[i] == fr[i]]
          解: [g =[%FM]= sum~ fr[i]*我一他零[i] ~{i<-[0..<n]}]
          where
            FM = II~ fm[i] ~{i<-[0..<n]}
            我一他零 i = 逆我非零 i * 我非零他零 i
            我非零他零 i = FM/fm[i]
            逆我非零 i = inv<%fm[i]> (我非零他零 i)
          关于 g%(f-f0) 见上面 另一篇论文

  hybrid approach
    ~ “1-subquadratic-and-then-quadratic” computational mode
        只有 最外面一层 用 subquadratic~
        数据规模变小后 用 quadratic~
  ===
    硬件空间复杂度~门的数量
    硬件时间复杂度~输入到输出的最长路径上的门的数量
    #复用可减少 空间复杂度，但 时间复杂度 增加
    The main advantage of the subquadratic multipliers is that their space complexities are often small.  But their time complexities are often larger than their quadratic counterparts.
vs:
  多项式乘法
    compute the product of two polynomials
  矩阵乘法
    compute a Toeplitz matrix-vector product (TMVP)


xxxxxxx:TODO

]]
[[
Low-Power and Low-Hardware Bit-Parallel Polynomial Basis Systolic Multiplier over GF(2^m) for Irreducible Polynomials(2017)(Mathe).pdf
===
https://libgen.lc/edition.php?id=72769507
wget 'https://libgen.rocks/get.php?md5=55ab281a4799e29c0fae17ff9f61399c&key=IMSLNMWNXX64EGML' -O 'Low-Power and Low-Hardware Bit-Parallel Polynomial Basis Systolic Multiplier over GF(2^m) for Irreducible Polynomials(2017)(Mathe).pdf'
]]
[[
===
wget '' -O ''
]]
[[
===
wget '' -O ''
]]
[[
===
wget '' -O ''
]]
]]]



[[[
  xxxxxxx
enumerate irreducible polynomial binary
[[
https://www.math.ucsd.edu/~jmckerna/Teaching/15-16/Spring/103B/l_17.pdf
  wget https://www.math.ucsd.edu/~jmckerna/Teaching/15-16/Spring/103B/l_17.pdf -O 'Irreducible polynomials--l_17.pdf'
]]
[[
https://www.intechopen.com/chapters/80483
  排版糟糕，但内容详细
===

Table 2 lists the primitive polynomials.

Number of primitive polynomials of degree N
N	No
1	1
2	1
4	2
8	16
16	2048
32	67108864
  #6710_8864 #近7千万个 monic本原不可约多项式
  # monic #多项式首项系数为一
Table of primitive polynomials up to degree 31
N	Primitive polynomials
1, 2, 3, 4, 6, 7, 15, 22	1 + X + Xn
5, 11, 21, 29	1 + X2 + Xn
10, 17, 20, 25, 28, 31	1 + X3 + Xn
9	1 + X4 + Xn
23	1 + X5 + Xn
18	1 + X7 + Xn
8	1 + X2 + X3 + X4 + Xn
12	1 + X + X3 + X4 + Xn
13	1 + X + X4 + X6 + Xn
14, 16	1 + X + X3 + X4 + Xn
Table 2. Primitive polynomials.
缺:19 24 26 27 30
]]
[[
[
https://crypto.stackexchange.com/questions/20590/choosing-an-optimal-generator-for-an-irreducible-polynomial-over-a-binary-field
    https://www.jjj.de/mathdata/all-irredpoly.txt
    http://www.jjj.de/mathdata/
      Tables of mathematical data
        https://www.jjj.de/fxt/fxtpage.html#fxtbook
          https://www.jjj.de/fxt/fxt-2022.04.13.tar.gz
            FXT is a library of low-level algorithms. Its main focus is on bit-manipulations, combinatorial generation, and fast transforms. The library is accompanied by the fxtbook. A strong emphasis is on performance and many of the routines are among the fastest available.
          https://www.jjj.de/fxt/fxtbook.pdf
          https://www.jjj.de/fxt/fxtbook-errata.txt
            "Matters Computational" (formerly titled "Algorithms for Programmers")
            wget 'https://www.jjj.de/fxt/fxtbook.pdf' -O 'fxtbook[Matters Computational][Algorithms for Programmers].pdf'
              5M
            wget https://www.jjj.de/fxt/fxtbook-errata.txt
            wget https://www.jjj.de/fxt/fxt-2022.04.13.tar.gz
              2M
            tar -xvzf fxt-2022.04.13.tar.gz
              包含许多东西:13MB
                doc/???-doc.txt
                data/all-irredpoly.txt
                demo/
            du -hs fxt/
            13M     fxt


    wget -r -l inf --no-remove-listing --no-parent -p -k -nc -N --no-use-server-timestamps -c --random-wait --wait=8 --tries=30 --limit-rate=200K --compression=auto -U "Mozilla/5.0 (iPhone; CPU iPhone OS 12_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.1.1 Mobile/15E148 Safari/604.1"    http://www.jjj.de/mathdata/
      压缩:mathdata-www.jjj.de.zip 312KB

[[
~/download/wget_ $ mv fxt-20220703-www.jjj.de/ ~/my_git_py/c_external/fxt/
cd ~/my_git_py/c_external/fxt/fxt-20220703-www.jjj.de/
~/.../fxt/fxt-20220703-www.jjj.de $ ls -1hs
total 7.3M
1.8M fxt-2022.04.13.tar.gz
 24K fxtbook-errata.txt
5.2M 'fxtbook[Matters Computational][Algorithms for Programmers].pdf'
312K mathdata-www.jjj.de.zip
mkdir ~/my_git_py/c_external/fxt/_ignore__unzip/
e ../../python3_src/.gitignore
  /**/_ignore__unzip
  /**/_ignore__build
cd ../_ignore__unzip/
tar -xvzf ../fxt-20220703-www.jjj.de/fxt-2022.04.13.tar.gz
view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/data/all-irredpoly.txt
view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/INSTALL.txt
mkdir ~/my_git_py/c_external/fxt/_ignore__build/
mkdir ~/my_git_py/c_external/fxt/_ignore__build/include/
cd ~/my_git_py/c_external/fxt/_ignore__unzip/fxt/
make install PREFIX=~/my_git_py/c_external/fxt/_ignore__build/
... ...
... ...
: '[install OK]'
ls ~/my_git_py/c_external/fxt/_ignore__build/
~/.../_ignore__unzip/fxt $ ls ~/my_git_py/c_external/fxt/_ignore__build/lib
libfxt.a
~/.../_ignore__unzip/fxt $ ls ~/my_git_py/c_external/fxt/_ignore__build/include/fxt/ -1
array-len.h
aux0
aux0-all.h
aux1
aux1-all.h
aux2
... ...
... ...


cp ~/my_git_py/c_external/fxt/fxt-20220703-www.jjj.de/'fxtbook[Matters Computational][Algorithms for Programmers].pdf'  ~/download/wget_/
ls  ~/download/wget_/

make demo PREFIX=~/my_git_py/c_external/fxt/_ignore__build/
: '[chkdtim]'
WHICH='all' ./scripts/demo.zsh
/data/data/com.termux/files/usr/bin/sh: 1: ./scripts/demo.zsh: Permission denied
make: *** [makefile:512: demo] Error 126



mkdir ~/ex_src/
mkdir ~/ex_src/fxt/
cp -r ~/my_git_py/c_external/fxt/   ~/ex_src/
~/ex_src $ du -hs ~/ex_src/fxt/
28M     /data/data/com.termux/files/home/ex_src/fxt/
~/ex_src $ cd ~/ex_src/fxt/_ignore__unzip/fxt/
make demo PREFIX=~/ex_src/fxt/_ignore__build/
... ...
... ...
1 warning generated.
: '[libfxt.a]'
: '[chkdtim]'
WHICH='all' ./scripts/demo.zsh
/data/data/com.termux/files/usr/bin/sh: 1: ./scripts/demo.zsh: Permission denied
make: *** [makefile:512: demo] Error 126

chmod +x ~/ex_src/fxt/_ignore__unzip/fxt/scripts/*.zsh
chmod +x ~/ex_src/fxt/_ignore__unzip/fxt/scripts/*.sh
chmod +x ~/ex_src/fxt/_ignore__unzip/fxt/scripts/*.pl

chmod +x ~/ex_src/fxt/_ignore__unzip/fxt/scripts/attic/*.sh
chmod +x ~/ex_src/fxt/_ignore__unzip/fxt/scripts/attic/*.pl

~/.../_ignore__unzip/fxt $ make demo PREFIX=~/ex_src/fxt/_ignore__build/
: '[chkdtim]'
WHICH='all' ./scripts/demo.zsh
env: ‘zsh’: No such file or directory
make: *** [makefile:512: demo] Error 127
~/.../_ignore__unzip/fxt $ zsh
The program zsh is not installed. Install it by executing:
  pkg install zsh
~/.../_ignore__unzip/fxt $ pkg install zsh
... ... 2MB -> 12MB
Unpacking zsh-completions (0.34.0) ...
Setting up attr (2.5.1) ...
Setting up libcap (2.64) ...
Setting up zsh (5.9) ...
Setting up zsh-completions (0.34.0) ...
Processing triggers for man (1.14.5-3) ...
~/.../_ignore__unzip/fxt $ make demo PREFIX=~/ex_src/fxt/_ignore__build/
: '[chkdtim]'
WHICH='all' ./scripts/demo.zsh
./scripts/demo.zsh:28: no such file or directory: /tmp/tmp-demo-out
./scripts/demo.zsh:33: no such file or directory: /tmp/tmp-demo-out
Nothing to do.  (?)
~/.../_ignore__unzip/fxt $
~/.../_ignore__unzip/fxt $ view scripts/demo.zsh
cp scripts/demo.zsh scripts/demo.zsh--old
vim scripts/demo.zsh
  TMPDIR=/tmp
  ===改为：
  TMPDIR=~/tmp
~/.../_ignore__unzip/fxt $ make demo PREFIX=~/ex_src/fxt/_ignore__build/
... ...
./demo/seq/A206702-demo.cc --> ./demo/seq/A206702-out.txt    warning: unknown warning option '-Wno-vla-larger-than'; did you mean '-Wno-frame-larger-than'? [-Wunknown-warning-option]
1 warning generated.
... ...
Stats:  534 done,  2 changed,  0 new.
~/.../_ignore__unzip/fxt $
~/.../_ignore__unzip/fxt $ ls ~/tmp/tmp-demo-out/
ls: cannot access '/data/data/com.termux/files/home/tmp/tmp-demo-out': No such file or directory
~/.../_ignore__unzip/fxt $ tree demo/
... ...
... ...
14 directories, 1116 files

find . -path "./demo/**/*-out.txt" > ~/my_tmp/fxt_demo-all-out-txts.txt
view /sdcard/0my_files/tmp/fxt_demo-all-out-txts.txt
  ./demo/gf2n/all-irredpoly-out.txt
  共556个文件
view ../../python3_src/c_external/fxt/_ignore__unzip/fxt/demo/topics.txt
  gf2n@ binary polynomials and finite fields @ Binary polynomials, finite fields GF(2^n) and shift registers.

]]

]


===
[https://www.jjj.de/mathdata/all-trinomial-primpoly-short.txt
  『3: 1 2』==>> x3+x+1, x3+x2+1 是 特征2域上的 不可约 本原 三项式 #本原<==>根 是 非零乘法群 的 生成子
===
#
# Complete list of primitive trinomials over GF(2)
# up to degree 400
# Short form:  a line of the form
#   d:  t1 t2 t3 t4 ...tn
# corresponds to n entries in the usual form:
#   d, tj, 0  (j \in 1..n)
#.
# Generated by Joerg Arndt, 2003-March-03
#

2:  1
3:  1 2
4:  1 3
5:  2 3
6:  1 5
7:  1 3 4 6
9:  4 5
10:  3 7
11:  2 9
15:  1 4 7 8 11 14
17:  3 5 6 11 12 14
18:  7 11
20:  3 17
21:  2 19
22:  1 21
23:  5 9 14 18
25:  3 7 18 22
28:  3 9 13 15 19 25
29:  2 27
31:  3 6 7 13 18 24 25 28
33:  13 20
35:  2 33
36:  11 25
39:  4 8 14 25 31 35
41:  3 20 21 38
47:  5 14 20 21 26 27 33 42
49:  9 12 15 22 27 34 37 40
52:  3 19 21 31 33 49
55:  24 31
57:  7 22 35 50
58:  19 39
60:  1 11 49 59
63:  1 5 31 32 58 62
65:  18 32 33 47
68:  9 33 35 59
71:  6 9 18 20 35 36 51 53 62 65
73:  25 28 31 42 45 48
79:  9 19 60 70
81:  4 16 35 46 65 77
84:  13 71
87:  13 74
89:  38 51
93:  2 91
94:  21 73
95:  11 17 78 84
97:  6 12 33 34 63 64 85 91
98:  11 27 71 87
100:  37 63
103:  9 13 30 31 72 73 90 94
105:  16 17 37 43 52 53 62 68 88 89
106:  15 91
108:  31 77
111:  10 49 62 101
113:  9 15 30 83 98 104
118:  33 45 73 85
119:  8 38 81 111
121:  18 103
123:  2 121
124:  37 87
127:  1 7 15 30 63 64 97 112 120 126
129:  5 31 46 83 98 124
130:  3 127
132:  29 103
134:  57 77
135:  11 16 22 113 119 124
137:  21 35 57 80 102 116
140:  29 111
142:  21 121
145:  52 69 76 93
148:  27 121
150:  53 97
151:  3 9 15 31 39 43 46 51 63 66 67 70 81 84 85 88 100 105 108 112 120 136 142 148
153:  1 8 145 152
159:  31 34 40 119 125 128
161:  18 39 60 101 122 143
167:  6 35 59 77 90 108 132 161
169:  34 42 57 84 85 112 127 135
170:  23 147
172:  7 165
174:  13 161
175:  6 16 18 57 118 157 159 169
177:  8 22 88 89 155 169
178:  87 91
183:  56 127
185:  24 41 69 116 144 161
191:  9 18 51 71 120 140 173 182
193:  15 73 85 108 120 178
194:  87 107
198:  65 133
199:  34 67 132 165
201:  14 17 59 79 122 142 184 187
202:  55 147
207:  43 164
209:  6 8 14 45 47 50 62 147 159 162 164 195 201 203
212:  105 107
215:  23 51 63 77 101 114 138 152 164 192
217:  45 64 66 82 85 132 135 151 153 172
218:  11 15 71 83 135 147 203 207
223:  33 34 64 70 91 132 153 159 189 190
225:  32 74 88 97 109 116 128 137 151 193
231:  26 34 197 205
233:  74 159
234:  31 103 131 203
236:  5 231
239:  36 81 158 203
241:  70 171
247:  82 102 145 165
249:  86 163
250:  103 147
252:  67 185
255:  52 56 82 173 199 203
257:  12 41 48 51 65 192 206 209 216 245
258:  83 175
263:  93 170
265:  42 127 138 223
266:  47 219
268:  25 61 207 243
270:  53 133 137 217
271:  58 70 201 213
273:  23 53 67 88 92 110 113 160 163 181 185 206 220 250
274:  67 99 135 139 175 207
278:  5 273
279:  5 10 38 40 41 59 76 80 125 154 199 203 220 238 239 241 269 274
281:  93 99 182 188
282:  35 43 239 247
284:  119 165
286:  69 73 213 217
287:  71 116 125 162 171 216
289:  21 36 84 205 253 268
292:  97 195
294:  61 233
295:  48 112 123 142 147 148 153 172 183 247
297:  5 83 103 122 137 160 175 194 214 292
300:  7 73 91 209 227 293
302:  41 261
305:  102 203
313:  79 121 192 234
314:  15 299
316:  135 181
319:  36 52 129 190 267 283
321:  31 56 76 82 155 166 239 245 265 290
322:  67 255
327:  34 152 175 293
329:  50 54 275 279
332:  123 209
333:  2 331
337:  55 57 135 139 147 190 198 202 280 282
342:  125 217
343:  75 135 138 159 184 205 208 268
345:  22 37 106 239 308 323
350:  53 297
351:  34 55 116 134 217 235 296 317
353:  69 95 138 143 153 173 180 200 210 215 258 284
359:  68 117 242 291
362:  63 107 255 299
364:  67 297
366:  29 337
367:  21 171 196 346
369:  91 110 259 278
370:  139 183 187 231
375:  16 64 149 182 193 226 311 359
377:  41 75 302 336
378:  43 107 271 335
380:  47 333
382:  81 301
383:  90 108 135 248 275 293
385:  6 24 51 54 142 159 226 243 331 334 361 379
386:  83 303
390:  89 301
391:  28 31 360 363
393:  7 62 91 302 331 386
394:  135 259
396:  25 109 169 175 221 227 287 371
]
[https://www.jjj.de/mathdata/all-trinomial-irredpoly-short.txt
  『3: 1 2』==>> x3+x+1, x3+x2+1 是 特征2域上的 不可约 三项式 (本原+非本原)
===
#
# Complete list of irreducible trinomials over GF(2)
# up to degree 400
# Short form:  a line of the form
#   d:  t1 t2 t3 t4 ...tn
# corresponds to n entries in the usual form:
#   d, tj, 0  (j \in 1..n)
#.
# Generated by Joerg Arndt, 2003-March-03
#

2:  1
3:  1 2
4:  1 3
5:  2 3
6:  1 3 5
7:  1 3 4 6
9:  1 4 5 8
10:  3 7
11:  2 9
12:  3 5 7 9
14:  5 9
15:  1 4 7 8 11 14
17:  3 5 6 11 12 14
18:  3 7 9 11 15
20:  3 5 15 17
21:  2 7 14 19
22:  1 21
23:  5 9 14 18
25:  3 7 18 22
28:  1 3 9 13 15 19 25 27
29:  2 27
30:  1 9 21 29
31:  3 6 7 13 18 24 25 28
33:  10 13 20 23
34:  7 27
35:  2 33
36:  9 11 15 21 25 27
39:  4 8 14 25 31 35
41:  3 20 21 38
42:  7 35
44:  5 39
46:  1 45
47:  5 14 20 21 26 27 33 42
49:  9 12 15 22 27 34 37 40
52:  3 7 19 21 31 33 45 49
54:  9 21 27 33 45
55:  7 24 31 48
57:  4 7 22 25 32 35 50 53
58:  19 39
60:  1 9 11 15 17 23 37 43 45 49 51 59
62:  29 33
63:  1 5 11 28 31 32 35 52 58 62
65:  18 32 33 47
66:  3 63
68:  9 33 35 59
71:  6 9 18 20 35 36 51 53 62 65
73:  25 28 31 42 45 48
74:  35 39
76:  21 55
79:  9 19 60 70
81:  4 16 35 46 65 77
84:  5 9 11 13 27 35 39 45 49 57 71 73 75 79
86:  21 65
87:  13 74
89:  38 51
90:  27 63
92:  21 71
93:  2 91
94:  21 73
95:  11 17 78 84
97:  6 12 33 34 63 64 85 91
98:  11 27 71 87
100:  15 19 25 37 49 51 63 75 81 85
102:  29 37 65 73
103:  9 13 30 31 72 73 90 94
105:  4 7 8 16 17 28 37 43 49 52 53 56 62 68 77 88 89 97 98 101
106:  15 91
108:  17 27 31 33 45 63 75 77 81 91
110:  33 77
111:  10 49 62 101
113:  9 15 30 83 98 104
118:  33 45 73 85
119:  8 38 81 111
121:  18 30 91 103
123:  2 121
124:  19 37 45 55 69 79 87 105
126:  21 49 77 105
127:  1 7 15 30 63 64 97 112 120 126
129:  5 31 46 83 98 124
130:  3 127
132:  17 29 103 115
134:  57 77
135:  11 16 22 29 106 113 119 124
137:  21 35 57 80 102 116
140:  15 29 45 65 75 95 111 125
142:  21 121
145:  52 69 76 93
146:  71 75
147:  14 49 98 133
148:  27 121
150:  53 73 77 97
151:  3 9 15 31 39 43 46 51 63 66 67 70 81 84 85 88 100 105 108 112 120 136 142 148
153:  1 8 145 152
154:  15 139
155:  62 93
156:  9 11 57 61 63 65 91 93 95 99 145 147
159:  31 34 40 119 125 128
161:  18 39 60 101 122 143
162:  27 63 81 99 135
166:  37 129
167:  6 35 59 77 90 108 132 161
169:  34 42 57 84 85 112 127 135
170:  11 23 147 159
172:  1 7 81 91 165 171
174:  13 57 117 161
175:  6 16 18 57 118 157 159 169
177:  8 22 88 89 155 169
178:  31 87 91 147
180:  3 27 33 45 55 69 111 125 135 147 153 177
182:  81 101
183:  56 127
185:  24 41 69 116 144 161
186:  11 79 107 175
191:  9 18 51 71 120 140 173 182
193:  15 73 85 108 120 178
194:  87 107
196:  3 33 67 129 163 193
198:  9 65 133 189
199:  34 67 132 165
201:  14 17 59 79 122 142 184 187
202:  55 147
204:  27 99 105 177
207:  43 164
209:  6 8 14 45 47 50 62 147 159 162 164 195 201 203
210:  7 203
212:  105 107
214:  73 141
215:  23 51 63 77 101 114 138 152 164 192
217:  45 64 66 82 85 132 135 151 153 172
218:  11 15 71 83 99 119 135 147 203 207
220:  7 33 49 171 187 213
223:  33 34 64 70 91 132 153 159 189 190
225:  32 74 88 97 109 116 128 137 151 193
228:  113 115
231:  26 34 91 140 197 205
233:  74 159
234:  31 103 131 203
236:  5 231
238:  73 117 121 165
239:  36 81 158 203
241:  70 171
242:  95 147
244:  111 133
247:  82 102 145 165
249:  35 86 163 214
250:  103 147
252:  15 27 33 39 53 59 67 77 81 105 109 117 135 143 147 171 175 185 193 199 213 219 225 237
253:  46 207
255:  52 56 82 173 199 203
257:  12 41 48 51 65 192 206 209 216 245
258:  71 83 175 187
260:  15 35 95 105 155 165 225 245
263:  93 170
265:  42 127 138 223
266:  47 219
268:  25 61 207 243
270:  53 81 133 137 189 217
271:  58 70 201 213
273:  23 28 53 55 56 67 88 92 98 110 113 160 163 175 181 185 206 217 218 220 245 250
274:  67 99 135 139 175 207
276:  63 91 185 213
278:  5 273
279:  5 10 38 40 41 59 73 76 80 125 154 199 203 206 220 238 239 241 269 274
281:  93 99 182 188
282:  35 43 63 219 239 247
284:  53 99 119 141 143 165 185 231
286:  69 73 213 217
287:  71 116 125 162 171 216
289:  21 36 84 205 253 268
292:  37 97 195 255
294:  33 49 61 81 213 233 245 261
295:  48 112 123 142 147 148 153 172 183 247
297:  5 83 103 122 137 160 175 194 214 292
300:  5 7 45 55 57 73 75 91 111 147 153 189 209 225 227 243 245 255 293 295
302:  41 261
303:  1 302
305:  102 203
308:  15 293
310:  93 217
313:  79 121 192 234
314:  15 299
316:  63 135 181 253
318:  45 273
319:  36 52 129 190 267 283
321:  31 41 56 76 82 155 166 239 245 265 280 290
322:  67 255
324:  51 81 93 99 135 149 175 189 225 231 243 273
327:  34 152 175 293
329:  50 54 275 279
330:  99 231
332:  89 123 209 243
333:  2 331
337:  55 57 135 139 147 190 198 202 280 282
340:  45 165 175 295
342:  125 133 209 217
343:  75 135 138 159 184 205 208 268
345:  22 37 106 239 308 323
346:  63 283
348:  103 245
350:  53 297
351:  34 55 79 116 134 217 235 272 296 317
353:  69 95 138 143 153 173 180 200 210 215 258 284
354:  99 135 219 255
358:  57 301
359:  68 117 242 291
362:  63 107 255 299
364:  9 67 297 355
366:  29 337
367:  21 171 196 346
369:  91 110 259 278
370:  139 183 187 231
372:  111 135 165 207 237 261
375:  16 64 149 182 193 226 311 359
377:  41 75 302 336
378:  43 63 107 147 231 271 315 335
380:  47 63 105 275 317 333
382:  81 301
383:  90 108 135 248 275 293
385:  6 24 51 54 111 142 159 226 243 274 331 334 361 379
386:  83 303
388:  159 229
390:  9 49 89 301 341 381
391:  28 31 360 363
393:  7 62 91 302 331 386
394:  135 259
396:  25 51 87 109 169 175 221 227 287 309 345 371
399:  26 49 86 109 154 181 218 245 290 313 350 373
]
[https://www.jjj.de/mathdata/all-irredpoly.txt
===
#
# Complete list of binary irreducible polynomials
# up to degree 11
#.
# Generated by Joerg Arndt, 2003-October-30
#


2,1,0


3,1,0
3,2,0


4,1,0
4,3,0
# non-primitive:
4,3,2,1,0


5,2,0
5,3,0
5,3,2,1,0
5,4,2,1,0
5,4,3,1,0
5,4,3,2,0


6,1,0
6,4,3,1,0
6,5,0
6,5,2,1,0
6,5,3,2,0
6,5,4,1,0
# non-primitive:
6,3,0
6,4,2,1,0
6,5,4,2,0


7,1,0
7,3,0
7,3,2,1,0
7,4,0
7,4,3,2,0
7,5,2,1,0
7,5,3,1,0
7,5,4,3,0
7,5,4,3,2,1,0
7,6,0
7,6,3,1,0
7,6,4,1,0
7,6,4,2,0
7,6,5,2,0
7,6,5,3,2,1,0
7,6,5,4,0
7,6,5,4,2,1,0
7,6,5,4,3,2,0


8,4,3,2,0
8,5,3,1,0
8,5,3,2,0
8,6,3,2,0
8,6,4,3,2,1,0
8,6,5,1,0
8,6,5,2,0
8,6,5,3,0
8,6,5,4,0
8,7,2,1,0
8,7,3,2,0
8,7,5,3,0
8,7,6,1,0
8,7,6,3,2,1,0
8,7,6,5,2,1,0
8,7,6,5,4,2,0
# non-primitive:
8,4,3,1,0
8,5,4,3,0
8,5,4,3,2,1,0
8,6,5,4,2,1,0
8,6,5,4,3,1,0
8,7,3,1,0
8,7,4,3,2,1,0
8,7,5,1,0
8,7,5,4,0
8,7,5,4,3,2,0
8,7,6,4,2,1,0
8,7,6,4,3,2,0
8,7,6,5,4,1,0
8,7,6,5,4,3,0


9,4,0
9,4,3,1,0
9,5,0
9,5,3,2,0
9,5,4,1,0
9,6,4,3,0
9,6,4,3,2,1,0
9,6,5,3,0
9,6,5,3,2,1,0
9,6,5,4,2,1,0
9,6,5,4,3,2,0
9,7,2,1,0
9,7,4,2,0
9,7,5,1,0
9,7,5,2,0
9,7,5,3,2,1,0
9,7,5,4,2,1,0
9,7,5,4,3,2,0
9,7,6,3,2,1,0
9,7,6,4,0
9,7,6,4,3,1,0
9,7,6,5,4,2,0
9,7,6,5,4,3,0
9,8,4,1,0
9,8,4,2,0
9,8,4,3,2,1,0
9,8,5,1,0
9,8,5,4,0
9,8,5,4,3,1,0
9,8,6,3,2,1,0
9,8,6,4,3,1,0
9,8,6,5,0
9,8,6,5,3,1,0
9,8,6,5,3,2,0
9,8,6,5,4,1,0
9,8,6,5,4,3,2,1,0
9,8,7,2,0
9,8,7,3,2,1,0
9,8,7,5,4,2,0
9,8,7,5,4,3,0
9,8,7,6,2,1,0
9,8,7,6,3,1,0
9,8,7,6,3,2,0
9,8,7,6,4,2,0
9,8,7,6,4,3,0
9,8,7,6,5,1,0
9,8,7,6,5,3,0
9,8,7,6,5,4,3,1,0
# non-primitive:
9,1,0
9,4,2,1,0
9,6,3,1,0
9,6,5,2,0
9,7,4,3,0
9,8,0
9,8,6,3,0
9,8,7,5,0


10,3,0
10,4,3,1,0
10,5,2,1,0
10,5,3,2,0
10,6,5,2,0
10,6,5,3,2,1,0
10,7,0
10,7,3,1,0
10,7,6,2,0
10,7,6,4,2,1,0
10,7,6,5,2,1,0
10,7,6,5,4,1,0
10,7,6,5,4,3,2,1,0
10,8,3,2,0
10,8,4,3,0
10,8,5,1,0
10,8,5,4,0
10,8,5,4,3,2,0
10,8,6,1,0
10,8,6,4,2,1,0
10,8,6,5,3,1,0
10,8,7,2,0
10,8,7,3,2,1,0
10,8,7,4,2,1,0
10,8,7,5,0
10,8,7,6,2,1,0
10,8,7,6,5,2,0
10,8,7,6,5,4,2,1,0
10,8,7,6,5,4,3,1,0
10,9,4,1,0
10,9,4,2,0
10,9,5,2,0
10,9,5,4,2,1,0
10,9,6,1,0
10,9,6,3,2,1,0
10,9,6,4,3,1,0
10,9,6,5,4,3,0
10,9,6,5,4,3,2,1,0
10,9,7,3,0
10,9,7,5,4,2,0
10,9,7,6,0
10,9,7,6,4,1,0
10,9,7,6,4,3,2,1,0
10,9,7,6,5,4,3,2,0
10,9,8,4,2,1,0
10,9,8,4,3,2,0
10,9,8,5,0
10,9,8,5,4,3,0
10,9,8,6,2,1,0
10,9,8,6,3,2,0
10,9,8,6,4,2,0
10,9,8,6,4,3,0
10,9,8,6,5,1,0
10,9,8,6,5,4,3,2,0
10,9,8,7,3,2,0
10,9,8,7,4,1,0
10,9,8,7,5,4,0
10,9,8,7,6,4,3,1,0
10,9,8,7,6,5,4,1,0
10,9,8,7,6,5,4,3,0
# non-primitive:
10,3,2,1,0
10,4,3,2,0
10,5,4,2,0
10,6,2,1,0
10,6,4,1,0
10,6,5,1,0
10,7,4,3,0
10,7,5,3,0
10,7,5,3,2,1,0
10,7,6,3,0
10,7,6,5,3,2,0
10,8,3,1,0
10,8,4,3,2,1,0
10,8,6,5,0
10,8,6,5,2,1,0
10,8,7,4,3,1,0
10,8,7,5,3,1,0
10,8,7,5,4,3,0
10,8,7,6,0
10,9,5,1,0
10,9,5,4,0
10,9,6,4,0
10,9,7,2,0
10,9,7,5,2,1,0
10,9,7,5,3,2,0
10,9,7,5,4,3,2,1,0
10,9,7,6,3,2,0
10,9,7,6,5,4,2,1,0
10,9,8,3,2,1,0
10,9,8,4,0
10,9,8,5,3,1,0
10,9,8,5,4,2,0
10,9,8,6,5,4,3,1,0
10,9,8,7,0
10,9,8,7,2,1,0
10,9,8,7,5,3,0
10,9,8,7,6,2,0
10,9,8,7,6,5,3,1,0
10,9,8,7,6,5,4,3,2,1,0


11,2,0
11,4,2,1,0
11,5,3,1,0
11,5,3,2,0
11,6,2,1,0
11,6,5,1,0
11,6,5,2,0
11,6,5,4,0
11,6,5,4,3,1,0
11,7,3,2,0
11,7,4,2,0
11,7,4,3,2,1,0
11,7,5,3,0
11,7,5,4,0
11,7,6,3,2,1,0
11,7,6,4,0
11,7,6,5,0
11,7,6,5,2,1,0
11,7,6,5,3,1,0
11,7,6,5,4,2,0
11,8,3,2,0
11,8,4,1,0
11,8,5,2,0
11,8,5,3,0
11,8,5,4,3,1,0
11,8,5,4,3,2,0
11,8,6,2,0
11,8,6,3,0
11,8,6,4,0
11,8,6,4,3,1,0
11,8,6,5,4,1,0
11,8,6,5,4,2,0
11,8,6,5,4,3,2,1,0
11,8,7,1,0
11,8,7,3,2,1,0
11,8,7,5,3,1,0
11,8,7,5,3,2,0
11,8,7,5,4,3,0
11,8,7,6,2,1,0
11,8,7,6,4,3,0
11,8,7,6,5,2,0
11,8,7,6,5,4,2,1,0
11,9,0
11,9,2,1,0
11,9,4,1,0
11,9,4,2,0
11,9,5,3,0
11,9,6,3,0
11,9,6,5,0
11,9,6,5,3,2,0
11,9,6,5,4,3,0
11,9,6,5,4,3,2,1,0
11,9,7,2,0
11,9,7,4,0
11,9,7,4,3,2,0
11,9,7,5,2,1,0
11,9,7,5,3,1,0
11,9,7,5,4,1,0
11,9,7,5,4,2,0
11,9,7,6,4,2,0
11,9,7,6,4,3,2,1,0
11,9,7,6,5,3,0
11,9,7,6,5,3,2,1,0
11,9,7,6,5,4,0
11,9,7,6,5,4,3,1,0
11,9,8,1,0
11,9,8,3,0
11,9,8,4,0
11,9,8,5,4,1,0
11,9,8,5,4,3,2,1,0
11,9,8,6,0
11,9,8,6,3,1,0
11,9,8,6,4,3,0
11,9,8,6,4,3,2,1,0
11,9,8,6,5,2,0
11,9,8,6,5,3,2,1,0
11,9,8,6,5,4,3,2,0
11,9,8,7,2,1,0
11,9,8,7,3,1,0
11,9,8,7,4,1,0
11,9,8,7,4,2,0
11,9,8,7,5,3,2,1,0
11,9,8,7,5,4,2,1,0
11,9,8,7,5,4,3,2,0
11,9,8,7,6,3,0
11,9,8,7,6,4,3,1,0
11,9,8,7,6,4,3,2,0
11,9,8,7,6,5,2,1,0
11,9,8,7,6,5,3,2,0
11,10,3,1,0
11,10,3,2,0
11,10,4,3,0
11,10,4,3,2,1,0
11,10,6,4,2,1,0
11,10,6,5,0
11,10,6,5,3,1,0
11,10,6,5,4,1,0
11,10,7,2,0
11,10,7,3,0
11,10,7,4,2,1,0
11,10,7,4,3,1,0
11,10,7,4,3,2,0
11,10,7,5,4,1,0
11,10,7,5,4,3,2,1,0
11,10,7,6,2,1,0
11,10,7,6,3,2,0
11,10,7,6,4,1,0
11,10,7,6,4,2,0
11,10,7,6,5,1,0
11,10,7,6,5,3,0
11,10,7,6,5,4,2,1,0
11,10,8,1,0
11,10,8,3,2,1,0
11,10,8,4,3,2,0
11,10,8,5,2,1,0
11,10,8,5,3,2,0
11,10,8,6,0
11,10,8,6,2,1,0
11,10,8,6,4,2,0
11,10,8,6,4,3,0
11,10,8,6,5,1,0
11,10,8,6,5,3,2,1,0
11,10,8,6,5,4,0
11,10,8,7,4,1,0
11,10,8,7,4,3,2,1,0
11,10,8,7,5,3,0
11,10,8,7,5,4,3,1,0
11,10,8,7,5,4,3,2,0
11,10,8,7,6,3,0
11,10,8,7,6,4,2,1,0
11,10,8,7,6,4,3,1,0
11,10,8,7,6,5,0
11,10,8,7,6,5,2,1,0
11,10,8,7,6,5,4,2,0
11,10,9,2,0
11,10,9,4,3,2,0
11,10,9,5,0
11,10,9,5,2,1,0
11,10,9,5,3,1,0
11,10,9,5,4,1,0
11,10,9,5,4,3,0
11,10,9,6,2,1,0
11,10,9,6,3,1,0
11,10,9,6,4,2,0
11,10,9,6,4,3,2,1,0
11,10,9,6,5,4,0
11,10,9,6,5,4,3,1,0
11,10,9,6,5,4,3,2,0
11,10,9,7,0
11,10,9,7,4,1,0
11,10,9,7,4,3,2,1,0
11,10,9,7,5,1,0
11,10,9,7,5,4,3,1,0
11,10,9,7,6,3,2,1,0
11,10,9,7,6,4,3,2,0
11,10,9,7,6,5,4,1,0
11,10,9,7,6,5,4,3,0
11,10,9,8,3,1,0
11,10,9,8,4,3,0
11,10,9,8,5,4,0
11,10,9,8,5,4,2,1,0
11,10,9,8,6,4,3,2,0
11,10,9,8,6,5,3,1,0
11,10,9,8,6,5,3,2,0
11,10,9,8,6,5,4,2,0
11,10,9,8,7,1,0
11,10,9,8,7,4,0
11,10,9,8,7,4,2,1,0
11,10,9,8,7,4,3,1,0
11,10,9,8,7,5,2,1,0
11,10,9,8,7,5,3,2,0
11,10,9,8,7,5,4,2,0
11,10,9,8,7,6,3,2,0
11,10,9,8,7,6,4,1,0
11,10,9,8,7,6,5,2,0
11,10,9,8,7,6,5,3,0
# non-primitive:
11,7,6,1,0
11,8,5,4,2,1,0
11,8,7,6,5,3,2,1,0
11,9,7,6,5,1,0
11,10,5,4,0
11,10,6,5,4,2,0
11,10,8,7,6,5,4,3,2,1,0
11,10,9,7,6,3,0
11,10,9,8,6,5,4,3,0
11,10,9,8,7,6,5,4,3,1,0
]
]]
[[
===
]]
[[
===
]]
[[
===
]]
[[
Concrete quantum cryptanalysis of binary elliptic curves(2020)(Gustavo).pdf
===
https://www.researchgate.net/figure/List-of-irreducible-polynomials-for-binary-finite-fields-used-in-this-paper_tbl1_347321760
  https://www.researchgate.net/publication/347321760_Concrete_quantum_cryptanalysis_of_binary_elliptic_curves/download
Table 1: List of irreducible polynomials for binary finite fields used in this paper. 
Degree   Irreducible polynomial  Source 
8   :   x8+ x4+ x3+ x + 1   [ACD+05] 
16  :   x16+ x5+ x3+ x + 1  [ACD+05] 
127 :   x127+ x + 1         [ACD+05] 
163 :   z163+ z7+ z6+ z3+ 1 [KG13] 
233 :   z233+ z74+ 1        [KG13] 
283 :   z283+ z12+ z7+ z5+ 1[KG13] 
571 :   z571+ z10+ z5+ z2+ 1[KG13]
]]

[[
[
分解 2**m-1, p**m-1, 因为 有限域 经常用到。
  factor 2^k-1
  factor integer of special form 2^k-1
  wget 'https://www.ams.org/journals/mcom/1967-21-097/S0025-5718-67-99898-5/S0025-5718-67-99898-5.pdf' -O 'Some Factorizations of 2^n±1 and Related Results(1966)(Brillhart).pdf'
    分解:N
    [[N=2k+1] -> [k**2 == (k+1)**2-N]]
      [[N=2k+1] -> [N==x**2-y**2] -> [1<x-y<=x+y<N] -> [ceil_sqrt N <=x <= k][0<=y<=x-2<=k-2]]
    [[N%2==1][N>=3] -> [@[x <- [ceil_sqrt N..=N]] -> [not$ is_square x**2-N]] -> [is_prime N]]
    [[N%2==1][N>=3] -> [?[x <- [ceil_sqrt N..=N//2]] -> ?[y <- [0..=x-2]] -> [y**2 == x**2-N]] -> [{(x-y), (x+y)} <= all_divisors_of(N)\-\{1,N}]]
    #为什么不选y??因为 y的 取值范围 更大:
    #   # [[N%2==1][N>=3] -> [@[y <- [0..<N//2]] -> [not$ is_square y**2+N]] -> [is_prime N]]
    #
    如何跳过无效的x?
      moduli = 两两互素的模的集合
        len moduli >= 21
        模可以是 合数: 比如 17*83
      [[M0,M1 <- moduli] -> [M0=!=M1] -> [gcd(M0,M1)==1]]
      [is_x_ok N moduli x =[def]= [@[M <- moduli] -> [is_quadratic_residue[%M](x**2-N)]]]
      CRT = Chinese remainder theorem
      [all_ok_x_mod N M =[def]= {x <- [0..<M] | [is_quadratic_residue[%M](x**2-N)]}]
      [所有有效配置 N moduli =[def]= [@[M<-moduli] -> (all_ok_x_mod N M)]]
      每一份有效配置，可用 CRT 组合出 x0=CRT(有效配置)%II moduli, x<- 有效配置覆盖的所有有效值(N,moduli,有效配置)={x0+i*II moduli | [i<-[(ceil_sqrt N-x0-1)//II moduli +1..= (k-x0)//II moduli]]}
      效率/划不划算:
        每新增一个 模M，有效配置的数量 *= len(all_ok_x_mod N M)
          #len(all_ok_x_mod N M)有没可能是1？
          #存在，但孤例！见下面:『平方差分解法的增加新模大数零开销的充要条件』
        但 同时 len(有效配置覆盖的所有有效值 N moduli 有效配置) 可能会有所下降，大约 (/M)
          求 min(len(all_ok_x_mod N M)/M)
          求 worst_efficiency(M)=max(len(all_ok_x_mod N M)/M) where gcd(N,M)==1

      正整数素性判定:
        [@[u <- [2..]] -> [?[a <- [1..<u]] -> [[a**(u-1)%u==1][@[p<-all_prime_factors_of(u-1)] -> [a**((u-1)//p)%u=!=1]]]] -> [is_prime u]]
        #同一个a<u> --> 拆成多个a<u,p>
        [@[u <- [2..]] -> [@[p<-all_prime_factors_of(u-1)] -> [?[a <- [1..<u]] -> [[a**(u-1)%u==1][a**((u-1)//p)%u=!=1]]]] -> [is_prime u]]
        #如何合并a<u,p>为a<u>？难。
        [@[p<-all_prime_factors_of(u-1)] -> [order<u>(a<u,p>)%p**max_height_of_prime_power_(p,u-1) == 0]]
        [@[p<-all_prime_factors_of(u-1)] -> [(u-1)//order<u>(a<u,p>) % p =!= 0]]
        [(u-1) == order<u>(a<u>)]
        [u % order<u>(a<u>) ==1]
        [@[p<-all_prime_factors_of(u-1)] -> [?[k <- [1..<=u-2]] -> [gcd(k,p)==1][a<u,p> =[%u]= a<u>**k =![%u]!= a<u> **((u-1)//p *k)]]]
        方程组:
        [@[k :: [@[p<-all_prime_factors_of(u-1)] -> [1..<=u-2]]] -> [@[p<-all_prime_factors_of(u-1)] -> [gcd(k<p>,p)==1]] -> ?[e] -> [sum e<p>*k<p> {p} =[%(u-1)]= 1]]
          let M:=II{p}
          let C<p>:=u//p**max_height_of_prime_power_(p,u)
          assume e<p> == e2<p>*C<p>
          assume k2<p> == k<p>*C<p>
          [sum e2<p>*k<p>*C<p> {p} =[%(u-1)]= 1]
          [sum e2<p>*k2<p> {p} =[%(u-1)]= 1]
          k2 <- coprimes_of p**max_height_of_prime_power_(p,u)
            搜索空间太大，离散对数 难求

      ######
      ???[len(all_ok_x_mod N M)有没可能是1]???
        存在！
            见下面:『平方差分解法的增加新模大数零开销的充要条件』
            [all_ok_x_mod 2 3 == {0}]
            分解(3k+2)型的正整数，必有：[x%3==0]
            分解(3k+1)型的正整数，必有：[y%3==0]

        # [%7]: quadratic_residue => [0, 1, 4, 2]
        #   diff between quadratic_residue => [0=..., 1=1-0=2-1, 2=2-0=4-2, 3=0-4=4-1, {#接着只是反转#} 4=1-4=4-0, 5=0-2=2-4, 6=0-1=1-2]
        [x**2-y**2 =[%M]= N =[%M]= a**2-b**2]
          ==>> x,y 与 a,b 什么关系？
            x 的解 包含{+a,-a}
              至少2个，除非 [a==-a%M]:
                [2*a%M==0]
                [M%2==0]:
                  x 的解 包含{0,M//2}
                [M%2=!=0]
                [a%M == 0]
                [mu M == 0]:
                  [?[p<-[1..<M]] -> [M%p==0] -> [(M//p)**2%M==0]]
                  # [max_height_of_prime_power_ p M >=2]
                  [x**2 =[%M]= 0]的解 包含{0,M//p}
            即 [[len(all_ok_x_mod N M)==1] ==>> [(all_ok_x_mod N M) == {0}][M%2=!=0][mu M =!= 0]]
          [N%M==0]:
            [y =[%M]= x]or[y =[%M]= -x]
          [M%2=!=0]:
            [2*M//2+1 == M]
            [2*(M//2+1)%M == 1]
            [let inv_2 := (M//2+1)]

            @u.[gcd(u,M)==1]:
              ?inv_u. [u*inv_u=[%M]=1]
              [let v = inv_u*N]
              [u*v=[%M]=N]
              [let x+y=[%M]=u]
              [let x-y=[%M]=v]
              [x =[%M]= (u+v)*inv_2]
              [y =[%M]= (u-v)*inv_2]
              [x =[%M]= (u+v)*inv_2
                 =[%M]= (u+inv_u*N)*inv_2
              ]
        [[M%2=!=0] -> [(all_ok_x_mod N M) |>=| {(u+inv_u*N)*inv_2%M | [@u.[gcd(u,M)==1]]}]]
          ??? [M=7][N=1][inv_2==4][u<-[1..=6]]:
            (all_ok_x_mod 1 7)
              # [[is_prime M] -> coprimes_of(M)%M = {0}]
            |>=| inv_2 .* {u+inv_u*N}%M
            = 4 .* {1+1,2+4,3+5,4+2,5+3,6+6}%M
            = 4 .* {2,6,8,6,8,12}%7
            = 4 .* {2,6,1,5}%7
            = {8,24,4,20}%7
            = {1,3,4,6}%7
            #   x**2 => {1,2}%7
            #   对应上面的:diff between quadratic_residue => [..., 1=1-0=2-1, ...}]
        [len(all_ok_x_mod N M)==1]:
          !![[len(all_ok_x_mod N M)==1] ==>> [(all_ok_x_mod N M) == {0}][M%2=!=0][mu M =!= 0]]
          [(all_ok_x_mod N M) == {0}][M%2=!=0][mu M =!= 0]
          !![[M%2=!=0] -> [(all_ok_x_mod N M) |>=| {(u+inv_u*N)*inv_2%M | [@u.[gcd(u,M)==1]]}]]
          [(all_ok_x_mod N M) |>=| {(u+inv_u*N)*inv_2%M | [@u.[gcd(u,M)==1]]}]

          !![?u.[gcd(u,M)==1]]
          [{0} == {(u+inv_u*N)*inv_2%M | [@u.[gcd(u,M)==1]]}]
          [@[u.[gcd(u,M)==1]] -> [(u+inv_u*N)*inv_2%M ==0]]
          [@[u.[gcd(u,M)==1]] -> [(u+inv_u*N)%M ==0]]
          [@[u.[gcd(u,M)==1]] -> [(u*u+u*inv_u*N)%M ==0]]
          [@[u.[gcd(u,M)==1]] -> [(u*u+N)%M ==0]]
          [@[u.[gcd(u,M)==1]] -> [u*u =[%M]= -N]]
            #平方差分解法的增加新模零开销的必要条件囗过时
          [N%M =!= 0]
          [is_prime M]:
            [@[u <- [1..<M]] -> [u*u =[%M]= -N]]
            [all_quadratic_residues[%M] == {0, -N%M}]
            [M==3]
          [not$ is_prime M]:
            [Mp <- all_prime_factors_of M]
            !![M%2=!=0][len(all_ok_x_mod N M)==1]
            [Mp%2=!=0][len(all_ok_x_mod N Mp)==1]
            [Mp==3]
            [M == 3**e]
            !![mu M =!= 0]
            [e <2]
            !![not$ is_prime M]
            !![M>=3]
            [M不存在]
          [M=3][N%M==2]:
            is_quadratic_residue=>[0,1]
            diff between quadratic_residue=>{0=..., 1=1-0, 2=0-1}
            完美！
            [all_ok_x_mod 2 3 == {0}]
            分解(3k+2)型的正整数，必有：[x%3==0]
            分解(3k+1)型的正整数，必有：[y%3==0]
        平方差分解法的增加新模大数零开销的充要条件 = [M=3][N%M==2]
          #平方差分解法的增加新模零开销的必要条件
        !![y**2-x**2=[%M]=(-N)]
        平方差分解法的增加新模小数零开销的充要条件 = [M=3][(-N)%M==2]


  https://rosettacode.org/wiki/Factors_of_a_Mersenne_number
    [d <- all_divisors_of(2**m-1)]
      <==> [(2**m-1)%d==0]
      <==> [2**m%d==1]
      <==> [py.pow(2,m,d)==1]
    [is_prime p][(2**p-1)%d == 0] -> [(d-1)%(2*p)==0][d%8 <- [1,7]]
      #因子 必为 2*k*p+1, 8u+-1
    https://rosettacode.org/wiki/Lucas-Lehmer_test#Python
  divisors of integer of special form 2^k-1
  divisors of Mersenne number
]
列出 m-> 最小系数的 本原不可约多项式
  进一步 可列出 所有 本原不可约多项式
列出 m-> 最小系数的 不可约多项式
找到 [m,1,0]型 不可约多项式 并 判断 本原与否
nn_ns.math_nn.numbers ++已知梅森素数列表
    view ../../python3_src/nn_ns/math_nn/numbers/Mersenne_exponents.py
直接求值比较，得到 无 非本原不可约多项式 的 所有m，看看有哪些不是梅森素数的相应指数/比特数
  e script/gf__find_degrees_of_which_irreducible_polynomial_be_primitive.py
    e ../../python3_src/nn_ns/math_nn/Mobius.py
      factor with hints...
  e script/gf__enumerate_primitive_irreducible_polynomials.py

搜索所有 N,M:
  见上面:『平方差分解法的增加新模大数零开销的充要条件』
  e script/平方差分解法的增加新模零开销的必要条件.py

历程:
  原貌字符串
  字串拟周期 与 总数
  字串总数生成函数囗公式
    多项式除法 无限展开
    view others/数学/递推/一元有理分式-转化为-递推公式.txt
  不知为何 突然转到 模乘法 ??加密??
  有限域 多项式 模乘法 [%p][%f(x)]
  如何 选择 f(x) 使得 模乘法 计算量少？
    [%2]:
      任意 偶项式 [%2] 可约
      只考虑 奇项式:
        三项式 最优，但 很多 次数m 的 三项式 没有 不可约 比如:[m%8==0]
        五项式 猜想 任意 次数m 存在 本原不可约五项式
  判定/随机搜索/枚举 有限域 本原不可约多项式 需要 分解 (p**m-1)
  分解正整数:使用 平方差筛子
  哪些 模/moduli 比较好用/效率高？
xxxxxxx:TODO
e script/gf__find_degrees_of_which_irreducible_polynomial_be_primitive.py
e ../../python3_src/nn_ns/math_nn/Mobius.py
e ../../python3_src/nn_ns/math_nn/factor_pint_into_prime2exp__using_hints.py
e ../../python3_src/nn_ns/math_nn/mk_coprimes.py
e ../../python3_src/nn_ns/math_nn/factor_pint_into_power.py
e ../../python3_src/seed/math/max_power_of_base_as_factor_of_.py
view ../../python3_src/seed/io/savefile/SaveFile.py
cd ~/my_git_py
grep 'in.*file' -r . -l -a
grep 'InFile' -r . -l -a
grep 'SaveFile' -r . -l -a

from seed.io.savefile.SaveFile import SaveFileDict
# path_or_iofile, kwargs
SaveFileDict(path_or_iofile, encoding='u8', allow_create_file=False, allow_write_file=True, allow_write_header=True, kwargs=kwargs)
factor (2^m-1) @[m<-[1..]]
    SaveFileSet
    SaveFileDict
    SaveFileSeq__ObjectPerLine
    SaveFileSeq__TuplePerBlock
unbuffered_growonly_dict_in_file
UnbufferedGrowonlyDictInFile
e ../../python3_src/seed/io/savefile/UnbufferedGrowonlyDictInFile.py
UnbufferedGrowonlyDictInFile(path_or_iofile, encoding='u8', allow_create_file=True, allow_write_file=True, allow_write_header=True, kwargs=kwargs, may_key2default=may_key2default, setitem_by_key2default_only=True)
tabular_cached_calc(path, calc, kwargs_as_description4ofile)
from seed.io.savefile.unbuffered_growonly_dict_in_file import tabular_cached_calc, UnbufferedGrowonlyDictInFile, UnbufferedDictInFile
e script/factor_Mersenne_numbers.py
e ../../python3_src/nn_ns/math_nn/numbers/Mersenne_exponents.py
e ../../python3_src/nn_ns/math_nn/factor_Mersenne_number_into_prime2exp.py

!mv ../../python3_src/seed/io/savefile/UnbufferedGrowonlyDictInFile.py ../../python3_src/seed/io/savefile/unbuffered_growonly_dict_in_file.py
xxxxxxx:TODO

类似 view script/parse_html_of_integer_factor_result_at_factordb_com.py 里的简单dispatch-main
e script/parse_html_of_integer_factor_result_at_factordb_com.py  自动下载 所有素因子p 并递归下载 (p-1)的 整数分解 用于 证明
  factordb.com
    搜索 -> 整数分解 但 大数只显示部分
    内部ID -> 大数 完整数字
  下限阈值？或者 用sympy 分解，但 限定耗时
e ../lots/NOTE/Python/howto/set-timeout-to-kill-thread-or-subprocess.txt
  how python set timeout to kill thread/subprocess?
https://alexandra-zaharia.github.io/posts/kill-subprocess-and-its-children-on-timeout-python/
e ../lots/NOTE/Python/howto/set-timeout-to-kill-thread-or-subprocess.txt

[[
想要递归下载整数分解(factordb.com)用于证明(u->{p:e} then recur (p-1)->{...})，但又不想下载太多，下限阈值？或 使用sympy分解，并 限制时长(timeout?)
help(sympy.factorint)
- ``use_trial``: Toggle use of trial division
- ``use_rho``: Toggle use of Pollard's rho method
- ``use_pm1``: Toggle use of Pollard's p-1 method

Algorithm:
    The function switches between multiple algorithms. Trial division quickly finds small factors (of the order 1-5 digits)
    , and finds all large factors if given enough time. The Pollard rho and p-1 algorithms are used to find large factors ahead of time
    ; they will often find factors of the order of 10 digits within a few seconds:
>>> (10**10).bit_length()
34
>>> (10**11).bit_length()
37
要不，直接 设置 下限阈值=10**10 得了；timeout 太麻烦


]]

e ../../python3_src/nn_ns/math_nn/factor_pint__via_cached_certificated_pint2prime2exp.py
  Pratt Certificate
  The Pratt certificate is a primality certificate based on Fermat's little theorem converse.
  e script/parse_html_of_integer_factor_result_at_factordb_com.py
    部分分解！(2**710-1)分解证书 无法完成。失败！

view others/数学/整数分解/factorint.txt
  e others/数学/p_adic_integer_ring.txt


[%N] 互素基:
  [is_coprime_basis_of N s =[def]= [s |<=| all_coprimes_of N][{II~ a**f(a) ~{a<-s} %N | [@f :: s->[1..]]}==all_coprimes_of(N)]]
  极小互素基
  [is_min_coprime_basis_of N s =[def]= [is_coprime_basis_of N s][@[a<-s] -> [not$ is_coprime_basis_of N $ s\-\{a}]]]
  [len(all_coprimes_of N) == phi(N)]
  [N==9]:
    phi(9)=2*3=6
    {2:[2,4,8,7,5,1]}
  [N==15]:
    phi(15)=2*4=8
    {2:[2,4,8,1], 7:[7,4,13,1][14,11]}
  [N==12]:
    phi(12)=2*2=4
    {5:[5,1], 7:[7,1][11]}
  [N==4]:
    phi(4)=2
    {3:[3,1]}
  [N==8]:
    phi(8)=2**2=4
    {3:[3,1], 5:[5,1][7]}
  [N==16]:
    phi(16)=2**3=8
    {3:[3,9,11,1], 5:[5,9,13,1][15,7]}

  如何找到(min_coprime_basis_of N):
    N的 不同素因子的个数
    2-power (2**e>=8) 只有2个本原根？
    p-power (p>=3) 只有1个本原根？
    p-power的本原根的阶 之间的 gcd关系


e script/primality_test.py
    wget 'https://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866102-2/S0025-5718-1987-0866102-2.pdf' -O 'Implementation of a New Primality Test(1987)(Cohen).pdf'


]]
]]]
]]]]]
]]]]]]]



TODO:generating function ~ 有理分式 ~ 展开式 ~ 多项式 除法 ...
  view others/数学/递推/一元有理分式-转化为-递推公式.txt




e others/数学/编程/永恒代码/原貌字符串.txt
e ../lots/NOTE/pseudo_period_of_word/note4pseudo_period_of_word.txt
e script/bifix.py
e ../../python3_src/seed/text/unicode/group_chars_by_block_and_general_category.py
  移位加密 - 路径名
    只针对字母，不加密符号。。。
  同一编码区，同一gc，的 相邻字符 组成一个 移动块。
e ../../python3_src/seed/algo/closure.py

e others/app/termux/setup4realme/termux-setup.txt
  Android 打开本地网页
  欧路词典 ...
  www.eudic.net 安卓版 完整词典 -> 手机 eudb_en
./0未整理复制粘贴文本/6未整理复制粘贴文本.txt
    链接: https://pan.baidu.com/s/1ugzkQCVv8PrHL4601AvMaw
    密码: 1me4
.../txt_phone/txt $ ls -1hs ~/20220614_copy5sd__0my_files/unzip/eudb_en/
total 159M
 79M 1317108648.eudb
 23M 1522017926.eudb
172K 1922908499.eudb
 19M 20017.eudb
 11M 315772229.eudb
4.2M 375916128.eudb
 25M 99569493.eudb
view script/欧路词典.py
cd /sdcard/20220614_copy5sd__0my_files/unzip/eudb_en/
.../unzip/eudb_en $ for i in $(ls) ; do echo $i ; py $my_txt/script/欧路词典.py readline    -b 1046   -n '"@"'    -i  $i ; done
1317108648.eudb
1046 '汉语大辞典'
1522017926.eudb
1046 '新世纪汉英科技大词典'
1922908499.eudb
1046 '计算机词汇'
20017.eudb
1046 'r'
315772229.eudb
1046 '中华成语大词典'
375916128.eudb
1046 '现代汉语词典'
99569493.eudb
1046 '新世纪英汉科技大词典'
.../unzip/eudb_en $

  [[
.../txt_phone/txt $ grep '欧路' -r . -l
./TODO.txt
./TODO2.txt
./TODO3[20220407].txt
./0未整理复制粘贴文本/6未整理复制粘贴文本.txt
./others/app/app.txt
./others/app/app_data_path.txt
./others/app/手机卡顿.txt
./others/app/手机自动关机重启掉电卡顿.txt
./others/app/termux/setup4realme/termux-setup.txt
./others/app/usage/some_app_usage.txt
./script/info_tri_planar_graphs.py
./script/欧路词典.py
./.TODO.txt.swp
.../txt_phone/txt $ grep 'eudb_en' -r . -l
./TODO2.txt
./0未整理复制粘贴文本/6未整理复制粘贴文本.txt
./others/app/app_data_path.txt
./others/app/termux/setup4realme/termux-setup.txt
./script/欧路词典.py
.../txt_phone/txt $
.../txt_phone/txt $ grep '新世纪' -r . -l
./script/欧路词典.py
  ]]

查 话费余额/清单
  『详单查询』
    https://gd.189.cn/TS/new/login.html?loginOldUri=/TS/myhome/query/xiangdan_chaxun.html#/?cmpid=cpb-fwdt-cx-ylcx-xdcx
    短信 0.1元/条

view others/数学/编程/python/Python_interpreter--CPython.txt



ops = type_ctor+tmpl_args
ops+obj hash
  ops.mk_hash_wrapper
  ops.hash
  ops.eq
  obj {cache {ops:(hash, weakref<hash_wrapper>}}
bind ops+obj
bind ops+ctx
  ops 有 语境
  interpreter也有自己的语境
  help==>>语境关键词 深度收集 #并支持类似的 深度收集 框架，向前兼容
bind ops+ctx+obj
  ops immutable
  ctx mutable?
  obj opaque
public symbol
  get('pkg.mod', 'attr....get_tmay_descript', spec--hashable--repr-literal_eval_able)->public symbol
    if cache:
      raise or return sym
    import pkg...mod as M
    tm = M.attr...get_tmay_descript(spec)
    if not tm:
      set cache err
    else:
      mk new public symbol
      set cache sym
    recur...
DONE:
  page_rank 添加一个 虚拟节点，与其他节点 双向 连通所有节点，保证 有进有出 动态平衡存在，重点是 没有 不连通分量，有向图强连通分量唯一，保证 解唯一，虚拟点 不 参与 概率分配。

view ../../python3_src/seed/algo/page_rank.py
    mk_pseudo_mapping_opss
    之前肯定有！重构代码！！
view ../../python3_src/nn_ns/app/crypt/involution/InvolutoryCipher.py
  from seed.seq_tools.seq_as_mapping import SeqAsMapping
  from seed.mapping_tools.mapping_as_seq import MappingAsSeq
TODO:
  不允许嵌套但允许内嵌原貌字符串的通用单点转义方案
  e ../../python3_src/自己的相关数据/on_working.txt
  e ../../python3_src/seed/seq_tools/escape_schemes/universal_single_point_escape_scheme__enable_raw_text__disable_recur.py
TODO:备份:浏览器收藏；阅读APP记录；当前编辑中未完成的代码文件
  ===编辑中的代码:
  e ../../python3_src/seed/seq_tools/lsls52ls.py
      bisearch 替代数组
  e ../../python3_src/seed/math/matrix/solve_matrix.py
    线性规划/不等式组/凸包切割
  e ../../python3_src/nn_ns/app/crypt/involution/InvolutoryCipher.py
    填充...
  e ../../python3_src/seed/seq_tools/escape_schemes/universal_single_point_escape_scheme__enable_raw_text__disable_recur.py
    结束串 合格判定
  ===论文:下载地址
  e /sdcard/0my_files/book/math/linear_programming/
    --> 复制到:view others/book/linear_programming.txt
  ===阅读APP
  view /storage/emulated/0/0my_files/tmp/xxx/阅读app备份json/\[20211017]阅读app备份json/myBookShelf.json
  view others/app/备份app配置信息/阅读app备份json-delta\[20220315]\[20211017].zip
  view others/app/备份app配置信息/阅读app备份json-delta\[20220604]\[20220315].zip
  ===备份:公历农历节气对照表？
  view /sdcard/0my_files/tmp/out4py/农历/农历.py.打印公历农历日期对照表.out.txt
    view script/农历/农历.py.打印公历农历日期对照表.out.txt.zip
      已备份！
  ===备份:知轩藏书-小说列表自建页面？
  !mv /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/saved_sortss/sorts\[20220420]/zxcs-sorts-37-39-42[20220420].zip script/download_zxcs_novel/zips/
  view script/download_zxcs_novel/merge_link_iinfos_and_scores.py
  view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/saved_sortss/sorts\[20220420]/42.scored.html
    xxx view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.scored.html
    xxx file:///sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.scored.html
  === org.mozilla.firefox如何导出导入收藏夹？
  [[
https://android.stackexchange.com/questions/171240/export-firefox-for-android-bookmarks-to-html-file
As of 2019, Firefox for Android has no built-in support for exporting bookmarks. However there are some workarounds/alternatives: According to the "Chosen Solution" on the Firefox Support Forum, use Firefox Sync for Android to transparently move bookmarks across devices.
  好恶心！有一不干人事的蠢货！
  ]]
[[2022手机价格
[
https://zhuanlan.zhihu.com/p/429282569
realmeQ3s

    处理器：骁龙778G
    屏幕：6.6英寸，LCD，144Hz
    摄像头：4800w主摄+黑白镜头+微距镜头

realme 真我Q3s 骁龙778G 5G 144Hz变帧屏 5000mAh大
京东
¥1199.00
去购买

优点：

    搭载骁龙778G处理器，在高分辨率下玩王者荣耀，半小时平均帧数是47帧，有时候打团会降到35帧左右，千元机主流表现水平。续航能力好，5000mAh的大电池容量，玩一个小时的游戏耗电15%左右，不玩游戏可以撑一整天，没有续航焦虑。电量完全充满需要65分钟。屏幕是LCD屏，支持144hz的高刷新率，支持7档智能变帧，但是由于应用适配问题，使用起来会有割裂感，建议全局144hz。

缺点：使用转子马达。
]
[
https://zhuanlan.zhihu.com/p/95806258
[
Redmi Note 11 4G（综合产品力最强4G百元机）
Redmi Note 11 4G 4GB+128GB 梦幻晴空
京东
¥969.00
去购买​

推荐指数：⭐️⭐️⭐️⭐️⭐️

优势：

    外观设计、机身轻薄，配色挺漂亮；Helio G88处理器，同价位性能很不错；90Hz三档变速刷新率屏幕，在百元机中比较少见；5000万像素三摄，超广角、微距等拍照功能较全面；支持红外遥控、立体声双扬声器；支持18W有线快充，标配22.5W充电器；5000mAh超大容量电池带来长续航；

不足：

    采用eMMC5.1闪存规格；

点评：

Redmi Note 11 4G是当前小米旗下1000元以内综合产品力最强的一款4G入门机。

与另外几款入门级4G手机相比，Redmi Note 11 4G不仅拥有性能更强的处理器、90Hz刷新率屏幕，而且在具备5000mAh大电池的基础上拥有比较轻薄的机身，181g的机身重量在千元机中手感很不错。

另外，Redmi Note 11 4G的外观设计做得很不错，晴空、白色、黑色三款配色在百元机中都比较出彩，是当前非常值得入手的一款产品。
]
[

Redmi Note11 SE（综合产品力最强的5G百元机）
Redmi Note11SE 4GB+128GB 暗影黑
京东
¥1099
去购买​
【定金100抵200 享6重好礼】红米Note 11 SE
天猫
¥999.00
去购买​

推荐指数：⭐️⭐️⭐️⭐️⭐️

优势：

    天玑700，百元机中性能好；90Hz四档变速刷新率，触控流畅；5000mAh大电池带来长续航；

不足：

    同价位无明显不足；

点评：

Redmi Note11 SE本质上是Redmi Note 10 5G这款千元机的套娃机。

Redmi Note 10 5G虽然是Redmi Note 9 5G的迭代机型，但是除了屏幕刷新率升级到90Hz和机身更轻薄以外，在处理器性能、相机、扬声器等方面其实是缩水的，综合产品力不如Redmi Note 9 5G。尤其在Redmi Note 11 5G发布之后，产品力更是相对偏弱，在1000-1500价位竞争力比较一般。

所以，小米将Redmi Note 10 5G换了个壳、改个名字、降低了100块钱售价就成了Redmi Note11 SE。

那么降价之后的Redmi Note11 SE顿时就成为1000元以内性能最强的小米机型，瞬间变得值得选购了。

在999元价位，Redmi Note11 SE拥有天玑700处理器、1080p高刷屏幕、18W快充、5000mAh大电池以及相对轻薄的机身，是一款性价比颇高的5G入门级手机。

不过只建议选购4GB+128GB版本，因为8GB+128GB版本同价位竞争力一般。

]
[
realme Q3s（1500以内价位性能最强的手机）
realme Q3s 8+128GB 星云色
京东
¥1419
去购买​

推荐指数：⭐️⭐️⭐️⭐️⭐️

优势：

    星光纹理设计，外观比较漂亮；高通骁龙778G处理器，同价位性能最强；7档144Hz智能变速刷新率屏幕，兼顾屏幕流畅与低功耗；电竞级VC液冷散热系统，同价位散热不错；30W有线快充，同价位充电速度较快；5000mAh大电池带来长续航；

不足：

    塑料机身；不支持NFC；后置相机缺乏超广角镜头；

点评：

原本realme Q3就是1500-2000价位产品力最强的机型之一，如今升级到realme Q3s之后产品力更上一层楼。

相对于realme Q3，relame Q3s主要升级了三点：

    处理器升级，从高通骁龙750G升级为高通骁龙778G，后者这款处理器常见于1500-2000价位机型；屏幕升级，120Hz高刷屏升级为144Hz变速高刷屏；手感升级，机身厚度从8.8mm降为8.5mm，手感更好一些。

总体来说，realme Q3s不仅是一款性能超强的机型，而且是屏幕、续航、外观兼顾的产品，在1000-1500价位非常值得选购。
]
]
]]
[[[[[
TODO:线性不等式组 解方程。。。
  solve linear inequality algorithm source code
  linear programming线性规划
    我的算法:切割凸包
      face_idx->ordered[vertex]
        {face:{vtx:vtx}}
          仅限于？三维？
      vertex_idx->ordered[face_idx]
        {vtx:{face:face}}
      vertex_idx->point/coor
      #vertex_idx->ordered[edge_idx]
      #edge_idx -> {vertex_idx, vertex_idx}
      E+2=V+F
      F:切面数
      M:不等式的数目
      N:变量囗数目(标准/非负)
      F <= M
      V0 = 原点+各维无穷原点=1+N
      V <= V0 -1+N
    另:证明无解:
      等式方程组:
        行的线性组合 得 左零=右非零
      不等式组:
        大于等于零行*正系数+小于等于零的行*负系数 < 0
[[我的算法:切割凸包
自造词:单锥simplex(k+1个端点的k-convex_hull), 延伸空间span_space, 次平面hyperplane(比主空间低一维的延伸空间), 主空间space(相对于hyperplane而言, RR**d), facet次切面(k-convex_hull的低一维外表面, 是(k-1)-convex_hull)
凸包convex_hull
  m-vertices
  k-convex_hull k维凸包，即 m个端点的延伸空间 k维
  d维 实数 主空间, d>=k
k-simplex共有k+1个端点/0-face，k+1个facet/(k-1)-face, C(k+1,k-i)个 i-face
  i-face 是 i-convex_hull
  k-simplex 的 i-face 是 i-simplex
k-convex_hull的k个共点facet的交点是 端点
k-convex_hull的k-1个共边facet的交边是 棱边


* [d>k]:
  如果d>k,则 重立坐标系，令d'=k
* [d==k]:
  记录 当前凸包 的 以下信息:
    vtc = 所有端点
    edges = 所有棱边
    facets = 所有次切面
    edge2vtc = 棱边的所有端点#==2#棱边的表达
    facet2法向量 = facet2linear_equality = 次切面的表达#(d+1)个系数, 坐标向量变量=d个实数变量
    facet2inequality_signs # 标准化系数，防重复，重复时 不等号 可能不同，多个并存
    vtc2point = 端点的坐标#端点的表达#坐标向量=d个实数

    facet2vtc = 次切面的所有端点#>=k
    vtx2facets = 端点的所有次切面#==k
    vtx2edges = 端点的所有棱边#>=k
    edge2facets = 棱边的所有次切面#==k-1
  ##约束:==大概率降维;</>/<=/>=大概率不降维;!=无影响
  #以下不考虑==,!=
  TODO:
  次平面 是否 重复？
    若已出现过，则 考虑 约束/不等号 是否 更改，更新 信息
  次平面 切割 凸包 所得 新凸包:
    + 新增端点 为 次平面 与 旧棱边的交点
      通过 判断 棱边的两个端点 关于 次平面 线性函数的求值结果 的 正负符号 是否 相反(零 再说)
        [次平面上的向量 * 法向量 == 0]
        [次平面上的点 * 法向量 == 常量K]
        [这里假设 所有不等式 都是『>=』]
        则[保留的旧端点 * 法向量 >= 常量K]
        则[删除的旧端点 * 法向量 < 常量K]
    + 新增棱边 为 次平面上的棱边
      穷举C(新增端点数,2) 再 判断 此两端点u,v的连线是否是 棱边:
        棱边 是 至少(k-1)个 次切面 的 共线
        所以 len(vtx2facets[v]/-\vtx2facets[u])>=k-1
    - 删除旧端点(<0)
    + 更新旧端点(==0) vtx2facets[v]+=curr_facet
    - 删除旧棱边(两端点均被删;<0) #只要有一个端点不被删，即保留
    - 更新旧棱边(相交==>>端点改变)

]]
[[凸包
  D = 空间维数
  点 :: [Real]{len=D}
  M = len(点集)
  N = len(凸包端点集)
  ====
  难题零 任意非唯一拆分凸包为单锥: 凸包端点集 -> {单锥端点集} #结果非唯一
    m-vertices k-convex_hull -> {k-simplex}{len=m-k}
  ====
  ### 难题一 求凸包端点集: 点集 -> 凸包端点集
  难题一 求凸包端点集: 点集 -> (凸包端点到分割面系数, 点到凸组合系数)
    [凸包端点集 <= 点集]
    [@点 <- 点集\-\凸包端点集. [难题二(点,凸包端点集)===Right _]]
    [@点 <- 凸包端点集. [难题二(点,凸包端点集\-\{点})===Left _]]
  ====
  难题二 内外判定证明: 点 -> 凸包端点集 -> Either 分割面系数<D> 凸组合系数<N>
    分割面系数 :: [Real%1]{len=D}
      @凸包端点. [内积(凸包端点 - 点, 分割面系数) > 0]
    凸组合系数 :: [Real]{len=N}
      ## 凸组合 = 凸组合(凸组合系数, sorted(凸包端点集)) =[def]= 矩阵(sorted(凸包端点集))*向量(凸组合系数)
      [凸组合 === 点][sum 凸组合系数 === 1][min 凸组合系数 >= 0]
      ###需要 线性规划？
      #分割面系数 <<== [X:slack] X.>0 && A*X.>b 无目标函数，只求任意解
      #     改求 距离, 最短距离？找出 由凸包外的点 指向 凸包上距其最近的点 的 这条射线，则 凸包任意点 在此射线上的投影 只能 处于 最近点 外侧
      #     分解为 多个 k-simplex
      #         ??找出 facet 再求 最近点??
      #         见下面:计算点到单锥距离的最近点
      #     xxx 二次方程？奇异矩阵？偏导？
      #凸组合系数 <<== [X==凸组合系数] X.>=0 && A'*X==b' <<== X.>0 && A''*X.>b'' 无目标函数，只求任意解
      #     可以 将 k-convex_hull<N> 分割成 (N-k)个 k-simplex
      #     simplex 生成空间内部点 线性组合 解 唯一(判断 唯一的 线性组合系数 是否为 凸组合系数 容易)，生成空间外部点 无解
  ====
  问题三 两端点是否相邻: 两端点->凸包端点集->Either (端点,凸组合系数<N-1>) 分割面系数<D>
    输出-端点 <- 输入-两端点 |<=| 凸包端点集
    凸组合系数<N-1> 用于组合除了 输出-端点  的其余端点，结果为 输入-两端点 的 中点
    分割面系数<D> 分隔 输入-两端点 与 其余端点
    ###即：判断 输入-两端点 的 中点 是否在 凸包内部 <==> 中点 是否在 (凸包\-\输入两端点其一)内部

]]
[[
face? 各维切面？
simplex? 多维三角单锥体？
  k-simplex in RR**d, -1<=k<=d
    d维实数欧几里得空间
  k-simplex <- convex k-polytype
  k-simplex is a k-polytype formed by the convex hull of (k+1) points in RR**d, d>=k
  ===
  number of i-faces of k-simplex is C(k+1,k-i)===C(k+1, i+1)
    ##i.e. choose (k-i) from total (k+1) facets
    #   i-face is intersection of (k-i) facets
    #   i-face is i-simplex
    #   all faces form a lattice
    #
    1 k-face is the k-simplex itself
    1 -1-face is the empty set of vertex
    k+1 (k-1)-faces/facets
    k+1 0-faces/vertices
    C(k+1,2) (k-2)-faces/ridges
    C(k+1,2) 1-faces/edges
standard perturbation techniques?
  the line L through the origin spanned by a is an admissible shelling line for P. This assumption is justified since admissibility of the shelling line can be simulated using standard perturbation techniques.


k-simplex 的 (k+1)个facet 将 k维空间 分割成 (2**(k+1)-1) 个 块。假设块内的点 可以 见到 i个facet(不被其他facet挡住)，则 这样的块共有C(k+1,i)个，i<-[1..=k+1]; i=/=0; i===k+1时，唯一的块即是k-simplex的内部
计算点到单锥距离的最近点
  #自造词:单锥simplex, 次平面hyperplane
  外部点u到k-simplex的距离的计算:
    * [k==0]:
        点到点的距离，直接计算
    * [k>0]:
      * [u不在 k-simplex的延伸空间内]:
        求点z，分解uv为 两个正交分量: uz, zv
          [uz+zv=uv]
            令 uz=uv-zv
          [@x<-f端点集. [xv*uz=0=xv*(uv-zv)]] #正交
            d new vars, k new equalities
            d >= k, 是 点坐标系统的维数
          [?C::mx<k,1>. [(x-v) | x<-f端点集]*C == zv] #共面
            k new vars, d new equalities
          ==>> (d+k)vars, (d+k) equalities
        [uz 是否为 零向量] 决定 [u在不在 k-simplex的延伸空间内]
        问题转化为 [z到k-simplex的距离 且 z在k-simplex的延伸空间内]

      * [u在 k-simplex的延伸空间内]:
        从k-simplex的(k+1)个端点中排除一个v，由剩下的k个端点确定一个facet, f.
        判断 u,v,f的位置关系:
          * u在f的延伸空间内
          * f对于u可见，即 线段uv 穿过f的延伸空间
          * f对于u不可见，即 线段uv 不穿过f的延伸空间
          ###如何计算？
            以v为原点，以f的k个端点为 单位长度的轴向量，构建坐标系统，得到 k维空间RR**k
            f的延伸空间 是 新空间内 的 次平面(？自造词)，由于 端点 坐标 是 echo_mx<k,k>[:,i]，f的延伸空间 可表达为 [k-sum x[i] {i<-[1..=k]}===0]
                !!次平面 总是将 空间(仅高出次平面1维) 分成3部分: [===0],[>0],[<0]
            记 lhs<X> = k-sum x[i] {i<-[1..=k]}
            [f的延伸空间 === {X | [lhs<X>===0]}]
            [lhs<v> > 0]
            根据lhs<u>与0的大小关系，可知u,v,f的位置关系

        如果『u在f的延伸空间内』，则 这样的 f只有一个，问题转化为 u 到 (k-1)-simplex f 的距离计算(降维)
        否则 问题转化为 u到 所有对于u可见的f的交集『某一维face』(即 排除所有相应的端点v) 的 距离，假设 可见的f共有w个，w<-[1..=k],则 该face(not facet)是一个(k-w)-simplex (必定降维，可能一步到位直接成端点)
]]
[[[
[[
https://www.researchgate.net/publication/258121773_A_Simple_Algorithm_for_Convex_Hull_Determination_in_High_Dimensions
    Algorithm: Determining an approximation convex hull based on a user defined threshold
    近似算法 无用

[4] V. Bayer, “Survey of Algorithms for the Convex Hull Problem”, Department of Computer Science, Oregon State University, 1999.
]]
[[
n**(d/2)
  n - num_vertices
  d - num_dimensios
https://libgen.lc/edition.php?id=13339536
  https://link.springer.com/article/10.1007/BF02573985
    An optimal convex hull algorithm in any fixed dimension (1993)(Chazelle)[nlogn+n^(d//2)].pdf
ls /sdcard/Download/Chazelle1993_Article_AnOptimalConvexHullAlgorithmIn.pdf
!mv /sdcard/Download/Chazelle1993_Article_AnOptimalConvexHullAlgorithmIn.pdf  '/sdcard/0my_files/book/math/linear_programming/An optimal convex hull algorithm in any fixed dimension (1993)(Chazelle)[nlogn+n^floor_half(d)].pdf'
view /sdcard/0my_files/book/math/linear_programming/An optimal convex hull algorithm in any fixed dimension (1993)(Chazelle)[nlogn+n^floor_half(d)].pdf
  20. Seidel, R. Constructing higher-dimensional convex hulls at logarithmic cost per face, Proc. 18th Annual ACM Syrup. on Theory of Computing, 1986, pp. 404-413.
    https://doi.org/10.1145/12130.12172
      https://dl.acm.org/doi/10.1145/12130.12172
        https://dl.acm.org/doi/pdf/10.1145/12130.12172

!mv /sdcard/Download/12130.12172.pdf  '/sdcard/0my_files/book/math/linear_programming/Constructing higher-dimensional convex hulls at logarithmic cost per face (1986)(Seidel)[m^2+Flogm].pdf'
  very good!
  很多清晰的基础的定义与基础事实
]]
[[
http://www.math.louisville.edu/~ewa/m107/chapter5.pdf
  good!!!
!mkdir /sdcard/0my_files/book/math/linear_programming/
!mv /sdcard/Download/chapter5.pdf  /sdcard/0my_files/book/math/linear_programming/[LP]linear_programming[Simplex-Method][Big-M-Method].pdf
view /sdcard/0my_files/book/math/linear_programming/[LP]linear_programming[Simplex-Method][Big-M-Method].pdf

[
The Simplex Method:
  Maximization with < constraints
  The Simplex Tableau
  When are we finished? ！！流程图！！
  [[
[!Start!] Write standard max problem in standard form ; Initial Simplex Tableau
  -> <?end1?>
<?end1?> negative indicators?
  No -> [Stop! Optimal solution]
  Yes -> [!select pivot column!]
          -> <?end2?>
<?end2?> positive elements in pivot column?
  No -> [Stop! No solution]
  Yes -> [!Select pivot perform pivot operation!]
          -> <?end1?>
  ]]

The Dual Problem
  Minimization with >= Constraints
Mixed Problems
  The Big M Method
  Modified Problem
  Big M, slack, surplus, artificial variables
  Minimization using Big M

]
[
SUMMARY
(Type, Constraints, Right side constants, coeff. of objective function, Solution method)

(Max, <, nonnegative, any, Simplex + slack)
(Min, >, any, nonnegative, dual + above)
(Max, Mixed (<,>,=), nonnegative, any,,modified with slack+surplus+artificial)
(Min, Mixed (<,>,=), nonnegative, any, Max negative of objective)
]
]]
]]]
[[[
[[
https://www.geeksforgeeks.org/simplex-algorithm-tabular-method/

Simplex Algorithm – Tabular Method

    Difficulty Level : Expert
    Last Updated : 16 May, 2020

Simplex Algorithm is a well-known optimization technique in Linear Programming.
The general form of an LPP (Linear Programming Problem) is
Max/Min Z = c^tX s.t. AX \leq b X \geq 0

Example: Let’s consider the following maximization problem.
Max x_1 + x_2 s.t. x_1 + x_2 + x4 = 8 2x_1 + x_2 + x_3 = 10
Initial construction steps :

    Build your matrix A. A will contain the coefficients of the constraints.
    Matrix b will contain the amount of resources.
    And matrix c will contain the coefficients of objective function or cost.

For the above problem –
Matrix A – At Iteration 0

At Iteration 0

Explanation of table-
B : Basis and contains the basic variables. Simplex algorithm starts with those variables which form an indentity matrix. In the above eg x4 and x3 forms a 2×2 identity matrix.
CB : Its the coefficients of the basic variables in the objective function. The objective functions doesn’t contain x4 and x3, so these are 0.
XB : The number of resources or we can say the RHS of the constraints.
yi : The complete Matrix A.

Simplex Algorithm
1. Start with the initial basis associated with identity matrix.
2. Calculate the relative profits.

For MAX problem-
If all the relative profits are less than or equal to 0, then the current basis is the optimal one. STOP.
Else continue to 3.

For MIN problem
If all the relative profits are greater than or equal to 0, then the current basis is the optimal one. STOP.
Else continue to 3.

3. Find the column corresponding to max relative profit. Say column k has the max
Rel. profit. So xk will enter the basis.

4. Perform a min ratio test to determine which variable will leave the basis.
    min ratio test:  XBr/y_{rk} = min\{XB_i/y_{ik}\}
Index of the min element i.e 'r' will determine the leaving variable.
The basic variable at index r, will leave the basis.
NOTE: Min ratio test is always performed on positive elements.

5. It's evident that the entered variable will not form an identity matrix, so
we will have to perform row operations to make it identity again.
Find the pivot element. The element at index (r, k) will be the pivot element and
row r will be the pivot row.

6. Divide the rth row by pivot to make it 1. And subtract c*(rth row) from other
rows to make them 0, where c is the coefficient required to make that row 0.

Table at Iteration 1

Table at iteration 1

Calculation of relative profits – (Cj – Zj), where Cj is the coefficient in Z and Zj is yi*CB
C1 – Z1 = 1 – (1*0 + 2*0)
C2 – Z2 = 1 – (1*0 + 1*0)
C3 – Z3 = 0 – (0*0 + 1*0)
C4 – Z4 = 0 – (1*0 + 0*0)

So Relative profits are- 1, 1, 0, 0 (As shown in the table)
Clearly not all the relative profits are less or equal to 0. So will perform the next iteration.
Determination of entering variable and leaving variable.
Max relative profit 1 at index 1. So x1 will enter the basis.
min ratio test: XBr/y_{rk} = min\{8/1, 10/2\}
Min of (8, 5) is 5 which is at index 2. So x3 will leave the basis.

Since x1 entered perform required row operations to make an identity matrix.

Pivot index = [2, 4]
Pivot element = 2

Divide the 2nd row by pivot element i.e 2 to make it 1.
And subtract 1*R2 from R1 to make it 0
See the next table.

Table At Iteration 2

Table at iteration 2

Relative profits = 0, 1/2, -1/2, 0
Pivot index = [1, 5]
Pivot element = 1/2
Perform necessary row operations.
See next table

Table At iteration 3

Relative profits = 0, 0, 0, -1
Since all relative profits are less than or equal to 0. So optimality is reached.
This will be the final simplex table and the optimal one.
Value of Z at optimality = 6*1 + 2*1 = 8

Following cases can occur while performing this algorithm.

    Case 1 – Unbounded Solution
    If the column corresponding to the max relative profit contains only non-positive real numbers then we won’t be able to perform the min ratio test. Therefore it is reported as unbounded solution.
    Case 2 – Alternate Solution
    If at any iteration any one of the non-basic variable’s relative profit comes out to be 0, then it contains alternate solutions. Many optimal solutions will exist.

Example 2
The above example was an equality case where we were able to find the initial basis. Now we will perform simplex on an example where there is no identity forming.
MAX 2x_1 + 5x_2 s.t. x_1 + x_2 \leq 6 x_2 \leq 3 x_1 + 2x_2 \leq 9
Convert the above problem into standard form i.e
MAX 2x_1 + 5x_2 s.t. x_1 + x_2 + x_3 = 6 x_2 + x_4 = 3 x_1 + 2x_2 + x_5 = 9
where x3, x4 and x5 are slack variables. These will form identity and hence the initial basis.
Table at Iteration 0

Table at iteration 0

Now continuing as the previous example.
Table at iteration 1

Table at iteration 1

Relative profits = 2, 5, 0, 0, 0
Pivot Index = [2, 5]
Pivot element = 1

Table at Iteration 2

Table at iteration 2

Relative Profits = 2, 0, 0, -5, 0
Pivot Index = [1, 4]
Pivot Element = 1

Table at iteration 3

Table at iteration 3

Relative profits = 0, 0, 0, -2, -3, 0
Since all relative profits are less than equal to 0. Optimality is reached.
This is the final simplex table and the optimal one.
Value of Z at optimality = 3*2 + 3*5 + 0*0 = 21

Code Implementation of Simplex Algorithm
import numpy as np
from fractions import Fraction # so that numbers are not displayed in decimal.

print("\n                 ****SiMplex Algorithm ****\n\n")

# inputs

# A will contain the coefficients of the constraints
A = np.array([[1, 1, 0, 1], [2, 1, 1, 0]])
# b will contain the amount of resources
b = np.array([8, 10])
# c will contain coefficients of objective function Z
c = np.array([1, 1, 0, 0])

# B will contain the basic variables that make identity matrix
cb = np.array(c[3])
B = np.array([[3], [2]])
 # cb contains their corresponding coefficients in Z
cb = np.vstack((cb, c[2]))
xb = np.transpose([b])
# combine matrices B and cb
table = np.hstack((B, cb))
table = np.hstack((table, xb))
# combine matrices B, cb and xb
# finally combine matrix A to form the complete simplex table
table = np.hstack((table, A))
# change the type of table to float
table = np.array(table, dtype ='float')
# inputs end

# if min problem, make this var 1
MIN = 0

print("Table at itr = 0")
print("B \tCB \tXB \ty1 \ty2 \ty3 \ty4")
for row in table:
    for el in row:
                # limit the denominator under 100
        print(Fraction(str(el)).limit_denominator(100), end ='\t')
    print()
print()
print("Simplex Working....")

# when optimality reached it will be made 1
reached = 0
itr = 1
unbounded = 0
alternate = 0

while reached == 0:

    print("Iteration: ", end =' ')
    print(itr)
    print("B \tCB \tXB \ty1 \ty2 \ty3 \ty4")
    for row in table:
        for el in row:
            print(Fraction(str(el)).limit_denominator(100), end ='\t')
        print()

    # calculate Relative profits-> cj - zj for non-basics
    i = 0
    rel_prof = []
    while i<len(A[0]):
        rel_prof.append(c[i] - np.sum(table[:, 1]*table[:, 3 + i]))
        i = i + 1

    print("rel profit: ", end =" ")
    for profit in rel_prof:
        print(Fraction(str(profit)).limit_denominator(100), end =", ")
    print()
    i = 0

    b_var = table[:, 0]
    # checking for alternate solution
    while i<len(A[0]):
        j = 0
        present = 0
        while j<len(b_var):
            if int(b_var[j]) == i:
                present = 1
                break;
            j+= 1
        if present == 0:
            if rel_prof[i] == 0:
                alternate = 1
                print("Case of Alternate found")
                # print(i, end =" ")
        i+= 1
    print()
    flag = 0
    for profit in rel_prof:
        if profit>0:
            flag = 1
            break
        # if all relative profits <= 0
    if flag == 0:
        print("All profits are <= 0, optimality reached")
        reached = 1
        break

    # kth var will enter the basis
    k = rel_prof.index(max(rel_prof))
    min = 99999
    i = 0;
    r = -1
    # min ratio test (only positive values)
    while i<len(table):
        if (table[:, 2][i]>0 and table[:, 3 + k][i]>0):
            val = table[:, 2][i]/table[:, 3 + k][i]
            if val<min:
                min = val
                r = i     # leaving variable
        i+= 1

        # if no min ratio test was performed
    if r ==-1:
        unbounded = 1
        print("Case of Unbounded")
        break

    print("pivot element index:", end =' ')
    print(np.array([r, 3 + k]))

    pivot = table[r][3 + k]
    print("pivot element: ", end =" ")
    print(Fraction(pivot).limit_denominator(100))

        # perform row operations
    # divide the pivot row with the pivot element
    table[r, 2:len(table[0])] = table[
            r, 2:len(table[0])] / pivot

    # do row operation on other rows
    i = 0
    while i<len(table):
        if i != r:
            table[i, 2:len(table[0])] = table[i,
                 2:len(table[0])] - table[i][3 + k] *
                 table[r, 2:len(table[0])]
        i += 1


    # assign the new basic variable
    table[r][0] = k
    table[r][1] = c[k]

    print()
    print()
    itr+= 1


print()

print("***************************************************************")
if unbounded == 1:
    print("UNBOUNDED LPP")
    exit()
if alternate == 1:
    print("ALTERNATE Solution")

print("optimal table:")
print("B \tCB \tXB \ty1 \ty2 \ty3 \ty4")
for row in table:
    for el in row:
        print(Fraction(str(el)).limit_denominator(100), end ='\t')
    print()
print()
print("value of Z at optimality: ", end =" ")

basis = []
i = 0
sum = 0
while i<len(table):
    sum += c[int(table[i][0])]*table[i][2]
    temp = "x"+str(int(table[i][0])+1)
    basis.append(temp)
    i+= 1
# if MIN problem make z negative
if MIN == 1:
    print(-Fraction(str(sum)).limit_denominator(100))
else:
    print(Fraction(str(sum)).limit_denominator(100))
print("Final Basis: ", end =" ")
print(basis)

print("Simplex Finished...")
print()

For the above just plug in the required values and you will get a detailed step by step solution of your LPP by the simplex algorithm.

]]
[[
https://optimization.cbe.cornell.edu/index.php?title=Simplex_algorithm


Simplex algorithm
Jump to navigation
Jump to search

Author: Guoqing Hu (SysEn 6800 Fall 2020)
Contents

    1 Introduction
    2 Algorithmic Discussion
    3 Numerical Example
    4 Application
        4.1 Mathematical Problem
        4.2 Industrial Application
    5 Conclusion
    6 References

Introduction

Simplex algorithm (or Simplex method) is a widely-used algorithm to solve the Linear Programming(LP) optimization problems. The simplex algorithm can be thought of as one of the elementary steps for solving the inequality problem, since many of those will be converted to LP and solved via Simplex algorithm.[1] Simplex algorithm has been proposed by George Dantzig, initiated from the idea of step by step downgrade to one of the vertices on the convex polyhedral.[2] "Simplex" could be possibly referred to as the top vertex on the simplicial cone which is the geometric illustration of the constraints within LP problems.[3]
Algorithmic Discussion

There are two theorems in LP:

    The feasible region for an LP problem is a convex set (Every linear equation's second derivative is 0, implying the monotonicity of the trend). Therefore, if an LP has an optimal solution, there must be an extreme point of the feasible region that is optimal
    For an LP optimization problem, there is only one extreme point of the LP's feasible region regarding every basic feasible solution. Plus, there will be a minimum of one basic feasible solution corresponding to every extreme point in the feasible region.[4]

Geometric Illustration of LP problem

Based on the two theorems above, the geometric illustration of the LP problem could be depicted. Each line of this polyhedral will be the boundary of the LP constraints, in which every vertex will be the extreme points according to the theorem. The simplex method is the way to adjust the nonbasic variables to travel to different vertex till the optimum solution is found.[5]

Consider the following expression as the general linear programming problem standard form:

max ∑ i = 1 n c i x i {\displaystyle \max \sum _{i=1}^{n}c_{i}x_{i}} {\displaystyle \max \sum _{i=1}^{n}c_{i}x_{i}}

With the following constraints:

s . t . ∑ j = 1 n a i j x j ≤ b i i = 1 , 2 , . . . , m x j ≥ 0 j = 1 , 2 , . . . , n {\displaystyle {\begin{aligned}s.t.\quad \sum _{j=1}^{n}a_{ij}x_{j}&\leq b_{i}\quad i=1,2,...,m\\x_{j}&\geq 0\quad j=1,2,...,n\end{aligned}}} {\displaystyle {\begin{aligned}s.t.\quad \sum _{j=1}^{n}a_{ij}x_{j}&\leq b_{i}\quad i=1,2,...,m\\x_{j}&\geq 0\quad j=1,2,...,n\end{aligned}}}

The first step of the simplex method is to add slack variables and symbols which represent the objective functions:

ϕ = ∑ i = 1 n c i x i z i = b i − ∑ j = 1 n a i j x j i = 1 , 2 , . . . , m {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\z_{i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{j}\quad i=1,2,...,m\end{aligned}}} {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\z_{i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{j}\quad i=1,2,...,m\end{aligned}}}

The new introduced slack variables may be confused with the original values. Therefore, it will be convenient to add those slack variables z i {\displaystyle z_{i}} {\displaystyle z_{i}} to the end of the list of x-variables with the following expression:

ϕ = ∑ i = 1 n c i x i x n + i = b i − ∑ j = 1 n a i j x i j i = 1 , 2 , . . . , m {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\x_{n+i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{ij}\quad i=1,2,...,m\end{aligned}}} {\displaystyle {\begin{aligned}\phi &=\sum _{i=1}^{n}c_{i}x_{i}\\x_{n+i}&=b_{i}-\sum _{j=1}^{n}a_{ij}x_{ij}\quad i=1,2,...,m\end{aligned}}}

With the progression of simplex method, the starting dictionary (which is the equations above) switches between the dictionaries in seeking for optimal values. Every dictionary will have m basic variables which form the feasible area, as well as n non-basic variables which compose the objective function. Afterward, the dictionary function will be written in the form of:








              ϕ
              = ϕ ¯ + ∑ j = 1 n c j ¯ x j


              x i
              = b i ¯ − ∑ j = 1 n a i j ¯ x i j i = 1 , 2 , . . . , n + m





    {\displaystyle {\begin{aligned}\phi &={\bar {\phi }}+\sum _{j=1}^{n}{\bar {c_{j}}}x_{j}\\x_{i}&={\bar {b_{i}}}-\sum _{j=1}^{n}{\bar {a_{ij}}}x_{ij}\quad i=1,2,...,n+m\end{aligned}}}

{\displaystyle {\begin{aligned}\phi &={\bar {\phi }}+\sum _{j=1}^{n}{\bar {c_{j}}}x_{j}\\x_{i}&={\bar {b_{i}}}-\sum _{j=1}^{n}{\bar {a_{ij}}}x_{ij}\quad i=1,2,...,n+m\end{aligned}}}

Where the variables with bar suggest that those corresponding values will change accordingly with the progression of the simplex method. The observation could be made that there will specifically one variable goes from non-basic to basic and another acts oppositely. This kind of variable is referred to as the entering variable. Under the goal of increasing ϕ {\displaystyle \phi } {\displaystyle \phi }, the entering variables are selected from the set {1,2,...,n}. As long as there are no repetitive entering variables can be selected, the optimal values will be found. The decision of which entering variable should be selected at first place should be made based on the consideration that there usually are multiple constraints (n>1). For the Simplex algorithm, the coefficient with the least value is preferred since the major objective is maximization.

The leaving variables are defined as which go from basic to non-basic. The reason of their existence is to ensure the non-negativity of those basic variables. Once the entering variables are determined, the corresponding leaving variables will change accordingly from the equation below:

x i = b i ¯ − a i k ¯ x k i ϵ { 1 , 2 , . . . , n + m } {\displaystyle x_{i}={\bar {b_{i}}}-{\bar {a_{ik}}}x_{k}\quad i\,\epsilon \,\{1,2,...,n+m\}} {\displaystyle x_{i}={\bar {b_{i}}}-{\bar {a_{ik}}}x_{k}\quad i\,\epsilon \,\{1,2,...,n+m\}}

Since the non-negativity of entering variables should be ensured, the following inequality can be derived:

b i ¯ − a i ¯ x k ≥ 0 i ϵ { 1 , 2 , . . . , n + m } {\displaystyle {\bar {b_{i}}}-{\bar {a_{i}}}x_{k}\geq 0\quad i\,\epsilon \,\{1,2,...,n+m\}} {\displaystyle {\bar {b_{i}}}-{\bar {a_{i}}}x_{k}\geq 0\quad i\,\epsilon \,\{1,2,...,n+m\}}

Where x k {\displaystyle x_{k}} {\displaystyle x_{k}} is immutable. The minimum x i {\displaystyle x_{i}} {\displaystyle x_{i}} should be zero to get the minimum value since this cannot be negative. Therefore, the following equation should be derived:

x k = b i ¯ a i k ¯ {\displaystyle x_{k}={\frac {\bar {b_{i}}}{\bar {a_{ik}}}}} {\displaystyle x_{k}={\frac {\bar {b_{i}}}{\bar {a_{ik}}}}}

Due to the nonnegativity of all variables, the value of x k {\displaystyle x_{k}} {\displaystyle x_{k}} should be raised to the largest of all of those values calculated from above equation. Hence, the following equation can be derived:

x k = min a i k ¯ > 0 b i ¯ a i k ¯ i = 1 , 2 , . . . , n + m {\displaystyle x_{k}=\min _{{\bar {a_{ik}}}>0}\,{\frac {\bar {b_{i}}}{\bar {a_{ik}}}}\quad i=1,2,...,n+m} {\displaystyle x_{k}=\min _{{\bar {a_{ik}}}>0}\,{\frac {\bar {b_{i}}}{\bar {a_{ik}}}}\quad i=1,2,...,n+m}

Once the leaving-basic and entering-nonbasic variables are chosen, reasonable row operation should be conducted to switch from the current dictionary to the new dictionary, as this step is called pivot.[4]

As in the pivot process, the coefficient for the selected pivot element should be one, meaning the reciprocal of this coefficient should be multiplied to every element within this row. Afterward, multiplying this specific row with corresponding coefficients and adding this to different rows, one should get 0 values for all other entries in this pivot element's column.

If there are any negative variables after the pivot process, one should continue finding the pivot element by repeating the process above. At once there are no more negative values for basic and non-basic variables. The optimal solution is found.[6][7]
Numerical Example

Considering the following numerical example to gain better understanding:

max 4 x 1 + x 2 + 4 x 3 {\displaystyle \max {4x_{1}+x_{2}+4x_{3}}} {\displaystyle \max {4x_{1}+x_{2}+4x_{3}}}

with the following constraints:

2 x 1 + x 2 + x 3 ≤ 2 x 1 + 2 x 2 + 3 x 3 ≤ 4 2 x 1 + 2 x 2 + x 3 ≤ 8 x 1 , x 2 , x 3 ≥ 0 {\displaystyle {\begin{aligned}2x_{1}+x_{2}+x_{3}&\leq 2\\x_{1}+2x_{2}+3x_{3}&\leq 4\\2x_{1}+2x_{2}+x_{3}&\leq 8\\x_{1},x_{2},x_{3}&\geq 0\end{aligned}}} {\displaystyle {\begin{aligned}2x_{1}+x_{2}+x_{3}&\leq 2\\x_{1}+2x_{2}+3x_{3}&\leq 4\\2x_{1}+2x_{2}+x_{3}&\leq 8\\x_{1},x_{2},x_{3}&\geq 0\end{aligned}}}

With adding slack variables to get the following equations:

z − 4 x 1 − x 2 − 4 x 3 = 0 2 x 1 + x 2 + x 3 + s 1 = 2 x 1 + 2 x 2 + 3 x 3 + s 2 = 4 2 x 1 + 2 x 2 + x 3 + s 3 = 8 x 1 , x 2 , x 3 , s 1 , s 2 , s 3 ≥ 0 {\displaystyle {\begin{aligned}z-4x_{1}-x_{2}-4x_{3}&=0\\2x_{1}+x_{2}+x_{3}+s_{1}&=2\\x_{1}+2x_{2}+3x_{3}+s_{2}&=4\\2x_{1}+2x_{2}+x_{3}+s_{3}&=8\\x_{1},x_{2},x_{3},s_{1},s_{2},s_{3}&\geq 0\end{aligned}}} {\displaystyle {\begin{aligned}z-4x_{1}-x_{2}-4x_{3}&=0\\2x_{1}+x_{2}+x_{3}+s_{1}&=2\\x_{1}+2x_{2}+3x_{3}+s_{2}&=4\\2x_{1}+2x_{2}+x_{3}+s_{3}&=8\\x_{1},x_{2},x_{3},s_{1},s_{2},s_{3}&\geq 0\end{aligned}}}


The simplex tableau can be derived as following:

x 1 x 2 x 3 s 1 s 2 s 3 z b 2 1 1 1 0 0 0 2 1 2 3 0 1 0 0 4 2 2 1 0 0 1 0 8 − 4 − 1 − 4 0 0 0 1 0 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 2&1&1&1&0&0&0&2\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 2&1&1&1&0&0&0&2\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}}

In the last row, the column with the smallest value should be selected. Although there are two smallest values, the result will be the same no matter of which one is selected first. For this solution, the first column is selected. After the least coefficient is found, the pivot process will be conducted by searching for the coefficient b i x 1 {\displaystyle {\frac {b_{i}}{x_{1}}}} {\displaystyle {\frac {b_{i}}{x_{1}}}}. Since the coefficient in the first row is 1 and 4 for the second row, the first row should be pivoted. And following tableau can be created:

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.5 0.5 0.5 0 0 0 1 1 2 3 0 1 0 0 4 2 2 1 0 0 1 0 8 − 4 − 1 − 4 0 0 0 1 0 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\1&2&3&0&1&0&0&4\\2&2&1&0&0&1&0&8\\\hline -4&-1&-4&0&0&0&1&0\end{array}}}

By performing the row operation still every other rows (other than first row) in column 1 are zeroes:

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.5 0.5 0.5 0 0 0 1 0 1.5 2.5 − 0.5 1 0 0 3 0 1 0 − 1 0 1 0 6 0 1 − 2 2 0 0 1 4 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&1.5&2.5&-0.5&1&0&0&3\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&1.5&2.5&-0.5&1&0&0&3\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}}

Because there is one negative value in last row, the same processes should be performed again. The smallest value in the last row is in the third column. And in the third column, the second row has the smallest coefficients of b i x 3 {\displaystyle {\frac {b_{i}}{x_{3}}}} {\displaystyle {\frac {b_{i}}{x_{3}}}} which is 1.2. Thus, the second row will be selected for pivoting. The simplex tableau is the following:

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.5 0.5 0.5 0 0 0 1 0 0.6 1 − 0.2 0.4 0 0 1.2 0 1 0 − 1 0 1 0 6 0 1 − 2 2 0 0 1 4 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.5&0.5&0.5&0&0&0&1\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&1&0&-1&0&1&0&6\\\hline 0&1&-2&2&0&0&1&4\end{array}}}

By performing the row operation to make other columns 0's, the following could be derived

x 1 x 2 x 3 s 1 s 2 s 3 z b 1 0.2 0 0.6 − 0.2 0 0 0.4 0 0.6 1 − 0.2 0.4 0 0 1.2 0 − 0.1 0 0.2 0.6 − 1 0 − 4.2 0 2.2 0 1.6 0.8 0 1 6.4 {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.2&0&0.6&-0.2&0&0&0.4\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&-0.1&0&0.2&0.6&-1&0&-4.2\\\hline 0&2.2&0&1.6&0.8&0&1&6.4\end{array}}} {\displaystyle {\begin{array}{c c c c c c c | r}x_{1}&x_{2}&x_{3}&s_{1}&s_{2}&s_{3}&z&b\\\hline 1&0.2&0&0.6&-0.2&0&0&0.4\\0&0.6&1&-0.2&0.4&0&0&1.2\\0&-0.1&0&0.2&0.6&-1&0&-4.2\\\hline 0&2.2&0&1.6&0.8&0&1&6.4\end{array}}}

There is no need to further conduct calculation since all values in the last row are non-negative. From the tableau above, x 1 {\displaystyle x_{1}} {\displaystyle x_{1}}, x 3 {\displaystyle x_{3}} {\displaystyle x_{3}} and z {\displaystyle z} {\displaystyle z} are basic variables since all rows in their columns are 0's except one row is 1.Therefore, the optimal solution will be x 1 = 0.4 {\displaystyle x_{1}=0.4} {\displaystyle x_{1}=0.4}, x 2 = 0 {\displaystyle x_{2}=0} {\displaystyle x_{2}=0}, x 3 = 1.2 {\displaystyle x_{3}=1.2} {\displaystyle x_{3}=1.2}, achieving the maximum value: z = 6.4 {\displaystyle z=6.4} {\displaystyle z=6.4}
Application

The simplex method can be used in many programming problems since those will be converted to LP (Linear Programming) and solved by the simplex method. Besides the mathematical application, much other industrial planning will use this method to maximize the profits or minimize the resources needed.
Mathematical Problem

The simplex method is commonly used in many programming problems. Due to the heavy load of computation on the non-linear problem, many non-linear programming(NLP) problems cannot be solved effectively. Consequently, many NLP will rely on the LP solver, namely the simplex method, to do some of the work in finding the solution (for instance, the upper or lower bound of the feasible solution), or in many cases, those NLP will be wholly linearized to LP and solved from the simplex method.[1] Other than solving the problems, simplex method can also be used reliably to support the LP's solution from other theorem, for instance the Farkas' theorem in which Simplex method proves the suggested feasible solutions.[1] Besides solving the problems, the Simplex method can also enlighten the scholars with the ways of solving other problems, for instance, Quadratic Programming (QP).[8] For some QP problems, they have linear constraints to the variables which can be solved analogous to the idea of the Simplex method.
Industrial Application

The industries from different fields will use the simplex method to plan under the constraints. With considering that it is usually the case that the constraints or tradeoffs and desired outcomes are linearly related to the controllable variables, many people will develop the models to solve the LP problem via the simplex method, for instance, the agricultural and economic problems

Farmers usually need to rationally allocate the existed resources to obtain the maximum profits. The potential constraints are raised from multiple perspectives including policy restriction, budget concerns as well as farmland area. Farmers may incline to use the simplex-method-based model to have a better plan, as those constraints may be constant in many scenarios and the profits are usually linearly related to the farm production, thereby forming the LP problem. Currently, there is an existing plant-model that can accept inputs such as price, farm production, and return the optimal plan to maximize the profits with given information.[9]

Besides agricultural purposes, the Simplex method can also be used by enterprises to make profits. The rational sale-strategy will be indispensable to the successful practice of marketing. Since there are so many enterprises international wide, the marketing strategy from enamelware is selected for illustration. After widely collecting the data of the quality of varied products manufactured, cost of each and popularity among the customers, the company may need to determine which kind of products well worth the investment and continue making profits as well as which won't. Considering the cost and profit factors are linearly dependent on the production, economists will suggest an LP model that can be solved via the simplex method.[10]

The above professional fields are only the tips of the iceberg to the simplex method application. Many other fields will use this method since the LP problem is gaining popularity in recent days and the simplex method plays a crucial role in solving those problems.
Conclusion

It is indisputable to acknowledge the influence of the Simplex method to programming, as this method won the 'National Medal of Science' to its inventor, George Dantzig.[11] Not only for its wide usage in the mathematic models and industrial manufacture, but the Simplex method also provides a new perspective in solving the inequality problems. As its contribution to the programming substantially boosts the advancement of the current technology and economy from making the optimal plan with the constraints. Nowadays, with the development of technology and economics, the Simplex method is substituted with some more advanced solvers which can solve the problems with faster speed and handle a larger amount of constraints and variables, but this innovative method marks the creativity at that age and continuously offer the inspiration to the upcoming challenges.
References

Linear complementarity, linear and nonlinear programming Internet Edition.
Dantzig, G. B. (1987, May). Origins of the simplex method.
Strang, G. (1987). Karmarkar’s algorithm and its place in applied mathematics. The Mathematical Intelligencer, 9(2), 4-10. doi:10.1007/bf03025891.
Vanderbei, R. J. (2000). Linear programming: Foundations and extensions. Boston: Kluwer.
Sakarovitch M. (1983) Geometric Interpretation of the Simplex Method. In: Thomas J.B. (eds) Linear Programming. Springer Texts in Electrical Engineering. Springer, New York, NY. https://doi.org/10.1007/978-1-4757-4106-3_8
Evar D. Nering and Albert W. Tucker, 1993, Linear Programs and Related Problems, Academic Press. (elementary)
Robert J. Vanderbei, Linear Programming: Foundations and Extensions, 3rd ed., International Series in Operations Research & Management Science, Vol. 114, Springer Verlag, 2008. ISBN 978-0-387-74387-5.
Wolfe, P. (1959). The simplex method for quadratic programming. Econometrica, 27(3), 382. doi:10.2307/1909468
Hua, W. (1998). Application of the revised simplex method to the farm planning model.
Nikitenko, A. V. (1996). Economic analysis of the potential use of a simplex method in designing the sales strategy of an enamelware enterprise. Glass and Ceramics, 53(12), 367-369. doi:10.1007/bf01129674.

    Cottle, R., Johnson, E. and Wets, R. (2007). George B. Dantzig (1914–2005). Notices Amer. Math. Soc. 54, 344–362.

Navigation menu

    Log in
    Request account

    Page
    Discussion

    Read
    View source
    View history

Search

    Textbook Home
    About This Text
    Wiki Editing Help
    Feedback (2021)
    Feedback (2020)
    Recent Changes

Tools

    What links here
    Related changes
    Special pages
    Printable version
    Permanent link
    Page information

    This page was last edited on 5 October 2021, at 08:26.

    Privacy policy
    About Cornell University Computational Optimization Open Textbook - Optimization Wiki
    Disclaimers

    Powered by MediaWiki
]]
[[Simplex algorithm
https://google.github.io/or-tools/cpp_linear/linear__solver_8h.html
  https://google.github.io/or-tools/cpp_linear/linear__solver_8h_source.html

Google OR-Tools 9.3
C++ Reference

    Algorithms
    CP-SAT
    Graph
    Routing
    Linear solver

C++ Reference: Linear solver
Toggle main menu visibility
Classes | Namespaces | Functions | Variables
linear_solver.h File Reference
Detailed Description

A C++ wrapper that provides a simple and unified interface to several linear programming and mixed integer programming solvers: GLOP, GLPK, CLP, CBC, and SCIP.

The wrapper can also be used in Java, C#, and Python via SWIG.

What is Linear Programming?

In mathematics, linear programming (LP) is a technique for optimization of a linear objective function, subject to linear equality and linear inequality constraints. Informally, linear programming determines the way to achieve the best outcome (such as maximum profit or lowest cost) in a given mathematical model and given some list of requirements represented as linear equations.

The most widely used technique for solving a linear program is the Simplex algorithm, devised by George Dantzig in 1947. It performs very well on most instances, for which its running time is polynomial. A lot of effort has been put into improving the algorithm and its implementation. As a byproduct, it has however been shown that one can always construct problems that take exponential time for the Simplex algorithm to solve. Research has thus focused on trying to find a polynomial algorithm for linear programming, or to prove that linear programming is indeed polynomial.

Leonid Khachiyan first exhibited in 1979 a weakly polynomial algorithm for linear programming. "Weakly polynomial" means that the running time of the algorithm is in O(P(n) * 2^p) where P(n) is a polynomial of the size of the problem, and p is the precision of computations expressed in number of bits. With a fixed-precision, floating-point-based implementation, a weakly polynomial algorithm will thus run in polynomial time. No implementation of Khachiyan's algorithm has proved efficient, but a larger breakthrough in the field came in 1984 when Narendra Karmarkar introduced a new interior point method for solving linear programming problems. Interior point algorithms have proved efficient on very large linear programs.

Check Wikipedia for more detail: http://en.wikipedia.org/wiki/Linear_programming

Example of a Linear Program

maximize: 3x + y subject to: 1.5 x + 2 y <= 12 0 <= x <= 3 0 <= y <= 5

A linear program has: 1) a linear objective function 2) linear constraints that can be equalities or inequalities 3) bounds on variables that can be positive, negative, finite or infinite.

What is Mixed Integer Programming?

Here, the constraints and the objective are still linear but there are additional integrality requirements for variables. If all variables are required to take integer values, then the problem is called an integer program (IP). In most cases, only some variables are required to be integer and the rest of the variables are continuous: this is called a mixed integer program (MIP). IPs and MIPs are generally NP-hard.

Integer variables can be used to model discrete decisions (build a datacenter in city A or city B), logical relationships (only place machines in datacenter A if we have decided to build datacenter A) and approximate non-linear functions with piecewise linear functions (for example, the cost of machines as a function of how many machines are bought, or the latency of a server as a function of its load).

How to use the wrapper

The user builds the model and solves it through the MPSolver class, then queries the solution through the MPSolver, MPVariable and MPConstraint classes. To be able to query a solution, you need the following:

    A solution exists: MPSolver::Solve has been called and a solution has been found.
    The model has not been modified since the last time MPSolver::Solve was called. Otherwise, the solution obtained before the model modification may not longer be feasible or optimal.

See also
    ../examples/linear_programming.cc for a simple LP example.
    ../examples/integer_programming.cc for a simple MIP example.

All methods cannot be called successfully in all cases. For example: you cannot query a solution when no solution exists, you cannot query a reduced cost value (which makes sense only on continuous problems) on a discrete problem. When a method is called in an unsuitable context, it aborts with a LOG(FATAL). TODO(user): handle failures gracefully.

For developers: How the wrapper works

MPSolver stores a representation of the model (variables, constraints and objective) in its own data structures and a pointer to a MPSolverInterface that wraps the underlying solver (GLOP, CBC, CLP, GLPK, or SCIP) that does the actual work. The underlying solver also keeps a representation of the model in its own data structures. The model representations in MPSolver and in the underlying solver are kept in sync by the 'extraction' mechanism: synchronously for some changes and asynchronously (when MPSolver::Solve is called) for others. Synchronicity depends on the modification applied and on the underlying solver.

Definition in file linear_solver.h.

Go to the source code of this file.
Classes
class  	MPSolver
 	This mathematical programming (MP) solver class is the main class though which users build and solve problems. More...

class  	MPObjective
 	A class to express a linear objective. More...

class  	MPVariable
 	The class for variables of a Mathematical Programming (MP) model. More...

class  	MPConstraint
 	The class for constraints of a Mathematical Programming (MP) model. More...

class  	MPSolverParameters
 	This class stores parameter settings for LP and MIP solvers. More...

class  	MPSolverInterface

Namespaces
namespace  	operations_research

Functions
 	ABSL_DECLARE_FLAG (bool, linear_solver_enable_verbose_output)

bool 	SolverTypeIsMip (MPModelRequest::SolverType solver_type)

bool 	SolverTypeIsMip (MPSolver::OptimizationProblemType solver_type)

const absl::string_view 	ToString (MPSolver::OptimizationProblemType optimization_problem_type)

std::ostream & 	operator<< (std::ostream &os, MPSolver::OptimizationProblemType optimization_problem_type)

std::ostream & 	operator<< (std::ostream &os, MPSolver::ResultStatus status)

bool 	AbslParseFlag (absl::string_view text, MPSolver::OptimizationProblemType *solver_type, std::string *error)

std::string 	AbslUnparseFlag (MPSolver::OptimizationProblemType solver_type)

bool 	MPSolverResponseStatusIsRpcError (MPSolverResponseStatus status)

Variables
constexpr double 	kDefaultPrimalTolerance = 1e-07

Function Documentation
ABSL_DECLARE_FLAG 	( 	bool  	,
		linear_solver_enable_verbose_output  	
	) 		

]]
]]]
]]]]]
DONE:
e ../../python3_src/seed/math/matrix/solve_matrix.py
  matrix:solve
    unify-std row:
      coeff *= ??
    pivot below column nonzreos
      which?


[[
语法:
  码流多个层次
  缓存cfg运算结果
    无副作用函数
    语境无关
    指导裁剪 缓存的码流
  句法符号: 功能=识别+生成
  检查符号: 功能=检查局部变量locals

  码流 -> 树
  树 -> 受限通用数据类型
    基本数据类型:
      没有内建类型
      真值类型-并不需要，直接使用case of 而非 if-else
      整数类型 用 List<Digit>表达
      Monad?表达 出错
        字符串 用于 io？
          List<List<Hex>>
      其他都是:Disjoint_Union互斥并联
        可移植？类似 集合
          T a b = T1 a | T2 b
          S b = (T _ b) .T2 b? | S0
        缓存属性:
          Tree a = Leaf a | Fork [Tree a]@children {sz::UInt}{sz=f children}
          公开可读，可不读，按名读取(向后兼容，随时可以新增缓存属性！)
          构造时 不能赋值！自动生
            序列化时，不显示
            因为 表达成 构造表达式的样子，而构造表达式并不包含缓存属性
      IO:
        输出至 外部哪些 数据类型？
          List v <-> Array<v>
          List v <-> Set<v>
          List (k, v) <-> Lookup<k,v> #eq? bool? class?
          List<List<Hex> > <-> 字符串
          整数#真值? 0/1? 外部弱类型，内部有类型指引，可以正确转为
          没有 元组？不够通用
    区分:惰性求值，勤性求值
      惰性求值-如何实现-无循环引用:
        使用 内部时间戳！
          使用 惰性表达式 时:
            生成一个时间戳t0，用以递归约束 内部子表达式构造时间
            可以引用任何 固实勤性表达式
            只能引用 构造时间t>t0的 惰性表达式/或/半固实构造(自身时间戳=所有子表达式时间戳的最小值)
                ??既然 半固实没有产生 新的时间戳，那到底哪个构造产生新的时间戳？
        或者:用户显式提供 一个 rank 以 对 惰性表达式 分层
        或者:使用 依赖于 类型的rank
        或者:使用 依赖于 模块包的rank
          A模块依赖B 意味着 A有可能 使用 B类型构造器，因此 无法从参数上 看出是否 发生 类型循环
            只有没有 发生类型循环，就不会出现 循环引用
          没有类型循环的一个充分条件是:
            类型T 定义于 模块A
            类型S 定义于 模块B
            T 的 子数据 是属于 类型S
              ==>> A头文件 依赖于 B头文件
              ==>> B头文件 不依赖于 A头文件
              因此 如果 S的对象实例 引用 类型T，则 该类型 必然 是 通过 类型参数 直接 传递，而非 另行 构造(因为 没有 T的构造器)
            可见，出现 循环引用，必然 是 同一模块中的 一组 循环引用 类型(没有子类型...)+可修改性(包括 惰性求值 在内:惰性表达式闭包)！！！
              高阶类型参数，也可能传递 类型构造器，造成循环，这其实是 循环类型的实现细节(隐参数)...
              相似的结构:分形？
    xxx 局部并行裸指针循环?
      bug:其实就是：
        obj{
        .x = f<raw obj>(...)
        .y = f<raw obj>(...)
        }
      !!! 类似
        x = f x
        y = f z
        z = f y
        等，惰性表达式 其实 就已经 产生了 循环引用！！
          f x 是 一个 包含 x的对象！
        除非 即时传参 即时运算，
          即：f x 是 lambda x: f x
          但 这样一来，很多计算都重复了！
  ===
  子类:只允许 并联分支 减少，不允许 增加 串联分量 (除了 缓存属性)
    序列化/反序列化 等 等价变换中，信息损失
  ===
  其实 不需要 完整的类型定义，只需要 类型构造器 声明 就 可以了
  函数 也 不需要 定义，只要 声明 就可以了
  唯一的表达式 就是 函数调用，能够 匹配类型就可以了
    具体实现 由 运行库 或 用户 提供！
  构造器 也是 函数
  解析 复杂 字面值，可仿 C++带单位字面值
    其实就是 函数+字符串
    看来 字符串 少不了要 内建
  注意:句法符号 是 函数
    也有 输入输出
      输入:模版参数
      输出:解析结果
      中间变量:可选命名序列/属性语法？

  ===
  命名(可选):
    并联分支:
      ; = x {
        | w
        | expr
        | [ ... ]
        | = y [ ... ]
        | { ... }
        | = z { ... }
      }
      优先: 『/』替代『|』
    串联分量:
      ; = x [
        , w
        , expr
        , [ ... ]
        , = y [ ... ]
        , { ... }
        , = z { ... }
      ]
  ===
  模版
    ; = x(...) ...
  ===
  局部私有命名空间"where"
  ===
  自举？
    精简版-->>复杂版

]]


[[
view others/数学/编程/术语/控控非门CCNOT--Toffoli门.txt

===

Yaoyun Shi发现只用Toffoli门加上单比特的Hadamard 门就可以构造出任意的量子电路。

这个结论有可以用下面这句话概括：量子计算超越经典计算的地方就在于多了单比特的Hadamard门，或者说所有的量子计算算法不过就是经典计算机加上Hadamard门。
]]



cmake 之类 的 自动生成 的 中间文件，应该 独立 配置 一个 属性文件(本文件.(虚拟修改时刻+hash) / + 所有[依赖文件.(相对路径+虚拟修改时刻+hash)] #本文件.虚拟修改时刻=1+max(所有[依赖文件.虚拟修改时刻], default=-1)#)
  独立于 文件系统 的 好处是：解压/复制/移动，权限不足 等等 问题 不再


cross-?-compiler
  executable<host_exec_lang> :: script_lang -> source_code_lang -> exec_lang_id -> exec_lang<exec_lang_id>
  executable<host_exec_lang>(script8compiler, source_code, name4target_exec_lang) -> executable<target_exec_lang>

语法-语言:
  命名空间
    ==>>export
      ???export until some-a-ancestor-X
        在X之下 的 所有包 可见
        强调向上传递，避免 错误定位
      export to some-a-pkg-X
        在X之下 的 所有包 可见

    ==>>import
    铁律:import 的 所有对象名 必须是 固定不变的集合
      显式枚举
      隐式计算 的前提是 所有输入 固定不变
        即 锚定 头文件 的 特定版本
    禁止:
      from xxx import *
      import xxx (*)
      #why?多个输出也会冲突！除非只有一条输出指令 或者 引入包自己 声明 命名规则(比如：正则表达式，版本演进，接口只增不减，约束只强不弱(命名规则 不断 缩减 许可的命名空间))并限定版本下限、或者 本地 就地 声明 转发的标识过滤规则（版本演进，过滤规则 不断弱化，允许越来越大的转发空间），或者 锚定 版本(反正，新版本 必须 声明 所覆盖 的 所有旧版本==>>整个历史无缺无漏)
      #     有意义吗？版本下限 其实 就是 唯一的约束，新版本的新接口，用户事实上看不到！！所以锚定 版本全部引入是合理的，锚定的是 头文件/接口文件 版本，而非 源文件/具化实现
      #bug:但 允许 全部 向外转发:
      #bug:export from xxx (*)
      #bug:重点在于: 只要内部使用，就必须显式声明
        ?(？即使使用 限定词前缀？)
        import xxx as X (x)
        X.x
        import xxx as X (*)？？行不行？
          可以，反正命名无冲突，且只要 包内容 立即可见，完全可以反推（除非是 头文件，而且 还没用上，既然 只在 源文件 中 使用，头文件不用，头文件 便不该 引入，减少依赖；源文件 可 自动生成 的 requirements需求文件/依赖？）
          requirements vs dependencies

编译器自举:
  逆推 则是 语言 不断剥离复杂特性，形成一序列缩水语言子集
  ===
  最初的编译器 只能使用 某个平台上的 某种固有语言 来实现
    机器语言/汇编语言
    这个 最初的编译器 代码量 应该尽量小
      适合 在任何新机器上 直接使用 汇编语言 实现
      只做一件事: 将 某种高级语言 翻译成 汇编语言
      即 实现 文本文件 的 翻译
        文本文件 -> 文本文件
      弱类型 脚本语言
      数据 不可修改(父节点 必需 在 子节点 构造 之后 才能 构造)，但 对象/公开共享节点 允许 多个拥有者/父节点，使用 用户不可见 的 可修改 引用计数 以实现 内存自动管理/无需垃圾回收
        循环引用 只能 使用 私有独占的裸指针 私有子引用=(父节点/独占拥有者，私有子裸指针)
      使用 用户不可见 不可修改 的 类指针 以 区分 公开共享节点/私有独占节点
      ===
      底层构造，更高层不可见:
        第一，指针/计数器
              #指针下限>=字节
              #?机器字?可以用指针替代?用作 引用计数#因为 引用 来自于 其他地址，数量不超过指针表达范围
              #?单字符?除非 预设固定字符集，这样一来，字符数量固定，但如果使用机器字表达字符，则 隐含了 对 机器字 的 下限要求
        ??第二，整块字节串??#似乎没有用武之地
        第三，内存管理
        第四，底层元组=四指针大小(类指针/不可修改，引用计数/可修改，左节点/不可修改，右节点/不可修改)
          带不带长度？
          ===
          大整数.最低位.底层元组=四指针大小(类指针/不可修改，引用计数/可修改，低位计数/不可修改，高位节点/不可修改)
          大整数.非最低位.底层元组=四指针大小(低位计数{*3}/不可修改，高位节点/不可修改)
          ####第四，底层元组=四指针大小(引用计数/可修改，类指针/不可修改，子树节点数/不可修改，左节点/不可修改，右节点/不可修改)
      高层构造:
        第一，读写 本地 二进制文件
        第二，通用容器
              底层元组
              ==>>中层短元组
              ==>>以下节点
              序列finger_tree
                序列.树节点(?深度?，整树节点数，左翼{深度-1}{n,m}，中间子树{深度+1}，右翼{深度}{n,m})
                序列.树.翼节点(?深度?, 翼节点{深度-1}{p,q})
                序列.树.翼节点{深度=-1}===序列.树.叶节点(元素)
              序列==>>高层长元组/高层数组...有序集合/有序词典
                带不带长度？
        第三，大整数操作
              ==>>弱类型，与其他类型区分开来，内部完全私有，再无需 引用计数
              <<==序列<计数器>
                #除法 受限制，除数 在 字节 范围？比特位右移？
        第四，字符串操作
              #未来的字符数量没有上限，只能使用大整数
              <<==序列<自然数><<==序列<大整数>
              类似 Haskell:
                []
                Char:Str
              唯一的 空字符串:
                字符串.唯一空元组=(#再次使用 类指针#)
        第五，限制 字符集 及 编码方案，字符串编解码
        第六，语言 表达 应该是 易于 解析 的 通用数据 表达形式
              甚至于 指定 编码:
                比如：采用 6(7*)6 或 (7*)7 动态字节编码
              指定 区分 关键词：
                自然数 是 普通字符/用户数据
                负数 是 转义字符/保留字符/特殊字符/关键字/带外信息
              二进制文件
                ==>> 序列<大整数>===含带外信息的字符串
                ==>> 序列<(负字符串，正字符串)>
                ==>> (允空正字符串，序列<(非空负字符串，非空正字符串)>，允空负字符串)
        第七，使用 通用容器+基本数据类型(字符串+大整数) 实现 (数据 即 函数)通用函数/解释性脚本函数



反排版:
  从 已排版 的 多行多列/阵列 数据(带空位？) 中 提取数据
  该依照什么次序？
  若是 偶然性多列，行 并非 记录，类似『ls』输出多列文件名，则 应该 按 列 读取？
    不太对，输出/排版 也 可能 是 先填满当前行再换行 flow。但这样一来就无分列的必要。
  若是 每行记录一条数据，哪怕 有 空缺，也该 行优先。




https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf
  [分布式系统][共识协议]Paxos Made Simple.pdf
  view /mnt/m_external_sd/000edt/0my_files/book/并发/\[分布式系统]\[共识协议]Paxos\ Made\ Simple.pdf


标识/命名
  名称/译名 既重要也不重要
  统一形式 有助于 记忆
    译名 保持 同构，方便 自造词
    但 形式化 意味浓厚，自动造词 等于 随机命名，变成 行内黑话，是对 自然语言 直观易理解 的 背叛。
  重要:
    外行/入门 直观
    外行人 遇到问题 能够 直觉 与 该 名称 有关，进一步了解
  不重要:
    内行人是知道 是什么，有哪些特性，用在哪里



并行作用:
  单个 差量 作用于 单个 基量，没问题
  问题在于: 多个差量无优先次序地作用到多个基量融合上。
      缺失？覆盖？整合？删除？碰撞？
      首先是 输入状态判断
        某个 属性 于 各个差量 各个基量 中的 存在性
      其次是 输出状态检查
        怎样的输出才算合格？
      再次是 输入输出状态比照，更进一步检查
        怎样的修改才算合理？
      还有：给出 修改意见/指令
        根据 中间状态，给出 修改步骤
        是 继续循环 填充/修改，还是 中止(局部个人终止 vs 全局出错中止)？

  幂等差量作用:
    ##!!!幂等 注定 不可逆！！
    什么数据结构？怎样支持？
    词典/映射:
      针对预先指定 键值:
        删、新增、覆盖、整合/深入整合
      过滤/针对符合条件的 所有已存在 键值:
    集合:
      缺失则填充默认值
      存在则删除
    multiset/排序序列:
      绝对位置不重要，相对位置重要
      在指定的两元素间插入某些新元素(仅当不存在才插入)
      删除？
    数组/序列:
      ？矩阵？
      绝对位置重要，相对位置不重要
      深入元素
      尾部增删

    树:
      不相干分支独立更新，独占互斥
      ===节点构造器 到底 需不需要 静态类型/固化？
      注解/修饰==>>多重用途
        ==>>节点 拥有 多种视图
          ，比如应用A需要属性.a，应用B需要属性.b
            ==>> {.a{A}=1, .b{B}=2, .c{A,B}=3, .d{A}=4, .d{B}=5}
            应用A看到:过滤后的结果:{.a=1, .c=3, .d=4}
            应用B看到:过滤后的结果:{.b=2, .c=3, .d=5}
        ==>>节点不存在特定于应用的预先设计的构造器，只有最泛化的弱类型构造器
      ====
      ##??可是 全局约束 比如 id唯一性 如何表达？
      ##??有序 结构 中，给 元素 贴上 唯一id 作为 标签，供 外部 定位 而不因 增删元素 而 错失。
      ##    ==>>即使是 有序 结构，元素 也要 命名？问题是 不自然/太麻烦/无描述性质强调外延区别与内涵大纲的自动命名成为必然 导致难用
      ##        可用 补丁/锚定固址差量 来 渐进 按需命名
      ##    局部 唯一 命名 对于构成 路径 很重要
      ##    全局 唯一 命名 对于 在版本修订间 不断漂移 的 对象 #比如 在 向上路径 中 插入 新节点，所有 子节点 路径 改变
      树节点=史节点|野节点
      史节点=[无序可见性]树节点{无序修饰词}
      可见性=用途名#哪个应用会使用？#比较『feature:on='特性选择表达式'』
      修饰词=树节点
      野节点=丫节点|叶节点
      叶节点=内建基础数据类型
        真值/枚举/三态/四态，整数.../标志位集，字节串，字符串
        带单位？带解码方案？data_URI？
      丫节点=自定义丫节点|内建丫节点
      自定义丫节点=(伪构造器别名, 有序参数, 无名无序参数, 命名独占无序参数)
      内建丫节点=内建容器丫节点|内建运算丫节点|内建约束定义丫节点
      内建容器丫节点=自动有序(可选/optional/Maybe|单选/Either|空缺)|有序(元组|数组|多维阵列/张量|递增/排序？==>>相邻约束)|无序(集合|多选/词典映射|多重集合|多重多选|双射==>>无序阵列+列约束+行约束+记录集合约束)
      内建运算丫节点
        模版
        组合算子
        匿名函数
      内建约束定义丫节点
        定义数据类型#用于读取时动态自动检查


    到底都有哪些数据结构？
        逻辑-程序流程==>>真值
        计数、数组索引、地址指针、数学运算==>>自然数/整数/有理数/多项式(根)？
        码流/序列化/存储/阅读:字节串、字符串
        表达运算==>>组合算子/函数？
        语法树/高阶反省==>>树
        ===
        串联:元组、数组、正则表达式序列/空间重叠？
        并联:枚举量/单选vs标志位集/集合/多选、多选/词典映射(任意数量键值)、单选/互斥并联(单键词典)

幂等 注定 不可逆！！
  差量作用
    幂等 则 不可逆
    不幂等 则 不稳定、不可移植？
  ===差量 分类
  幂等差量
    终态判定，不可逆
    终态=limit (f**i)(始态) {i<-0..+oo}
  锚定固址差量=补丁
    可逆，由于 输入 只有一个允许值，必然可逆
    始态检查: 始态 是否是 指定值
  可移植差量
    始态检查: 始态 是否 符合 假设
    * 可逆可移植差量
      始态检查 包含 可逆性检查
补丁打到哪里？
    不可控，不可预测，否则可在设计阶段隔离开来，成为 参数 或 底层支持库API
    跨函数跨对象跨模块，跨越一切人为预设边界，散落各处



一切都是数据
  说到底，编程语言 也不过是 在 试图简化 抽象语法树 的 表达
  没有 声明式语言，没有 命令式语言
    Haskell IO 显然就是这样
  ===
  一切都是数据，但 更重要的是 类型/约束，即 数据 的 接口
    在得到实际数据之前 便知道 可以怎么使用，通常 数据 的 实际值 有很多可能
    弱类型+强约束==>>泛用性
      弱类型==>>通用函数可接受
      强约束==>>静态价值更高，更有用
    抽取分享信息: 提供 多层次变换函数，不断 弱化类型，通过增强静态约束，尽量减少信息损失

Haskell show/read
  [[
  show 无需 显示类型信息，显示了也没用，动态按需加载模块？静态链接的程序...
  read 必须 知道 完整的类型信息
    ==>> 不支持 子类
    如：[C <: B][ls :: [B]][ls含C的对象] ==>> [(read :: str->[B]) 并不能读取C对象]
    其实 最外派生类/子类 相当于 单选互斥并联 的 一个分支
      最糟糕的是 分支空间开放，未来或第三方 子类 无法 读取
  ]]
  [[
  ===
  读取read:
    要么 类似 json，指定一个 固定数据类型集合，只使用它们作为通用数据结构。
      data_obj :: 固定类型(外部静态依赖)
      外部静态依赖 意外着 恒定不变，旧解析器永不过时
    要么 动态导入模块与类型，则 所谓数据实际上 变成脚本，并且 需要 运行环境 恰好安装了该模块 或 能够自动收缩下载安装。
      外部动态依赖(file_type+version+import_stmts) + data_obj
      外部动态依赖 意味着 易扩展(支持版本更新、支持第三方扩展)，版本更新则旧解析器(或 运行期支持库)会过时失效，导入外部资源则离线情形数据失效。
    要么 独立自足(standalone/self-contained)，离线内嵌 所有 类型定义
      datatype_def_stmts + data_obj
      但 既然 与 解析器 的 预编译固有静态类型 不匹配，就只能是 弱类型/运行期检查模拟动态强类型
    ==>> 其实都一样，即 读取需预先指定类型
      区别在于:
        第一种情况:自由构造数据，或有 预设的固定约束
        第二种情况:只保留极小固定格式，其他内容的解析 允许引用未来特性(允许语法扩展、允许语义扩展)、允许引用外部资源
        第三种情况:包含 自定义约束 读取时 检查
    ===无忧扩展:别名
      alias
      ===可疑扩展:模版、运算
  ]]
  [[
  ===
  序列化show:
    多态:
      show :: legal_cls_set, __class__ => base_cls -> str
        在 固定的类型集合 下，填充 __class__ 至 base_cls 的 差距
      show :: legal_cls2identifier, __class__ => base_cls -> str
      show :: identifier4cls -> base_cls -> str
      show :: identifier4cls -> base_cls -> tail/str -> str
      read :: legal_cls_set => str -> base_cls
      read :: identifier2legal_cls => str -> (__class__<:)base_cls
      read :: identifier2legal_cls_reader => str -> ((__class__<:)base_cls, tail/str)

  ]]
  [[
  ]]
static_cast:
  newtype/alias
  类型参数 的 角色role
  子类？
  函数输入输出 的 角色 相当不同
  ===
  隐含约束？
    若只是 自由构造的数据自然无妨
    但类似 Haskell.Set 之类，通过 私有化/不导出 构造器，控制 构造，进而 实现 排序 约束。
    static_cast 可能导致乱序、逆序


cache:
  自动缓存 deep-immutable-lazy-property:
  幂等？
  比如:hash
  比如:deep-frozen/burn 初始化结束，禁止修改，深度冻结


迭代:流访问 树访问
  StateMonad
    自定义语境context
      非全局状态global/static/thread_local/nonlocal
    隐式传递implicit
      非显式参数parameter
    跨对象
      业务无关/隔离
      非对象指针this/self
  StateMonad:
    position:
      流访问：
        索引号+各低层地址
      树访问：
        路径
        部分拆解树
        更新操作:新半树+已访问旧半树+未访问旧半树
  就地异常处理:
    how = StateMonad::yield_where
    ===
    哪里where:
      where = StateMonad::position
    怎么处理how:
      * 中止
      * 忽略/替换...


分层树有向无环图:
  ##==>>文件系统:文件hard_link泛化至 部分文件夹(否则只能 symbol_link)
  DAG节点 赋值一个 偏序类型值
    约束:
      子节点.偏序类型值 ~<=~ 父节点.偏序类型值
      [子节点.偏序类型值 ~==~ 父节点.偏序类型值] <==> [父子 为 同层文件夹，不可使用 hard_link，即 子节点 只有 唯一父节点，即 同层文件夹 构成 一片 森林]
      [子节点.偏序类型值 ~<~ 父节点.偏序类型值] <==> [父子 为 不同层文件夹，可使用 hard_link，即 子节点 可有多个 父节点，即 子节点 相当于 文件，父节点 相当于 文件夹]
  真副本:写时复制
  真引用:读写共享同一对象






端午节
  view /sdcard/0my_files/tmp/out4py/农历/农历.py.打印公历农历日期对照表.out.txt

对称卷积?:
  输入输出的近期历史/完整历史？:
    y[n] = f(y[n-1]..y[n-p],x[n-1]..x[n-q]; x[n])
    可逆:x[n] = g(y[n-1]..y[n-p],x[n-1]..x[n-q]; y[n])

view others/数学/编程/差量编程-可逆计算-声明式语言.txt



编译器:
  bootstrap? 目标平台是？虚拟机？基础部件是什么？约束假设-内存并行假设？
  全局命名-局部命名--跨语言跨层次命名映射
  shell? 命令行？控制台？
    实现了计算，但关键是：输入输出，人机交互，组件组合

充电宝 使用
  https://zhuanlan.zhihu.com/p/378421765
  https://zhuanlan.zhihu.com/p/162140252
  接口类型
  快充协议
  100元内 小米，品胜，京造，绿联，罗马仕
村里-65元-龙奇？

2+3+5+7=17
2+3+5+7+11=28




xxxxxxx
https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf
  [分布式系统][共识协议]Paxos Made Simple.pdf
共识协议？
  其余宕机，突然 单机？
  连 参与者的数目 都不确定，如何 确认 大多数 的 数量？
    参与者 加入 作为一个事件 需要 申请批准，但 掉线宕机 却不需要。
  新参与者 试图申请加入，但其实只有自己？
  多个新参与者 独立起源初始化，多个系统 如何 互动 合并？
  连线中断，失联等效宕机，但 实际各自存活
    此后是 大陆隔离，独立演化，不再一致，没有共识
    还是 苦苦等待，停滞不前？


obj_cls_tower[obj, level, ...]
  level=0: as obj
  level=1: as cls<obj>
DONE:
  view ../../python3_src/seed/func_tools/recur5yield.py


CANCELLED:加密网页 第二版
  e ../../python3_src/自己的相关数据/on_working.txt

整理 通假字 生僻字
  view 0未整理复制粘贴文本/3未整理复制粘贴文本.txt
DONE: 整理 敏感词
  view /storage/emulated/0/Download/\[20220415]敏感词违禁词与形近字/unzip
  e /storage/emulated/0/Download/\[20220415]敏感词违禁词与形近字/parse_banned_words.py



歌曲下载:
  https://www.musicenc.com/?search
歌词 干了这杯酒 荣华富贵

下载:《汉语字典》相关
  https://www.52pojie.cn/thread-1203253-1-1.html
    https://pan.baidu.com/s/1qWBGsEg#/home/%2F/%2F
    view /sdcard/hugh.android/GuHanYu.apk

欧路词典文件格式



unicode 兼容字符 的 『原字符』属性名 是什么？

DONE:邓力群自述：十二个春秋
  view ++enc=gb18030 /sdcard/0my_files/book/邓力群自述：十二个春秋.txt


py merge folder



[设计]DAG:[
  类似 程序语句，靠 输入输出 参数 决定 拓扑偏序
  实际参数+虚拟参数
  实际节点+虚拟节点

  语句格式:
    『节点名:输入参数列表->输出参数列表』
      多个输入 以 实现AND
      多个输出 以 实现OR
      比如：节点X运行，当且仅当[(a&&b)||(c&&d)]

        A: ... -> a
        B: ... -> b
        C: ... -> c
        D: ... -> d
        $A_B: a b -> a_b__c_d
        $C_D: c d -> a_b__c_d
        X: a_b__c_d -> ...

]

[设计]可追踪性数据:[
  从哪来？输入/参考资料/底本
  做了哪些处理？步骤/生成数据的程序
  有怎样的要求/目的/约束/定义？规范/控制参数
  ===
  重点是：别人能否重现/复刻？别人能否判断所见数据符合规范声明与否？别人能否更正错误？别人能否推广输入范围？别人能否独立更新合并数据以使之不断进化壮大？
  ===
  比如：《说文解字》定义了『六书』，后人可以：
    + 依此类推，分类更多汉字
    + 判断《说文解字》自身的归类有没有出错
    + 根据『六书』归类的歧义程度，评价『六书』这个定义的好坏。
]


[设计]PTS lambda lang design:[
  数据 即是 函数 LocalRouter naive解释 类似 Lisp:
    (...)数据/函数
    [...]调用 #反身赋值 ls[:] = [...]
]

view ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_14_0_annex/unicode_ver14_0_UAX31_UAX38摘要.txt
  抽取 Unihan 中感兴趣的属性？




古籍？下载？


DONE:更新 外部存储器:
  密码
  歌
DONE:github? 搞定上传？
  view others/app/termux/github/GitHub不再支持密码验证解决方案-ver2.txt
DONE:文本质量评估？继续？
  e 文本质量评估.txt

DONE:汉字笔划 --> 4bit/8bit


[
doing:
e ../../python3_src/自己的相关数据/on_working.txt
e script/collect_hz_components.py
拆字:
  拆否？
    天，矢/知，广，之，鬼...
    呆果男
    ===
    点 视为 附加物
      其他单笔，如果接触其他部件，也视为 附加物，不拆出
      土士王玉主义互母舟
    部件 并非 稳定，一个 代表 多个，不断精细化归类
      月:月，青字底，肉月
      日:日，子曰，冒头
      火:火，火左旁，火底，四点水，
      木:木，木左旁，木底(带钩？)
      耳:耳，戢，左立耳，右立耳，取，最，聽
    不同地区，字形不同，部件不同
    字形有特别约束的，不拆:
      二三土士未末曰冃日
    字形排版复杂的，不拆:
      兔鬼包
  命名:
    例子减去其余部分:
      打丁==>>提手
    近似叠加+所在例子:
      口木刺==>>朿 #不是『束/呆/杏』
]


]]]


[[TODO 整理一下
[[[[[[[
目录
  e ./0未整理复制粘贴文本/0未整理复制粘贴文本.txt
  e 0未整理复制粘贴文本/1未整理复制粘贴文本.txt
  e 0未整理复制粘贴文本/2未整理复制粘贴文本.txt

======================
======================
======================
e ./0未整理复制粘贴文本/0未整理复制粘贴文本.txt
  [[
有大伪 出处？
？乐浪郡？->取名
?下载《老子想尔注》
?下载《云笈七签》《雲笈七籤》
?《春秋策：先秦诸子与史记评述》 第2章 诸子天人论导源 『兹为图以明五者之相关如下：』下面没有了。
  看来真是『图』，而非『文本』
孙子吴起列传-马陵？桂陵？-间隔 十年？十三年？-田忌？田朌？-襄陵？大梁？
  田忌+田朌
？郑公克段？
  郑伯克段于鄢
？商圣白圭？
?秦伯让王？秦伯/仲雍/季历 三兄弟，之父-古公亶父，季历之子-姬昌
  泰伯 非 秦伯
  无情对: 庄子*让王
?天民 真人

？歌词:爱恨情仇 人憔悴
  https://www.musicenc.com/?search
  口是心非 - 黄静美/尚雅
    https://www.musicenc.com/article/398290.html
  口是心非 - 童珺
    https://www.musicenc.com/article/1147455.html
  口是心非 - 丫蛋蛋（马启涵）&崔铭嘉
    https://www.musicenc.com/article/34866.html
  口是心非-张雨生#竟然是 国语版？
  口是心非 粤语版
    http://www.shiyinren.com/kw/antiserver.kuwo.cn/anti.s?rid=MUSIC_148624884&response=res&format=mp3|aac&type=convert_url&br=128kmp3&agent=iPhone&callback=getlink&jpcallback=getlink.mp3
      难听！
     口是心非（粤语版） (cover: 绝版雪碧) - 壹聲憂傷
     http://www.shiyinren.com/kw/antiserver.kuwo.cn/anti.s?rid=MUSIC_182229646&response=res&format=mp3|aac&type=convert_url&br=128kmp3&agent=iPhone&callback=getlink&jpcallback=getlink.mp3
永乐:
  纪纲 死期 与 (刘永福xx 而是:) 邱福？战败于北漠，孰先孰后？
    #拖后腿？
    #土木堡？

古代每户人家平均几人？
?毕竟空 胜义有
无印subtitle?
账户vs帐户
  帐户account 但 账户 似乎也行
起讫 qi3 qi4 开始+终结
  起迄
?servo n 伺服机构，随动系统
？一家 白藕 青叶 红莲


麻将规则
  麻将玩法 学习 入门

grep 与 字符 的unicode 转义？
  DONE
  e others/app/termux/grep/grep_regex_pattern_howto_escape_char.txt
  e others/app/termux/shell_string_howto_escape_char.txt

]]

!mkdir 0未整理复制粘贴文本
!mv 0未整理复制粘贴文本.txt 0未整理复制粘贴文本/
view 0未整理复制粘贴文本/0未整理复制粘贴文本.txt
e 0未整理复制粘贴文本/1未整理复制粘贴文本.txt
[[

py unicode 库？
  py lib parse unihan ?

unicode annex 下载
  下载 unicode标准+annex

unicode标准的中文版翻译？
  Unicode®标准英文术语翻译对照表及部分术语汇释
  Unicode Standard 译介尝试（一）・文种名、符号名与块名
  统一码 百度百科
]]


[[
e 0未整理复制粘贴文本/2未整理复制粘贴文本.txt
四角号码，仓颉码
]]



[[
e 0未整理复制粘贴文本/3未整理复制粘贴文本.txt
  在下面 搜索:已下载
收集 敏感词/屏蔽词 大全
形近字 近似字 替换字 大全
罕见字、罕用字、生僻字 大全
收集 形近字/易错字/错别字/混淆字 大全
古今字 通假字 大全
]]



[[
e 0未整理复制粘贴文本/4未整理复制粘贴文本.txt
六书
  象形
  指事
  会意
代词
量词
象声词/拟声词
叹词
虚词
语气词
助词
副词
连词
介词
汉语语法相关名词
偏旁部首大全
]]



[[

e 0未整理复制粘贴文本/5未整理复制粘贴文本.txt
文选
  绕梁三日
  纪昌学射
  九方皋相马

]]



[[
e 0未整理复制粘贴文本/6未整理复制粘贴文本.txt
止戈为武
  趾-行动-炫耀？
  止-平息？

我的termux故障:
  DONE:
    #err: view others/app/termux/apt_update_fail__solved.txt
    view others/app/termux/apt_update__fail/apt_update_fail__solved_ver2.txt

欧路词典文件格式
]]

TODO
]]]]]]]




[[[失败:
  www待查 无印subtitle? 毕竟空 胜义有，外挂/外接/内嵌/内接/内联

  =======
  外挂/外接/内嵌/内接/内联
    attach 附加
    embed 嵌入
  外挂 cheating program 作弊器  ##-英语点津 - China Daily
    plug
    plugin



?下载《论语疏证》杨树达
  view /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-3/《论语疏证》.txt
    #子罕第九 诸后缺失
?下载 老子他说
  view  /storage/72A2-151D/000edt/0my_files/book_txt/小说天堂txt/重命名/小说天堂txt-6/《老子他说》.txt
    共26章，也只解说了 道德经 前26章，似乎不全
?下载《云笈七签》《雲笈七籤》
?下载《春秋策：先秦诸子与史记评述》 第2章 诸子天人论导源 『兹为图以明五者之相关如下：』下面没有了。
view ++enc=gbk /mnt/m_external_sd/000edt/0my_files/novel/《逍遥小书生》（校对版全本）作者：荣小荣.txt
  一百多章后，尾丢头前插
  第91章~第120章 完全缺失
    第91章 我家小姐有请
    第120章 如仪视察



婚礼新娘跑路，份子钱咋整？
外挂接口？外挂 翻译 ？attachment?

四书五经，大学
搜你妹-->轻心搜？安装失败

天气晚来秋
  语法问题？
  [[我试试:
唐代王维的《山居秋暝》
空山新雨后，天气晚来秋。
明月松间照，清泉石上流。
竹喧归浣女，莲动下渔舟。
随意春芳歇，王孙自可留。

空山，新雨后的空山；天气，？？的天气。
  ]]


download: cppreference.com
  termux
  update clang c++20
  [[

apt update
  !!失败！！
apt upgrade clang

已解决:
  #err: view others/app/termux/apt_update_fail__solved.txt
  view others/app/termux/apt_update__fail/apt_update_fail__solved_ver2.txt

e 0未整理复制粘贴文本/clang.txt
]]






小说下载？
  e others/book/小说下载进程.txt
    view  /sdcard/0my_files/tmp/list_book_novel_txt.txt
  @20220417
]]]
]]

[[ ]]
[[ ]]
[[ ]]
[[ ]]
TODO










[[
https://f-droid.en.softonic.com/android
F-Droid 闭式商店
下载了 UserLAnd
]]








[[
DONE:邓力群自述：十二个春秋
  https://github.com/hankinghu/literature-books/master/邓力群自述：十二个春秋.txt
    ===
    svn ls https://github.com/hankinghu/literature-books/trunk/
      ok！
    $ cd ~/1tmp/svn_
    $ svn export https://github.com/hankinghu/literature-books/trunk/邓力群自述：十二个春秋.txt
      A    邓力群自述：十二个春秋.txt
      Export complete.
    mv 邓力群自述：十二个春秋.txt /sdcard/0my_files/book/
  view ++enc=gb18030 /sdcard/0my_files/book/邓力群自述：十二个春秋.txt
]]




[[[
范畴论 教科书
可计算性
e others/book/category-theory.txt
e others/book/computability.txt
  view /mnt/m_external_sd/000edt/0my_files/book/math/category\ theory/
  view /mnt/m_external_sd/000edt/0my_files/book/math/computability/

[[
ls /mnt/m_external_sd/000edt/0my_files/book/math/category\ theory/
'Abstract and concrete categories--the joy of cats(1990ed+2004update-web)(Adamek).pdf'
'Axiomatic Method and Category Theory (2014)(Andrei Rodin).pdf'
'Basic Category Theory (2014)(Leinster).pdf'
'Categorical Logic and Type Theory (1999)(Bart Jacobs).djvu'
'Categories for the Working Mathematician (2ed)(1998)(Mac Lane).pdf'
'Category Theory (2ed)(2010)(Steve Awodey).pdf'
'Category Theory for Computing Science (1995-rev20200423)(Michael Barr).pdf'
'Category Theory for Programmers (20181021)(v1.0.0-0-g41e0fc3)(Milewski).pdf'
'Category Theory for Programmers (20190812)(v1.3.0-0-g6bb0bc0)(Milewski).pdf'
'Category Theory for Scientists (dynamic-20130514).pdf'
'Category Theory for Scientists (static-20130205).pdf'
'Category Theory in Context (2014)(Emily).pdf'
'Conceptual Mathematics--A First Introduction to Categories (2ed)(2009)(Lawvere).pdf'
'Introduction to CATEGORY THEORY and CATEGORICAL LOGIC (Thomas Streicher).pdf'
'Introduction to Categories and Categorical Logic (Samson Abramsky)(2006-2011).pdf'
'Introduction to Categories and Categorical Logic (Samson Abramsky).pdf'
'Topoi--The Categorial Analysis of Logic (1983)(Robert Goldblatt).pdf'
'范畴论(2006)(贺伟)(书签+去水印).pdf'
]]
[[
ls /mnt/m_external_sd/000edt/0my_files/book/math/computability/
'Higher-Order Computability (2015)(Longley).pdf'
'Hilbert Tenth Problem--Intro to Logic,Number Theory,Computability (2019)(Murty).pdf'
'The Foundations of Computability Theory (2ed)(2020)(Borut).pdf'
'The Incomputable--Journeys Beyond the Turing Barrier (2017)(Cooper).pdf'
]]
]]]

[[
方人

人道 注重 集体，个人 需时刻关注 与其他人的关系，自己在社会中的位置
修天道者，不关心别人，不与别人比较，没有奖状/排行榜之类的东西。


“天道远，人道迩”，谚语，字面意思是天道悠远、人道切近，[3]典出《左传·昭公十八年》子产所言：“天道远，人道迩，非所及也，何以知之？”[2]

释义
天道：上天的意思的体现。人道：人事。迩：近。[1] 鲁昭公十八年（前524年，郑定公六年），包括郑国在内的多个诸侯国发生火灾。据《左传》记载，此前一年（前525年，郑定公五年），郑国人裨灶就曾经预言火灾的发生，并要求用瓘、斝、玉瓒祭神，子产不答应。[6] [4] [5] 这次火灾后，裨灶又说：“不采纳我的意见，郑国还要发生火灾。”郑国人请求采纳他的意见，子产不同意。子太叔说：“宝物是用来保护百姓的。如果有了火灾，国家差不多会灭亡。可以挽救灭亡，您爱惜它干什么？”子产说：“天道悠远，人道切近，两不相关。如何由天道而知人道？灶哪里懂得天道？这个人的话多了，难道不会偶尔也说中的？”于是就不给。后来也没有再发生火灾。[2]
出处
《左传·昭公十八年》：裨灶曰：“不用吾言，郑又将火。”子产不可。子大叔曰：“宝，以保民也。若有火，国几亡。可以救亡，子何爱焉？”子产曰：“天道远，人道迩，非所及也，何以知之？灶焉知天道？是亦多言矣，岂不或信？”遂不与，亦不复火。[2]

]]








[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
[[
]]
