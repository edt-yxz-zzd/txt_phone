
tar_7zip.txt
	see: TODO_list/upload_book.txt

tar -cvf /the_io_dir/the_output_archive.tar.lzma --lzma -C /the_io_dir/    the_input_file
  -cvf c[create]v[verbose]f[opath]
  --lzma ...类似7z的压缩方式
  -C C[change dir] # 可能是设定『压缩包根路径』相应的实际起点，跟pwd无关(即使此选项在-cvf之前，opath也不受影响)，避免压缩包内的多余路径前缀(使用-tvf打印包内文件系统)
  例子:
  tar -cvf /sdcard/0my_files/tmp/out4py/seed.math.prime_pint.generate_primes.._reduce_coeff__36__refine.using_param6n7022.n_le_10pow7.out.txt.tar.lzma --lzma -C /sdcard/0my_files/tmp/out4py/ seed.math.prime_pint.generate_primes.._reduce_coeff__36__refine.using_param6n7022.n_le_10pow7.out.txt
tar -tf /the_io_dir/the_output_archive.tar.lzma
  tar -tvf /the_io_dir/the_output_archive.tar.lzma
    verbose=>文件路径前冠文件信息
  ###tar -tvf /the_io_dir/the_output_archive.tar.lzma --lzma
    --lzma 应是无用
  -tvf t[list?#why]v[verbose]f[opath]
  打印文件清单
tar -xf /the_io_dir/the_output_archive.tar.lzma -O | more
  tar -xvf /the_io_dir/the_output_archive.tar.lzma -O | more
    verbose=>文件输出前插入文件路径
  #NOTE:not『-xvfO』which treat "O" as fpath
  -xvf x[extract]v[verbose]f[opath]
  -O --to-stdout
  解压到标准输出文件

pkg install unrar
pkg install p7zip


7z@p7zip
	https://sevenzip.osdn.jp/chm/cmdline/commands/
	7z e xx.7z xx.txt
		extract one file
	7z x xx.7z
		extract whole tree
		7z a xx.7z -v10k -v15k -v2m *.txt
			creates multivolume xx.7z archive. First volume will be 10 KB, second will be 15 KB, and all others will be 2 MB.
			7z x xx.7z.001
		7z a -tzip archive.zip *.txt
			adds all *.txt files from current directory to zip archive archive.zip.
		7z t -t7z.split archive.7z.001
			tests all files in archive.7z.001. It also checks that archive is multivolume .7z archive.
		7z x -t# sfxarchive.exe
		7z x xx.iso.001 -tiso.split -o<output_dir>
		7z x xx.iso.001 -tudf.split -o<output_dir>
			Passing the -t flag with the "split" indication will specifically tell 7z that the iso has multi-parts, the preceding "iso" or "udf" will depend on your iso container format.
	7z a archive1.zip subdir\
		adds all files and subfolders from folder subdir to archive archive1.zip. The filenames in archive will contain subdir\ prefix.
gzip -k file
	#bad -L=3B -M, used "split" instead
	tar cvzf - dir/ | split -b 200m - backup.tar.gz.
		"-" : stdout, stdin
		cat backup.tar.gz.* | tar xzvf -
	tar -cvzf xxx.tar.gz xxx/
	tar -cvf xxx.tar xxx/
	tar -cvjf xxx.tar.bz2 xxx/
	tar -cvjf xxx.tar.bz2 -C xxx/ .
	tar -czvf /path/to/foo.tgz --exclude=\*.{jpg,gif,png,wmv,flv,tar.gz,zip} /path/to/foo/.
	===
	tar -xvf xxx.tar
	tar -xvzf xxx.tar.gz
	tar -xvjf xxx.tar.bz2

pkg install unrar
pkg install p7zip
	test output mtime#stat
	!!!changed
	-tzip
		-mtc
	-t7z
		-mtm
		-mta
		-mtc
		-mtr
		###no solution found!!!
tar -xvzf xx.tgz
	Cannot utime: Operation not permitted
		Are you trying to extract the tar onto a non-Linux filesystem e.g. USB drive or a mounted Windows partition? If so, try extracting it onto a Linux filesystem. 
		!!yes, own is root, mv fails too
	$ tar -xvzf xx.tgz -C ~/1tmp/
		!!success
	$ mv -t . ~/1tmp/q
	mv: preserving times for './q': Operation not permitted
	mv: preserving permissions for ‘./q’: Operation not permitted




[[
see:py::shutil,tarfile,zipfile
httpd -f /sdcard/0my_files/git_repos/txt_phone/lots/NOTE/html/httpd-confs/httpd.conf-sdcard_0my_files-unzip-py_doc-python_3_12_4_docs_html
http://127.0.0.1:3124/library/tarfile.html#module-tarfile
http://127.0.0.1:3124/library/shutil.html#archiving-operations
==>>:
High-level utilities to create and read compressed and archived files are also provided. They rely on the zipfile and tarfile modules.

shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]])
shutil.unpack_archive(filename[, extract_dir[, format[, filter]]]

shutil.get_archive_formats()
  -> [(name, description)]
shutil.get_unpack_formats()
  -> [(name, extensions, description)]

default-supported-names of get_archive_formats&get_unpack_formats:
  zip: ZIP file (unpacking compressed files works only if the corresponding module is available).
  tar: uncompressed tar file.
  gztar: gzip’ed tar-file (if the zlib module is available).
  bztar: bzip2’ed tar-file (if the bz2 module is available).
  xztar: xz’ed tar-file (if the lzma module is available).


===
view others/app/termux/help/xz.txt
man lzma
  『lzma』 is equivalent to 『xz --format=lzma』.
man xz
view others/app/termux/help/xz.man.txt
view others/app/termux/help/xz.help.txt
man xz
  ==>> file suffix: .xz  .lzma  .lz  ; .txz  .tlz # .txz==.tar.xz  .tlz==.tar.lz
  ==>> format:auto,xz,lzma/alone,lzip,raw


==>>:
py -m tarfile -l script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma
  => 『script/搜索冫最短加链长度.py..statistics.out.txt』


tarfile.open(name=None, mode='r', fileobj=None, bufsize=10240, **kwargs)
  mode has to be a string of the form 'filemode[:compression]':
  * 'r' or 'r:*'
    Open for reading with transparent compression (recommended).
  * 'r:'
    Open for reading exclusively without compression.
  * 'r:gz'
    Open for reading with gzip compression.
  * 'r:bz2'
    Open for reading with bzip2 compression.
  * 'r:xz'
    Open for reading with lzma compression.
  * 'x:xz'
    Create a tarfile with lzma compression. Raise a FileExistsError exception if it already exists.
  * 'w:xz'
    Open for lzma compressed writing.
  ===
  * 'r|xz'
    Open an lzma compressed stream for reading.
  * 'w|xz'
    Open an lzma compressed stream for writing.
tarfile.is_tarfile(name)
  :: (str|?file?|file-like object) -> bool

[tar_file ~=~ [tar-block]]
[archive_member == stored file) ~=~ [head-block; data-block...]]

TarFile Objects
The TarFile object provides an interface to a tar archive.
  A tar archive is a sequence of blocks.
  An archive member (a stored file) is made up of a header block followed by data blocks.
    It is possible to store a file in a tar archive several times.
    Each archive member is represented by a TarInfo object, see TarInfo Objects for details.


TarInfo Objects
A TarInfo object represents one member in a TarFile.
  Aside from storing all required attributes of a file (like file type, size, time, permissions, owner etc.)
    , it provides some useful methods to determine its type.
  It does not contain the file’s data itself.

TarInfo objects are returned by TarFile’s methods getmember(), getmembers() and gettarinfo().

Modifying the objects returned by getmember() or getmembers() will affect all subsequent operations on the archive.
  For cases where this is unwanted, you can use copy.copy() or call the replace() method to create a modified copy in one step.

Several attributes can be set to None to indicate that a piece of metadata is unused or unknown. Different TarInfo methods handle None differently:
  * extract() or extractall() methods will ignore the corresponding metadata, leaving it set to a default.
  * addfile() will fail.
  * list() will print a placeholder string.

class tarfile.TarInfo(name='')
  Create a TarInfo object.

classmethod TarInfo.frombuf(buf, encoding, errors)
  Create and return a TarInfo object from string buffer buf.
  Raises HeaderError if the buffer is invalid.

classmethod TarInfo.fromtarfile(tarfile)
  Read the next member from the TarFile object tarfile and return it as a TarInfo object.

TarInfo.tobuf(format=DEFAULT_FORMAT, encoding=ENCODING, errors='surrogateescape')
  Create a string buffer from a TarInfo object. For information on the arguments see the constructor of the TarFile class.


TarFile.getmember(name)
  -> TarInfo{name} | ^KeyError@non_existed
  Note If a member occurs more than once in the archive, its last occurrence is assumed to be the most up-to-date version.

TarFile.getmembers()
  -> [TarInfo]
  The list has the same order as the members in the archive.

TarFile.getnames()
  -> [TarInfo.name]
  It has the same order as the list returned by getmembers().

TarFile.next()
  [open4reading] => -> may TarInfo{next_member}

TarFile.gettarinfo(name=None, arcname=None, fileobj=None)
  -> TarInfo
  Create a TarInfo object from the result of os.stat() or equivalent on an existing file.
    The file is either named by name, or specified as a file object fileobj with a file descriptor.
    name may be a path-like object.
    If given, arcname specifies an alternative name for the file in the archive, otherwise, the name is taken from fileobj’s name attribute, or the name argument. The name should be a text string.

  You can modify some of the TarInfo’s attributes before you add it using addfile().
    If the file object is not an ordinary file object positioned at the beginning of the file, attributes such as size may need modifying. This is the case for objects such as GzipFile.
    The name may also be modified, in which case arcname could be a dummy string.




TarFile.addfile(tarinfo, fileobj=None)
TarFile.extractfile(member)
  :: member/(filename|TarInfo) -> may fileobj{regular file|link}/io.BufferedReader | ^KeyError@non_existed

TarFile.add(name, arcname=None, recursive=True, *, filter=None)
TarFile.extract(member, path='', set_attrs=True, *, numeric_owner=False, filter=None)
TarFile.extractall(path='.', members=None, *, numeric_owner=False, filter=None)

view ../../python3_src/seed/for_libs/for_tarfile.py
py_adhoc_call  { -end4print }  seed.for_libs.for_tarfile   @str.read_solo_tarfile_  :script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma  --xencoding4data:ascii
py_adhoc_call  { -end4print }  seed.for_libs.for_tarfile   ,str.iter_read_solo_tarfile_  :script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma  --xencoding4data:ascii

]]

[[
copy from:view script/搜索冫最短加链长度.py
===
tar --create --verbose --file=script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma  --lzma script/搜索冫最短加链长度.py..statistics.out.txt
tar -cvf script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma  --lzma script/搜索冫最短加链长度.py..statistics.out.txt
view script/搜索冫最短加链长度.py..statistics.out.txt
    (1, 0, ((1,), (1, 0, 0)))
    ... ...
    (2173, 15, ((1, 2, 4, 8, 16, 32, 64, 128, 256, 272, 280, 281, 537, 818, 1636, 2173), (1, 2108288, 15261095)))
du -h script/搜索冫最短加链长度.py..statistics.out.txt
    188K
du -h script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma
    28K

tar --extract --verbose --file=script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma --to-stdout | more
tar -xvf script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma -O | more
    -C, --directory=DIR
tar -xf script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma -O | diff - script/搜索冫最短加链长度.py..statistics.out.txt -s
    Files - and script/搜索冫最短加链长度.py..statistics.out.txt are identical

py -m tarfile -l script/搜索冫最短加链长度.py..statistics.out.txt.tar.lzma
  => 『script/搜索冫最短加链长度.py..statistics.out.txt』

]]

[[
stdin,stdout
  -si
  -so
... | 7z a  -si   path_to_file.7z
7z e  -so   path_to_file.7z

<<==:
view others/app/termux/help/7z.man.txt
a      Add
u      Update
e      Extract
x      eXtract with full paths

for relative ipath???
  -w/sdcard/0my_files/tmp/
  but fail for e/a:Extract/Add
for relative opath@extract???
  -o/sdcard/0my_files/tmp/
  fail for a:Add
echo aaa | 7z a  -si   /sdcard/0my_files/tmp/0tmp
  it seems always write to 0tmp.7z
7z e  -so   /sdcard/0my_files/tmp/0tmp.7z
=> aaa
stat /sdcard/0my_files/tmp/0tmp.7z
snippet -n 9999 /sdcard/0my_files/tmp/0tmp.7z
[b"7z\xbc\xaf'\x1c\x00\x04\xce\xa7z\x19\x08\x00\x00\x00",
 b'\x00\x00\x00\x00:\x00\x00\x00\x00\x00\x00\x00k\xdb0{',
 b'\x01\x00\x03aaa\n\x00\x01\x04\x06\x00\x01\t\x08\x00',
 b'\x07\x0b\x01\x00\x01!!\x01\x18\x0c\x04\x00\x08\n\x01\x95',
 b']\xf8w\x00\x00\x05\x01\x19\x03\x00\x00\x00\x14\n\x01\x00',
 b'\xd8\x02\x0f\xd2\x95N\xdb\x01\x15\x06\x01\x00\x00\x00\x00\x00',
 b'\x00\x00']

]]









====man tar
view others/app/termux/help/tar.man.txt
[[
-c --create
-f --file
-x --extract
-v --verbose

   Compression options
       -a, --auto-compress
       -j, --bzip2
       -J, --xz
       -lzma
       -z, --gzip, --gunzip, --ungzip

   Overwrite control
       --skip-old-files
              Don't replace existing files when extracting, silently skip over
       -k, --keep-old-files
              Don't replace existing files when extracting.

       --keep-newer-files
              Don't replace existing files that are newer than their archive
              copies.
]]
