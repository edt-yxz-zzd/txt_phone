
e others/app/gvim/括号匹配.txt
:h %
:h 'matchpairs'

:h :au
  :h autocmd-intro
   注册于特定场合自动执行的命令

:set matchpairs?
  =>『matchpairs=(:),{:},[:]』
  -->:
  :set matchpairs=(:),{:},[:],『:』,「:」,【:】,〖:〗,〔:〕,〈:〉,《:》,｛:｝,［:］,（:）,“:”,‘:’,<:>


[[[
:h %
===
9. Various motions				*various-motions*

							*%*
%			Find the next item in this line after or under the
			cursor and jump to its match. |inclusive| motion.
			Items can be:
			([{}])		parenthesis or (curly/square) brackets
					(this can be changed with the
					'matchpairs' option)
			/* */		start or end of C-style comment
			#if, #ifdef, #else, #elif, #endif
					C preprocessor conditionals (when the
					cursor is on the # or no ([{
					following)
			For other items the matchit plugin can be used, see
			|matchit-install|.  This plugin also helps to skip
			matches in comments.

			When 'cpoptions' contains "M" |cpo-M| backslashes
			before parens and braces are ignored.  Without "M" the
			number of backslashes matters: an even number doesn't
			match with an odd number.  Thus in "( \) )" and "\( (
			\)" the first and last parenthesis match.

			When the '%' character is not present in 'cpoptions'
			|cpo-%|, parens and braces inside double quotes are
			ignored, unless the number of parens/braces in a line
			is uneven and this line and the previous one does not
			end in a backslash.  '(', '{', '[', ']', '}' and ')'
			are also ignored (parens and braces inside single
			quotes).  Note that this works fine for C, but not for
			Perl, where single quotes are used for strings.

			Nothing special is done for matches in comments.  You
			can either use the matchit plugin |matchit-install| or
			put quotes around matches.

			No count is allowed, {count}% jumps to a line {count}
			percentage down the file |N%|.  Using '%' on
			#if/#else/#endif makes the movement linewise.

						*[(*
[(			go to [count] previous unmatched '('.
			|exclusive| motion.

						*[{*
[{			go to [count] previous unmatched '{'.
			|exclusive| motion.

						*])*
])			go to [count] next unmatched ')'.
			|exclusive| motion.

						*]}*
]}			go to [count] next unmatched '}'.
			|exclusive| motion.

The above four commands can be used to go to the start or end of the current
code block.  It is like doing "%" on the '(', ')', '{' or '}' at the other
end of the code block, but you can do this from anywhere in the code block.
Very useful for C programs.  Example: When standing on "case x:", "[{" will
bring you back to the switch statement.


===
]]]
[[[
===
						*'matchpairs'* *'mps'*
'matchpairs' 'mps'	string	(default "(:),{:},[:]")
			local to buffer
	Characters that form pairs.  The |%| command jumps from one to the
	other.
	Only character pairs are allowed that are different, thus you cannot
	jump between two double quotes.
	The characters must be separated by a colon.
	The pairs must be separated by a comma.  Example for including '<' and
	'>' (HTML): >
		:set mps+=<:>

<	A more exotic example, to jump between the '=' and ';' in an
	assignment, useful for languages like C and Java: >
		:au FileType c,cpp,java set mps+==:;

<	For a more advanced way of using "%", see the matchit.vim plugin in
	the $VIMRUNTIME/pack/dist/opt/matchit directory. |add-local-help|

	
===
]]]

