
e others/数学/整数分解/www-factorization.txt

[[[
https://mathworld.wolfram.com/ClassGroupFactorizationMethod.html
===
Class Group Factorization Method
A prime factorization algorithm.

REFERENCES
Lenstra, A. K. and Lenstra, H. W. Jr. "Algorithms in Number Theory." In Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity (Ed. J. van Leeuwen). New York: Elsevier, pp. 673-715, 1990.
]]]
[[[
https://mathworld.wolfram.com/PrimeFactorizationAlgorithms.html
===
Pollard-Strassen method
The fastest-known fully proven deterministic algorithm is the Pollard-Strassen method (Pomerance 1982; Hardy et al. 1990).
===
Prime Factorization Algorithms
Many algorithms have been devised for determining the prime factors of a given number (a process called prime factorization). They vary quite a bit in sophistication and complexity. It is very difficult to build a general-purpose algorithm for this computationally "hard" problem, so any additional information that is known about the number in question or its factors can often be used to save a large amount of time.

The simplest method of finding factors is so-called "direct search factorization" (a.k.a. trial division). In this method, all possible factors are systematically tested using trial division to see if they actually divide the given number. It is practical only for very small numbers.

The fastest-known fully proven deterministic algorithm is the Pollard-Strassen method (Pomerance 1982; Hardy et al. 1990).
]]]

[[[
https://mathworld.wolfram.com/PollardRhoFactorizationMethod.html
===
Pollard rho Factorization Method
A prime factorization algorithm also known as Pollard Monte Carlo factorization method. There are two aspects to the Pollard rho factorization method. The first is the idea of iterating a formula until it falls into a cycle. Let n=pq, where n is the number to be factored and p and q are its unknown prime factors. Iterating the formula

 x_(n+1)=x_n^2+a (mod n), 	
(1)
or almost any polynomial formula (an exception being x_n^2-2) for any initial value x_0 will produce a sequence of number that eventually fall into a cycle. The expected time until the x_ns become cyclic and the expected length of the cycle are both proportional to sqrt(n).

However, since n=pq with p and q relatively prime, the Chinese remainder theorem guarantees that each value of x (mod n) corresponds uniquely to the pair of values (x (mod p)), x (mod q)). Furthermore, the sequence of x_ns follows exactly the same formula modulo p and q, i.e.,

x_(n+1)	=	[x_n (mod p)]^2+a (mod p)	
(2)
x_(n+1)	=	[x_n (mod q)]^2+a (mod q).	
(3)
Therefore, the sequence (mod p) will fall into a much shorter cycle of length on the order of sqrt(p). It can be directly verified that two values x_1 and x_2 have the same value (mod p), by computing

 GCD(|x_2-x_1|,n), 	
(4)
which is equal to p.

The second part of Pollard's method concerns detection of the fact that a sequence has become periodic. Pollard's suggestion was to use the idea attributed to Floyd of comparing x_i to x_(2i) for all i. A different method is used in Brent's factorization method.

Under worst conditions, the Pollard rho algorithm can be very slow.
]]]
[[[
https://mathworld.wolfram.com/BrentsFactorizationMethod.html
===
Brent's Factorization Method
The second part of Pollard rho factorization method concerns detection of the fact that a sequence has become periodic. Pollard's original suggestion was to use the idea attributed to Floyd of comparing x_i to x_(2i) for all i. Brent's improvement to Pollard's method concerns how to detect periodicity, and replaces Floyd's method with the following algorithm. Keep only one running copy of x_i. If i is a power of a base b, let y=x_i, and at each step, compare the current value x_i with the saved value y. In the factorization case, instead of comparing x_i with y, compute

 GCD(|x_i-y|,n). 
More generally, Brent (1980) considered using any base b for saving values instead of b=2. However, he found b=2 to be very close to optimal.
]]]
[[[
https://mathworld.wolfram.com/Pollardp-1FactorizationMethod.html
===
Pollard p-1 Factorization Method
A prime factorization algorithm which can be implemented in a single-step or double-step form. In the single-step version, a prime factor p of a number n can be found if p-1 is a product of small primes by finding an m such that

 m=c^q (mod n), 
where p-1|q, with q a large number and (c,n)=1. Then since p-1|q, m=1 (mod p), so p|m-1. There is therefore a good chance that nm-1, in which case GCD(m-1,n) (where GCD is the greatest common divisor) will be a nontrivial divisor of n.

In the double-step version, a prime factor p can be found if p-1 is a product of small primes and a single larger prime.
]]]
[[[
https://mathworld.wolfram.com/WilliamspPlus1FactorizationMethod.html
===

Williams p+1 Factorization Method
A variant of the Pollard p-1 method which uses Lucas sequences to achieve rapid factorization if some factor p of N has a decomposition of p+1 in small prime factors.
]]]
[[[
https://mathworld.wolfram.com/ContinuedFractionFactorizationAlgorithm.html
===
Continued Fraction Factorization Algorithm
A prime factorization algorithm which uses residues produced in the continued fraction of sqrt(mN) for some suitably chosen m to obtain a square number. The algorithm solves

 x^2=y^2 (mod n) 
by finding an m for which m^2 (mod n) has the smallest upper bound. The method requires (by conjecture) about exp(sqrt(2lnnlnlnn)) steps, and was the fastest prime factorization algorithm in use before the quadratic sieve, which eliminates the 2 under the square root (Pomerance 1996), was developed.
]]]
[[[
https://mathworld.wolfram.com/DixonsFactorizationMethod.html
===
Dixon's Factorization Method
Contribute
To this Entry »
In order to find integers x and y such that

 x^2=y^2 (mod n) 	
(1)
(a modified form of Fermat's factorization method), in which case there is a 50% chance that GCD(n,x-y) is a factor of n, choose a random integer r_i, compute

 g(r_i)=r_i^2 (mod n), 	
(2)
and try to factor g(r_i). If g(r_i) is not easily factorable (up to some small trial divisor d), try another r_i. In practice, the trial rs are usually taken to be |_sqrt(n)_|+k, with k=1, 2, ..., which allows the quadratic sieve factorization method to be used. Continue finding and factoring g(r_i)s until N=pid are found, where pi is the prime counting function. Now for each g(r_i), write

 g(r_i)=p_(1i)^(a_(1i))p_(2i)^(a_(2i))...p_(Ni)^(a_(Ni)), 	
(3)
and form the exponent vector

 v(r_i)=[a_(1i); a_(2i); |; a_(Ni)]. 	
(4)
Now, if a_(ki) are even for any k, then g(r_i) is a square number and we have found a solution to (◇). If not, look for a linear combination sum_(i)c_iv(r_i) such that the elements are all even, i.e.,

 c_1[a_(11); a_(21); |; a_(N1)]+c_2[a_(12); a_(22); |; a_(N2)]+...+c_N[a_(1N); a_(2N); |; a_(NN)]=[0; 0; |; 0]  (mod 2) 	
(5)
 [a_(11) a_(12) ... a_(1N); a_(21) a_(22) ... a_(2N); | | ... |; a_(N1) a_(N2) ... a_(NN)][c_1; c_2; |; c_N]=[0; 0; |; 0]  (mod 2). 	
(6)
Since this must be solved only mod 2, the problem can be simplified by replacing the a_(ij)s with

 b_(ij)={0   for a_(ij) even; 1   for a_(ij) odd. 	
(7)
Gaussian elimination can then be used to solve

 bc=z 	
(8)
for c, where z is a vector equal to 0 (mod 2). Once c is known, then we have

 product_(k)g(r_k)=product_(k)r_k^2 (mod n), 	
(9)
where the products are taken over all k for which c_k=1. Both sides are perfect squares, so we have a 50% chance that this yields a nontrivial factor of n. If it does not, then we proceed to a different z and repeat the procedure. There is no guarantee that this method will yield a factor, but in practice it produces factors faster than any method using trial divisors. It is especially amenable to parallel processing, since each processor can work on a different value of r.
]]]
[[[
https://mathworld.wolfram.com/EllipticCurveFactorizationMethod.html
===
Elliptic Curve Factorization Method
The elliptic curve factorization method, abbreviated ECM and sometimes also called the Lenstra elliptic curve method, is a factorization algorithm that computes a large multiple of a point on a random elliptic curve modulo the number to be factored N. It tends to be faster than the Pollard rho factorization and Pollard p-1 factorization methods.

Zimmermann maintains a table of the largest factors found using the ECM. As of Jan. 2009, the largest prime factor found using the ECM had 67 decimal digits. This factor of 10^(381)+1 was found by B. Dodson on Aug. 24, 2006 (Zimmermann).
]]]
[[[
https://mathworld.wolfram.com/EllipticPseudoprime.html
===
Elliptic Pseudoprime
Let E be an elliptic curve defined over the field of rationals Q(sqrt(-d)) having equation

 y^2=x^3+ax+b 
with a and b integers. Let P be a point on E with integer coordinates and having infinite order in the additive group of rational points of E, and let n be a composite natural number such that (-d/n)=-1, where (-d/n) is the Jacobi symbol. Then if

 (n+1)P=0 (mod n), 
n is called an elliptic pseudoprime for (E,P).
]]]
[[[
https://mathworld.wolfram.com/StrongEllipticPseudoprime.html
===

Strong Elliptic Pseudoprime
Let n be an elliptic pseudoprime associated with (E,P), and let n+1=2^sk with k odd and s>=0. Then n is a strong elliptic pseudoprime when either kP=0 (mod n) or 2^rkP=0 (mod n) for some r with 1<=r<s.
]]]
[[[
https://mathworld.wolfram.com/EllipticCurvePrimalityProving.html
===

Elliptic Curve Primality Proving
Elliptic curve primality proving, abbreviated ECPP, is class of algorithms that provide certificates of primality using sophisticated results from the theory of elliptic curves. A detailed description and list of references are given by Atkin and Morain (1990, 1993).

Adleman and Huang (1987) designed an independent algorithm using hyperelliptic curves of genus two.

ECPP is the fastest known general-purpose primality testing algorithm. ECPP has a running time of O((lnN)^4). As of 2004, the program PRIMO can certify a 4769-digit prime in approximately 2000 hours of computation (or nearly three months of uninterrupted computation) on a 1 GHz processor using this technique. As of 2009, the largest prime certified using this technique was the 11th Mills' prime (http://primes.utm.edu/primes/page.php?id=77907)

 (((((((((2^3+3)^3+30)^3+6)^3+80)^3+12)^3+450)^3+894)^3+3636)^3+70756)^3+97220, 
which has 20562 decimal digits. The proof was performed using a distributed computation that started in September 2005 and ended in June 2006 and required a cumulative CPU-time corresponding to 2.39 GHz for 2219 days (just over 6 years).

In March 2021, P. Underwood proved the repunit prime R_(49081) (https://primes.utm.edu/primes/page.php?id=133761) to be prime using elliptic curve primality proving. The certification took 20 months on an AMD 3990x computer with 64 cores, and verification took about 13 hours (Underwood 2022).
]]]
[[[
https://mathworld.wolfram.com/Atkin-Goldwasser-Kilian-MorainCertificate.html
===
Atkin-Goldwasser-Kilian-Morain Certificate
A recursive primality certificate for a prime p. The certificate consists of a list of

1. A point on an elliptic curve C

 y^2=x^3+g_2x+g_3 (mod p) 
for some numbers g_2 and g_3.

2. A prime q with q>(p^(1/4)+1)^2, such that for some other number k and m=kq with k!=1, mC(x,y,g_2,g_3,p) is the identity on the curve, but kC(x,y,g_2,g_3,p) is not the identity. This guarantees primality of p by a theorem of Goldwasser and Kilian (1986).

3. Each q has its recursive certificate following it. So if the smallest q is known to be prime, all the numbers are certified prime up the chain.

A Pratt certificate is quicker to generate for small numbers. The Wolfram Language task ProvablePrimeQ[n] in the Wolfram Language package PrimalityProving` therefore generates an Atkin-Goldwasser-Kilian-Morain certificate only for numbers above a certain limit (10^(10) by default), and a Pratt certificate for smaller numbers.
]]]
[[[
https://mathworld.wolfram.com/ExcludentFactorizationMethod.html
===
Excludent Factorization Method
Also known as the difference of squares method. It was first used by Fermat and improved by Gauss. Gauss looked for integers x and y satisfying

 y^2=x^2-N (mod E) 
for various moduli E. This allowed the exclusion of many potential factors. This method works best when factors are of approximately the same size, so it is sometimes better to attempt mN for some suitably chosen value of m.
]]]
[[[
https://mathworld.wolfram.com/FermatsFactorizationMethod.html
===

Fermat's Factorization Method
Given a number n, Fermat's factorization methods look for integers x and y such that n=x^2-y^2. Then

 n=(x-y)(x+y) 	
(1)
and n is factored. A modified form of this observation leads to Dixon's factorization method and the quadratic sieve.

Every positive odd integer can be represented in the form n=x^2-y^2 by writing n=ab (with a>b) and noting that this gives

a	=	x+y	
(2)
b	=	x-y.	
(3)
Adding and subtracting,

a+b	=	2x	
(4)
a-b	=	2y,	
(5)
so solving for x and y gives

x	=	1/2(a+b)	
(6)
y	=	1/2(a-b).	
(7)
Therefore,

 x^2-y^2=1/4[(a+b)^2-(a-b)^2]=ab. 	
(8)
As the first trial for x, try x_1=[sqrt(n)], where [x] is the ceiling function. Then check if

 Deltax_1=x_1^2-n 	
(9)
is a square number. There are only 22 combinations of the last two digits which a square number can assume, so most combinations can be eliminated. If Deltax_1 is not a square number, then try

 x_2=x_1+1, 	
(10)
so

Deltax_2	=	x_2^2-n	
(11)
	=	(x_1+1)^2-n	
(12)
	=	x_1^2+2x_1+1-n	
(13)
	=	Deltax_1+2x_1+1.	
(14)
Continue with

Deltax_3	=	x_3^2-n	
(15)
	=	(x_2+1)^2-n	
(16)
	=	x_2^2+2x_2+1-n	
(17)
	=	Deltax_2+2x_2+1	
(18)
	=	Deltax_2+2x_1+3,	
(19)
so subsequent differences are obtained simply by adding two.

Maurice Kraitchik sped up the algorithm by looking for x and y satisfying

 x^2=y^2 (mod n), 	
(20)
i.e., n|(x^2-y^2). This congruence has uninteresting solutions x=+/-y (mod n) and interesting solutions x≢+/-y (mod n). It turns out that if n is odd and divisible by at least two different primes, then at least half of the solutions to x^2=y^2 (mod n) with xy relatively prime to n are interesting. For such solutions, (n,x-y) is neither n nor 1 and is therefore a nontrivial factor of n (Pomerance 1996). This algorithm can be used to prove primality, but is not practical. In 1931, Lehmer and Powers discovered how to search for such pairs using continued fractions. This method was improved by Morrison and Brillhart (1975) into the continued fraction factorization algorithm, which was the fastest algorithm in use before the quadratic sieve factorization method was developed.
]]]
[[[
https://mathworld.wolfram.com/SmoothNumber.html
===

Smooth Number
An integer is k-smooth if it has no prime factors >k. The following table gives the first few k-smooth numbers for small k. Berndt (1994, p. 52) called the 7-smooth numbers "highly composite numbers."

k	OEIS	k-smooth numbers
2	A000079	1, 2, 4, 8, 16, 32, 64, 128, 256, 512, ...
3	A003586	1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, ...
5	A051037	1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, ...
7	A002473	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, ...
11	A051038	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, ...
The probability that a random positive integer <=n is k-smooth is psi(n,k)/n, where psi(n,k) is the number of k-smooth numbers <=n. This fact is important in application of Kraitchik's extension of Fermat's factorization method because it is related to the number of random numbers which must be examined to find a suitable subset whose product is a square.

Since about pi(k) k-smooth numbers must be found (where pi(k) is the prime counting function), the number of random numbers which must be examined is about pi(k)n/psi(n,k). But because it takes about pi(k) steps to determine if a number is k-smooth using trial division, the expected number of steps needed to find a subset of numbers whose product is a square is ∼[pi(k)]^2n/psi(n,k) (Pomerance 1996). Canfield et al. (1983) showed that this function is minimized when

 k∼exp(1/2sqrt(lnnlnlnn)) 	
(1)
and that the minimum value is about

 exp(2sqrt(lnnlnlnn)). 	
(2)
In the continued fraction factorization algorithm, n can be taken as 2sqrt(n), but in Fermat's factorization method, it is n^(1/2+epsilon). k is an estimate for the largest prime in the factor base (Pomerance 1996).

The curiosity

 11859210 approx 11859211->
7×13×19^4 approx 2×3^4×5×11^4->
91×19^4 approx 10×33^4->
9.1 approx (33^4)/(19^4)->
9.1^(1/4) approx 33/19 	
(3)
involves the largest consecutive 19-smooth numbers, 11859210 and 11859211.
]]]
https://mathworld.wolfram.com/LegendresFactorizationMethod.html
[[[
===
Legendre's Factorization Method
A prime factorization algorithm in which a sequence of trial divisors is chosen using a quadratic sieve. By using quadratic residues of N, the quadratic residues of the factors can also be found.
]]]
[[[
https://mathworld.wolfram.com/NumberFieldSieve.html
===
Number Field Sieve
An extremely fast factorization method developed by Pollard which was used to factor the RSA-130 number. This method is the most powerful known for factoring general numbers, and has complexity

 O{exp[c(logn)^(1/3)(loglogn)^(2/3)]}, 	
(1)
reducing the exponent over the continued fraction factorization algorithm and quadratic sieve. There are three values of c relevant to different flavors of the method (Pomerance 1996). For the "special" case of the algorithm applied to numbers near a large power,

 c=((32)/9)^(1/3)=1.526285..., 	
(2)
for the "general" case applicable to any odd positive number which is not a power,

 c=((64)/9)^(1/3)=1.922999..., 	
(3)
and for a version using many polynomials (Coppersmith 1993),

 c=1/3(92+26sqrt(13))^(1/3)=1.901883.... 	
(4)
SEE ALSO
]]]
[[[
https://mathworld.wolfram.com/QuadraticSieve.html
===
Quadratic Sieve
A sieving procedure that can be used in conjunction with Dixon's factorization method to factor large numbers n. Pick values of r given by

 r=|_sqrt(n)_|+k, 	
(1)
where k=1, 2, ... and |_x_| is the floor function. We are then looking for factors p such that

 n=r^2 (mod p), 	
(2)
which means that only numbers with Legendre symbol (n/p)=1 (less than N=pi(d) for trial divisor d, where pi(d) is the prime counting function) need be considered. The set of primes for which this is true is known as the factor base. Next, the congruences

 x^2=n (mod p) 	
(3)
must be solved for each p in the factor base. Finally, a sieve is applied to find values of f(r)=r^2-n which can be factored completely using only the factor base. Gaussian elimination is then used as in Dixon's factorization method in order to find a product of the f(r)s, yielding a perfect square.

The method requires about exp(sqrt(lnnlnlnn)) steps, improving on the continued fraction factorization algorithm by removing the 2 under the square root (Pomerance 1996). The use of multiple polynomials gives a better chance of factorization, requires a shorter sieve interval, and is well suited to parallel processing.

QuadraticSieve
A type of quadratic sieve can also be used to generate the prime numbers by considering the parabola x=y^2. Consider the points lying on the parabola with integer coordinates (y^2,y) for y=2, 3, .... Now connect pairs of integer points lying on the two branches of the parabola, above and below the x-axis. Then the points where these lines intersect the x-axis correspond to composite numbers, while those integer points on the positive x-axis which are not crossed by any lines are prime numbers.
]]]
[[[
https://mathworld.wolfram.com/Veryprime.html
===
Veryprime
A positive integer n is a veryprime iff all primes p<=sqrt(n) satisfy

 {|2[n (mod p)]-p|<=1   very strong; |2[n (mod p)]-p|<=sqrt(p)   strong; |2[n (mod p)]-p|<=p/2   weak. 	
(1)
The weak veryprimes are then 2, 3, 5, 7, 11, 13, 17, 19, 23, 37, 43, 47, 53, 67, 73, 103, 107, 137, 157, 173, 227, 347, 487, 773, ... (OEIS A050264), the strong veryprimes are 2, 3, 5, 7, 11, 13, 17, 19, 23, 37, 43, 47, 53, 67, 73, 137, 227, ..., and the very strong veryprimes are 2, 3, 5, 7, 11, 13, 17, 19, 23, 37, 43, 47, 53, 67, 73, 137, ..., with no others in the first 100000 primes.
]]]
[[[
https://mathworld.wolfram.com/Quiteprime.html
===
Quiteprime
A positive integer n>1 is quiteprime iff all primes p<=sqrt(n) satisfy

 |2[n (mod p)]-p|<=p+1-sqrt(p). 
Also define 2 and 3 to be quiteprimes. Then the first few quiteprimes are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 137, ... (OEIS A050260), and the first few primes which are not quiteprimes are 131, 181, 197, 199, 233, 241, 263, 307, 311, 313, 331, 337, 353, 373, 379, ... (OEIS A050261).
]]]
[[[
https://mathworld.wolfram.com/TrialDivision.html
===
Trial Division
A brute-force method of finding a divisor of an integer n by simply plugging in one or a set of integers and seeing if they divide n. Repeated application of trial division to obtain the complete prime factorization of a number is called direct search factorization. An individual integer being tested is called a trial divisor.
]]]
[[[
https://mathworld.wolfram.com/DirectSearchFactorization.html
===
Direct Search Factorization
Direct search factorization is the simplest (and most simple-minded) prime factorization algorithm. It consists of searching for factors of a number by systematically performing trial divisions, usually using a sequence of increasing numbers. Multiples of small primes are commonly excluded to reduce the number of trial divisors, but just including them is sometimes faster than the time required to exclude them. Direct search factorization is very inefficient, and can be used only with fairly small numbers.

When using this method on a number n, only divisors up to |_sqrt(n)_| (where |_x_| is the floor function) need to be tested. This is true since if all integers less than this had been tried, then

 n/(|_sqrt(n)_|+1)<sqrt(n). 	
(1)
In other words, all possible factors have had their cofactors already tested. It is also true that, when the smallest prime factor p of n is >RadicalBox[n, 3], then its cofactor m (such that n=pm) must be prime. To prove this, suppose that the smallest p is >RadicalBox[n, 3]. If m=ab, then the smallest value a and b could assume is p. But then

 n=pm=pab>=p^3>n, 	
(2)
which cannot be true. Therefore, m must be prime, so

 n=p_1p_2. 	
(3)
]]]
[[[
===

wget 'https://math.osu.edu/sites/math.osu.edu/files/What_is_2018_Continued_Fraction_Factoring_Method.pdf' -O 'What is The Continued Fraction Factoring Method.pdf'
wget 'https://math.dartmouth.edu/~carlp/PDF/implementation.pdf' -O 'cf_factor2.pdf'
wget 'https://www.math.umd.edu/~lcw/three68.pdf' -O 'cf_factor3.pdf'
wget 'https://www.maths.cam.ac.uk/undergrad/catam/II/15pt10.pdf' -O 'cf_factor4.pdf'


References

Morrison, M. A. and Brillhart, J. ``A Method of Factoring and the Factorization of $F_7$.'' Math. Comput. 29, 183-205, 1975.

Pomerance, C. ``A Tale of Two Sieves.'' Not. Amer. Math. Soc. 43, 1473-1485, 1996.

wget 'https://www.ams.org/journals/mcom/1975-29-129/S0025-5718-1975-0371800-5/S0025-5718-1975-0371800-5.pdf' -O 'A Method of Factoring and the Factorization of F7(1975)(Brillhart).pdf'

wget 'https://www.ams.org/notices/199612/pomerance.pdf' -O 'A Tale of Two Sieves(1996)(Pomerance).pdf'



the class group method Factorization

wget 'https://math.uchicago.edu/~may/VIGRE/VIGRE2010/REUPapers/Akman-Duffy.pdf' -O 'class group method Factorization 1.pdf'

xxx wget 'https://www.math.columbia.edu/~warner/classes/algebraicnumbertheory2018/classgroups.pdf' -O 'CALCULATING CLASS GROUPS AND APPLICATIONS.pdf'

wget 'https://swc-math.github.io/notes/files/06BernsteinCD.pdf' -O 'class group method Factorization 2.pdf'

wget '' -O ''

Pollard-Strassen method

https://arxiv.org/abs/2202.12401
  A deterministic algorithm for finding r-power divisors
https://arxiv.org/abs/1408.2608
  A deterministic algorithm for integer factorization
  O(n**(1/3 +?))



wget 'https://arxiv.org/pdf/2202.12401.pdf' -O 'A deterministic algorithm for finding r-power divisors(2022)(Harvey).pdf' -U 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0'
wget 'https://arxiv.org/pdf/1408.2608.pdf' -O 'A deterministic algorithm for integer factorization(2014)(Hiary).pdf' -U 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0'

David Harvey, Markus Hittmeir
Download PDF
Building on work of Boneh, Durfee and Howgrave-Graham, we present a deterministic algorithm that provably finds all integers p such that pr|N in time O(N1/4r+ϵ) for any ϵ>0. For example, the algorithm can be used to test squarefreeness of N in time O(N1/8+ϵ); previously, the best rigorous bound for this problem was O(N1/6+ϵ), achieved via the Pollard--Strassen method.

https://www.arxiv-vanity.com/papers/1408.2608/
  网页版！不错！
A deterministic algorithm for integer factorization
Ghaith A. Hiary
Download PDF
A deterministic algorithm for factoring n using n1/3+o(1) bit operations is presented. The algorithm tests the divisibility of n by all the integers in a short interval at once, rather than integer by integer as in trial division. The algorithm is implemented.
The Pollard-Strassen algorithm [9, 12] uses an FFT precomputation to improve the time complexity to n **(1 / 4 + o ( 1)) bit operations and requiring n **(1 / 4 + o ( 1)) bits of storage (memory); see [1, 3, 4, 13] for example. As far as we know, this is the fastest deterministic factoring algorithm with a fully proven complexity, though it has the practical disadvantage of requiring much memory space.
  所需 内存太多



[4] Richard Crandall and Carl Pomerance, Prime numbers, second ed., Springer, New York, 2005, A computational perspective. MR 2156291 (2006a:11005)
[5] H. Davenport, The higher arithmetic, eighth ed., Cambridge University Press, Cambridge, 2008, An introduction to the theory of numbers, With editing and additional material by James H. Davenport. MR 2462408 (2009j:11001)
[6] R. Sherman Lehman, Factoring large integers, Math. Comp. 28 (1974), 637–646. MR 0340163 (49 #4919)
[7] H. W. Lenstra, Jr., Divisors in residue classes, Math. Comp. 42 (1984), no. 165, 331–340. MR 726007 (85b:11118)
[8] James McKee, Turning Euler’s factoring method into a factoring algorithm, Bull. London Math. Soc. 28 (1996), no. 4, 351–355. MR 1384821 (97f:11010)
      找不到pdf


https://math.dartmouth.edu/~carlp/
  没有 book下载
  只有 paper下载

wget_U 'http://thales.doa.fmph.uniba.sk/macaj/skola/teoriapoli/primes.pdf' -O 'Prime numbers-A Computational Perspective(2ed)(2005)(Pomerance).pdf'
  https://link.springer.com/book/10.1007/0-387-28979-8
    Includes supplementary material: sn.pub/extras
    https://extras.springer.com/?query=978-0-387-25282-7
      https://storage.googleapis.com/sgw-extras/zip/2005/978-0-387-28979-3.zip
      wget_U 'https://storage.googleapis.com/sgw-extras/zip/2005/978-0-387-28979-3.zip' -O 'Prime numbers-A Computational Perspective(2005)(Pomerance).pdf.supplementary material.zip'







https://www.researchgate.net/publication/333651440_FACTORIZATION_USING_SQUARE_ROOT_OF_A_SQUARE_BINARY_QUADRATIC_FORM
    xxx wget 'https://www.researchgate.net/profile/Anuradha-Pratha-2/publication/333651440_FACTORIZATION_USING_SQUARE_ROOT_OF_A_SQUARE_BINARY_QUADRATIC_FORM/links/5cfa0dba299bf13a384334b0/FACTORIZATION-USING-SQUARE-ROOT-OF-A-SQUARE-BINARY-QUADRATIC-FORM.pdf?_tp=eyJjb250ZXh0Ijp7ImZpcnN0UGFnZSI6InB1YmxpY2F0aW9uRGV0YWlsIiwicGFnZSI6InB1YmxpY2F0aW9uRGV0YWlsIn19' -O 'FACTORIZATION_USING_SQUARE_ROOT_OF_A_SQUARE_BINARY_QUADRATIC_FORM.pdf' -U 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0' 
    还是得靠浏览量下载
    FACTORIZATION USING SQUARE ROOT OF A SQUARE BINARY QUADRATIC FORM(2016)(Kameswari).pdf
      已下载
wget 'https://iosrjournals.org/iosr-jm/papers/Vol12-issue5/Version-3/D1205031929.pdf' -O 'Factorization via Difference of Squares using Ambiguous Forms.pdf'



wget 'https://www.ams.org/journals/mcom/1974-28-126/S0025-5718-1974-0340163-2/S0025-5718-1974-0340163-2.pdf' -O 'Factoring large integers(1974)(Lehman).pdf'
wget 'https://www.ams.org/journals/mcom/1984-42-165/S0025-5718-1984-0726007-1/S0025-5718-1984-0726007-1.pdf' -O 'Divisors in residue classes(1984)(Lenstra).pdf'
  https://www.jstor.org/stable/pdf/2007582.pdf


subproduct tree
Shank’s class group method
  better complexity of n **(1 / 5 + o ( 1)) bit operations to factor n
, but it assumes the generalized Riemann hypothesis, which is unproved so far.

[[
Shank’s class group method (see [4]) has a better complexity of n **(1 / 5 + o ( 1)) bit operations to factor n, but it assumes the generalized Riemann hypothesis, which is unproved so far.
[4] Richard Crandall and Carl Pomerance, Prime numbers, second ed., Springer, New York, 2005, A computational perspective. MR 2156291 (2006a:11005)
Prime numbers-A Computational Perspective(2ed)(2005)(Pomerance).pdf
Shanks, D., 7, 80, 236, 246, 248, 250, 347, 349, 359
pg236:However, the simple and elegant idea behind baby-steps, giant-steps is useful in many contexts, as we shall see in Section 7.5.  It also can be used for factoring, as shown in [Shanks 1971].  In fact, that paper introduced the baby-steps, giant-steps idea.  The context here is the class group of binary quadratic forms with a given discriminant.  We shall visit this method at the end of this chapter, in Section 5.6.4.
pg246:It is possible to trace through the above argument and come up with an algorithm for the composition of forms.  Here is a relatively compact procedure: it may be found in [Shanks 1971] and in [Schoof 1982].  Algorithm 5.6.7
5.6.4 Ambiguous forms and factorization
]]








https://arxiv.org/abs/1105.1456

wget 'https://arxiv.org/pdf/1105.1456.pdf' -O 'On Shanks Algorithm for Modular Square Roots(2011).pdf' -U 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0' 


baby-step giant-step algorithm 

wget 'https://iosrjournals.org/iosr-jm/papers/Vol12-issue1/Version-1/C012110916.pdf' -O 'baby-step giant-step algorithm-1.pdf'
baby-step giant-step-Shank's Baby-Step Giant-Step Attack Extended To Discrete Log with Lucas Sequences(2016)(Kameswari).pdf

wget 'https://pages.cs.wisc.edu/~sandlund/BabyStepGiantStep_Sn.pdf' -O 'baby-step giant-step algorithm-2.pdf'
baby-step giant-step-Baby-Step Giant-Step Algorithms for the Symmetric Group(2016)(Bach).pdf

wget 'https://www-users.cse.umn.edu/~saad/PDF/ys-2017-03.pdf' -O 'acceleration techniques.pdf'
acceleration techniques-SHANKS SEQUENCE TRANSFORMATIONS AND ANDERSON ACCELERATION(2017)(BREZINSKI).pdf


]]]
[[[
https://www.arxiv-vanity.com/papers/1408.2608/
===
arXiv Vanity renders academic papers from arXiv as responsive web pages so you don’t have to squint at a PDF

View this paper on arXiv
A deterministic algorithm for integer factorization
Ghaith A. Hiary
Department of Mathematics, The Ohio State University, 231 West 18th Ave, Columbus, OH 43210.
ABSTRACT.
A deterministic algorithm for factoring n using n **(1 / 3 + o ( 1)) bit operations is presented.
The algorithm tests the divisibility of n by all the integers in a short interval at once, rather than integer by integer as in trial division.
The algorithm is implemented.

Key words and phrases:
Integer factorization, algorithm, continued fraction.
2010 Mathematics Subject Classification:
Primary 11Y05.
Preparation of this material is partially supported by the National Science Foundation under agreements No. DMS-1406190 and by the Leverhulme Trust (while at the University of Bristol).
1.INTRODUCTION
One can use trial division to factor an integer n using ≤n **(1 / 2) divisions on integers of size ≤n
.
There are several algorithms that improve the running time to n **(1 / 3 + o ( 1)) bit operations without using fast Fourier transform (FFT) techniques:
    Lehman’s method [6] which “uses a dissection of the continuum similar to the Farey dissection,”
    Lenstra’s algorithm [7] which looks for divisors of n in residue classes,
    McKee’s algorithm [8] which is related to Euler’s factoring method,
    and an algorithm due to Rubinstein [11] that relies on estimates for Kloosterman sums.

The Pollard-Strassen algorithm [9, 12] uses an FFT precomputation to improve the time complexity to n **(1 / 4 + o ( 1)) bit operations and requiring n **(1 / 4 + o ( 1)) bits of storage (memory); see [1, 3, 4, 13] for example.
    As far as we know, this is the fastest deterministic factoring algorithm with a fully proven complexity, though it has the practical disadvantage of requiring much memory space.

The Coppersmith algorithm [2] for finding small roots of bivariate rational polynomials enables factoring n using n **(1 / 4 + o ( 1)) operations. This algorithm uses lattice basis reduction techniques, and it has the advantage of requiring little memory space. (However, the n **(o ( 1)) factor in the running time seems significant, involving a high power of log n .)

Shank’s class group method (see [4]) has a better complexity of n **(1 / 5 + o ( 1)) bit operations to factor n, but it assumes the generalized Riemann hypothesis, which is unproved so far.


In this paper, we present a new deterministic method for factoring n in n **(1 / 3 + o ( 1)) time.
    Like the other exponential factoring methods mentioned before, this algorithm is mainly of a theoretical interest. There are already probabilistic methods that far outperform it in practice, and in heuristically subexponential time; see [4] for a survey of such methods.
    Our goal, rather, is to present a new deterministic approach for integer factorization that we hope can be improved in the future.

2.MAIN RESULT
An integer n > 1 is composite if the equation [n = x*y] has a non-trivial integer solution ( x , y) .
    One can test whether [n = x*y] holds by testing if [(n / x)≡0 mod 1], which can be decided on dividing n by x directly, say.
    By looping through the integers 1 < x≤√n this way, one will either find a non-trivial factor of n , or, if no such factor is found, one concludes that n is prime.
    This trial division procedure is guaranteed to terminate after ≤√n steps.
The new algorithm that we present, Algorithm 1, enables a speed-up over trial division because it can test the equation [n / ( x + h)≡0 mod 1] for many integers [h∈[−H , H ]] in basically a single step.
    The observation is that, locally (i.e. if H is small enough compared to x), one can approximate (n / ( x + h)) by a linear polynomial in h with rational coefficients. The oscillations of this polynomial modulo 1 are easy to understand, due to linearity, which leads to the speed-up.
The main result is Theorem 2.1, which gives an upper bound on the complexity of Algorithm 1.
    The complexity is measured by the total number of the following operations consumed: + ,−, × , ÷ , exp , log .
    This in turn can be routinely bounded in terms of bit operations since all the numbers that occur in Theorem 2.1 can be expressed using ≪log n bits.
We will make use of some basic algorithms such as how to generate the continued fraction (CF) convergents of a rational number and how to solve a quadratic equation.
We will use the notation [ x ] to denote the nearest integer to x (if x is half an integer, we take [ x ] =⌊x⌋).

[Initialize]
set x_0 = min {⌈( 17*n) **(1 / 3)⌉,⌊√n⌋} , x = x_0 + 2 , H = 1 ;

[Trial division]
check if n has a divisor 1 < k≤ x_0 , if so return k ;

[Loop]
while( x−H≤⌊√n⌋) {
generate the CF convergents of n / x**2 , say [ b_0 / q_0 ,…, b_r / q_r ] , then find the convergent with the largest q_j≤4*H ;
set b = b_j , q = q_j , a = [ q*n / x ] ;
solve ( q*n−a*x) + ( b*x−a)*h + b*h**2 = 0
; for each integer solution h test if x + h divides n , if so return x + h ;
increment x←x + 2*H + 1 , set H =⌊( 17*n)**(−1 / 3) *x⌋;
}
return n is prime;

Algorithm 1 Given an integer n > 1 , this algorithm finds a non-trivial factor of n or proves that n is prime.

Theorem 2.1.Algorithm 1 returns a non-trivial factor of n > 1 , or proves that n is prime, using ≪n **(1 / 3) *(log n)**2 operations on numbers of ≪log n bits.

The while loop in Algorithm 1 checks for divisors of 
n
 in successive blocks of the form 
[
x
−
H
,
x
+
H
]
. The block size, 
2
H
+
1
, increases as the loop progresses. Roughly speaking, as the algorithm searches through an interval like 
[
x
,
2
x
]
, 
H
 doubles in size, increasing from 
H
≈
x
/
(
17
n
)
1
/
3
 at the beginning, to 
H
≈
2
x
/
(
17
n
)
1
/
3
 by the end. This choice of 
H
 is not optimal, in that it can be chosen larger depending on 
a
, 
b
, and 
q
; see §4. However, fixing the choice like we did simplifies the proof of Theorem 2.1 later.

One feature of Algorithm 2.1 is that, like the Pollard-Strassen method, it can be adapted to obtain partial information about the factorization of 
n
. For example, after small modifications, Algorithm 1 can rule out factors of 
n
 in a given interval 
[
z
,
z
+
w
]
, 
z
,
w
∈
Z
+
, using 
≪
(
w
n
1
/
3
/
z
+
1
)
log
(
n
+
z
+
w
)
 operations. To do so, one adjusts the trial division statement to cover the smaller range 
z
≤
k
≤
min
{
x
0
,
z
+
w
}
, then initializes 
x
=
x
0
+
2
 or 
x
=
z
+
1
 depending on whether 
z
<
x
0
 or not, and adjusts the loop statement to be 
w
h
i
l
e
(
x
−
H
≤
z
+
w
)
.

It is interesting to compare our method with the Coppersmith algorithm.1 Using the latter, one can factor 
n
=
p
q
 in poly-log time in 
n
 if the high-order 
1
4
log
2
N
 bits of 
p
 are known.2 (Here, 
log
2
 is the logarithm to base 
2
.) By comparison, our method requires more, the high-order 
1
3
log
2
N
 bits of 
p
. Therefore, our method is of a comparable strength to the algorithm of Rivest and Shamir [10], where this problem is set up in terms of integer programming in two dimensions.

3.PROOF OF THEOREM 2.1
Lemma 3.1.Let 
n
, 
x
, and 
H
 be positive integers. Then there is a rational approximation of 
n
/
x
2
 of the form
(1)		
n
x
2
=
b
q
+
ϵ
2
q
q
′
,
0
<
q
≤
4
H
≤
q
′
,
|
ϵ
2
|
<
1.
This approximation can be found using 
≪
log
(
n
+
x
)
 operations on integers of 
≪
log
(
n
+
x
)
 bits.
Proof.This follows routinely from the classical theory of continued fractions; see [5] for example. ∎
Lemma 3.2.Let 
n
≥
400
, 
x
, and 
H
 be positive integers with 
H
/
x
≤
(
17
n
)
−
1
/
3
. For each integer 
|
h
|
≤
H
, if 
n
/
(
x
+
h
)
≡
0
mod
1
 then 
h
 must be a solution of the equation 
g
n
,
x
(
y
)
:=
c
0
+
c
1
y
+
c
2
y
2
=
0
 where, letting
(2)		
n
x
=
a
q
+
ϵ
1
q
,
a
=
[
q
n
/
x
]
,
we have 
c
0
:=
x
ϵ
1
=
q
n
−
a
x
, 
c
1
:=
ϵ
1
−
x
ϵ
2
/
q
′
=
b
x
−
a
, and 
c
2
:=
n
q
/
x
2
−
ϵ
2
/
q
′
=
b
. (Here, 
q
, 
q
′
, and 
ϵ
2
 are as in Lemma 3.1.) Moreover, 
g
n
,
x
(
y
)
 does not vanish identically, so there are at most two solutions of the equation 
g
n
,
x
(
y
)
=
0
.
Proof.Since 
x
+
h
>
0
 for 
|
h
|
≤
H
, we have the identity: 
n
/
(
x
+
h
)
=
n
/
x
−
n
h
/
x
2
+
n
h
2
/
(
(
x
+
h
)
x
2
)
. Let us define 
ϵ
(
h
)
:=
ϵ
1
−
h
ϵ
2
/
q
′
+
q
n
h
2
/
(
(
x
+
h
)
x
2
)
. Then
(3)		
n
x
+
h
=
a
−
b
h
q
+
ϵ
(
h
)
q
.
Multiplying both sides by 
q
, we see that if 
n
/
(
x
+
h
)
≡
0
mod
1
 then necessarily 
a
−
b
h
+
ϵ
(
h
)
≡
0
mod
q
. In particular, since 
a
−
b
h
 is an integer, so must 
ϵ
(
h
)
; i.e. 
ϵ
(
h
)
≡
0
mod
1
. By the triangle inequality, the bound 
|
h
|
≤
H
, and the bound 
H
≤
x
/
2
, we have
(4)		
|
ϵ
(
h
)
|
≤
|
ϵ
1
|
+
∣
∣
∣
ϵ
2
H
q
′
∣
∣
∣
+
q
n
H
2
x
2
(
x
−
H
)
.
By construction, 
|
ϵ
1
|
≤
1
/
2
, 
|
ϵ
2
H
/
q
′
|
<
1
/
4
, and 
q
≤
4
H
. Since also 
H
≤
(
17
n
)
−
1
/
3
x
 by hypothesis, we obtain that 
q
n
H
2
/
(
x
2
(
x
−
H
)
)
≤
4
n
(
H
/
x
)
3
/
(
1
−
H
/
x
)
≤
(
4
/
17
)
/
(
1
−
6800
−
1
/
3
)
<
1
/
4
, where we used the assumption 
n
≥
400
. So we deduce that 
|
ϵ
(
h
)
|
<
1
/
2
+
1
/
4
+
1
/
4
=
1
. Therefore, in our situation, the congruence 
ϵ
(
h
)
≡
0
mod
1
 is equivalent to the equation 
ϵ
(
h
)
=
0
. Last, since 
(
x
+
h
)
ϵ
(
h
)
=
g
n
,
x
(
h
)
, and 
x
+
h
≠
0
, we deduce that the equations 
ϵ
(
h
)
=
0
 and 
g
n
,
x
(
h
)
=
0
 are equivalent.
For the second part of the lemma, note that if 
g
n
,
x
(
y
)
≡
0
, then 
c
0
=
c
1
=
c
2
=
0
. Since 
c
0
=
0
 then 
ϵ
1
=
0
. And since 
c
1
=
0
 also, we deduce that 
ϵ
2
=
0
. But then 
c
2
=
n
q
/
x
2
−
ϵ
2
/
q
′
=
n
q
/
x
2
≠
0
. ∎

Proof of Theorem 2.1.We choose integers 
1
<
x
0
<
x
1
⋯
, and 
1
≤
H
1
≤
H
2
≤
…
, and define the following sequence of intervals: 
B
0
:=
[
2
,
x
0
]
, 
B
1
:=
[
x
1
−
H
1
,
x
1
+
H
1
]
, 
B
2
:=
[
x
2
−
H
2
,
x
2
+
H
2
]
,
…
. Specifically, we choose 
x
0
:=
⌈
(
17
n
)
1
/
3
⌉
, 
x
1
:=
x
0
+
2
, 
H
1
=
1
, and, for 
j
≥
2
, we let 
x
j
:=
x
j
−
1
+
2
H
j
−
1
+
1
 where 
H
j
:=
⌊
(
17
n
)
−
1
/
3
x
j
⌋
. So 
1
≤
H
1
≤
H
2
≤
⋯
, and therefore 
B
0
∪
⋯
∪
B
j
 covers the interval 
[
2
,
x
j
]
 completely. We use trial division to search for a factor of 
n
 in 
B
0
 using 
≪
n
1
/
3
 operations. If a factor is found, then it is returned and the algorithm reaches an end point. Otherwise, we successively search for a factor in the intervals 
B
j
=
[
x
j
+
H
j
,
x
j
−
H
j
]
. We note at this point that if 
n
<
400
 then the algorithm reaches an end after searching 
B
0
. This is because 
x
0
=
⌈
(
17
n
)
1
/
3
⌉
≥
⌊
√
n
⌋
 for 
n
<
400
, as can be checked by direct computation, and this implies that the algorithm will not enter the while loop. So, in analyzing the Loop phase of the algorithm, we may assume that 
n
≥
400
. Furthermore, we observe that 
H
j
/
x
j
≤
(
17
n
)
−
1
/
3
 by construction, and so 
n
, 
x
j
, and 
H
j
 satisfy the hypothesis of Lemma 3.2. Thus, applying the Lemma to 
B
j
, one can quickly locate all the divisors of 
n
 in that block (if any) using 
≪
log
(
n
+
x
j
)
 operations on numbers of 
≪
log
(
n
+
x
j
)
 bits. This is mainly the cost of finding the rational approximation in Lemma 3.1 via the continued fraction representation of 
n
/
x
2
, then solving the resulting quadratic equation. Last, we only need to search 
B
j
 that satisfy 
B
j
∩
[
2
,
⌊
√
n
⌋
]
≠
∅
; i.e. 
x
j
−
H
j
≤
√
n
. This is because if no factor is found in these 
B
j
, then one will have proved 
n
 prime. Given this, it is easy to show that the total number of blocks that need to be searched is 
≪
n
1
/
3
log
(
2
+
n
/
x
0
)
. Since 
n
≥
2
 by hypothesis, this is 
≪
n
1
/
3
log
n
, which yields the result. ∎
4.IMPLEMENTATION
We implemented Algorithm 1 in Mathematica. The implementation is available at https://people.math.osu.edu/hiary.1/factorTest.nb. We were able to reduce the running time by about 
20
%
 by choosing the block size asymmetrically about 
x
. From the left we set 
H
L
=
⌊
(
17
n
)
−
1
/
3
x
⌋
, which is the same as in Algorithm 1, and from the right we set 
H
R
=
min
{
H
R
,
1
,
H
R
,
2
}
 where 
H
R
,
1
=
⌊
0.4
(
1
−
|
ϵ
1
|
)
q
′
/
|
ϵ
2
|
⌋
 and 
H
R
,
2
=
⌊
√
0.6
(
1
−
|
ϵ
1
|
)
x
3
/
(
q
n
)
)
⌋
. Also, we required that 
q
≤
4
H
L
. Together, this ensured that 
|
ϵ
(
h
)
|
<
1
 for 
−
H
L
≤
h
≤
H
R
, as needed, and it allowed a larger block size. This is because 
H
R
 will be at least the size of 
H
L
, but it can get much larger if 
|
ϵ
2
/
q
′
|
 and 
q
 happened to be small; e.g. if 
n
/
x
2
 can be approximated well by a rational with a small denominator. To take advantage of the larger block size in the implementation, we incremented 
x
←
x
+
H
L
+
H
R
+
1
 instead of 
x
←
x
+
2
H
L
+
1
.

Our implementation of Lemma 3.1 became faster, on average, than trial division when 
H
L
≳
50
. So we used trial division in the interval 
[
2
,
⌈
50
(
17
n
)
1
/
3
]
⌉
]
. The running time of the full algorithm started to beat trial division when 
n
≳
10
14
, with 
n
 a product of two primes of roughly equal size. The algorithm is about two times faster than trial division when 
n
≈
10
18
. This running time can be expected to improve using a more careful implementation; e.g. one need not generate all the continued fraction convergents of 
n
/
x
2
, as done now, but only the convergents with denominator 
≤
4
H
L
.

REFERENCES
[1] Alin Bostan, Pierrick Gaudry, and Éric Schost, Linear recurrences with polynomial coefficients and application to integer factorization and Cartier-Manin operator, SIAM J. Comput. 36 (2007), no. 6, 1777–1806. MR 2299425 (2008a:11156)
[2] Don Coppersmith, Finding a small root of a bivariate integer equation; factoring with high bits known, Advances in cryptology—EUROCRYPT ’96 (Saragossa, 1996), Lecture Notes in Comput. Sci., vol. 1070, Springer, Berlin, 1996, pp. 178–189. MR 1421585 (97h:94009)
[3] Edgar Costa and David Harvey, Faster deterministic integer factorization, Math. Comp. 83 (2014), no. 285, 339–345. MR 3120593
[4] Richard Crandall and Carl Pomerance, Prime numbers, second ed., Springer, New York, 2005, A computational perspective. MR 2156291 (2006a:11005)
[5] H. Davenport, The higher arithmetic, eighth ed., Cambridge University Press, Cambridge, 2008, An introduction to the theory of numbers, With editing and additional material by James H. Davenport. MR 2462408 (2009j:11001)
[6] R. Sherman Lehman, Factoring large integers, Math. Comp. 28 (1974), 637–646. MR 0340163 (49 #4919)
[7] H. W. Lenstra, Jr., Divisors in residue classes, Math. Comp. 42 (1984), no. 165, 331–340. MR 726007 (85b:11118)
[8] James McKee, Turning Euler’s factoring method into a factoring algorithm, Bull. London Math. Soc. 28 (1996), no. 4, 351–355. MR 1384821 (97f:11010)
[9] J. M. Pollard, Theorems on factorization and primality testing, Proc. Cambridge Philos. Soc. 76 (1974), 521–528. MR 0354514 (50 #6992)
[10] Ronald L. Rivest and Adi Shamir, Efficient factoring based on partial information, Advances in cryptology—EUROCRYPT ’85 (Linz, 1985), Lecture Notes in Comput. Sci., vol. 219, Springer, Berlin, 1986, pp. 31–34. MR 851581
[11] Michael O. Rubinstein, The distribution of solutions to 
x
y
=
n
(
mod
a
)
 with an application to factoring integers, Integers 13 (2013), Paper No. A12, 20. MR 3083474
[12] Volker Strassen, Einige Resultate über Berechnungskomplexität, Jber. Deutsch. Math.-Verein. 78 (1976/77), no. 1, 1–8. MR 0438807 (55 #11713)
[13] O. N. Vasilenko, Number-theoretic algorithms in cryptography, Translations of Mathematical Monographs, vol. 232, American Mathematical Society, Providence, RI, 2007, Translated from the 2003 Russian original by Alex Martsinkovsky. MR 2273200 (2007g:11160)
Want to hear about new tools we're making? Sign up to our mailing list for occasional updates.

Enter your email address
 
Subscribe

If you find a rendering bug, file an issue on GitHub. Or, have a go at fixing it yourself – the renderer is open source!

For everything else, email us at feedback@arxiv-vanity.com.

A project from Replicate, with help from LaTeXML. Contribute on GitHub. Latest papers.
]]]

[[[
https://math.stackexchange.com/questions/185524/pollard-strassen-algorithm
===
http://web.maths.unsw.edu.au/~davidharvey/talks/factoring.pdf
http://algo.inria.fr/bostan/publications/BoGaSc07.pdf
http://www.issac-conference.org/2010/assets/AFAMCA3.pdf
xxx wget 'http://web.maths.unsw.edu.au/~davidharvey/talks/factoring.pdf' -O 'Pollard-Strassen algorithm-subproduct tree-slide.pdf'
xxx wget 'http://algo.inria.fr/bostan/publications/BoGaSc07.pdf' -O 'Pollard-Strassen algorithm-subproduct tree-Main algorithmic ideas(2007).pdf'
wget 'http://specfun.inria.fr/bostan/publications/BoSc05.pdf' -O 'Pollard-Strassen algorithm-subproduct tree-Polynomial evaluation and interpolation on special sets of points(2005)(Bostan).pdf'


wget 'http://www.issac-conference.org/2010/assets/AFAMCA3.pdf' -O 'Pollard-Strassen algorithm-subproduct tree-Asymptotically fast algorithms for modern computer algebra(2010).pdf'
===
===
Pollard-Strassen Algorithm
Asked 11 years ago
Modified 5 years, 1 month ago
Viewed 12k times
16

I'm aware that the Pollard-Strassen algorithm can be used to find all prime factors of n not exceeding B in O(nϵB1/2) time. This is really useful because I need to find all factors less than n1/3 to determine if n is squarefree, which could therefore theoretically be done in O(n1/6+ϵ).

However I can't find anything more than a brief overview of the algorithm itself, let alone a worked example. Could anyone provide a detailed explanation or example, or reference to where I can find one? Additionally, I'm interested in other algorithms, if they exist, which provide all factors not exceeding B=⌈n1/3⌉ quickly.

number-theoryreference-requestalgorithmsprime-numbersfactoring
Share
Cite
Follow
edited Aug 22, 2012 at 18:04
MJD's user avatar
MJD
64.3k3838 gold badges289289 silver badges544544 bronze badges
asked Aug 22, 2012 at 17:39
LordLing's user avatar
LordLing
16311 gold badge11 silver badge55 bronze badges
I was going to write it myself, but a quick google search lead me to this. Unless the algorithm you wanted is not this.. – 
Karolis Juodelė
 Aug 22, 2012 at 19:03
1
Actually those are both Pollard's rho algorithm. It's a probabilistic algorithm and also only works at finding factors of any size, not less than a specific bound. – 
LordLing
 Aug 22, 2012 at 21:49
I should add: you can see how it's difficult for me to track down this algorithm's details though! :) There are only a few mentions of it. – 
LordLing
 Aug 22, 2012 at 21:51
The method is also described in the book Prime Numbers by Crandall and Pomerance (2005), in the chapter 5.5 Polynomial evaluation method. – 
minmax
 Jul 6, 2018 at 21:12
This arXiv paper appeared 4 years after your question. You may be interested in it and its references. – 
user21820
 Jul 9, 2018 at 2:14
Add a comment
1 Answer
Sorted by:

Highest score (default)
14

The basic idea of Strassen's factorization method is that if you have the product fi of a consecutive set of integers modulo the number to be factored n, and that set of integers contains one the factors of n, then gcd(fi,n) will be greater than unity. The trick then is to compute fi for non-overlapping sets of possible factors quickly.

Here is a brute-force example that shows how the 9th block of numbers reveals 293 as a factor of 1000009:

var n = (BigInteger)1000009;
var c = (int)Math.Floor(Math.Pow((double)n, 0.25));
var f = new BigInteger[c];
for (var i = 0; i < c; i++)
{
    f[i] = 1;
    var jmin = 1 + i * c;
    var jmax = jmin + c - 1;
    for (var j = jmin; j <= jmax; j++)
        f[i] = f[i] * j % n;
}
for (var i = 0; i < c; i++)
{
    var factor = BigInteger.GreatestCommonDivisor(f[i], n);
    if (factor != 1)
    {
        Console.WriteLine("i = {0}, factor = {1}", i, factor);
        break;
    }
}
The second for-loop takes O(n1/4logn), and so the hard work of the algorithm is to compute fi in faster than the O(n1/2) demonstrated in the first for-loop above. How this is done is by using subproduct trees and multipoint evaluation.
    Here is a slide presentation that describes the details pretty well.
      http://web.maths.unsw.edu.au/~davidharvey/talks/factoring.pdf
    Also this paper (search for "Main algorithmic ideas") has a good high level overview of the algorithm.
      http://algo.inria.fr/bostan/publications/BoGaSc07.pdf
    Finally, subproduct trees are given a good treatment in this presentation, Asymptotically fast algorithms for modern computer algebra.
      http://www.issac-conference.org/2010/assets/AFAMCA3.pdf

Share
Cite
Follow
answered Aug 23, 2012 at 0:45
Rick Sladkey's user avatar
Rick Sladkey
92311 gold badge99 silver badges1010 bronze badges
Should that 0.25 be 0.34? – 
6c1
 Nov 13, 2012 at 14:07
Add a comment
===
]]]

[[[
https://handwiki.org/wiki/Continued_fraction_factorization
===
Continued fraction factorization
From HandWiki

In number theory, the continued fraction factorization method (CFRAC) is an integer factorization algorithm. It is a general-purpose algorithm, meaning that it is suitable for factoring any integer n, not depending on special form or properties. It was described by D. H. Lehmer and R. E. Powers in 1931,[1] and developed as a computer algorithm by Michael A. Morrison and John Brillhart in 1975.[2] The continued fraction method is based on Dixon's factorization method. It uses convergents in the regular continued fraction expansion of

[math]\displaystyle{ \sqrt{kn},\qquad k\in\mathbb{Z^+} }[/math].
Since this is a quadratic irrational, the continued fraction must be periodic (unless n is square, in which case the factorization is obvious).

It has a time complexity of [math]\displaystyle{ O\left(e^{\sqrt{2\log n \log\log n}}\right)=L_n\left[1/2,\sqrt{2}\right] }[/math], in the O and L notations.[3]

References
 Lehmer, D.H.; Powers, R.E. (1931). "On Factoring Large Numbers". Bulletin of the American Mathematical Society 37 (10): 770–776. doi:10.1090/S0002-9904-1931-05271-X.
 Morrison, Michael A.; Brillhart, John (January 1975). "A Method of Factoring and the Factorization of F7". Mathematics of Computation (American Mathematical Society) 29 (129): 183–205. doi:10.2307/2005475.
 Pomerance, Carl (December 1996). "A Tale of Two Sieves". Notices of the AMS 43 (12): pp. 1473–1485.
Further reading
Samuel S. Wagstaff, Jr. (2013). The Joy of Factoring. Providence, RI: American Mathematical Society. pp. 143–171. ISBN 978-1-4704-1048-3.
Integer factorization	
Continued fraction (CFRAC)Dixon'sLenstra elliptic curve (ECM)Euler'sPollard's rhop − 1p + 1Quadratic sieve (QS)General number field sieve (GNFS)Special number field sieve (SNFS)Rational sieveFermat'sShanks's square formsTrial divisionShor's
Modular square root	
CipollaPocklington'sTonelli–ShanksBerlekamp
Other algorithms	
ChakravalaCornacchiaExponentiation by squaringInteger square rootLLLModular exponentiationMontgomery reductionSchoof's
Italics indicate that algorithm is for numbers of special forms


Public domain	
0.00
 (0 votes)
Original source: https://en.wikipedia.org/wiki/Continued fraction factorization. Read more

Category: Integer factorization algorithms
]]]



