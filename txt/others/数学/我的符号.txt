
e others/数学/我的符号.txt

语句前缀:
『:>』=[def]=『定义/let』
『!!』=[def]=『因为』
『=>』=[def]=『所以』
『_L』=[def]=『悖论/矛盾』
『[...]:』=[def]=『前提/假设:后附缩进推论序列』
例子:
  :> [(q,r) := a/%b]
  !! [(q,r) := a/%b]
  => [a == q*b+r][0 <= r < b]
  『!!』通用，但『:>』『=>』主要用于:等不等式序列中
  [expr1
  == ...
  :> [...]
  => [...]
  >= ...
  >= ...
  ]


表达式/命题:
『[...命题/表达式...]』=[def]=『真值』
『:=』=[def]=『赋值/定义变量』
『:=>』=[def]=『定义变量满足后面的条件/s.t.』
『->』=[def]=『蕴含』
『<->』=[def]=『等价于/当且仅当/iff』
『@』=[def]=『任意/所有:定义/引入变量』
『?』=[def]=『存在:定义/引入变量』
『\』=[def]=『匿名函数:定义/引入变量』
『$』=[def]=『递归函数:定义/引入变量』
『::』=[def]=『左操作数是右操作数的实例对象/右操作数是左操作数的类型』
    # [@[x :: int] -> ?[y :: int] -> [y < x]]
    # [$公共知识牜知道版 :: [@[fact::Prop] -> [[fact][@[x::Agent] -> [know_(公共知识牜知道版 fact;x)]]]]]
    #   ++『$』@20250904:公共知识: view ../lots/NOTE/博弈论/怪诞博弈论.txt
『<:』=[def]=『左操作数是右操作数的子类型』
『|<=|』=[def]=『被包含/左操作数是右操作数的子集』
『<-』=[def]=『属于/左操作数是右操作数的元素』
『:<-』=[def]=『任意元素/提取任一元素』
  [@[A,B :: Set] -> [A |<=| B] -> [a :<- A] -> [a <- B]]
  <==>
  [@[A,B :: Set] -> [A |<=| B] -> @[a :<- A] -> [a <- B]]
  <==>
  [@[A,B :: Set] -> [A |<=| B] -> @[a <- A] -> [a <- B]]
『/%』=[def]=『divmod』


view ../lots/NOTE/PTS/idea\ -\ syntax\ design\[working].txt
  #新解释/新对比:
    #确定性算法耂赋值『:=』
    #随机性算法耂赋值『:<-』
      #view others/数学/编程/密码学/加密框架之其他可能.txt
      # 『:<-』的新含义:源起: '/sdcard/0my_files/book/cryptography/Introduction to Modern Cryptography(2th)(2015)(Jonathan Katz)(Yehuda Lindell).pdf'
      #或视为从『集合纟输出』以某种概率分布选中一个输出

    two qualifier for ":<-":
summation
离散:求和:sum[f(j) | [j:<-[0..=9]]]
product
离散:求积:II[f(j) | [j:<-[0..=9]]]
integral
连续:定积分:SS{f(t) | [t:<~ 0~>9]}
  [x::real]:
    [num_primes_le(x) =[def]= len{p | [[p :: prime][p < x]]}]
    # Li(x):the function logarithmic integral of x
    [Li(x) =[def]= SS{1/ln(t) | [t :<~ 2 ~> x]}]
  [[N>=1] -> [num_primes_le(N) == num_primes_le(floor_sqrt(N)) -1+sum[mu(d)*(N//d) | [[d:<-all_divisors_of(II[p | [[p::prime][p**2<=N]]])][d<=N]]]]]
  [num_primes_le(x) /~/ Li(x) /~/ x/ln(x)]
    #Li更佳:
    #??? [(abs(Li(x) -num_primes_le(x))) = o(abs(x/ln(x) -num_primes_le(x)))]
  [num_primes_le(PRIMES_S1[n]) == n]
  [PRIMES_S1[1+num_primes_le(x)] == min_prime_gt_(x)]

