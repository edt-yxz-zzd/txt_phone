
e others/数学/不可约多项式/不可约多项式牜特色用途.txt
view /storage/emulated/0/0my_files/book/math/fxtbook[Matters Computational][Algorithms for Programmers].pdf

二域:GF(2**n):
不可约多项式:p(x):
  #irreducible
  [(ZZ%2)[x]%p(x) ~=~ GF(2**deg(p))]
  用途:field_polynomial:表达有限域元素暨有限域加法乘法

  ######################
  * 本原不可约多项式:p(x):
    #primitive
    [(x)是 有限域(ZZ%2)[x]%p(x)的 本原根]
    用途:LFSR线性反馈移位寄存器:PRNG伪随机数生成器:CRC循环冗余码校验
      CRC:(Cyclic Redundancy Check)[#散列算法:视输入爻元串为多项式，取模作为摘要输出#]
        [多项式冃摘要{爻元串冃输入[:0]} := 初始值 %p(x)]
        [多项式冃摘要{爻元串冃输入[:k+1]} := ((多项式冃摘要{爻元串冃输入[:k]}*x)+爻元串冃输入[k]) %p(x)]

  ######################
  * [deg(x**(1/2) %p(x)) <= (deg(p(x))+1)//2]:
    用途:方便多项式开平方
    [n := deg(p(x))]
    [deg(x**(1/2)) <= (n+1)//2]
    特色算法:开平方:
      一次半精度乘法，无需求模
        需求:保存预先计算的x**(1/2)
      ?[(even(x),odd(x)) :=> [f(x) == even(x**2)+x*odd(x**2)]]
      [f(x)**(1/2)
      == even(x**2)**(1/2)+x**(1/2)*odd(x**2)**(1/2)
      == even(x)+x**(1/2)*odd(x)
        #注意:even(x),odd(x),x**(1/2) 的 次数 只有 p(x)的次数的一半
        #结果的次数 小于 p(x)，无需取模
        !! [deg(f(x)) <= n-1]
         [deg(even(x)) <= deg(f(x))//2 == (n-1)//2]
        [deg(odd(x)) <= (deg(f(x))-1)//2 == (n-2)//2]
        !! [deg(x**(1/2)) <= (n+1)//2]
        [deg(even(x)+x**(1/2)*odd(x))
        == max(deg(even(x)), deg(x**(1/2))+deg(odd(x)))
        <= max((n-1)//2, (n+1)//2+(n-2)//2)
        == max((n-1)//2, (n-1)//2+n//2)
        == (n-1)//2+n//2
        == (2*n-1)//2
        == n-1
        < n
        ]
      ]


    例如: [p(x) == 1+x*B(x)**2][最简情形]:
        # B(x)必然存在，只是可能需要 预先计算，那还不如 直接保存 x**(1/2)
    !! [x*B(x)**2 =[%p(x)]= 1]
    [(x*B(x))**2 == x* x*B(x)**2 == x]
    [x**(1/2) == x*B(x)]
      #注意只用于:最简情形
      #通用情形则直接保存x**(1/2)即x**(2**(n-1))
    [B(x) == x**(-1/2) == x**(2**(n-1)-1)]
    #######
    [n := deg(p(x))]
    [h := deg(B(x))]
    最简情形:[0 <= h < n/2]:
      !! [(a+b)**2 =[%2]= (a**2+b**2)]
      [p(x) == 1+sum [b[k]*x**(2*k+1) | [k :<- [0..=h]]]]
        # 即 除了最低阳爻，高位阳爻都处于奇数位
      [deg(p(x)) == n == (1+2*h)]
      [h == (n-1)///2]
      !! [deg(B(x)) == h == (n-1)/2]
      !! [x**(1/2) == x*B(x)]
      [deg(x**(1/2)) <= deg(x*B(x)) == 1+h == (n+1)//2]
      [deg(x**(1/2)) == (n+1)//2]
        #即:此配置满足前置条件
        #即:优化开平方
    通用情形:[0 <= h < n]:
      #即:此配置未必满足前置条件
      [B(x)
      == ((p(x)-1)*x**-1)**(1/2)
      == x**(-1/2)
      == x**(1/2) /x
      # 使用下面:通用算法:开平方
      == x**(2**(n-1)) /x
      == x**(2**(n-1)-1)
      ]

    通用算法:倒数:
      !! [[a =!= 0] -> [a**(2**n-1) == 1]]
       [[a =!= 0] -> [a**(2**n-2) == a**-1]]
       [[f(x) =!= 0] -> [f(x)**-1 == f(x)**(2**n-2)]]
    通用算法:开平方:
      !! [a**(2**n) == a]
      [a**(2**(n-1)) == a**(1/2)]
      [f(x)**(1/2) == f(x)**(2**(n-1))]

  ######################
  * 规范不可约多项式:p(x):
    #normal
    规范 =[def]= [p(x)]
  ######################


本底域是二域:
[minimal_polynomial(w;x) =[def]= binary irreducible_polynomial whose has w as zero]
[minimal_polynomial(w;x) == II [(x-wzk) | {wzk := w**2**k | [k :<- [0..]]}]]
  {wzk} - w的所有共轭根
  !! 本底域是二域
  minimal_polynomial 系数 皆为 ZZ%2 #{0,1}
bug:[minimal_polynomial <: primitive_irreducible_polynomial]
  例如:GF(2**6)本原根的阶为63，必然有阶为9的元素w；整除9的(2**i-1)的i不能小于6，故而w的最小多项式的次数为6，模域同构于GF(64)；而w不是GF(64)本原根，其最小多项式也就不是本原不可约多项式。
    >>> [(i, 2**i%9) for i in range(7)]
    [(0, 1), (1, 2), (2, 4), (3, 8), (4, 7), (5, 5), (6, 1)]
