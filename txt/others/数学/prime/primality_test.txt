
e others/数学/prime/primality_test.txt
[[
Carmichael number
===
[n :<- [2..]]:
    [[n is Carmichael number] =[def]= [[not$ is_prime_(n)][@[g :<- [0..<n]] -> [gcd(g,n)==1] -> [g**(n-1) %n == 1]]]]
[[n is Carmichael number] <-> [n <- [2..]][not$ is_prime_(n)][max_order_mod_(n) \\\ (n-1)]]
===
Carmichael number:
    [8911 == 7*19*67]
      [8911 is 3-SPRP] #A020229
    [15841 == 7*31*73]
      [15841 is 2-SPRP] #A001262
    #   [561 == 3*11*17]
    #   [1105 == 5*13*17]
    #   [1729 == 7*13*19]
    ######################
    proof:
    [(8911-1) == 2* 3**4 *5*11]
    [max_order_mod_(8911) == lcm(7-1,19-1,67-1) == 2* 3**2 *11]
    [max_order_mod_(8911) \\\ (8911-1)]
    [8911 is Carmichael number]

    [(15841-1) == 2**5 * 3**2 *5*11]
    [max_order_mod_(15841) == lcm(7-1,31-1,73-1) == 2**3 * 3**2 *5]
    [max_order_mod_(15841) \\\ (15841-1)]
    [15841 is Carmichael number]
===
view ../../python3_src/nn_ns/math_nn/numbers/_patch_prime_.py
view ../../python3_src/nn_ns/math_nn/numbers/_patch_prime_..b001918.b002233.out.txt
3,5,7,11,13,17,19,31,67,73,
2,2,3, 2, 2, 3, 2, 3, 2, 5,
    # [2 == the_least_positive_primitive_root_mod_(11)]
    # [3 == the_least_positive_primitive_root_mod_(31)]
===
]]


[[
pseudoprime
strong pseudoprime

probable-prime (PRP)
strong probable-prime (SPRP)
  b-SPRP
Extended Riemann Hypothesis (ERH)

[n,b :: int][n =!= 0][b%n =!= 0]:
    [is_strong_pseudoprime_(b;n) =[def]= [[n >= 3][n%2==1][(e,t) :=> [[e,t :: pint][t%2==1][t*2**e == n-1]]][[b**t %n == +1]or[?[s :<- [0..<e]] -> [(b**t)**(2**s) %n == -1]]]]]

    [[is_strong_pseudoprime_(b;n)] -> [gcd(n,b) == 1]]
[[Extended Riemann Hypothesis (ERH)] -> @[n :: int] -> [n > 0] -> [n%2==1] -> [[is_prime_(n)] <-> [@[b :<- [2..<min(n, 2*(log n)**2)]] -> [is_strong_pseudoprime_(b;n)]]]]
  # what is the base of log?
==>>:
!! [2 < e ~= 2.718281828459045 < 10]
[[Extended Riemann Hypothesis (ERH)] -> @[n :: int] -> [n > 0] -> [n%2==1] -> [[is_prime_(n)] <-> [@[b :<- [2..<min(n, 2*(ceil_log2 n)**2)]] -> [is_strong_pseudoprime_(b;n)]]]]
==>>:
!! [[is_strong_pseudoprime_(b;n)] -> [gcd(n,b) == 1]]
[[Extended Riemann Hypothesis (ERH)] -> @[n :: int] -> [n > 0] -> [n%2==1] -> [[is_prime_(n)] <-> [@[b :<- [2..<min(1+floor_sqrt(n), 2*(ceil_log2 n)**2)]] -> [is_strong_pseudoprime_(b;n)]]]]
  # switch to trial_division
]]


[[
wget https://oeis.org/A001262/b001262.txt
view /sdcard/Download/b001262.txt
1 2047
2 3277
3 4033
...
9998 142873722181
9999 142876490401
10000 142899381901
>>> (142899381901).bit_length()
38
>>> 2**37 < 142899381901 < 2**38
True
]]


[[
>>> (10**12).bit_length()
40
>>> 2**39 < 10**12 < 2**40
True
>>> len(str(2**64))
20
>>> 10**19 < 2**64 < 10**20
True
>>> len(str(2**32))
10
>>> 10**9 < 2**32 < 10**10
True
>>>
]]

[[[
https://en.wikipedia.org/wiki/Strong_pseudoprime
===
A strong pseudoprime is a composite number that passes the Miller–Rabin primality test. All prime numbers pass this test, but a small fraction of composites also pass, making them "pseudoprimes".
]]]

[[[
https://mathworld.wolfram.com/StrongPseudoprime.html
===
Strong Pseudoprime

A strong pseudoprime to a base a is an odd composite number n with n-1=d·2^s (for d odd) for which either

 a^d=1 (mod n) 	
(1)
or

 a^(d·2^r)=-1 (mod n) 	
(2)
for some r=0, 1, ..., s-1 (Riesel 1994, p. 91). Note that Guy (1994, p. 27) restricts the definition of strong pseudoprimes to only those satisfying (1).

The definition is motivated by the fact that a Fermat pseudoprime n to the base b satisfies

 b^(n-1)-1=0 (mod n). 	
(3)
But since n is odd, it can be written n=2m+1, and

 b^(2m)-1=(b^m-1)(b^m+1)=0 (mod n). 	
(4)
If n is prime, it must divide at least one of the factors, but can't divide both because it would then divide their difference

 (b^m+1)-(b^m-1)=2. 	
(5)
Therefore,

 b^m=+/-1 (mod n), 	
(6)
so write n=2^at+1 to obtain

 b^(n-1)-1=(b^t-1)(b^t+1)(b^(2t)+1)...(b^(2^(a-1)t)+1). 	
(7)
If n divides exactly one of these factors but is composite, it is a strong pseudoprime. A composite number is a strong pseudoprime to at most 1/4 of all bases less than itself (Monier 1980, Rabin 1980). The strong pseudoprimes provide the basis for Miller's primality test and Rabin-Miller strong pseudoprime test.

A strong pseudoprime to the base a is also an Euler pseudoprime to the base a (Pomerance et al. 1980). The strong pseudoprimes include some Euler pseudoprimes, Fermat pseudoprimes, and Carmichael numbers.

The following table lists the first few pseudoprimes to a number of small bases.

b	OEIS	b-strong pseudoprimes
2	A001262	2047, 3277, 4033, 4681, 8321, ...
3	A020229	121, 703, 1891, 3281, 8401, 8911, ...
4	A020230	341, 1387, 2047, 3277, 4033, 4371, ...
5	A020231	781, 1541, 5461, 5611, 7813, ...
6	A020232	217, 481, 1111, 1261, 2701, ...
7	A020233	25, 325, 703, 2101, 2353, 4525, ...
8	A020234	9, 65, 481, 511, 1417, 2047, ...
9	A020235	91, 121, 671, 703, 1541, 1729, ...
The number of strong 2-pseudoprimes less than 10^3, 10^4, ... are 0, 5, 16, 46, 162, ... (OEIS A055552). Note that Guy's (1994, p. 27) definition gives only the subset 2047, 4681, 15841, 42799, 52633, 90751, ..., giving counts inconsistent with those in Guy's table.

The strong k-pseudoprime test for k=2, 3, 5 correctly identifies all primes below 2.5×10^(10) with only 13 exceptions, and if 7 is added, then the only exception less than 2.5×10^(10) is 3215031751. Jaeschke (1993) showed that there are only 101 strong pseudoprimes for the bases 2, 3, and 5 less than 10^(12), nine if 7 is added, and none if 11 is added. Also, the bases 2, 13, 23, and 1662803 have no exceptions up to 10^(12).

If n is composite, then there is a base for which n is not a strong pseudoprime. There are therefore no "strong Carmichael numbers." Let psi_k denote the smallest strong pseudoprime to all of the first k primes taken as bases (i.e., the smallest odd number for which the Rabin-Miller strong pseudoprime test on bases less than or equal to the kth prime p_k fails). Jaeschke (1993) computed psi_k from k=5 to 8 and gave upper bounds for k=9 to 11.

psi_1	=	2047	
(8)
psi_2	=	1373653	
(9)
psi_3	=	25326001	
(10)
psi_4	=	3215031751	
(11)
psi_5	=	2152302898747	
(12)
psi_6	=	3474749660383	
(13)
psi_7	=	341550071728321	
(14)
psi_8	=	341550071728321	
(15)
psi_9	<=	3825123056546413051	
(16)
psi_(10)	<=	3825123056546413051	
(17)
psi_(11)	<=	3825123056546413051	
(18)
(OEIS A014233), where the bounds for psi_9, psi_(10), and psi_(11) were determined by Zhang and Tang (2003). A seven-step test utilizing older bounds on these results (Riesel 1994) allows all numbers less than 3.4×10^(14) to be tested.

Zhang (2001, 2002, 2005, 2006, 2007) conjectured that

psi_9	=	3825123056546413051	
(19)
psi_(10)	=	3825123056546413051	
(20)
psi_(11)	=	3825123056546413051	
(21)
psi_(12)	=	318665857834031151167461	
(22)
psi_(13)	=	3317044064679887385961981	
(23)
psi_(14)	=	6003094289670105800312596501	
(24)
psi_(15)	=	59276361075595573263446330101	
(25)
psi_(16)	=	564132928021909221014087501701	
(26)
psi_(17)	=	564132928021909221014087501701	
(27)
psi_(18)	=	1543267864443420616877677640751301	
(28)
psi_(19)	=	1543267864443420616877677640751301	
(29)
psi_(20)	>	10^(36).	
(30)
The Baillie-PSW primality test is a test based on a combination of strong pseudoprimes and Lucas pseudoprimes proposed by Pomerance et al. (Pomerance et al. 1980, Pomerance 1984).

SEE ALSO
Baillie-PSW Primality Test, Carmichael Number, Miller's Primality Test, Poulet Number, Pseudoprime, Rabin-Miller Strong Pseudoprime Test, Rotkiewicz Theorem, Strong Elliptic Pseudoprime, Strong Lucas Pseudoprime
]]]
[[[
https://mathworld.wolfram.com/Rabin-MillerStrongPseudoprimeTest.html
===
Rabin-Miller Strong Pseudoprime Test
A primality test that provides an efficient probabilistic algorithm for determining if a given number is prime. It is based on the properties of strong pseudoprimes.

The algorithm proceeds as follows. Given an odd integer n, let n=2^rs+1 with s odd. Then choose a random integer a with 1<=a<=n-1. If a^s=1 (mod n) or a^(2^js)=-1 (mod n) for some 0<=j<=r-1, then n passes the test. A prime will pass the test for all a.

The test is very fast and requires no more than (1+o(1))lgn multiplications (mod n), where lg is the logarithm base 2. Unfortunately, a number which passes the test is not necessarily prime. Monier (1980) and Rabin (1980) have shown that a composite number passes the test for at most 1/4 of the possible bases a. If N multiple independent tests are performed on a composite number, then the probability that it passes each test is 1/4^N or less.

However, if the smallest composite number that passes a particular set of tests is known ahead of time, then that set of tests constitutes a primality proof for all smaller numbers. The sequence of smallest odd numbers passing a multiple Rabin-Miller test using the first k primes for k=1, 2, ... is given by 2047, 1373653, 25326001, 3215031751, 2152302898747, 3474749660383, 341550071728321, 341550071728321, ... (OEIS A014233; Jaeschke 1993). Therefore, multiple Rabin tests using the first 7 primes (using 8 gives no improvement) are valid for every number up to 3.4×10^(14).

The Wolfram Language implements the multiple Rabin-Miller test in bases 2 and 3 combined with a Lucas pseudoprime test as the primality test used by the function PrimeQ[n]. As of 1997, this procedure is known to be correct only for all n<10^(16), but no counterexamples are known and if any exist, they are expected to occur with extremely small probability (i.e., much less than the probability of a hardware error on a computer performing the test).

SEE ALSO
Baillie-PSW Primality Test, Lucas-Lehmer Test, Miller's Primality Test, Primality Test, Pseudoprime, Strong Pseudoprime
]]]
[[[
https://mathworld.wolfram.com/CarmichaelCondition.html
===
Carmichael Condition
A number n satisfies the Carmichael condition iff (p-1)|(n/p-1) for all prime divisors p of n. This is equivalent to the condition (p-1)|(n-1) for all prime divisors p of n.

SEE ALSO
Carmichael Number
]]]
[[[
https://mathworld.wolfram.com/CarmichaelNumber.html
===
Carmichael Number
A Carmichael number is an odd composite number n which satisfies Fermat's little theorem

 a^(n-1)-1=0 (mod n) 	
(1)
for every choice of a satisfying (a,n)=1 (i.e., a and n are relatively prime) with 1<a<n. A Carmichael number is therefore a pseudoprime to any base. Carmichael numbers therefore cannot be found to be composite using Fermat's little theorem. However, if (a,n)!=1, the congruence of Fermat's little theorem is nonzero, thus identifying a Carmichael number n as composite.

Carmichael numbers are sometimes called "absolute pseudoprimes" and also satisfy Korselt's criterion. R. D. Carmichael first noted the existence of such numbers in 1910, computed 15 examples, and conjectured that there were infinitely many. In 1956, Erdős sketched a technique for constructing large Carmichael numbers (Hoffman 1998, p. 183), and a proof was given by Alford et al. (1994).

Any solution to Lehmer's totient problem must be a Carmichael number.

The first few Carmichael numbers are 561, 1105, 1729, 2465, 2821, 6601, 8911, 10585, 15841, 29341, ... (OEIS A002997). The number of Carmichael numbers less than 10^2, 10^3, ... are 0, 1, 7, 16, 43, 105, ... (OEIS A055553; Pinch 1993). The smallest Carmichael numbers having 3, 4, ... factors are 561=3×11×17, 41041=7×11×13×41, 825265, 321197185, ... (OEIS A006931).

Carmichael numbers have at least three prime factors. For Carmichael numbers with exactly three prime factors, once one of the primes has been specified, there are only a finite number of Carmichael numbers which can be constructed. Indeed, for Carmichael numbers with k prime factors, there are only a finite number with the least k-2 specified.

Numbers of the form (6k+1)(12k+1)(18k+1) are Carmichael numbers if each of the factors is prime (Korselt 1899, Ore 1988, Guy 1994). This can be seen since for

 N=(6k+1)(12k+1)(18k+1)=1296k^3+396k^2+36k+1, 	
(2)
N-1 is a multiple of 36k and the least common multiple of 6k, 12k, and 18k is 36k, so a^(N-1)=1 modulo each of the primes 6k+1, 12k+1, and 18k+1, hence a^(N-1)=1 modulo their product. The first few such Carmichael numbers correspond to k=1, 6, 35, 45, 51, 55, 56, ... (OEIS A046025) and are 1729, 294409, 56052361, 118901521, ... (OEIS A033502).

Let C(n) denote the number of Carmichael numbers less than n. Then, for all sufficiently large n,

 C(n)>n^(2/7) 	
(3)
(Alford et al. 1994), which proves that there are infinitely many Carmichael numbers. The upper bound

 C(n)<nexp(-(lnnlnlnlnn)/(lnlnn)) 	
(4)
has also been proved (R. G. E. Pinch).

The Carmichael numbers have the following properties:

1. If a prime p divides the Carmichael number n, then n=1 (mod p-1) implies that n=p (mod p(p-1)).

2. Every Carmichael number is squarefree.

3. An odd composite squarefree number n is a Carmichael number iff n divides the denominator of the Bernoulli number B_(n-1).

The largest known Carmichael numbers having a given number of factors are summarized in the following table (updated from Dubner 1989, 1998).

factors	digits	discoverer
3	60351	Broadhurst (2002)
4	29094	Broadhurst 2003 (Broadhurst 2015b)
5	1015	Caldwell and Dubner
6	19140	Broadhurst 2003 (Broadhurst 2015a)
SEE ALSO
Carmichael Condition, Lehmer's Totient Problem, Pseudoprime
]]]



https://oeis.org/wiki/Index_to_OEIS:_Section_Ps#pseudoprimes
  Miller-Rabin primality test

[[[
https://oeis.org/A014233
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A014233		Smallest odd number for which Miller-Rabin primality test on bases <= n-th prime does not reveal compositeness.		4
2047, 1373653, 25326001, 3215031751, 2152302898747, 3474749660383, 341550071728321, 341550071728321, 3825123056546413051, 3825123056546413051, 3825123056546413051, 318665857834031151167461, 3317044064679887385961981 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,1
COMMENTS	
Note that some terms are repeated.
Same as A006945 except for first term.
a(12) > 2^64.  Hence the primality of numbers < 2^64 can be determined by asserting strong pseudoprimality to all prime bases <= 37 (=prime(12)). Testing to prime bases <=31 does not suffice, as a(11) < 2^64 and a(11) is a strong pseudoprime to all prime bases <= 31 (=prime(11)). - Joerg Arndt, Jul 04 2012
REFERENCES	
R. Crandall and C. Pomerance, Prime Numbers: A Computational Perspective, Springer, NY, 2001; see p. 157.
LINKS	
Table of n, a(n) for n=1..13.
Martin R. Albrecht, Jake Massimo, Kenneth G. Paterson, Juraj Somorovsky, Prime and Prejudice: Primality Testing Under Adversarial Conditions, Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security, 281-298.
Joerg Arndt, Matters Computational (The Fxtbook), section 39.10, pp. 786-792.
Paul D. Beale, A new class of scalable parallel pseudorandom number generators based on Pohlig-Hellman exponentiation ciphers, arXiv:1411.2484 [physics.comp-ph], 2014-2015.
Paul D. Beale, Jetanat Datephanyawat, Class of scalable parallel and vectorizable pseudorandom number generators based on non-cryptographic RSA exponentiation ciphers, arXiv:1811.11629 [cs.CR], 2018.
C. Caldwell, Strong probable-primality and a practical test.
G. Jaeschke, On strong pseudoprimes to several bases, Mathematics of Computation, 61 (1993), 915-926.
Yupeng Jiang, Yingpu Deng, Strong pseudoprimes to the first 9 prime bases, arXiv:1207.0063v1 [math.NT], June 30, 2012.
A. J. Menezes, P. C. van Oorschot and S. A. Vanstone, Handbook of Applied Cryptography, CRC Press, 1996; see section 4.2.3, Miller-Rabin test.
C. Pomerance, J. L. Selfridge and S. S. Wagstaff, Jr., The pseudoprimes to 25.10^9, Mathematics of Computation 35 (1980), pp. 1003-1026.
Eric Bach, Explicit bounds for primality testing and related problems, Mathematics of Computation 55 (1990), pp. 355-380.
F. Raynal, Miller-Rabin's Primality Test
K. Reinhardt, Miller-Rabin Primality Test for odd n
Jonathan P. Sorenson, Jonathan Webster, Strong Pseudoprimes to Twelve Prime Bases, arXiv:1509.00864 [math.NT], 2015.
S. Wagon, Primality testing, Math. Intellig., 8 (No. 3, 1986), 58-61.
Eric Weisstein's World of Mathematics, Strong Pseudoprime
Eric Weisstein's World of Mathematics, Rabin-Miller Strong Pseudoprime Test
Wikipedia, Miller-Rabin primality test
Zhenxiang Zhang and Min Tang, Finding strong pseudoprimes to several bases. II, Mathematics of Computation 72 (2003), pp. 2085-2097.
Index entries for sequences related to pseudoprimes
FORMULA	
Bach shows that, on the ERH, a(n) >> exp(sqrt(1/2 * x log x)). - Charles R Greathouse IV, May 17 2011
CROSSREFS	
Sequence in context: A258812 A321556 A321550 * A160964 A022193 A069386
Adjacent sequences:  A014230 A014231 A014232 * A014234 A014235 A014236
KEYWORD	
nonn,hard,more
AUTHOR	
Jud McCranie, Feb 15 1997
EXTENSIONS	
Minor edits from N. J. A. Sloane, Jun 20 2009
a(9)-a(11) from Charles R Greathouse IV, Aug 14 2010
a(12)-a(13) from the Sorenson/Webster reference, Joerg Arndt, Sep 04 2015
STATUS	
approved
Last modified August 15 08:15 EDT 2023. Contains 364633 sequences. (Running on oeis4.)
]]]
[[[
https://oeis.org/A006945
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A006945		Smallest odd number that requires n Miller-Rabin primality tests.
(Formerly M4673)		3
9, 2047, 1373653, 25326001, 3215031751, 2152302898747, 3474749660383, 341550071728321, 341550071728321, 3825123056546413051, 3825123056546413051, 3825123056546413051, 318665857834031151167461, 3317044064679887385961981 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,1
COMMENTS	
The tests are performed on sequential prime numbers starting with 2.  Note that some terms are repeated.
Same as A014233 except for the first term.
REFERENCES	
R. Crandall and C. Pomerance, Prime Numbers: A Computational Perspective, Springer, NY, 2001; see p. 157.
N. J. A. Sloane and Simon Plouffe, The Encyclopedia of Integer Sequences, Academic Press, 1995 (includes this sequence).
LINKS	
Table of n, a(n) for n=1..14.
Joerg Arndt, Matters Computational (The Fxtbook)
Eric Bach, Explicit bounds for primality testing and related problems, Mathematics of Computation 55 (1990), pp. 355-380.
G. Jaeschke, On strong pseudoprimes to several bases, Math. Comp., 61 (1993), 915-926.
Yupeng Jiang, Yingpu Deng, Strong pseudoprimes to the first 9 prime bases, arXiv:1207.0063v1 [math.NT], June 30, 2012.
C. Pomerance, J. L. Selfridge and S. S. Wagstaff, Jr., The pseudoprimes to 25.10^9, Mathematics of Computation 35 (1980), pp. 1003-1026.
S. Wagon, Primality testing, Math. Intellig., 8 (No. 3, 1986), 58-61.
Zhenxiang Zhang and Min Tang, Finding strong pseudoprimes to several bases. II, Mathematics of Computation 72 (2003), pp. 2085-2097.
Index entries for sequences related to pseudoprimes
FORMULA	
Bach shows that, on the ERH, a(n) >> exp(sqrt(1/2 * x log x)). [Charles R Greathouse IV, May 17 2011]
CROSSREFS	
Cf. A089105, A089825.
Sequence in context: A232684 A039917 A162140 * A089825 A173281 A004820
Adjacent sequences:  A006942 A006943 A006944 * A006946 A006947 A006948
KEYWORD	
nonn,hard,more
AUTHOR	
N. J. A. Sloane.
EXTENSIONS	
Extended and description corrected by Jud McCranie Feb 15 1997.
a(10)-a(12) from Charles R Greathouse IV, Aug 14 2010
a(13)-a(14) copied from A014233 by Max Alekseyev, Feb 15 2017
STATUS	
approved
Last modified August 15 10:08 EDT 2023. Contains 364633 sequences. (Running on oeis4.)
]]]
[[[
https://oeis.org/A001262
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A001262		Strong pseudoprimes to base 2.		74
2047, 3277, 4033, 4681, 8321, 15841, 29341, 42799, 49141, 52633, 65281, 74665, 80581, 85489, 88357, 90751, 104653, 130561, 196093, 220729, 233017, 252601, 253241, 256999, 271951, 280601, 314821, 357761, 390937, 458989, 476971, 486737 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,1
COMMENTS	
The number 2^k-1 is in the sequence iff k is in A054723 or in A001567. - Thomas Ordowski, Sep 02 2016
The number (2^k+1)/3 is in the sequence iff k is in A127956. - Davide Rotondo, Aug 13 2021
REFERENCES	
R. K. Guy, Unsolved Problems Theory Numbers, A12.
P. Ribenboim, The Book of Prime Number Records. Springer-Verlag, NY, 2nd ed., 1989, p. 95.
LINKS	
T. D. Noe, Table of n, a(n) for n = 1..10000 (using data from A001567)
  https://oeis.org/A001262/b001262.txt
Joerg Arndt, Matters Computational (The Fxtbook), section 39.10, pp. 786-792.
Chris Caldwell, Strong probable prime.
Eric Weisstein's World of Mathematics, Strong Pseudoprime.
OEIS Wiki, Strong Pseudoprime.
Wikipedia, Strong pseudoprime.
Index entries for sequences related to pseudoprimes
EXAMPLE	
From Michael B. Porter, Sep 04 2016: (Start)
For k = 577, k-1 = 576 = 9*2^6. Since 2^(9*2^3) = 2^72 == -1 (mod 577), 577 passes the primality test, but since it is actually prime, it is not in the sequence.
For k = 3277, k-1 = 3276 = 819*2^2, and 2^(819*2) == -1 (mod 3277), so k passes the primality test, and k = 3277 = 29*113 is composite, so 3277 is in the sequence. (End)
MAPLE	
A007814 := proc(n) padic[ordp](n, 2) ; end proc:
isStrongPsp := proc(n, b) local d, s, r; if type(n, 'even') or n<=1 then return false; elif isprime(n) then return false; else s := A007814(n-1) ; d := (n-1)/2^s ; if modp(b &^ d, n) = 1 then return true; else for r from 0 to s-1 do if modp(b &^ d, n) = n-1 then return true; end if; d := 2*d ; end do: return false; end if; end if; end proc:
isA001262 := proc(n) isStrongPsp(n, 2) ; end proc:
for n from 1 by 2 do if isA001262(n) then print(n); end if; end do:
# R. J. Mathar, Apr 05 2011
MATHEMATICA	
sppQ[n_?EvenQ, _] := False; sppQ[n_?PrimeQ, _] := False; sppQ[n_, b_] := (s = IntegerExponent[n-1, 2]; d = (n-1)/2^s; If[PowerMod[b, d, n] == 1, Return[True], Do[If[PowerMod[b, d, n] == n-1, Return[True]]; d = 2*d, {s}]]); lst = {}; k = 3; While[k < 500000, If[sppQ[k, 2], Print[k]; AppendTo[lst, k]]; k += 2]; lst (* Jean-François Alcover, Oct 20 2011, after R. J. Mathar *)
PROG	
(PARI)
isStrongPsp(n, b)={
        my(s, d, r, bm) ;
        if( (n% 2) ==0 || n <=1, return(0) ; ) ;
        if(isprime(n), return(0) ; ) ;
        s = valuation(n-1, 2) ;
        d = (n-1)/2^s ;
        bm = Mod(b, n)^d ;
        if ( bm == Mod(1, n), return(1) ; ) ;
        for(r=0, s-1,
                bm = Mod(b, n)^d ;
                if ( bm == Mod(-1, n),
                        return(1) ;
                ) ;
                d *= 2;
        ) ;
        return(0);
}
isA001262(n)={
        isStrongPsp(n, 2)
}
{
for(n=1, 10000000000,
    if(isA001262(n),
        print(n)
    ) ;
) ;
} \\ R. J. Mathar, Mar 07 2012
(PARI) is_A001262(n, a=2)={ (bittest(n, 0) && !isprime(n) && n>8) || return; my(s=valuation(n-1, 2)); if(1==a=Mod(a, n)^(n>>s), return(1)); while(a!=-1 && s--, a=a^2); a==-1} \\ M. F. Hasler, Aug 16 2012
CROSSREFS	
Cf. A001567 (pseudoprimes to base 2), A020229 (strong pseudoprimes to base 3), A020231 (base 5), A020233 (base 7).
Cf. A072276 (SPP to base 2 and 3), A215568 (SPP to base 2 and 5), A056915 (SPP to base 2,3 and 5), A074773 (SPP to base 2,3,5 and 7).
Sequence in context: A241039 A278353 A038462 * A141232 A361256 A360184
Adjacent sequences:  A001259 A001260 A001261 * A001263 A001264 A001265
KEYWORD	
nonn,nice
AUTHOR	
N. J. A. Sloane
EXTENSIONS	
More terms from David W. Wilson, Aug 15 1996
STATUS	
approved
Last modified August 15 10:13 EDT 2023. Contains 364633 sequences. (Running on oeis4.)
]]]
[[[
===
view others/数学/整数分解/factorint.txt
]]]
[[[
===
[phi(1) == 1]
    # include 0
[@[n :: pint] -> [n >= 2] -> [1 <= phi(n) <= n -1]]
    # 『-1』 <<== exclude 0
[@[p :<- PRIMES] -> [phi(p) == p-1]]
[@[p2e :: {prime:pint}] -> [phi(II__p2e_(p2e)) == II((p-1)*p**(e-1) for p,e in p2e.items())]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> [u**phi(n) =[%n]= 1]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> [phi(n)%order_mod_(n;u) == 0]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> [m%order_mod_(n;u) == 0]]



[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[p :<- all_prime_factors_of_(m)] -> [(u**(m///p) -1)%n =!= 0] -> [max_power_of_base_as_factor_of_(p;m) == max_power_of_base_as_factor_of_(p;order_mod_(n;u))]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1] -> @[q :<- all_prime_factors_of_(n)] -> [(u**(m///p) -1)%q =!= 0]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1] -> @[q :<- all_prime_factors_of_(n)] -> [max_power_of_base_as_factor_of_(p;m) == max_power_of_base_as_factor_of_(p;order_mod_(q;u))]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1] -> @[q :<- all_prime_factors_of_(n)] -> [max_power_of_base_as_factor_of_(p;m) <= max_power_of_base_as_factor_of_(p;q-1)]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> [@[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1]] -> @[q :<- all_prime_factors_of_(n)] -> [(q-1)%m == 0]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> [@[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1]] -> [phi(n)%m == 0]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> [@[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1]] -> [m == n-1] -> [phi(n) >= m == n-1]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> [@[p :<- all_prime_factors_of_(m)] -> [gcd((u**(m///p) -1), n) == 1]] -> [m == n-1] -> [is_prime_(n)]]


[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[ft :<- all_positive_factors_of_(m)] -> [(u**(m///ft) -1)%n =!= 0] -> [ft >= 2]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[ft :<- all_positive_factors_of_(m)] -> [(u**(m///ft) -1)%n =!= 0] -> ?[p :<- all_prime_factors_of_(ft)] -> [0 <= max_power_of_base_as_factor_of_(ft;m)*max_power_of_base_as_factor_of_(p;ft) - max_power_of_base_as_factor_of_(p;order_mod_(n;u)) < max_power_of_base_as_factor_of_(p;ft)]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[ft :<- all_positive_factors_of_(m)] -> [(u**(m///ft) -1)%n =!= 0] -> @[q :<- all_prime_factors_of_(n)] -> [(u**(m///ft) -1)%q =!= 0]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[ft :<- all_positive_factors_of_(m)] -> [(u**(m///ft) -1)%n =!= 0] -> @[q :<- all_prime_factors_of_(n)] -> ?[p :<- all_prime_factors_of_(ft)] -> [0 <= max_power_of_base_as_factor_of_(ft;m)*max_power_of_base_as_factor_of_(p;ft) - max_power_of_base_as_factor_of_(p;order_mod_(q;u)) < max_power_of_base_as_factor_of_(p;ft)]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[ft :<- all_positive_factors_of_(m)] -> [(u**(m///ft) -1)%n =!= 0] -> @[q :<- all_prime_factors_of_(n)] -> ?[p :<- all_prime_factors_of_(ft)] -> [(max_power_of_base_as_factor_of_(ft;m) -1)*max_power_of_base_as_factor_of_(p;ft) < max_power_of_base_as_factor_of_(p;q-1)]]
[@[n :: pint] -> @[u :: int] -> [gcd(n,u) == 1] -> @[m :: pint] -> [u**m =[%n]= 1] -> @[ft2e :: {pint:pint}] -> [are_pairwise_coprime_(ft2e.keys())] -> [m == II__p2e_(ft2e)] -> [@[ft :<- ft2e.keys()] -> [(u**(m///ft) -1)%n =!= 0]] -> @[q :<- all_prime_factors_of_(n)] -> @[ft :<- ft2e.keys()] -> ?[p :<- all_prime_factors_of_(ft)] -> [(max_power_of_base_as_factor_of_(ft;m) -1)*max_power_of_base_as_factor_of_(p;ft) < max_power_of_base_as_factor_of_(p;q-1)].........]

]]]




[[[
# p-prime
# e-exponentiation
# n-number
# m-modulus
# g-generator
#
[phi(1) == 1]
    # include 0
[@[n :: pint] -> [n >= 2] -> [1 <= phi(n) <= n -1]]
    # 『-1』 <<== exclude 0
[@[p :<- PRIMES] -> [phi(p) == p-1]]
[@[p2e :: {prime:pint}] -> [phi(II__p2e_(p2e)) == II((p-1)*p**(e-1) for p,e in p2e.items())]]
[@[m :: pint] -> @[g :: int] -> [gcd(m,g) == 1] -> [g**phi(m) =[%m]= 1]]
[@[m :: pint] -> @[g :: int] -> [gcd(m,g) == 1] -> [phi(m)%order_mod_(m;g) == 0]]
[@[m :: pint] -> @[g :: int] -> [gcd(m,g) == 1] -> @[e :: pint] -> [g**e =[%m]= 1] -> [e%order_mod_(m;g) == 0]]
===
[[
[gde_(b;m) =[def]= max_power_of_base_as_factor_of_(b;m)]
  #greatest dividing exponent gde(n,b)
  #(flip gde) = gde_ = greatest_dividing_exponent_ = max_power_of_base_as_factor_of_
[m :: pint]:
    [all_rough_factorizations_of_(m) =[def]= {ft2e | [ft2e :: {pint:pint}][@[(ft,e) :<- ft2e.items()] -> [[ft >= 2][e >= 1]]][are_pairwise_coprime_(ft2e.keys())][m == II__ft2e_(ft2e)]}]
[[m :: pint] -> [ft2e :<- all_rough_factorizations_of_(m)] -> [are_pairwise_coprime_(ft2e.keys())]]

[m :: pint]:
    [all_coprimes_mod_(m) =[def]= {g | [[g :: int][gcd(m,g) == 1]]}]

[[m :: pint][e :: pint]]:
    [all_kth_roots_of_unity_mod_(m;e) =[def]= {g | [[g :: int][gcd(m,g) == 1][g**e =[%m]= 1]]}]
[[m :: pint][e :: pint][n :: int]]:
    [all_kth_roots_of__mod_(m,e;n) =[def]= {g | [[g :: int][gcd(m,g) == 1][g**e =[%m]= n]]}]

[m :: pint]:
    [[g :: int][gcd(m,g) == 1]]:
        [g**phi(m) =[%m]= 1]
        [g**order_mod_(m;g) =[%m]= 1]
        [phi(m)%order_mod_(m;g) == 0]

    [[g :: int][gcd(m,g) == 1][e :: pint][g**e =[%m]= 1]]:
        [e%order_mod_(m;g) == 0]

        [[p4e :<- all_prime_factors_of_(e)][(g**(e///p4e) -1)%m =!= 0]]:
            [m >= 2]
            [e///p4e %order_mod_(m;g) =!= 0]
            !! [e%order_mod_(m;g) == 0]
            [gde_(p4e;e) == gde_(p4e;order_mod_(m;g)) <= gde_(p4e;phi(m))]
                #[:模运算乘法群规模囗素因子指数下限]:here

        [@[p4e :<- all_prime_factors_of_(e)] -> [(g**(e///p4e) -1)%m =!= 0]]:
            [m >= 1]
            [1 <= e == order_mod_(m;g) <= phi(m)]
                #[:离散对数囗充要条件囗单基]:here
            [e == m-1]:
                [m == e+1 >= 2]
                !! [@[n :: pint] -> [n >= 2] -> [1 <= phi(n) <= n -1]]
                [phi(m) <= m-1 <= e]
                !! [1 <= e == order_mod_(m;g) <= phi(m)]
                [phi(m) == e == m-1]
                [is_prime_(m)]
            [[e == m-1] -> [is_prime_(m)]]
                #[:素性判定囗减一囗完全分解囗单基]:here

    [e :: pint]:
        [@[p4e :<- all_prime_factors_of_(e)] -> ?[g__p4e :<- all_kth_roots_of_unity_mod_(m;e)] -> [(g__p4e**(e///p4e) -1)%m =!= 0]]:
            [m >= 1]
            [g__e := II g__p4e**(e/// p4e**gde_(p4e;e)) {(p4e,g__p4e) :<- ...}]
            [1 <= e == order_mod_(m;g__e) <= phi(m)]
                #[:离散对数囗充要条件囗多基]:here
            [[e == m-1] -> [is_prime_(m)]]
                #[:素性判定囗减一囗完全分解囗多基]:here

    [[e :: pint][g**e =[%m]= 1]]:
        [[p4e :<- all_prime_factors_of_(e)][gcd((g**(e///p4e) -1), m) == 1]]:
            [m >= 1]
            [q4m :<- all_prime_factors_of_(m)]:
                [m >= 2]
                !! [m%q4m == 0]
                [gcd((g**(e///p4e) -1), q4m) == 1]
                !! [is_prime_(q4m)]
                [(g**(e///p4e) -1)%q4m =!= 0]
                    # 需要使用gcd投影到素因子分量，以模仿上面的:[(g**(e///p4e) -1)%m =!= 0]
                !! [g**e =[%m]= 1]
                [g**e =[%q4m]= 1]
                !! [:模运算乘法群规模囗素因子指数下限]:goto
                [gde_(p4e;e) == gde_(p4e;order_mod_(q4m;g)) <= gde_(p4e;phi(q4m))]
                [gde_(p4e;e) <= gde_(p4e;(q4m-1))]

        [@[p4e :<- all_prime_factors_of_(e)] -> [gcd((g**(e///p4e) -1), m) == 1]]:
            [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)%e == 0]]
                # [:素性判定囗减一囗部分分解囗原数素因子形式囗囗预备]:here

            !! [@[p2e :: {prime:pint}] -> [phi(II__p2e_(p2e)) == II((p-1)*p**(e-1) for p,e in p2e.items())]]
            [phi(m)%e == 0]

        [[ft4e :: pint][e%ft4e == 0][gcd(ft4e, e/// ft4e**gde_(ft4e;e)) == 1][(g**(e///ft4e) -1) %m =!= 0]]:
            [m >= 2]
            [e///ft4e %order_mod_(m;g) =!= 0]
            !! [e%order_mod_(m;g) == 0]
            @[p4ft4e :<- all_prime_factors_of_(ft4e)]:
                [gde_(p4ft4e;e) >= gde_(p4ft4e;order_mod_(m;g))]
                !! [gcd(ft4e, e/// ft4e**gde_(ft4e;e)) == 1]
                [gde_(p4ft4e;e) == gde_(p4ft4e;ft4e) *gde_(ft4e;e)]

            ?[p4ft4e :<- all_prime_factors_of_(ft4e)]:
                [gde_(p4ft4e;e) >= gde_(p4ft4e;order_mod_(m;g)) > gde_(p4ft4e;e) -gde_(p4ft4e;ft4e)]
                [gde_(ft4e;e) >= gde_(p4ft4e;order_mod_(m;g))/gde_(p4ft4e;ft4e) > gde_(ft4e;e) -1]
                [gde_(ft4e;e) == ceil_(gde_(p4ft4e;order_mod_(m;g))/gde_(p4ft4e;ft4e))]
                [gde_(ft4e;e) <= ceil_(gde_(p4ft4e;phi(m))/gde_(p4ft4e;ft4e))]
                    #[:模运算乘法群规模囗仿素因子指数下限]:here

        [[ft4e :: pint][e%ft4e == 0][gcd(ft4e, e/// ft4e**gde_(ft4e;e)) == 1][gcd((g**(e///ft4e) -1), m) == 1]]:
            [m >= 1]
            [q4m :<- all_prime_factors_of_(m)]:
                [m >= 2]
                !! [m%q4m == 0]
                [gcd((g**(e///ft4e) -1), q4m) == 1]
                !! [is_prime_(q4m)]
                [(g**(e///ft4e) -1)%q4m =!= 0]
                    # 需要使用gcd投影到素因子分量，以模仿上面的:[(g**(e///ft4e) -1)%m =!= 0]
                !! [g**e =[%m]= 1]
                [g**e =[%q4m]= 1]
                !! [:模运算乘法群规模囗仿素因子指数下限]:goto
                ?[p4ft4e :<- all_prime_factors_of_(ft4e)]:
                    [gde_(ft4e;e) <= ceil_(gde_(p4ft4e;phi(q4m))/gde_(p4ft4e;ft4e))]
                    [gde_(ft4e;e) <= ceil_(gde_(p4ft4e;(q4m-1))/gde_(p4ft4e;ft4e)) <= gde_(p4ft4e;(q4m-1))]
                    [(q4m-1)%(p4ft4e**gde_(ft4e;e)) == 0]
            [@[q4m :<- all_prime_factors_of_(m)] -> ?[p4ft4e<q4m> :<- all_prime_factors_of_(ft4e)] -> [(q4m-1)%(p4ft4e<q4m>**gde_(ft4e;e)) == 0]]
                # [:素性判定囗减一囗部分分解囗原数素因子下限囗囗预备]:here



    [[e :: pint][g**e =[%m]= 1][eF, eR :: pint][gcd(eF,eR) == 1][e == eF*eR][p2e4eF := factorization_of_(eF)][ft2e4eR :<- all_rough_factorizations_of_(eR)][p4eR := min_prime_factor_of_(eR) if eR > 1 else 1][B4eR :<- [1..=p4eR]]]:
        [ft4eR :<- ft2e4eR.keys()]:
            !! [[m :: pint] -> [ft2e :<- all_rough_factorizations_of_(m)] -> [are_pairwise_coprime_(ft2e.keys())]]
            [gcd(ft4eR, e/// ft4eR**gde_(ft4eR;e)) == 1]

        [@[p4eF :<- all_prime_factors_of_(eF)] -> [gcd((g**(e///p4eF) -1), m) == 1]]:
            !! [:素性判定囗减一囗部分分解囗原数素因子形式囗囗预备]:goto
            [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)%eF == 0]]
                # [:素性判定囗减一囗部分分解囗原数素因子形式]:here
                # [:Pocklington_Theorem_1914]:goto

            [@[ft4eR :<- ft2e4eR.keys()] -> [gcd((g**(e///ft4eR) -1), m) == 1]]:
                !! [gcd(ft4eR, e/// ft4eR**gde_(ft4eR;e)) == 1]
                !! [:素性判定囗减一囗部分分解囗原数素因子下限囗囗预备]:goto
                [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= II (min_prime_factor_of_(ft4eR)**gde_(ft4eR;e)) {ft4eR :<- ft2e4eR.keys()}]]
                [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= II (min_prime_factor_of_(ft4eR)**e4ft4eR) {(ft4eR,e4ft4eR) :<- ft2e4eR.items()}]]
                    # [:素性判定囗减一囗部分分解囗原数素因子下限]:here
                [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= B4eR**sum(ft2e4eR.values()) >= B4eR >= 1]]
                    # [:素性判定囗减一囗部分分解囗原数素因子下限囗减一的未分解部的素因子下限统一估值]:here
                [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= B4eR]]
                [@[q4m :<- all_prime_factors_of_(m)] -> [q4m >= 1+ eF*B4eR]]
                [[m < (1+ eF*B4eR)**2] -> [is_prime_(m)]]
                    #[:素性判定囗减一囗不完全分解囗囗平方型]:here
                !! [B4eR >= 1]
                [[m < (1+ eF)**2] -> [is_prime_(m)]]
                [e == m-1]:
                    [eF*eR == e == m-1]
                    !! [gcd(eF,eR) == 1]
                    [[eF =!= eR]or[eF==eR == 1]]
                    [m < (1+ eF)**2]
                        <==> [1+ eF*eR < (1+ eF)**2]
                        <==> [eR < (2+ eF)]
                        <==> [eF >= eR-1]
                    [eF >= eR-1]:
                        [m < (1+ eF)**2]
                        [is_prime_(m)]
                [[e == m-1] -> [eF >= eR-1] -> [is_prime_(m)]]
                    #[:素性判定囗减一囗不完全分解囗囗平方型囗简化型甲]:here




]]

[[
# using complete factorization
# without gcd
[[[m :: pint][m%2==1][m>=3]
  [e2 :: pint][L :: uint][ps :: [pint]{len=L}][es :: [pint]{len=L}]
  # ps neednot be a set /distinguish
  [@[p :<- ps] -> [is_prime_(p)]]
  [e := 2**e2 * II ps[i]**es[i] {i :<- [0..<L]}]
  [g2 :: int][g2**(e///2) %m == m-1]
  [gs :: [int]{len=L}][@[i :<- [0..<L]] -> [gs[i]**(e///2///ps[i]) %m =!= m-1]][@[i :<- [0..<L]] -> [gs[i]**(e///2) %m == m-1]]
  ] -> [
  [phi(m) %e == 0]
  [[e == m-1] -> [is_prime_(m)]]
  ]
]

# using partial factorization
# using gcd
[[[m :: pint][m%2==1][m>=3]
  [e2 :: pint][L :: uint][fts :: [pint]{len=L}][es :: [pint]{len=L}]
  # fts neednot be pairwise-coprime
  [@[ft :<- fts] -> [[ft%2==1][ft>=3]]]
  [Bs :: [pint]{len=L}][@[i :<- [0..<L]] -> @[p4ft :<- all_prime_factors_of_(fts[i])] -> [p4ft >= Bs[i]]]
  [e5ft := 2**e2 * II fts[i]**es[i] {i :<- [0..<L]}]
  [e5B := 2**e2 * II Bs[i]**es[i] {i :<- [0..<L]}]
  [g2 :: int][g2**(e5ft///2) %m == m-1]
  [gs :: [int]{len=L}][@[i :<- [0..<L]] -> [gcd(gs[i]**(e5ft///2///fts[i]) %m +1, m) == 1]][@[i :<- [0..<L]] -> [gs[i]**(e5ft///2) %m == m-1]]

  ###
  [js := [i | [i :<- [0..<L]][fts[i] == Bs[i]]]]
  [ej := 2**e2 * II fts[j]**es[j] {j :<- js}]

  ] -> [
  ###
  [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1) >= e5B]]
  [[(e5B+1)**2 > m] -> [is_prime_(m)]]

  ###
  [[e5ft == e5B] <==> [fts == Bs] <==> [@[ft :<- fts] -> [is_prime_(ft)]]]
  [[e5ft == e5B] -> [phi(m) %e5ft == 0]]
  [[e5ft == e5B] -> @[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1) %e5ft == 0]]

  ###
  [e5ft %ej == 0]
  [e5B %ej == 0]
  [@[j :<- js] -> [is_prime_(fts[j])]]
  [[phi(m) %ej == 0][phi(m) ///ej >= e5B///ej][phi(m) >= e5B]]
  [@[q4m :<- all_prime_factors_of_(m)] -> [[(q4m-1) %ej == 0][(q4m-1) ///ej >= e5B///ej][(q4m-1) >= e5B]]]

  ###
  [[[e5ft==m-1][eF := ej][eR := e5ft///ej][gcd(eF,eR)==1]
    [u := if [e5ft%3 == 1] then 3 else 1]
    [(q,r) := eR /% (2*u*eF)]
    # [kB :: pint][[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= kB]]
      # !! [(q4m-1) >= e5B]
      # !! [(q4m-1)///eF >= e5B///eF]
      # e.g. [kB := e5B///eF] #but select best to max rhs=(kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)
    [kB := min(e5B///eF, (((2*u*eF) +r-1)///2))]
    [m < (kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)]
    ] -> [
      [[is_prime_(m)] <-> [not$ [[r >= 2*kB][q >= ceil_(kB**2 /(2*u)) >= 1][sqrt(r**2 -8*u*q) %1 == 0]]]]
                #定理:一 #copy from below
      [[[r >= 2*kB][q >= ceil_(kB**2 /(2*u)) >= 1][sqrt(r**2 -8*u*q) %1 == 0]] -> [
        [(s+t) == r]
        [(s-t) == sqrt(r**2 -8*u*q)]
        [m == (1+s*eF)*(1+t*eF)]
        ]]
      ]
    ]
  ]
]
]]



]]]
[[[
view others/数学/整数分解/素数/primes.utm.edu..prove..merged.html
===
the Sieve of Eratosthenes
trial division
(strong) probable primality tests.
compositeness


the classical primality tests
    n-1 tests
        Pepin's Test for Fermat primes
    n+1 tests
        Lucas-Lehmer test for Mersenne primes
the general purpose tests


PRP == probable prime == prime | pseudoprime(==composite probable-prime)
pseudoprime == composite PRP
[n :: uint]:
    [[n is a weak probable prime base x (== x-PRP)] =[def]= [[1 < x%n < n] -> [x**(n-1)%n == 1]]]
        #Some early articles call all numbers satisfying this test pseudoprimes, but now the term pseudoprime is properly reserved for composite probable-primes.

Carmichael number
[n :: uint]:
    [is_Carmichael_number(n) =[def]= [[n >= 2][not$ is_prime_(n)][@[x :<- [1..<n]] -> [gcd(x,n) == 1] -> [x**(n-1) %n == 1]]]]

[[n,s,d :: pint][n >= 3][n%2==1][d%2==1][n-1 == 2**s *d]]:
    [[n is a strong probable prime base x (== x-SPRP)] =[def]= [[x**d %n == 1]or[?[r :<- [0..<s]] -> [(x**d)**(2**r) %n == -1]]]]

Miller's Test [Miller76]: If the extended Riemann hypothesis is true, then if n is an x-SPRP for all integers x with 1 < x < 2*(log n)**2 == 2*ln(n)**2, then n is prime.
    #require ERH
    2*ln(n)**2
heuristically we should be able to replace the bound in Miller's test with a bound near: (log 2)^-1 log n log log n.
  #heuristically
  #not exact
  ln(n)*lnln(n)/ln(2)
  log2(n)*lnln(n)


Note that there is no finite set of bases that will work in Miller's test.  In fact, if for n composite we let W(n) denote the least witness for n (the least x which shows n is composite), then there are infinitely many composite n with:
    [W(n) > (log n)**(1/(3 log log log n))]

Pocklington's Theorem (1914):  Let [n-1 = q**k *R] where q is a prime which does not divide R.  If there is an integer x such that [x**(n-1) %n == 1][gcd(x**((n-1)///q) %n -1,n) == 1], then each prime factor p of n has the form q**k*r+1.
    # [:Pocklington_Theorem_1914]:here

partial factorizations of N-1
    factor bound B:the direct search bound for factors of N-1
N-1 test:
(Notice that different a's can be used for each prime q.)  Theorem 2 can be improved even more: if F<R, but either every factor of R is greater than sqrt(R/F); or n<2*F**3, R=r*F+s, 0<s<F, and r is odd or s**2-4*r is not a square; then n is prime.  If you are interested in these theorems, then it is well worth going to the source: [BLS75].
BLS75:
    /sdcard/0my_files/book/math/factorint/snd/New primality criteria and factorizations of 2^m ± 1(1975)(Brillhart).pdf
      By John Brillhart, D. H. Lehmer and J. L. Selfridge

[m :: pint][m%2==1][m >= 3]:
    [e := m-1]:
        [[@[p4e :<- all_prime_factors_of_(e)] -> ?[g__p4e :<- all_kth_roots_of_unity_mod_(m;e)] -> [(g__p4e**(e///p4e) -1)%m =!= 0]] -> [is_prime_(m)]]
        [[@[p4e :<- all_prime_factors_of_(e)] -> ?[g__p4e :<- all_kth_roots_of__mod_(m,e///2;-1)] -> [p4e =!= 2] -> [(g__p4e**(e///(2*p4e)) +1)%m =!= 0]] -> [is_prime_(m)]]



N-1 is partially factored
[F1 is the even factored portion of (N-1)]

#copy from below
[[m,e,eF,eR :: pint][m >= 3][m%2 == 1][e == (m-1) == eF*eR][gcd(eF,eR) == 1][eR >= 3][eR%2 == 1]]:
    [@[p4eF :<- all_prime_factors_of_(eF)] -> ?[g__p4eF :<- all_kth_roots_of__mod_(m,e;+1)] -> [gcd((g__p4eF**(e///p4eF) -1), m) == 1]]:
        ?s,t :=> [s,t :: uint][m == (1+s*eF)*(1+t*eF)][s >= 0][t > 0][is_prime_(1+t*eF)]
        [s*t %(2*u) == 0]:
          #e.g. [u := if [eF%3 == eR%3 =!= 0] then 3 else 1] #<==> [u := if [e%3 == 1] then 3 else 1]
          [(q,r) := eR /% (2*u*eF)]
          [?[kB :<- [1..]] -> [q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= kB]]:
            [m < (kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)]:
              [[is_prime_(m)] <-> [not$ [[r >= 2*kB][q >= ceil_(kB**2 /(2*u)) >= 1][sqrt(r**2 -8*u*q) %1 == 0]]]]
                #定理:一 #copy from below

[[m,e,eF,eR :: pint][m >= 3][m%2 == 1][e == (m-1) == eF*eR][gcd(eF,eR) == 1][eR >= 3][eR%2 == 1]]:
    !! [m%2 == 1]
    [e%2 == 0]
    [eF*eR%2 == 0]
    !! [eR%2 == 1]
    [eF%2 == 0]

    [[@[p4eF :<- all_prime_factors_of_(eF)] -> ?[g__p4eF :<- all_kth_roots_of__mod_(m,e;+1)] -> [gcd((g__p4eF**(e///p4eF) -1), m) == 1]] -> [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)%eF == 0]]]

    #==>> [[@[p4eF :<- all_prime_factors_of_(eF)] -> ?[g__p4eF :<- all_kth_roots_of__mod_(m,e///2;-1)] -> [p4eF =!= 2] -> [gcd((g__p4eF**(e///(2*p4eF)) +1), m) == 1]] -> [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)%eF == 0]]]


    [@[p4eF :<- all_prime_factors_of_(eF)] -> ?[g__p4eF :<- all_kth_roots_of__mod_(m,e;+1)] -> [gcd((g__p4eF**(e///p4eF) -1), m) == 1]]:
        <==> [@[p4eF :<- all_prime_factors_of_(eF)] -> ?[g__p4eF :<- all_kth_roots_of__mod_(m,e///2;-1)] -> [p4eF =!= 2] -> [gcd((g__p4eF**(e///(2*p4eF)) +1), m) == 1]]

        [@[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)%eF == 0]]
        [[m < (1+eF)**2] -> [is_prime_(m)]]
        !! [m >= 3]
        ?s,t :=> [s,t :: uint][m == (1+s*eF)*(1+t*eF)][s >= 0][t > 0][is_prime_(1+t*eF)]
        !! [m == 1+eF*eR]
        [eR == s*t*eF + (s+t)]
        !! [gcd(eF,eR) == 1]
        [gcd(eF,(s+t)) == 1]
        !! [eR%2 == 1][eF%2 == 0]
        [(s+t)%2 == 1]
        [s%2 =!= t%2]
        [{s%2, t%2} == {0, 1}]
        [s*t %2 == 0]
        [s*t %(2*u) == 0]:
          #e.g. [u := if [eF%3 == eR%3 =!= 0] then 3 else 1] #<==> [u := if [e%3 == 1] then 3 else 1]
          #     see:e script/primality_test____st_solutions.py
          #     注意到: m很可能 最多只有两个 素因子 (尝试证明)；这样一来，更容易 找到更大的u
          #
          [v := s*t /// (2*u)]
          [eR == (2*u*eF)*v + (s+t)]
          [(q,r) := eR /% (2*u*eF)]
          [eR == (2*u*eF)*q + r]
          [(s+t) == (2*u*eF)*(q-v) + r]
          [(s+t) < (2*u*eF) +r]:
            <==> [r == (s+t)]
          [not$ is_prime_(m)]:
            [1 <= min(s,t)]
            [1 <= kB <= min(s,t)]:
              [(s-kB)*(t-kB) >= 0]
              [s*t >= kB*((s+t) -kB)]
              !! [m == (1+s*eF)*(1+t*eF)]
              [m == (s*t)*eF**2 +(s+t)*eF +1
              >= kB*((s+t) -kB)*eF**2 +(s+t)*eF +1
              == (kB*eF +1) * (((s+t) -kB)*eF +1)
              ]
              [m >= (kB*eF +1) * (((s+t) -kB)*eF +1)]
              [(s+t) <= ((m/(kB*eF +1) -1)/eF +kB)]
              [(s+t) < (2*u*eF) +r]
                <<== [m < (kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)]
              [m < (kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)]:
                [(s+t) < (2*u*eF) +r]
                [(s+t) == r]
                [v == q]
                !! [v := s*t /// (2*u)]
                [s*t == 2*u*v == 2*u*q]
                # solve for s,t
                [(s-t)**2 == (s+t)**2 -4*s*t
                == r**2 -8*u*q
                ]
                [(s-t)**2 == (r**2 -8*u*q)]
                [[(s,t) have integer solutions] <-> [sqrt(r**2 -8*u*q) %1 == 0]]
                [r == s+t >= 2*kB]
                [q == s*t /// (2*u) >= ceil_(kB**2 /(2*u)) >= 1]
          [?[kB :<- [1..]] -> [q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= kB]]:
            [m < (kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)]:
              [rhs == -eF**2 *kB**2 +((2*u*eF) +r)*eF**2 *kB +(((2*u*eF) +r)*eF +1) <= rhs{kB:=(((2*u*eF) +r-1)///2)} == eF**2 *((((2*u*eF) +r)**2-1)///4) +(((2*u*eF) +r)*eF +1)]
              [rhs == (kB*eF +1) * (((2*u*eF) +r -1 -kB)*eF +1 +eF) <= ((((2*u*eF) +r-1)///2)*eF +1 +eF///2)**2 -(eF///2)**2]
              [rhs <= (((2*u*eF) +r)*eF///2 +1)**2 -(eF///2)**2]

            [m < (kB*eF +1) * (((2*u*eF) +r -kB)*eF +1)]:
              [[is_prime_(m)] <-> [not$ [[r >= 2*kB][q >= ceil_(kB**2 /(2*u)) >= 1][sqrt(r**2 -8*u*q) %1 == 0]]]]
                #定理:一
                #原论文定理
                #kB可用 试除法 排除 提升
                #   [m%(1+ kB*eF) =?= 0]
                #   [(eR-kB)%(1+ kB*eF) =?= 0]
                #   或:
                #       [?g. [gcd((g**((m-1)///eF) %m -1), m) == 1]]
                #       [?g. [gcd((g**eR %m -1), m) == 1]]
                #       并且:
                #           [[q4eR :<- all_prime_factors_of_(eR)] -> [q4eR >= kB]]
                #但 由于 [m < ...]的右侧rhs是kB的二次多项式，最高系数为负数，kB有效范围为[1..=(((2*u*eF) +r-1)///2)], [rhs <= (((2*u*eF) +r)*eF///2 +1)**2 -(eF///2)**2]
          # 其实 不必:[(s+t) < (2*u*eF) +r]
          #     以下，我尝试拓展:
          [not$ is_prime_(m)]:
            [1 <= min(s,t)]
            [1 <= kB <= min(s,t)]:
              !! [(s+t) <= ((m/(kB*eF +1) -1)/eF +kB)]
              [kadd := 1+ floor_((((m/(kB*eF +1) -1)/eF +kB) -r)/(2*u*eF))]
              #see below: [kadd == q+1 -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]

              [m < (kB*eF +1) * ((kadd*(2*u*eF) +r -kB)*eF +1)]
              [(s+t) < kadd*(2*u*eF) +r]
              [(s+t) == r +(2*u*eF)*(q-v)]
              !! [eR == (2*u*eF)*q + r]
              [(s+t) == eR -(2*u*eF)*v]
              [0 <= q-v <= kadd-1]
              [v >= q-kadd+1]
                # 1:min_v

              [q >= v == s*t /// (2*u) >= ceil_(kB**2 /(2*u)) >= 1]
              [v >= ceil_(kB**2 /(2*u)) >= 1]
                # 2:min_v


              !! [v := s*t /// (2*u)]
              [s*t == 2*u*v]
              !! [s*t >= kB*((s+t) -kB)]
              !! [(s+t) == eR -(2*u*eF)*v]
              [2*u*v >= kB*((eR -(2*u*eF)*v) -kB)]
              [(2*u +kB*(2*u*eF))*v >= kB*(eR -kB)]
              [v >= ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]
                # 3:min_v

              !! [v >= q-kadd+1]
              !! [v >= ceil_(kB**2 /(2*u)) >= 1]
              !! [v >= ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]
              [min_v := max{1, q-kadd+1, ceil_(kB**2 /(2*u)), ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))}]

              [max_dqv := min{(kadd-1),(q-min_v),(q-1)}]
              [max_dqv == (q-min_v)]


              !! [kadd := 1+ floor_((((m/(kB*eF +1) -1)/eF +kB) -r)/(2*u*eF))]
              [q-kadd+1
              == q-floor_((((m/(kB*eF +1) -1)/eF +kB) -r)/(2*u*eF))
              == q +ceil_((r -((m/(kB*eF +1) -1)/eF +kB))/(2*u*eF))
              !! [eR == (2*u*eF)*q + r]
              == ceil_((eR -((m/(kB*eF +1) -1)/eF +kB))/(2*u*eF))
              == ceil_(((eR*eF-kB*eF -m/(kB*eF +1) +1)/eF)/(2*u*eF))
              == ceil_((m -kB*eF -m/(kB*eF +1))/eF/(2*u*eF))
              == ceil_((m*(kB*eF +1) -kB*eF*(kB*eF +1) -m)/(kB*eF +1)/eF/(2*u*eF))
              == ceil_((m -(kB*eF +1))*kB/(kB*eF +1)/(2*u*eF))
                # ...
              == ceil_(((eR*eF +1) -(kB*eF +1))*kB/eF/(2*u*(1 +kB*eF)))
              == ceil_((eR -kB)*kB/(2*u*(1 +kB*eF)))
              ]
              [q-kadd+1 == ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]
              [min_v == max{1, ceil_(kB**2 /(2*u)), ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))}]
                # cancel (q-kadd+1)
              [kadd == q+1 -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]


              [(kB**2 /(2*u)) <= (kB*(eR -kB) /(2*u*(1 +kB*eF)))]
                <==> [kB*(1 +kB*eF) <= (eR -kB)]
                <==> [kB*(2 +kB*eF) <= eR]
                <==> [(1 +kB*eF)**2 <= 1 +eF*eR == m]
                <==> [(1 +kB*eF)**2 <= m]
              [(1 +kB*eF)**2 <= m]:
                [(kB**2 /(2*u)) <= (kB*(eR -kB) /(2*u*(1 +kB*eF)))]
                [min_v == max{1, q-kadd+1, ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))}]
                [min_v == max{1, ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))}]
                  # omit ceil_(kB**2 /(2*u))

                [kB*(2 +kB*eF) <= eR]
                [eR > kB]
                [0 < (kB*(eR -kB) /(2*u*(1 +kB*eF)))]
                [1 <= ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]
                [min_v == ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF))) == (q-kadd+1)]
                  # omit 1
              [(1 +kB*eF)**2 <= m]:
                [min_v == ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF))) == (q-kadd+1)]
                [max_dqv == (q -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))) == kadd-1]



              !! [(s+t) >= 2*kB]
              !! [(s+t) == eR -(2*u*eF)*v]
              [eR -(2*u*eF)*v >= 2*kB]
              [v <= floor_((eR -2*kB)/(2*u*eF))]
              [v <= q +floor_((r -2*kB)/(2*u*eF))]
              [v <= q -ceil_((-r +2*kB)/(2*u*eF))]
                # 1:max_v

              !! [(s+t)**2 >= 4*(s*t)]
              !! [(s+t) == eR -(2*u*eF)*v]
              !! [s*t == 2*u*v]
              [(eR -(2*u*eF)*v)**2 >= 4*(2*u*v)]
              [(eR**2 -2*eR*(2*u*eF)*v +(2*u*eF)**2*v**2) >= 4*(2*u*v)]
              [(eR**2/(2*u*eF) -2*eR*v +(2*u*eF)*v**2) >= 4*(2*u*v)/(2*u*eF) == 4*v/eF]
              [(eR**2/(2*u*eF) -2*(eR +4*v/eF/(2*v))*v +(2*u*eF)*v**2) >= 0]
              [(eR**2/(2*u*eF) -2*(eR +2/eF)*v +(2*u*eF)*v**2) >= 0]
              !! 对称轴: [v == 2*(eR +2/eF) /2/(2*u*eF) == (r +(2*u*eF)*q +2/eF) /(2*u*eF) > q]
              !! [1 <= v <= q]
              [v <= min{q,两根中的小根}]
              [v <= ((2*(eR +2/eF)) -sqrt((2*(eR +2/eF))**2 -4*eR**2))/(2*(2*u*eF))
              == ((eR +2/eF) -sqrt((eR +2/eF)**2 -eR**2))/(2*u*eF)
              == ((eR +2/eF) -sqrt(2/eF *2*(eR +1/eF)))/(2*u*eF)
              == ((eR +2/eF) -2*sqrt((eR +1/eF)/eF))/(2*u*eF)
              == ((eR +2/eF) -2/eF*sqrt(eR*eF +1))/(2*u*eF)
              == ((m+1) -2*sqrt(m))/(2*u*eF)/eF
              == q +((r*eF +2) -2*sqrt(m))/(2*u*eF)/eF
              == q -(-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF
              ]
              [v <= q -ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                # 2:max_v


              !! [1 <= v <= q]
              !! [v <= q -ceil_((2*kB -r)/(2*u*eF))]
              !! [v <= q -ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
              [max_v := min{q-0, (q -ceil_((2*kB -r)/(2*u*eF))), (q -ceil_((-(r +2/eF) +2*sqrt((r +(2*u*eF)*q +1/eF)/eF))/(2*u*eF)))}]
              [max_v == q -max{0, ceil_((2*kB -r)/(2*u*eF)), ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)}]

              [min_dqv := max{0, q-max_v}]


              [0 <= ((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                <==> [(r*eF +2) <= 2*sqrt(m)]
                <==> [(r*eF +2)**2 <= 4*m == 4*(eR*eF+1)]
                <==> [(r**2*eF**2 +4 +4*r*eF) <= (4*eR*eF+4)]
                <==> [r**2*eF <= 4*(eR-r) == 4*q*(2*u*eF)]
                <==> [r**2 <= 4*q*(2*u)]
                !! [0 <= r < (2*u*eF)]
                <<== [(2*u*eF-1)**2 <= 4*q*(2*u)]
                不太行
                重来:
              [-1 < ((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                <==> [-eF*(2*u*eF) < (-(r*eF +2) +2*sqrt(m))]
                <==> [2*sqrt(m) > (r*eF +2) -eF*(2*u*eF) == 2 -eF*(2*u*eF -r)]
                !! [0 <= r < (2*u*eF)]
                <<== [2*sqrt(m) > 2 -eF*1]
                !! [eF%2 == 0][eF > 0]
                <<== [2*sqrt(m) > 0]
                !! [m > 0]
                <<== True
              [-1 < ((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
              [0 <= ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]

              [max_v == q -max{ceil_((2*kB -r)/(2*u*eF)), ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)}]
                #omit 0


              [((2*kB -r)/(2*u*eF)) <= ((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                <==> [(2*kB*eF -r*eF) <= (-(r*eF +2) +2*sqrt(m))]
                <==> [(kB*eF +1) <= sqrt(m)]
                <==> [(kB*eF +1)**2 <= m]
              [(1 +kB*eF)**2 <= m]:
                [((2*kB -r)/(2*u*eF)) <= ((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                [max_v == q -ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                  # omit ceil_((2*kB -r)/(2*u*eF))
              [(1 +kB*eF)**2 <= m]:
                [max_v == q -ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                [min_dqv == ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]



              [q-v <- [min_dqv..=max_dqv]]
              [(1 +kB*eF)**2 <= m]:
                !! [min_dqv == ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
                !! [max_dqv == (q -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))) == kadd-1]
                [q-v <- [ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)..=(q -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF))))]]

              # [dqv := q-v]
              [(1 +kB*eF)**2 <= m][dqv :<- [min_dqv..=max_dqv]][v == q -dqv]:
                !! [v := s*t /// (2*u)]
                [s*t == 2*u*v == 2*u*(q-dqv)]
                !! [(s+t) == eR -(2*u*eF)*v]
                !! [eR == (2*u*eF)*q + r]
                [(s+t) == r +(2*u*eF)*dqv]
                [s*t == 2*u*(q-dqv)]
                # solve for s,t
                [(s-t)**2 == (s+t)**2 -4*s*t
                == ((r +(2*u*eF)*dqv)**2 -8*u*(q-dqv))
                ]
                [(s-t)**2 == ((r +(2*u*eF)*dqv)**2 -8*u*(q-dqv))]
                [[(s,t) have integer solutions] <-> [sqrt((r +(2*u*eF)*dqv)**2 -8*u*(q-dqv)) %1 == 0]]
                #批量测试 完美平方:中国剩余定理+平方剩余==>>整数分解算法{u:=1,eF:=2;但eR:=2**?*odd不一定是奇数}？？？
                #e script/整数分解算法囗批量测试完美平方.py
          [[kB :<- [1..]][[q4m :<- all_prime_factors_of_(m)] -> [(q4m-1)///eF >= kB]][(1 +kB*eF)**2 <= m]]:
            [kadd := q+1 -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]
            [m < (kB*eF +1) * ((kadd*(2*u*eF) +r -kB)*eF +1)]

            [max_v := q -ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
            [min_dqv := ceil_((-(r*eF +2) +2*sqrt(m))/(2*u*eF)/eF)]
            [min_v := ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF)))]
            [max_dqv := (q -ceil_(kB*(eR -kB) /(2*u*(1 +kB*eF))))]

            [q-v <- [min_dqv..=max_dqv]]
            [min_v >= 1]
            [[?[dqv :<- [min_dqv..=max_dqv]] -> [[q -dqv >= 1][sqrt((r +(2*u*eF)*dqv)**2 -8*u*(q-dqv)) %1 == 0]]] <-> [not$ is_prime_(m)]]
            [[@[dqv :<- [min_dqv..=max_dqv]] -> [q -dqv >= 1] -> [sqrt((r +(2*u*eF)*dqv)**2 -8*u*(q-dqv)) %1 =!= 0]] <-> [is_prime_(m)]]
              #定理:二
              #我:扩展后的素性判定
              # 如何选取 kB,kadd 以最小化计算量???
              # kadd<kB> 由kB决定...
              #     先减后增，不过 递增 阶段 kB 很大，可能[(1 +kB*eF)**2 <= m]已不成立




        ===
          #     注意到: m很可能 最多只有两个 素因子 (尝试证明)；这样一来，更容易 找到更大的u
          # e script/primality_test____st_solutions.py
        [eF%3 == eR%3 =!= 0]:
          [k := eF%3]
          [k =[%3]= s*t*k +(s+t)]
          * [k == 1]:
            [1 =[%3]= s*t*1 +(s+t)]
            [2 =[%3]= (s+1)*(t+1)]
            [{s+1, t+1}%3 == {1, 2}]
            [{s, t}%3 == {0, 1}]
            [s*t%3 == 0]
          * [k == (-1)%3]:
            [-1 =[%3]= -s*t +(s+t)]
            [1 =[%3]= s*t -(s+t)]
            [1 =[%3]= (s-1)*(t-1)]
            [{s-1, t-1}%3 == {1, 2}]
            [{s, t}%3 == {2, 0}]
            [s*t%3 == 0]
          [s*t%3 == 0]
        [eF%3 =!= eR%3 =!= 0]:
        [eF%3 == 1 =!= 2 == eR%3 =!= 0]:
            [2 =[%3]= s*t*1 +(s+t)]
            [0 =[%3]= (s+1)*(t+1)]
            [2 <- {s,t}%3]
        [eF%3 == 2 =!= 1 == eR%3 =!= 0]:
            [1 =[%3]= s*t*2 +(s+t)]
            [2 =[%3]= s*t -(s+t)]
            [0 =[%3]= (s-1)*(t-1)]
            [2 <- {s,t}%3]
        [eF%3 == 0 =!= k == eR%3 =!= 0]:
            [k =[%3]= s*t*0 +(s+t)]
            [k =[%3]= (s+t)]
            [(s*t) =[%3]= (k-t)*t]
            * [t =[%3]= 0]:
              [(s*t) =[%3]= 0]
            * [t =[%3]= k]:
              [(s*t) =[%3]= 0]
            * [t =[%3]= -k]:
              [(s*t) =[%3]= 2*k * -k]
              [(s*t) =[%3]= k**2]
              [(s*t) =[%3]= 1]



]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]
[[[
===
]]]

