
e others/数学/involution自逆函数.txt


[f is invertible function] =[def]=
  [?g. @x. g(f(x))===x]
  let f**-1 =[def]= g

[f is involution] =[def]=
  [@x. f(f(x)) === x]
  [f . f === echo]
  [f === f**-1]

used in:
  view others/数学/编程/TODO_list/周期长度为二的对称加密.txt
    view ../../python3_src/nn_ns/app/crypt/InvolutoryCipher.py

[[[
[https://handwiki.org/wiki/Involution_(mathematics)



Short description: Function that is its own inverse
An involution is a function that, when applied twice, brings one back to the starting point.

In mathematics, an involution, involutory function, or self-inverse function[1] is a function f that is its own inverse,

    f(f(x)) = x

for all x in the domain of f.[2] Equivalently, applying f twice produces the original value.

The term anti-involution refers to involutions based on antihomomorphisms (see § Quaternion algebra, groups, semigroups below)

    f(xy) = f(y) f(x)

such that

    xy = f(f(xy)) = f( f(y) f(x) ) = f(f(x)) f(f(y)) = xy.

Contents

    1 General properties
    2 Involution throughout the fields of mathematics
        2.1 Pre-calculus
        2.2 Euclidean geometry
        2.3 Projective geometry
        2.4 Linear algebra
        2.5 Quaternion algebra, groups, semigroups
        2.6 Ring theory
        2.7 Group theory
        2.8 Mathematical logic
        2.9 Computer science
    3 See also
    4 References
    5 Further reading

General properties

Any involution is a bijection.

The identity map is a trivial example of an involution. Common examples in mathematics of nontrivial involutions include multiplication by −1 in arithmetic, the taking of reciprocals, complementation in set theory and complex conjugation. Other examples include circle inversion, rotation by a half-turn, and reciprocal ciphers such as the ROT13 transformation and the Beaufort polyalphabetic cipher.

The number of involutions, including the identity involution, on a set with n = 0, 1, 2, ... elements is given by a recurrence relation found by Heinrich August Rothe in 1800:

and for

The first few terms of this sequence are 1, 1, 2, 4, 10, 26, 76, 232 (sequence A000085 in the OEIS); these numbers are called the telephone numbers, and they also count the number of Young tableaux with a given number of cells.[3] The composition g ∘ f of two involutions f and g is an involution if and only if they commute: g ∘ f = f ∘ g.[4]

Every involution on an odd number of elements has at least one fixed point. More generally, for an involution on a finite set of elements, the number of elements and the number of fixed points have the same parity.[5]
Involution throughout the fields of mathematics
Pre-calculus

Basic examples of involutions are the functions:

,   or  
, as well as their composition

These are not the only pre-calculus involutions. Another one within the positive reals is:

The graph of an involution (on the real numbers) is line-symmetric over the line . This is due to the fact that the inverse of any general function will be its reflection over the 45° line . This can be seen by "swapping" with

. If, in particular, the function is an involution, then it will serve as its own reflection.

Other elementary involutions are useful in solving functional equations.
Euclidean geometry

A simple example of an involution of the three-dimensional Euclidean space is reflection through a plane. Performing a reflection twice brings a point back to its original coordinates.

Another involution is reflection through the origin; not a reflection in the above sense, and so, a distinct example.

These transformations are examples of affine involutions.
Projective geometry

An involution is a projectivity of period 2, that is, a projectivity that interchanges pairs of points.[6]:24

    Any projectivity that interchanges two points is an involution.
    The three pairs of opposite sides of a complete quadrangle meet any line (not through a vertex) in three pairs of an involution. This theorem has been called Desargues's Involution Theorem.[7] Its origins can be seen in Lemma IV of the lemmas to the Porisms of Euclid in Volume VII of the Collection of Pappus of Alexandria.[8]
    If an involution has one fixed point, it has another, and consists of the correspondence between harmonic conjugates with respect to these two points. In this instance the involution is termed "hyperbolic", while if there are no fixed points it is "elliptic". In the context of projectivities, fixed points are called double points.[6]:53

Another type of involution occurring in projective geometry is a polarity which is a correlation of period 2. [9]
Linear algebra
Further information: Involutory matrix

In linear algebra, an involution is a linear operator T on a vector space, such that

. Except for in characteristic 2, such operators are diagonalizable for a given basis with just 1s and −1s on the diagonal of the corresponding matrix. If the operator is orthogonal (an orthogonal involution), it is orthonormally diagonalizable.

For example, suppose that a basis for a vector space V is chosen, and that e1 and e2 are basis elements. There exists a linear transformation f which sends e1 to e2, and sends e2 to e1, and which is the identity on all other basis vectors. It can be checked that f(f(x)) = x for all x in V. That is, f is an involution of V.

For a specific basis, any linear operator can be represented by a matrix T. Every matrix has a transpose, obtained by swapping rows for columns. This transposition is an involution on the set of matrices.

The definition of involution extends readily to modules. Given a module M over a ring R, an R endomorphism f of M is called an involution if f 2 is the identity homomorphism on M.

Involutions are related to idempotents; if 2 is invertible then they correspond in a one-to-one manner.
Quaternion algebra, groups, semigroups

In a quaternion algebra, an (anti-)involution is defined by the following axioms: if we consider a transformation

then it is an involution if

(it is its own inverse)
and
(it is linear)

An anti-involution does not obey the last axiom but instead

This former law is sometimes called antidistributive. It also appears in groups as (xy)−1 = y−1x−1. Taken as an axiom, it leads to the notion of semigroup with involution, of which there are natural examples that are not groups, for example square matrix multiplication (i.e. the full linear monoid) with transpose as the involution.
Ring theory
Further information: *-algebra

In ring theory, the word involution is customarily taken to mean an antihomomorphism that is its own inverse function. Examples of involutions in common rings:

    complex conjugation on the complex plane
    multiplication by j in the split-complex numbers
    taking the transpose in a matrix ring.

Group theory

In group theory, an element of a group is an involution if it has order 2; i.e. an involution is an element a such that a ≠ e and a2 = e, where e is the identity element.[10]

Originally, this definition agreed with the first definition above, since members of groups were always bijections from a set into itself; i.e., group was taken to mean permutation group. By the end of the 19th century, group was defined more broadly, and accordingly so was involution.

A permutation is an involution precisely if it can be written as a product of one or more non-overlapping transpositions.

The involutions of a group have a large impact on the group's structure. The study of involutions was instrumental in the classification of finite simple groups.

An element x of a group G is called strongly real if there is an involution t with xt = x−1 (where xt = t−1⋅x⋅t).

Coxeter groups are groups generated by involutions with the relations determined only by relations given for pairs of the generating involutions. Coxeter groups can be used, among other things, to describe the possible regular polyhedra and their generalizations to higher dimensions.
Mathematical logic

The operation of complement in Boolean algebras is an involution. Accordingly, negation in classical logic satisfies the law of double negation: ¬¬A is equivalent to A.

Generally in non-classical logics, negation that satisfies the law of double negation is called involutive. In algebraic semantics, such a negation is realized as an involution on the algebra of truth values. Examples of logics which have involutive negation are Kleene and Bochvar three-valued logics, Łukasiewicz many-valued logic, fuzzy logic IMTL, etc. Involutive negation is sometimes added as an additional connective to logics with non-involutive negation; this is usual, for example, in t-norm fuzzy logics.

The involutiveness of negation is an important characterization property for logics and the corresponding varieties of algebras. For instance, involutive negation characterizes Boolean algebras among Heyting algebras. Correspondingly, classical Boolean logic arises by adding the law of double negation to intuitionistic logic. The same relationship holds also between MV-algebras and BL-algebras (and so correspondingly between Łukasiewicz logic and fuzzy logic BL), IMTL and MTL, and other pairs of important varieties of algebras (resp. corresponding logics).

In the study of binary relations, every relation has a converse relation. Since the converse of the converse is the original relation, the conversion operation is an involution on the category of relations. Binary relations are ordered through inclusion. While this ordering is reversed with the complementation involution, it is preserved under conversion.
Computer science

The XOR bitwise operation with a given value for one parameter is an involution. XOR masks were once used to draw graphics on images in such a way that drawing them twice on the background reverts the background to its original state. The NOT bitwise operation is also an involution, and is a special case of the XOR operation where one parameter has all bits set to 1.

Another example is a bit mask and shift function operating on color values stored as integers, say in the form RGB, that swaps R and B, resulting in the form BGR. f(f(RGB))=RGB, f(f(BGR))=BGR.

The RC4 cryptographic cipher is an involution, as encryption and decryption operations use the same function.

Practically all mechanical cipher machines implement a reciprocal cipher, an involution on each typed-in letter. Instead of designing two kinds of machines, one for encrypting and one for decrypting, all the machines can be identical and can be set up (keyed) the same way.[11]
See also

    Automorphism
    Idempotence
    ROT13

References

Robert Alexander Adams, Calculus: Single Variable, 2006, ISBN 0321307143, p. 165
Russell, Bertrand (1903), Principles of mathematics (2nd ed.), W. W. Norton & Company, Inc, p. 426, ISBN 9781440054167
The Art of Computer Programming, Volume 3: Sorting and Searching, Reading, Mass.: Addison-Wesley, 1973, pp. 48, 65.
Kubrusly, Carlos S. (2011), The Elements of Operator Theory, Springer Science & Business Media, Problem 1.11(a), p. 27, ISBN 9780817649982.
"A one-sentence proof that every prime p≡ 1 (mod 4) is a sum of two squares", American Mathematical Monthly 97 (2): 144, 1990, doi:10.2307/2323918.
A.G. Pickford (1909) Elementary Projective Geometry, Cambridge University Press via Internet Archive
J. V. Field and J. J. Gray (1987) The Geometrical Work of Girard Desargues, (New York: Springer), p. 54
Ivor Thomas (editor) (1980) Selections Illustrating the History of Greek Mathematics, Volume II, number 362 in the Loeb Classical Library (Cambridge and London: Harvard and Heinemann), pp. 610–3
H. S. M. Coxeter (1969) Introduction to Geometry, pp 244–8, John Wiley & Sons
John S. Rose. "A Course on Group Theory". p. 10, section 1.13.

    Greg Goebel. "The Mechanization of Ciphers". 2018.

Further reading

    Ell, Todd A.; Sangwine, Stephen J. (2007). "Quaternion involutions and anti-involutions". Computers & Mathematics with Applications 53 (1): 137–143. doi:10.1016/j.camwa.2006.10.029.
    Knus, Max-Albert; Merkurjev, Alexander; Rost, Markus; Tignol, Jean-Pierre (1998), The book of involutions, Colloquium Publications, 44, With a preface by J. Tits, Providence, RI: American Mathematical Society, ISBN 0-8218-0904-0
    Hazewinkel, Michiel, ed. (2001), "Involution", Encyclopedia of Mathematics, Springer Science+Business Media B.V. / Kluwer Academic Publishers, ISBN 978-1-55608-010-4


Public domain	
0.00
(0 votes)
Original source: https://en.wikipedia.org/wiki/ Involution (mathematics). Read more


Category:

    Functions and mappings


    This page was last edited on 29 January 2022, at 01:56.
    Privacy policyAbout HandWikiDisclaimers

]

[
https://handwiki.org/wiki/RC4

Short description: Stream cipher
RC4General
Designers	Ron Rivest (RSA Security)
First published	Leaked in 1994
(designed in 1987)
Cipher detail
Key sizes	40–2048 bits
State size	2064 bits (1684 effective)
Rounds	1
Speed	7 cycles per byte on original Pentium[1]
Modified Alleged RC4 on Intel Core 2: 13.9 cycles per byte[2]

In cryptography, RC4 (Rivest Cipher 4 also known as ARC4 or ARCFOUR meaning Alleged RC4, see below) is a stream cipher. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure.[3][4] It is especially vulnerable when the beginning of the output keystream is not discarded, or when nonrandom or related keys are used. Particularly problematic uses of RC4 have led to very insecure protocols such as WEP.[5]

(As of 2015), there is speculation that some state cryptologic agencies may possess the capability to break RC4 when used in the TLS protocol.[6] IETF has published RFC 7465 to prohibit the use of RC4 in TLS;[3] Mozilla and Microsoft have issued similar recommendations.[7][8]

A number of attempts have been made to strengthen RC4, notably Spritz, RC4A, VMPC, and RC4+.
Contents

    1 History
    2 Description
        2.1 Key-scheduling algorithm (KSA)
        2.2 Pseudo-random generation algorithm (PRGA)
        2.3 RC4-based random number generators
        2.4 Implementation
        2.5 Test vectors
    3 Security
        3.1 Roos' biases and key reconstruction from permutation
        3.2 Biased outputs of the RC4
        3.3 Fluhrer, Mantin and Shamir attack
        3.4 Klein's attack
        3.5 Combinatorial problem
        3.6 Royal Holloway attack
        3.7 Bar-mitzvah attack
        3.8 NOMORE attack
    4 RC4 variants
        4.1 RC4A
        4.2 VMPC
        4.3 RC4+
        4.4 Spritz
    5 RC4-based protocols
    6 See also
    7 References
    8 Further reading
    9 External links

History

RC4 was designed by Ron Rivest of RSA Security in 1987. While it is officially termed "Rivest Cipher 4", the RC acronym is alternatively understood to stand for "Ron's Code"[9] (see also RC2, RC5 and RC6).

RC4 was initially a trade secret, but in September 1994 a description of it was anonymously posted to the Cypherpunks mailing list.[10] It was soon posted on the sci.crypt newsgroup, where it was analyzed within days by Bob Jenkins.[11] From there it spread to many sites on the Internet. The leaked code was confirmed to be genuine as its output was found to match that of proprietary software using licensed RC4. Because the algorithm is known, it is no longer a trade secret. The name RC4 is trademarked, so RC4 is often referred to as ARCFOUR or ARC4 (meaning alleged RC4)[12] to avoid trademark problems. RSA Security has never officially released the algorithm; Rivest has, however, linked to the English Wikipedia article on RC4 in his own course notes in 2008[13] and confirmed the history of RC4 and its code in a 2014 paper by him.[14]

RC4 became part of some commonly used encryption protocols and standards, such as WEP in 1997 and WPA in 2003/2004 for wireless cards; and SSL in 1995 and its successor TLS in 1999, until it was prohibited for all versions of TLS by RFC 7465 in 2015, due to the RC4 attacks weakening or breaking RC4 used in SSL/TLS. The main factors in RC4's success over such a wide range of applications have been its speed and simplicity: efficient implementations in both software and hardware were very easy to develop.
Description

RC4 generates a pseudorandom stream of bits (a keystream). As with any stream cipher, these can be used for encryption by combining it with the plaintext using bit-wise exclusive-or; decryption is performed the same way (since exclusive-or with given data is an involution). This is similar to the one-time pad except that generated pseudorandom bits, rather than a prepared stream, are used.

To generate the keystream, the cipher makes use of a secret internal state which consists of two parts:

    A permutation of all 256 possible bytes (denoted "S" below).
    Two 8-bit index-pointers (denoted "i" and "j").

The permutation is initialized with a variable length key, typically between 40 and 2048 bits, using the key-scheduling algorithm (KSA). Once this has been completed, the stream of bits is generated using the pseudo-random generation algorithm (PRGA).
Key-scheduling algorithm (KSA)

The key-scheduling algorithm is used to initialize the permutation in the array "S". "keylength" is defined as the number of bytes in the key and can be in the range 1 ≤ keylength ≤ 256, typically between 5 and 16, corresponding to a key length of 40 – 128 bits. First, the array "S" is initialized to the identity permutation. S is then processed for 256 iterations in a similar way to the main PRGA, but also mixes in bytes of the key at the same time.

for i from 0 to 255
    S[i] := i
endfor
j := 0
for i from 0 to 255
    j := (j + S[i] + key[i mod keylength]) mod 256
    swap values of S[i] and S[j]
endfor

Pseudo-random generation algorithm (PRGA)
The lookup stage of RC4. The output byte is selected by looking up the values of S[i] and S[j], adding them together modulo 256, and then using the sum as an index into S; S(S[i] + S[j]) is used as a byte of the key stream, K.

For as many iterations as are needed, the PRGA modifies the state and outputs a byte of the keystream. In each iteration, the PRGA:

    increments i
    looks up the ith element of S, S[i], and adds that to j
    exchanges the values of S[i] and S[j] then uses the sum S[i] + S[j] (modulo 256) as an index to fetch a third element of S (the keystream value K below)
    then bitwise exclusive ORed (XORed) with the next byte of the message to produce the next byte of either ciphertext or plaintext.

Each element of S is swapped with another element at least once every 256 iterations.

i := 0
j := 0
while GeneratingOutput:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    K := S[(S[i] + S[j]) mod 256]
    output K
endwhile

Thus, this produces a stream of K[0],K[1],... which are XOR'ed with the plaintext to obtain the ciphertext. So ciphertext[l] = plaintext[l] ⊕ K[l] .
RC4-based random number generators

Several operating systems include arc4random, an API originating in OpenBSD providing access to a random number generator originally based on RC4. In OpenBSD 5.5, released in May 2014, arc4random was modified to use ChaCha20.[15][16] The implementations of arc4random in FreeBSD, NetBSD[17][18] and Linux's libbsd[19] also use ChaCha20. According to manual pages shipped with the operating system, in the 2017 release of its desktop and mobile operating systems, Apple replaced RC4 with AES in its implementation of arc4random. Man pages for the new arc4random include the backronym "A Replacement Call for Random" for ARC4 as a mnemonic,[20] as it provides better random data than rand() does.

Proposed new random number generators are often compared to the RC4 random number generator.[21][22]

Several attacks on RC4 are able to distinguish its output from a random sequence.[23]
Implementation

Many stream ciphers are based on linear-feedback shift registers (LFSRs), which, while efficient in hardware, are less so in software. The design of RC4 avoids the use of LFSRs and is ideal for software implementation, as it requires only byte manipulations. It uses 256 bytes of memory for the state array, S[0] through S[255], k bytes of memory for the key, key[0] through key[k-1], and integer variables, i, j, and K. Performing a modular reduction of some value modulo 256 can be done with a bitwise AND with 255 (which is equivalent to taking the low-order byte of the value in question).
Test vectors

These test vectors are not official, but convenient for anyone testing their own RC4 program. The keys and plaintext are ASCII, the keystream and ciphertext are in hexadecimal.
Key 	Keystream 	Plaintext 	Ciphertext
Key 	EB9F7781B734CA72A719… 	Plaintext 	BBF316E8D940AF0AD3
Wiki 	6044DB6D41B7… 	pedia 	1021BF0420
Secret 	04D46B053CA87B59… 	Attack at dawn 	45A01F645FC35B383552544B9BF5
Security

Unlike a modern stream cipher (such as those in eSTREAM), RC4 does not take a separate nonce alongside the key. This means that if a single long-term key is to be used to securely encrypt multiple streams, the protocol must specify how to combine the nonce and the long-term key to generate the stream key for RC4. One approach to addressing this is to generate a "fresh" RC4 key by hashing a long-term key with a nonce. However, many applications that use RC4 simply concatenate key and nonce; RC4's weak key schedule then gives rise to related key attacks, like the Fluhrer, Mantin and Shamir attack (which is famous for breaking the WEP standard).[24]

Because RC4 is a stream cipher, it is more malleable than common block ciphers. If not used together with a strong message authentication code (MAC), then encryption is vulnerable to a bit-flipping attack. The cipher is also vulnerable to a stream cipher attack if not implemented correctly.[25]

It is noteworthy, however, that RC4, being a stream cipher, was for a period of time the only common cipher that was immune[26] to the 2011 BEAST attack on TLS 1.0. The attack exploits a known weakness in the way cipher block chaining mode is used with all of the other ciphers supported by TLS 1.0, which are all block ciphers.

In March 2013, there were new attack scenarios proposed by Isobe, Ohigashi, Watanabe and Morii,[27] as well as AlFardan, Bernstein, Paterson, Poettering and Schuldt that use new statistical biases in RC4 key table[28] to recover plaintext with large number of TLS encryptions.[29][30]

The use of RC4 in TLS is prohibited by RFC 7465 published in February 2015.
Roos' biases and key reconstruction from permutation

In 1995, Andrew Roos experimentally observed that the first byte of the keystream is correlated to the first three bytes of the key and the first few bytes of the permutation after the KSA are correlated to some linear combination of the key bytes.[31] These biases remained unexplained until 2007, when Goutam Paul, Siddheshwar Rathi and Subhamoy Maitra[32] proved the keystream–key correlation and in another work Goutam Paul and Subhamoy Maitra[33] proved the permutation–key correlations. The latter work also used the permutation–key correlations to design the first algorithm for complete key reconstruction from the final permutation after the KSA, without any assumption on the key or initialization vector. This algorithm has a constant probability of success in a time which is the square root of the exhaustive key search complexity. Subsequently, many other works have been performed on key reconstruction from RC4 internal states.[34][35][36] Subhamoy Maitra and Goutam Paul[37] also showed that the Roos-type biases still persist even when one considers nested permutation indices, like S[S[i]] or S[S[S[i]]]. These types of biases are used in some of the later key reconstruction methods for increasing the success probability.
Biased outputs of the RC4

The keystream generated by the RC4 is biased to varying degrees towards certain sequences making it vulnerable to distinguishing attacks. The best such attack is due to Itsik Mantin and Adi Shamir who showed that the second output byte of the cipher was biased toward zero with probability 1/128 (instead of 1/256). This is due to the fact that if the third byte of the original state is zero, and the second byte is not equal to 2, then the second output byte is always zero. Such bias can be detected by observing only 256 bytes.[23]

Souradyuti Paul and Bart Preneel of COSIC showed that the first and the second bytes of the RC4 were also biased. The number of required samples to detect this bias is 225 bytes.[38]

Scott Fluhrer and David McGrew also showed such attacks which distinguished the keystream of the RC4 from a random stream given a gigabyte of output.[39]

The complete characterization of a single step of RC4 PRGA was performed by Riddhipratim Basu, Shirshendu Ganguly, Subhamoy Maitra, and Goutam Paul.[40] Considering all the permutations, they prove that the distribution of the output is not uniform given i and j, and as a consequence, information about j is always leaked into the output.
Fluhrer, Mantin and Shamir attack

In 2001, a new and surprising discovery was made by Fluhrer, Mantin and Shamir: over all the possible RC4 keys, the statistics for the first few bytes of output keystream are strongly non-random, leaking information about the key. If the nonce and long-term key are simply concatenated to generate the RC4 key, this long-term key can be discovered by analysing a large number of messages encrypted with this key.[41] This and related effects were then used to break the WEP ("wired equivalent privacy") encryption used with 802.11 wireless networks. This caused a scramble for a standards-based replacement for WEP in the 802.11 market, and led to the IEEE 802.11i effort and WPA.[42]

Protocols can defend against this attack by discarding the initial portion of the keystream. Such a modified algorithm is traditionally called "RC4-drop[n]", where n is the number of initial keystream bytes that are dropped. The SCAN default is n = 768 bytes, but a conservative value would be n = 3072 bytes.[43]

The Fluhrer, Mantin and Shamir attack does not apply to RC4-based SSL, since SSL generates the encryption keys it uses for RC4 by hashing, meaning that different SSL sessions have unrelated keys.[44]
Klein's attack

In 2005, Andreas Klein presented an analysis of the RC4 stream cipher showing more correlations between the RC4 keystream and the key.[45] Erik Tews, Ralf-Philipp Weinmann, and Andrei Pychkine used this analysis to create aircrack-ptw, a tool which cracks 104-bit RC4 used in 128-bit WEP in under a minute.[46] Whereas the Fluhrer, Mantin, and Shamir attack used around 10 million messages, aircrack-ptw can break 104-bit keys in 40,000 frames with 50% probability, or in 85,000 frames with 95% probability.
Combinatorial problem

A combinatorial problem related to the number of inputs and outputs of the RC4 cipher was first posed by Itsik Mantin and Adi Shamir in 2001, whereby, of the total 256 elements in the typical state of RC4, if x number of elements (x ≤ 256) are only known (all other elements can be assumed empty), then the maximum number of elements that can be produced deterministically is also x in the next 256 rounds. This conjecture was put to rest in 2004 with a formal proof given by Souradyuti Paul and Bart Preneel.[47]
Royal Holloway attack

In 2013, a group of security researchers at the Information Security Group at Royal Holloway, University of London reported an attack that can become effective using only 234 encrypted messages.[48][49][50] While yet not a practical attack for most purposes, this result is sufficiently close to one that it has led to speculation that it is plausible that some state cryptologic agencies may already have better attacks that render RC4 insecure.[6] Given that, (As of 2013), a large amount of TLS traffic uses RC4 to avoid attacks on block ciphers that use cipher block chaining, if these hypothetical better attacks exist, then this would make the TLS-with-RC4 combination insecure against such attackers in a large number of practical scenarios.[6]

In March 2015 researcher to Royal Holloway announced improvements to their attack, providing a 226 attack against passwords encrypted with RC4, as used in TLS.[51]
Bar-mitzvah attack

On the Black Hat Asia 2015, Itsik Mantin presented another attack against SSL using RC4 cipher.[52][53]
NOMORE attack

In 2015, security researchers from KU Leuven presented new attacks against RC4 in both TLS and WPA-TKIP.[54] Dubbed the Numerous Occurrence MOnitoring & Recovery Exploit (NOMORE) attack, it is the first attack of its kind that was demonstrated in practice. Their attack against TLS can decrypt a secure HTTP cookie within 75 hours. The attack against WPA-TKIP can be completed within an hour, and allows an attacker to decrypt and inject arbitrary packets.
RC4 variants

As mentioned above, the most important weakness of RC4 comes from the insufficient key schedule; the first bytes of output reveal information about the key. This can be corrected by simply discarding some initial portion of the output stream.[55] This is known as RC4-dropN, where N is typically a multiple of 256, such as 768 or 1024.

A number of attempts have been made to strengthen RC4, notably Spritz, RC4A, VMPC, and RC4+.
RC4A

Souradyuti Paul and Bart Preneel have proposed an RC4 variant, which they call RC4A.[56]

RC4A uses two state arrays S1 and S2, and two indexes j1 and j2. Each time i is incremented, two bytes are generated:

    First, the basic RC4 algorithm is performed using S1 and j1, but in the last step, S1[i]+S1[j1] is looked up in S2.
    Second, the operation is repeated (without incrementing i again) on S2 and j2, and S1[S2[i]+S2[j2]] is output.

Thus, the algorithm is:

All arithmetic is performed modulo 256
i := 0
j1 := 0
j2 := 0
while GeneratingOutput:
    i := i + 1
    j1 := j1 + S1[i]
    swap values of S1[i] and S1[j1]
    output S2[S1[i] + S1[j1]]
    j2 := j2 + S2[i]
    swap values of S2[i] and S2[j2]
    output S1[S2[i] + S2[j2]]
endwhile

Although the algorithm required the same number of operations per output byte, there is greater parallelism than RC4, providing a possible speed improvement.

Although stronger than RC4, this algorithm has also been attacked, with Alexander Maximov[57] and a team from NEC[58] developing ways to distinguish its output from a truly random sequence.
VMPC

Variably Modified Permutation Composition (VMPC) is another RC4 variant.[59] It uses similar key schedule as RC4, with j := S[(j + S[i] + key[i mod keylength]) mod 256] iterating 3 × 256 = 768 times rather than 256, and with an optional additional 768 iterations to incorporate an initial vector. The output generation function operates as follows:

All arithmetic is performed modulo 256.
i := 0
while GeneratingOutput:
    a := S[i]
    j := S[j + a]
    
    output S[S[S[j] + 1]]
    Swap S[i] and S[j]          (b := S[j]; S[i] := b; S[j] := a))
    
    i := i + 1
endwhile

This was attacked in the same papers as RC4A, and can be distinguished within 238 output bytes.[60][58]
RC4+

RC4+ is a modified version of RC4 with a more complex three-phase key schedule (taking about three times as long as RC4, or the same as RC4-drop512), and a more complex output function which performs four additional lookups in the S array for each byte output, taking approximately 1.7 times as long as basic RC4.[61]

All arithmetic modulo 256.  << and >> are left and right shift, ⊕ is exclusive OR
while GeneratingOutput:
    i := i + 1
    a := S[i]
    j := j + a
    
    Swap S[i] and S[j]               (b := S[j]; S[j] := S[i]; S[i] := b;)
    
    c := S[i<<5 ⊕ j>>3] + S[j<<5 ⊕ i>>3]
    output (S[a+b] + S[c⊕0xAA]) ⊕ S[j+b]
endwhile

This algorithm has not been analyzed significantly.
Spritz

In 2014, Ronald Rivest gave a talk and co-wrote a paper[14] on an updated redesign called Spritz. A hardware accelerator of Spritz was published in Secrypt, 2016[62] and shows that due to multiple nested calls required to produce output bytes, Spritz performs rather slowly compared to other hash functions such as SHA-3 and the best known hardware implementation of RC4.

The algorithm is:[14]

All arithmetic is performed modulo 256
while GeneratingOutput:
    i := i + w
    j := k + S[j + S[i]]
    k := k + i + S[j]
    swap values of S[i] and S[j]
    output z := S[j + S[i + S[z + k]]]
endwhile

The value w, is relatively prime to the size of the S array. So after 256 iterations of this inner loop, the value i (incremented by w every iteration) has taken on all possible values 0...255, and every byte in the S array has been swapped at least once.

Like other sponge functions, Spritz can be used to build a cryptographic hash function, a deterministic random bit generator (DRBG), an encryption algorithm that supports authenticated encryption with associated data (AEAD), etc.[14]

In 2016, Banik and Isobe proposed an attack that can distinguish Spritz from random noise.[63]
RC4-based protocols

    WEP
    WPA (default algorithm, but can be configured to use AES-CCMP instead of RC4)
    BitTorrent protocol encryption
    Microsoft Office XP (insecure implementation since nonce remains unchanged when documents get modified[64])
    Microsoft Point-to-Point Encryption
    Transport Layer Security / Secure Sockets Layer (was optional and then the use of RC4 was prohibited in RFC 7465)
    Secure Shell (optionally)
    Remote Desktop Protocol (optionally)
    Kerberos (optionally)
    SASL Mechanism Digest-MD5 (optionally, historic, obsoleted in RFC 6331)
    Gpcode.AK, an early June 2008 computer virus for Microsoft Windows, which takes documents hostage for ransom by obscuring them with RC4 and RSA-1024 encryption
    PDF
    Skype (in modified form)[65]

Where a protocol is marked with "(optionally)", RC4 is one of multiple ciphers the system can be configured to use.
See also

    TEA, Block TEA also known as eXtended TEA and Corrected Block TEA – A family of block ciphers that, like RC4, are designed to be very simple to implement.
    Advanced Encryption Standard
    CipherSaber

References

P. Prasithsangaree; P. Krishnamurthy (2003). Analysis of Energy Consumption of RC4 and AES Algorithms in Wireless LANs.
"Crypto++ 5.6.0 Benchmarks".
Andrei Popov (February 2015), Prohibiting RC4 Cipher Suites, doi:10.17487/RFC7465, RFC 7465
Lucian Constantin (14 May 2014). "Microsoft continues RC4 encryption phase-out plan with .NET security updates". ComputerWorld.
J. Katz; Y. Lindell (2014), Introduction to Modern Cryptography, Chapman and Hall/CRC, p. 77
John Leyden (6 September 2013). "That earth-shattering NSA crypto-cracking: Have spooks smashed RC4?".
"Mozilla Security Server Side TLS Recommended Configurations". Mozilla.
"Security Advisory 2868725: Recommendation to disable RC4". Microsoft. 12 November 2013.
Rivest FAQ
"Thank you Bob Anderson". Cypherpunks (Mailing list). 9 September 1994. Archived from the original on 22 July 2001. Retrieved 2007-05-28.
Bob Jenkins (1994-09-15). "Re: RC4 ?". Newsgroup: sci.crypt. Usenet: 359qjg$55v$1@mhadg.production.compuserve.com.
"Manual Pages: arc4random". 5 June 2013.
6.857 Computer and Network Security Spring 2008: Lectures and Handouts
Rivest, Ron; Schuldt, Jacob (27 October 2014). "Spritz – a spongy RC4-like stream cipher and hash function".
"OpenBSD 5.5".
deraadt, ed (21 July 2014). "libc/crypt/arc4random.c". "ChaCha based random number generator for OpenBSD."
riastradh, ed (16 November 2014). "libc/gen/arc4random.c". "Legacy arc4random(3) API from OpenBSD reimplemented using the ChaCha20 PRF, with per-thread state."
"arc4random – NetBSD Manual Pages".
"Update arc4random module from OpenBSD and LibreSSL".
"arc4random(3)". OpenBSD.
Bartosz Zoltak. "VMPC-R: Cryptographically Secure Pseudo-Random Number Generator, Alternative to RC4". 2010?
Chefranov, A.G. "Pseudo-Random Number Generator RC4 Period Improvement". 2006.
Itsik Mantin, Adi Shamir (2001). "A Practical Attack on Broadcast RC4". FSE 2001. pp. 152 – 164.
"RSA Security Response to Weaknesses in Key Scheduling Algorithm of RC4". RSA Laboratories. 1 September 2001.
Sklyarov, Dmitry (2004). Hidden Keys to Software Break-Ins and Unauthorized Entry. A-List Publishing. pp. 92–93. ISBN 978-1931769303.
"ssl - Safest ciphers to use with the BEAST? (TLS 1.0 exploit) I've read that RC4 is immune - Server Fault". serverfault.com.
Isobe, Takanori; Ohigashi, Toshihiro (10–13 Mar 2013). "Security of RC4 Stream Cipher". Hiroshima University.
Pouyan Sepehrdad; Serge Vaudenay; Martin Vuagnoux (2011). Discovery and Exploitation of New Biases in RC4. 6544. 74–91. doi:10.1007/978-3-642-19574-7_5. ISBN 978-3-642-19573-0.
Green, Matthew (2013-03-12). "Attack of the week: RC4 is kind of broken in TLS". Cryptography Engineering.
"On the Security of RC4 in TLS". Royal Holloway University of London.
Andrew Roos. A Class of Weak Keys in the RC4 Stream Cipher. Two posts in sci.crypt, message-id 43u1eh$1j3@hermes.is.co.za and 44ebge$llf@hermes.is.co.za, 1995.
Goutam Paul, Siddheshwar Rathi and Subhamoy Maitra. On Non-negligible Bias of the First Output Byte of RC4 towards the First Three Bytes of the Secret Key. Proceedings of the International Workshop on Coding and Cryptography (WCC) 2007, pages 285–294 and Designs, Codes and Cryptography Journal, pages 123–134, vol. 49, no. 1-3, December 2008.
Goutam Paul and Subhamoy Maitra. Permutation after RC4 Key Scheduling Reveals the Secret Key. SAC 2007, pages 360–377, vol. 4876, Lecture Notes in Computer Science, Springer.
Eli Biham and Yaniv Carmeli. Efficient Reconstruction of RC4 Keys from Internal States. FSE 2008, pages 270–288, vol. 5086, Lecture Notes in Computer Science, Springer.
Mete Akgun, Pinar Kavak, Huseyin Demirci. New Results on the Key Scheduling Algorithm of RC4. INDOCRYPT 2008, pages 40–52, vol. 5365, Lecture Notes in Computer Science, Springer.
Riddhipratim Basu, Subhamoy Maitra, Goutam Paul and Tanmoy Talukdar. On Some Sequences of the Secret Pseudo-random Index j in RC4 Key Scheduling. Proceedings of the 18th International Symposium on Applied Algebra, Algebraic Algorithms and Error Correcting Codes (AAECC), 8–12 June 2009, Tarragona, Spain, pages 137–148, vol. 5527, Lecture Notes in Computer Science, Springer.
Subhamoy Maitra and Goutam Paul. New Form of Permutation Bias and Secret Key Leakage in Keystream Bytes of RC4. Proceedings of the 15th Fast Software Encryption (FSE) Workshop, 10–13 February 2008, Lausanne, Switzerland, pages 253–269, vol. 5086, Lecture Notes in Computer Science, Springer.
Souradyuti Paul, Bart Preneel. "Analysis of Non-fortuitous Predictive States of the RC4 Keystream Generator". Indocrypt 2003. pp. 52 – 67.
Scott R. Fluhrer, David A. McGrew. "Statistical Analysis of the Alleged RC4 Keystream Generator". FSE 2000. pp. 19 – 30.
Basu, Riddhipratim; Ganguly, Shirshendu; Maitra, Subhamoy; Paul, Goutam (2008). "A Complete Characterization of the Evolution of RC4 Pseudo Random Generation Algorithm". Journal of Mathematical Cryptology 2 (3): 257–289. doi:10.1515/JMC.2008.012.
Fluhrer, Scott R.; Mantin, Itsik; Shamir, Adi (2001). "Weaknesses in the Key Scheduling Algorithm of RC4". Selected Areas in Cryptography: 1 – 24.
"Interim technology for wireless LAN security: WPA to replace WEP while industry develops new security standard".
"RC4-drop(nbytes) in the Standard Cryptographic Algorithm Naming database".
Rivest, Ron. "RSA Security Response to Weaknesses in Key Scheduling Algorithm of RC4".
A. Klein, Attacks on the RC4 stream cipher, Designs, Codes and Cryptography (2008) 48:269–286
Erik Tews, Ralf-Philipp Weinmann, Andrei Pyshkin. Breaking 104-bit WEP in under a minute.
Souradyuti Paul and Bart Preneel, A New Weakness in the RC4 Keystream Generator and an Approach to Improve the Security of the Cipher. Fast Software Encryption – FSE 2004, pp245 – 259 (PDF).
John Leyden (15 March 2013). "HTTPS cookie crypto CRUMBLES AGAIN in hands of stats boffins".
AlFardan (8 July 2013). "On the Security of RC4 in TLS and WPA". Information Security Group, Royal Holloway, University of London.
"On the Security of RC4 in TLS and WPA". Information Security Group, Royal Holloway, University of London. (website)
"RC4 must die".
"Briefings - March 26 & 27". 2015.
"Attacking SSL when using RC4". 2015.
"RC4 NOMORE: Numerous Occurrence MOnitoring & Recovery Exploit". 9 August 2015.
Ilya Mironov (1 June 2002), "(Not So) Random Shuffles of RC4", Advances in Cryptology – CRYPTO 2002, Lecture Notes in Computer Science, 2442, Springer-Verlag, pp. 304–319, doi:10.1007/3-540-45708-9_20, Cryptology ePrint Archive: Report 2002/067, ISBN 978-3-540-44050-5, retrieved 2011-11-04
Souradyuti Paul; Bart Preneel (2004), "A New Weakness in the RC4 Keystream Generator and an Approach to Improve the Security of the Cipher", Fast Software Encryption, FSE 2004, Lecture Notes in Computer Science, 3017, Springer-Verlag, pp. 245–259, doi:10.1007/978-3-540-25937-4_16, ISBN 978-3-540-22171-5, retrieved 2011-11-04
Alexander Maximov (22 February 2007), Two Linear Distinguishing Attacks on VMPC and RC4A and Weakness of RC4 Family of Stream Ciphers, Cryptology ePrint Archive: Report 2007/070, retrieved 2011-11-04
Yukiyasu Tsunoo; Teruo Saito; Hiroyasu Kubo; Maki Shigeri; Tomoyasu Suzaki; Takeshi Kawabata (2005), The Most Efficient Distinguishing Attack on VMPC and RC4A
Bartosz Zoltak (2004), "VMPC One-Way Function and Stream Cipher", Fast Software Encryption, FSE 2004, Lecture Notes in Computer Science, 3017, Springer-Verlag, pp. 210–225, doi:10.1007/978-3-540-25937-4_14, ISBN 978-3-540-22171-5, retrieved 2011-11-04
"CryptoLounge: RC4A".
Subhamoy Maitra; Goutam Paul (19 September 2008), "Analysis of RC4 and Proposal of Additional Layers for Better Security Margin", Progress in Cryptology – INDOCRYPT 2008, Lecture Notes in Computer Science, 5365, Springer-Verlag, pp. 27–39, doi:10.1007/978-3-540-89754-5_3, Cryptology ePrint Archive: Report 2008/396, ISBN 978-3-540-89753-8, retrieved 2011-11-04
"Hardware Accelerator for Stream Cipher Spritz". Secrypt 2016.
Banik, Subhadeep; Isobe, Takanori (2016-03-20). Peyrin, Thomas. ed (in en). Cryptanalysis of the Full Spritz Stream Cipher. Lecture Notes in Computer Science. Springer Berlin Heidelberg. pp. 63–77. doi:10.1007/978-3-662-52993-5_4. ISBN 9783662529928.
Hongjun Wu, "The Misuse of RC4 in Microsoft Word and Excel". https://eprint.iacr.org/2005/007

    "Skype's encryption procedure partly exposed". www.h-online.com.

Further reading

    Paul, Goutam; Subhamoy Maitra (2011). RC4 Stream Cipher and Its Variants. CRC Press. ISBN 9781439831359.
    "Chapter 17 – Other Stream Ciphers and Real Random-Sequence Generators". Applied Cryptography: Protocols, Algorithms, and Source Code in C (2nd ed.). Wiley. 1995. ISBN 978-0471117094.

External links

    Original posting of RC4 algorithm to Cypherpunks mailing list, Archived version
    RFC 4345 – Improved Arcfour Modes for the Secure Shell (SSH) Transport Layer Protocol
    RFC 6229 – Test Vectors for the Stream Cipher RC4
    RFC 7465 – Prohibiting RC4 Cipher Suites
    Kaukonen; Thayer, A Stream Cipher Encryption Algorithm "Arcfour", I-D draft-kaukonen-cipher-arcfour-03
    SCAN's entry for RC4
    RSA Security Response to Weaknesses in Key Scheduling Algorithm of RC4

RC4 in WEP

    (in)Security of the WEP algorithm
    Fluhrer; Mantin; Shamir (Summer–Fall 2002). "Attacks On RC4 and WEP" (PostScript). CryptoBytes 5 (2).

    vte

Stream ciphers
Widely used ciphers	

    RC4 block ciphers in stream mode ChaCha

eSTREAM Portfolio	
Software	

    HC-256 Rabbit Salsa20 SOSEMANUK

Hardware	

    Grain MICKEY Trivium

Other ciphers	

    A5/1 A5/2 Achterbahn E0 F-FCSR FISH ISAAC MUGI ORYX Panama Phelix Pike Py QUAD Scream SEAL SNOW SOBER SOBER-128 VEST VMPC WAKE

Theory	

    shift register LFSR NLFSR shrinking generator T-function IV

Attacks	

    correlation attack correlation immunity stream cipher attacks

    vte

Cryptography


Public domain	
0.00
(0 votes)
Original source: https://en.wikipedia.org/wiki/ RC4. Read more


Category:

    Pseudorandom number generators

Navigation
Wiki tools
Grammarly Check
Hostmonster hHosting
HandWiki ads
Powered by MediaWikiPowered by MathJax

    This page was last edited on 25 November 2021, at 23:57.
    Privacy policyAbout HandWikiDisclaimers
]

The RC4 cryptographic cipher is an involution, as encryption and decryption operations use the same function.
    xor-RC4 generates a pseudorandom stream of bits (a keystream).

A permutation is an involution precisely if it can be written as a product of one or more non-overlapping transpositions.

An involution is a projectivity of period 2, that is, a projectivity that interchanges pairs of points.

y = f x = ln ((e^x+1)/(e^x-1))
    e^y(e^x-1) = (e^x+1)
    e^y*e^x = (e^y+e^x+1)
    F(x,y)=0=F(y,x)
In mathematics, an involution, involutory function, or self-inverse function is a function f that is its own inverse

involution 退化
Define
in·vo·lu·tion
[ˌinvəˈlo͞oSHən]
NOUN

    physiology
    the shrinkage of an organ in old age or when inactive, e.g. of the uterus after childbirth.
    mathematics
    a function, transformation, or operator that is equal to its inverse, i.e. which gives the identity when applied to itself.
    formal
    the process of involving or complicating, or the state of being involved or complicated:
    "periods of artistic involution"
    synonyms:
    complexity · [more]



https://findanyanswer.com/what-functions-are-their-own-inverse
In mathematics, an involution, or an involutory function, is a function f that is its own inverse, f(f(x)) = x. for all x in the domain of f.

Examples of involutions in common rings:

    complex conjugation on the complex plane.
    multiplication by j in the split-complex numbers.
    taking the transpose in a matrix ring.


https://math.stackexchange.com/questions/541978/can-the-inverse-of-a-function-be-the-same-as-the-original-function
There is also a simple graphical interpretation: any function that when graphed is symmetrical over y=x
(that is, a diagonal line at 45° angle splits the graph in two mirror images of each other) will have this property. It's easy to see that you can draw boatloads of functions like that


involution = f==f^-1
    f x = a-x
    f x = a/x
    y = f x  ==>> F(y,x)=k=F(x,y) 对称方程
        x+y=a
        x*y=a
Coming from theory of coding (LDPC codes decoding), you have another involution: x-> −log(tanh(x/2)).
]]]


[[
非平凡的线性变换自逆函数:
[[线性变换f] -> [f . f == echo] -> [[f==echo]or[[(d1*d1+dx*n1) =!= 0][f(x) = (n1-d1*x)/(d1+dx*x)]]]]
===
[x = a-(a-x)]
[x = a/(a/x)]
[x = f(f(x))][f(x) = (n1+nx*x)/(d1+dx*x)]:
  [f(f(x))
  = (n1+nx*f(x))/(d1+dx*f(x))
  = (n1+nx*(n1+nx*x)/(d1+dx*x))/(d1+dx*(n1+nx*x)/(d1+dx*x))
  = (n1*(d1+dx*x)+nx*(n1+nx*x))/(d1*(d1+dx*x)+dx*(n1+nx*x))
  = ((n1*d1+n1*dx*x)+(nx*n1+nx*nx*x))/((d1*d1+d1*dx*x)+(dx*n1+dx*nx*x))
  = ((n1*d1+nx*n1)+(n1*dx+nx*nx)*x)/((d1*d1+dx*n1)+(d1*dx+dx*nx)*x)
  ]
  [f(f(x)) == x]:
    [(d1*dx+dx*nx) == 0]
    [(n1*d1+nx*n1) == 0]
    [(n1*dx+nx*nx) == (d1*d1+dx*n1) =!= 0]

    [[dx==0]or[nx==-d1]]
    [[n1==0]or[nx==-d1]]
    [nx**2==d1**2]
    [nx=+/-d1]
    * [nx==+d1]:
      [dx==0][n1==0]
      [f(x) = (0+d1*x)/(d1+0*x) = x]
        平凡！
    * [nx==-d1]:
      !! [(n1*dx+nx*nx) == (d1*d1+dx*n1) =!= 0]
      [(n1*dx+d1*d1) == (d1*d1+dx*n1) =!= 0]
      [(d1*d1+dx*n1) =!= 0]
      [1 + dx*n1/(d1*d1) =!= 0]
      [f(x) = (n1-d1*x)/(d1+dx*x)]
        非平凡！
        * [d1==0]:
          --> [f(x) = a/x]
        * [dx==0][d1=!=0]:
          --> [f(x) = a-x]

[[线性变换f] -> [f . f == echo] -> [[f==echo]or[[(d1*d1+dx*n1) =!= 0][f(x) = (n1-d1*x)/(d1+dx*x)]]]]
[y = (n1-d1*x)/(d1+dx*x)]
  <==> [y*(d1+dx*x) = (n1-d1*x)]
  <==> [(y*d1+dx*y*x) = (n1-d1*x)]
  <==> [(+d1*x+y*d1+dx*y*x) = n1] #对称方程
]]
