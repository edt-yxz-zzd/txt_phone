最小加法链
www_download_pdf:goto

[[[[[ver1:buggy...
view script/min_add.py
[n>=1]:
	[addsets =[def]= {s::{pint} | [1<-s][@u<-s. [u!=1] -> [?i<-s. [u-i<-s]]]}]
	[addsets_of n =[def]= {s<-addsets | [n<-s]}]
	[min_add n =[def]= -1+min {len s | s<-addsets_of n}]
		#why -1? see upper_bound::factor below
	[min_addsets_of n =[def]= {s<-addsets_of n | len s == 1+min_add n}]
	[inv_min_add m =[def]= (min_add^-1) m = {n | min_add n ==m}]
	[adders_of s n =[def]= {u<-s | [n-u<-s]}]
	[arr<s> a b =[def]= [adders_of s b == {a,b-a}]]
	[union_min_addsets_of n =[def]= \-/~~ min_addsets_of n]]


[@s][s<-addsets]:
	[1<-s]
	[len s >=2]<==>[2<-s]
	[len s >=3]<==>[{}!=s/-\{3,4}]

	#bottomup
	[[s!={1}] -> [s\\{max s} <-addsets]]



[@n][n>=1]:
	[@s][s <- min_addsets_of n]
	[ls:=sort s]

	[n>=2]<==>[len s >=2]<==>[2<-s]

	#popped
	[max s == n]

	#required
	[@u<-s. [u!=n] -> [?v<-s. [arr<s> u v]]]
	[n>=2]:
		[len s >=2][2<-s]
		[_2:=ls[-2]]
		[arr<s> _2 n]
		[arr<s> (n-_2) n]
		[n-_2 <- \-/~~ min_addsets_of _2]:
			#eg: [n==2*_2]or[n-_2<=2]
			[min_add _2 == min_add n -1]
			[s\\{n} <- min_addsets_of _2]
			
		[n>=3]:
			[_3 := ls[-3]]
			[n-_2 < _3]:
				[arr<s> _3 _2]



[@m][m>=0]:
	[ns:=inv_min_add m]
	[2^m == max ns]
	[{2^(m-1)+2^i | i<-[0..m-1]} <= ns]




[@k. [0<=k] -> [min_add (2^k) == k]]
[@i,k. [0<=i<=k] -> [min_add (2^k+2^i) == k+1]]
#lower_bound
[@n][n>=1]:
	[min_add n >= ceil(log2 n)]
#upper_bound
[@n][n>=1]:
	[@u<-[(n+1)//2..n-1]. [n-u<-union_min_addsets_of u] -> [min_add n <= 1+min_add u]]
	[@u. [n==2*u] -> [min_add n <= 1+min_add u]]
	[n>=4]==>>[min_add n <= 1+min_add (n-2)]
	[n>=2]==>>[min_add n <= 1+min_add (n-1)]
	[min_add n < n]

	#radix 2
	[n2:=(repr<%2> n)]
	[min_add n <= -1 +((log2 n)//1) +n2.count(1)]
	[min_add n <= -2 +len n2 +n2.count(1)]

	#fibonacci
	[nf:=(repr<%2> n)]
	[min_add n <= -2 +len nf +nf.count(1)]
		

	#factor
	[@u,v::pint. [n==u*v] -> [min_add n <= (min_add u)+(min_add v)]]

	#add
	[@u,v::pint. [n==u+v] -> [min_add n <= 1+(min_add u)+(min_add v)]]



maynot correct
1:0:1
2:1:1,2
3:2:1,2,3
4:2:1,2,4
5:3:..,3,5;..,4,5
6:3:..,3,6;..,4,6
7:4:..3,4,7;..5,7;..6,7
8:3:..4,8
9:4:..4,5,9;..3,6,9;..8,9
10:4:..5,10;..4,6,10;..8,10
11:5:.5,6,11;...4,7,11;..3,4,8,11;..9,11;..10,11
12:4:..6,12;..8,12
13:5:..6,7,13;..5,8,13;..4..9,13;..3,5,10,13;..12,13
14:5:..7,14;..6,8,14;..5,9,14;..4..10,14;..112,14;
]]]]]


=========20220919:
[[[[[[[ver2:
view script/min_add_ver2.py
最短扩张

__doc__:
r'''[[[
e script/min_add_ver2.py
最小加法链


最短扩张
已更新:view others/数学/最小加法链.txt
推导定理:goto

py script/min_add_ver2.py ,iter_shortest_add_chains > script/min_add_ver2.py.4.out.txt
    运行直至宕机软重启
view script/min_add_ver2.py.4.out.txt
    共315行

每行格式:
  (num_adds, final_sum, total_shortest_add_chains, shortest_add_chains)
  (uint, pint, pint, sorted[sorted[pint]])
[[输出4元组:
view script/min_add_ver2.py.4.out.txt
du -hs script/min_add_ver2.py.4.out.txt
    2.4MB
首行1行:(0, 1, 1, [(1,)])
末行315行:(10, 528, 10, [(1, 2, 4, 8, 16, 17, 33, 66, 132, 264, 528), (1, 2, 4, 8, 16, 32, 33, 66, 132, 264, 528), (1, 2, 4, 8, 16, 32, 34, 66, 132, 264, 528), (1, 2, 4, 8, 16, 32, 64, 66, 132, 264, 528), (1, 2, 4, 8, 16, 32, 64, 68, 132, 264, 528), (1, 2, 4, 8, 16, 32, 64, 128, 132, 264, 528), (1, 2, 4, 8, 16, 32, 64, 128, 136, 264, 528), (1, 2, 4, 8, 16, 32, 64, 128, 256, 264, 528), (1, 2, 4, 8, 16, 32, 64, 128, 256, 272, 528), (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 528)])
共315行

前315行过滤:[total_shortest_add_chains>=1000]降序排列
#行数从1开始
188行:(10, 142, 3903, ...)
185行:(10, 127, 2661, ...)
193行:(10, 158, 1906, ...)
187行:(10, 141, 1786, ...)
199行:(10, 174, 1686, ...)
205行:(10, 182, 1289, ...)
107行:(9, 71, 1258, ...)
    唯一一个[num_adds < 10][total_shortest_add_chains>=1000]
202行:(10, 178, 1210, ...)
210行:(10, 188, 1153, ...)

231行:(10, 220, 1096, ...)
222行:(10, 210, 1075, ...)
196行:(10, 169, 1034, ...)
237行:(10, 228, 1012, ...)
208行:(10, 186, 1011, ...)


前21行:所有[num_adds <= 5]
1:(0, 1, 1, [(1,)])
(1, 2, 1, [(1, 2)])
(2, 3, 1, [(1, 2, 3)])
(2, 4, 1, [(1, 2, 4)])
(3, 5, 2, [(1, 2, 3, 5), (1, 2, 4, 5)])
(3, 6, 2, [(1, 2, 3, 6), (1, 2, 4, 6)])
(3, 8, 1, [(1, 2, 4, 8)])
(4, 7, 5, [(1, 2, 3, 4, 7), (1, 2, 3, 5, 7), (1, 2, 3, 6, 7), (1, 2, 4, 5, 7), (1, 2, 4, 6, 7)])
(4, 9, 3, [(1, 2, 3, 6, 9), (1, 2, 4, 5, 9), (1, 2, 4, 8, 9)])
(4, 10, 4, [(1, 2, 3, 5, 10), (1, 2, 4, 5, 10), (1, 2, 4, 6, 10), (1, 2, 4, 8, 10)])
(4, 12, 3, [(1, 2, 3, 6, 12), (1, 2, 4, 6, 12), (1, 2, 4, 8, 12)])
(4, 16, 1, [(1, 2, 4, 8, 16)])
(5, 11, 15, [(1, 2, 3, 4, 7, 11), (1, 2, 3, 4, 8, 11), (1, 2, 3, 5, 6, 11), (1, 2, 3, 5, 8, 11), (1, 2, 3, 5, 10, 11), (1, 2, 3, 6, 8, 11), (1, 2, 3, 6, 9, 11), (1, 2, 4, 5, 6, 11), (1, 2, 4, 5, 7, 11), (1, 2, 4, 5, 9, 11), (1, 2, 4, 5, 10, 11), (1, 2, 4, 6, 7, 11), (1, 2, 4, 6, 10, 11), (1, 2, 4, 8, 9, 11), (1, 2, 4, 8, 10, 11)])
(5, 13, 10, [(1, 2, 3, 5, 8, 13), (1, 2, 3, 5, 10, 13), (1, 2, 3, 6, 7, 13), (1, 2, 3, 6, 12, 13), (1, 2, 4, 5, 8, 13), (1, 2, 4, 5, 9, 13), (1, 2, 4, 6, 7, 13), (1, 2, 4, 6, 12, 13), (1, 2, 4, 8, 9, 13), (1, 2, 4, 8, 12, 13)])
(5, 14, 14, [(1, 2, 3, 4, 7, 14), (1, 2, 3, 5, 7, 14), (1, 2, 3, 6, 7, 14), (1, 2, 3, 6, 8, 14), (1, 2, 3, 6, 12, 14), (1, 2, 4, 5, 7, 14), (1, 2, 4, 5, 9, 14), (1, 2, 4, 5, 10, 14), (1, 2, 4, 6, 7, 14), (1, 2, 4, 6, 8, 14), (1, 2, 4, 6, 10, 14), (1, 2, 4, 6, 12, 14), (1, 2, 4, 8, 10, 14), (1, 2, 4, 8, 12, 14)])
(5, 15, 4, [(1, 2, 3, 5, 10, 15), (1, 2, 3, 6, 9, 15), (1, 2, 3, 6, 12, 15), (1, 2, 4, 5, 10, 15)])
(5, 17, 2, [(1, 2, 4, 8, 9, 17), (1, 2, 4, 8, 16, 17)])
(5, 18, 7, [(1, 2, 3, 6, 9, 18), (1, 2, 3, 6, 12, 18), (1, 2, 4, 5, 9, 18), (1, 2, 4, 6, 12, 18), (1, 2, 4, 8, 9, 18), (1, 2, 4, 8, 10, 18), (1, 2, 4, 8, 16, 18)])
(5, 20, 6, [(1, 2, 3, 5, 10, 20), (1, 2, 4, 5, 10, 20), (1, 2, 4, 6, 10, 20), (1, 2, 4, 8, 10, 20), (1, 2, 4, 8, 12, 20), (1, 2, 4, 8, 16, 20)])
(5, 24, 4, [(1, 2, 3, 6, 12, 24), (1, 2, 4, 6, 12, 24), (1, 2, 4, 8, 12, 24), (1, 2, 4, 8, 16, 24)])
(5, 32, 1, [(1, 2, 4, 8, 16, 32)])
22:(6, 19, 33, ...)
36:(6, 64, 1, ...)
37:(7, 29, 132, ...)
62:(7, 128, 1, ...)
63:(8, 47, 220, ...)
106:(8, 256, 1, ...)
107:(9, 71, 1258, ...)
184:(9, 512, 1, ...)
185:(10, 127, 2661, ...)
315:(10, 528, 10, ...)


]]


py script/min_add_ver2.py @_read_output_of_iter_shortest_add_chains :script/min_add_ver2.py.4.out.txt
{1: 0, 2: 1, 3: 2, 4: 2, 5: 3, 6: 3, 8: 3, 7: 4, 9: 4, 10: 4, 12: 4, 16: 4, 11: 5, 13: 5, 14: 5, 15: 5, 17: 5, 18: 5, 20: 5, 24: 5, 32: 5, 19: 6, 21: 6, 22: 6, 23: 6, 25: 6, 26: 6, 27: 6, 28: 6, 30: 6, 33: 6, 34: 6, 36: 6, 40: 6, 48: 6, 64: 6, 29: 7, 31: 7, 35: 7, 37: 7, 38: 7, 39: 7, 41: 7, 42: 7, 43: 7, 44: 7, 45: 7, 46: 7, 49: 7, 50: 7, 51: 7, 52: 7, 54: 7, 56: 7, 60: 7, 65: 7, 66: 7, 68: 7, 72: 7, 80: 7, 96: 7, 128: 7, 47: 8, 53: 8, 55: 8, 57: 8, 58: 8, 59: 8, 61: 8, 62: 8, 63: 8, 67: 8, 69: 8, 70: 8, 73: 8, 74: 8, 75: 8, 76: 8, 77: 8, 78: 8, 81: 8, 82: 8, 83: 8, 84: 8, 85: 8, 86: 8, 88: 8, 90: 8, 92: 8, 97: 8, 98: 8, 99: 8, 100: 8, 102: 8, 104: 8, 108: 8, 112: 8, 120: 8, 129: 8, 130: 8, 132: 8, 136: 8, 144: 8, 160: 8, 192: 8, 256: 8, 71: 9, 79: 9, 87: 9, 89: 9, 91: 9, 93: 9, 94: 9, 95: 9, 101: 9, 103: 9, 105: 9, 106: 9, 107: 9, 109: 9, 110: 9, 111: 9, 113: 9, 114: 9, 115: 9, 116: 9, 117: 9, 118: 9, 119: 9, 121: 9, 122: 9, 123: 9, 124: 9, 125: 9, 126: 9, 131: 9, 133: 9, 134: 9, 135: 9, 137: 9, 138: 9, 140: 9, 145: 9, 146: 9, 147: 9, 148: 9, 149: 9, 150: 9, 152: 9, 153: 9, 154: 9, 156: 9, 161: 9, 162: 9, 163: 9, 164: 9, 165: 9, 166: 9, 168: 9, 170: 9, 172: 9, 176: 9, 180: 9, 184: 9, 193: 9, 194: 9, 195: 9, 196: 9, 198: 9, 200: 9, 204: 9, 208: 9, 216: 9, 224: 9, 240: 9, 257: 9, 258: 9, 260: 9, 264: 9, 272: 9, 288: 9, 320: 9, 384: 9, 512: 9, 127: 10, 139: 10, 141: 10, 142: 10, 143: 10, 151: 10, 155: 10, 157: 10, 158: 10, 159: 10, 167: 10, 169: 10, 171: 10, 173: 10, 174: 10, 175: 10, 177: 10, 178: 10, 179: 10, 181: 10, 182: 10, 183: 10, 185: 10, 186: 10, 187: 10, 188: 10, 189: 10, 190: 10, 197: 10, 199: 10, 201: 10, 202: 10, 203: 10, 205: 10, 206: 10, 207: 10, 209: 10, 210: 10, 211: 10, 212: 10, 213: 10, 214: 10, 215: 10, 217: 10, 218: 10, 219: 10, 220: 10, 221: 10, 222: 10, 225: 10, 226: 10, 227: 10, 228: 10, 229: 10, 230: 10, 231: 10, 232: 10, 233: 10, 234: 10, 236: 10, 238: 10, 241: 10, 242: 10, 243: 10, 244: 10, 245: 10, 246: 10, 248: 10, 249: 10, 250: 10, 252: 10, 255: 10, 259: 10, 261: 10, 262: 10, 265: 10, 266: 10, 268: 10, 270: 10, 273: 10, 274: 10, 276: 10, 280: 10, 281: 10, 289: 10, 290: 10, 291: 10, 292: 10, 293: 10, 294: 10, 296: 10, 297: 10, 298: 10, 300: 10, 304: 10, 306: 10, 308: 10, 312: 10, 321: 10, 322: 10, 323: 10, 324: 10, 325: 10, 326: 10, 328: 10, 330: 10, 332: 10, 336: 10, 340: 10, 344: 10, 352: 10, 360: 10, 368: 10, 385: 10, 386: 10, 387: 10, 388: 10, 390: 10, 392: 10, 396: 10, 400: 10, 408: 10, 416: 10, 432: 10, 448: 10, 480: 10, 513: 10, 514: 10, 516: 10, 520: 10, 528: 10}

py script/min_add_ver2.py @_mk_rngs5output_of_iter_shortest_add_chains :script/min_add_ver2.py.4.out.txt
[(1, 191), (192, 223), (224, 235), (236, 237), (238, 239), (240, 247), (248, 251), (252, 253), (255, 263), (264, 267), (268, 269), (270, 271), (272, 275), (276, 277), (280, 282), (288, 295), (296, 299), (300, 301), (304, 305), (306, 307), (308, 309), (312, 313), (320, 327), (328, 329), (330, 331), (332, 333), (336, 337), (340, 341), (344, 345), (352, 353), (360, 361), (368, 369), (384, 389), (390, 391), (392, 393), (396, 397), (400, 401), (408, 409), (416, 417), (432, 433), (448, 449), (480, 481), (512, 515), (516, 517), (520, 521), (528, 529)]


py script/min_add_ver2.py ,_iter_one_chain_per_final_sum5output_of_iter_shortest_add_chains :script/min_add_ver2.py.4.out.txt > script/min_add_ver2.py.4.out.1chain.txt
view script/min_add_ver2.py.4.out.1chain.txt

py script/min_add_ver2.py ,_iter_two_chains_per_final_sum5output_of_iter_shortest_add_chains :script/min_add_ver2.py.4.out.txt > script/min_add_ver2.py.4.out.2chain.txt
view script/min_add_ver2.py.4.out.2chain.txt
du -hs script/min_add_ver2.py.4.out.2chain.txt
    32KB
[[
(0, 1, 1, [(1,)])
(1, 2, 1, [(1, 2)])
(2, 3, 1, [(1, 2, 3)])
(2, 4, 1, [(1, 2, 4)])
(3, 5, 2, [(1, 2, 3, 5), (1, 2, 4, 5)])
(3, 6, 2, [(1, 2, 3, 6), (1, 2, 4, 6)])
(3, 8, 1, [(1, 2, 4, 8)])
(4, 7, 5, [(1, 2, 3, 4, 7), ..., (1, 2, 4, 6, 7)])
(4, 9, 3, [(1, 2, 3, 6, 9), ..., (1, 2, 4, 8, 9)])
(4, 10, 4, [(1, 2, 3, 5, 10), ..., (1, 2, 4, 8, 10)])
(4, 12, 3, [(1, 2, 3, 6, 12), ..., (1, 2, 4, 8, 12)])
(4, 16, 1, [(1, 2, 4, 8, 16)])
(5, 11, 15, [(1, 2, 3, 4, 7, 11), ..., (1, 2, 4, 8, 10, 11)])
(5, 13, 10, [(1, 2, 3, 5, 8, 13), ..., (1, 2, 4, 8, 12, 13)])
(5, 14, 14, [(1, 2, 3, 4, 7, 14), ..., (1, 2, 4, 8, 12, 14)])
(5, 15, 4, [(1, 2, 3, 5, 10, 15), ..., (1, 2, 4, 5, 10, 15)])
(5, 17, 2, [(1, 2, 4, 8, 9, 17), (1, 2, 4, 8, 16, 17)])
(5, 18, 7, [(1, 2, 3, 6, 9, 18), ..., (1, 2, 4, 8, 16, 18)])
(5, 20, 6, [(1, 2, 3, 5, 10, 20), ..., (1, 2, 4, 8, 16, 20)])
(5, 24, 4, [(1, 2, 3, 6, 12, 24), ..., (1, 2, 4, 8, 16, 24)])
(5, 32, 1, [(1, 2, 4, 8, 16, 32)])
(6, 19, 33, [(1, 2, 3, 4, 8, 11, 19), ..., (1, 2, 4, 8, 16, 18, 19)])
(6, 21, 29, [(1, 2, 3, 4, 7, 14, 21), ..., (1, 2, 4, 8, 16, 20, 21)])
(6, 22, 40, [(1, 2, 3, 4, 7, 11, 22), ..., (1, 2, 4, 8, 16, 20, 22)])
(6, 23, 4, [(1, 2, 3, 5, 10, 13, 23), ..., (1, 2, 4, 5, 9, 18, 23)])
(6, 25, 14, [(1, 2, 3, 5, 10, 15, 25), ..., (1, 2, 4, 8, 16, 24, 25)])
(6, 26, 24, [(1, 2, 3, 5, 8, 13, 26), ..., (1, 2, 4, 8, 16, 24, 26)])
(6, 27, 5, [(1, 2, 3, 6, 9, 18, 27), ..., (1, 2, 4, 8, 9, 18, 27)])
(6, 28, 23, [(1, 2, 3, 4, 7, 14, 28), ..., (1, 2, 4, 8, 16, 24, 28)])
(6, 30, 12, [(1, 2, 3, 5, 10, 15, 30), ..., (1, 2, 4, 8, 10, 20, 30)])
(6, 33, 2, [(1, 2, 4, 8, 16, 17, 33), (1, 2, 4, 8, 16, 32, 33)])
(6, 34, 4, [(1, 2, 4, 8, 9, 17, 34), ..., (1, 2, 4, 8, 16, 32, 34)])
(6, 36, 12, [(1, 2, 3, 6, 9, 18, 36), ..., (1, 2, 4, 8, 16, 32, 36)])
(6, 40, 8, [(1, 2, 3, 5, 10, 20, 40), ..., (1, 2, 4, 8, 16, 32, 40)])
(6, 48, 5, [(1, 2, 3, 6, 12, 24, 48), ..., (1, 2, 4, 8, 16, 32, 48)])
(6, 64, 1, [(1, 2, 4, 8, 16, 32, 64)])
(7, 29, 132, [(1, 2, 3, 4, 7, 11, 18, 29), ..., (1, 2, 4, 8, 16, 24, 28, 29)])
(7, 31, 77, [(1, 2, 3, 4, 7, 14, 17, 31), ..., (1, 2, 4, 8, 10, 20, 30, 31)])
(7, 35, 43, [(1, 2, 3, 4, 7, 14, 21, 35), ..., (1, 2, 4, 8, 16, 32, 34, 35)])
(7, 37, 39, [(1, 2, 3, 5, 8, 16, 21, 37), ..., (1, 2, 4, 8, 16, 32, 36, 37)])
(7, 38, 92, [(1, 2, 3, 4, 8, 11, 19, 38), ..., (1, 2, 4, 8, 16, 32, 36, 38)])
(7, 39, 20, [(1, 2, 3, 5, 8, 13, 26, 39), ..., (1, 2, 4, 8, 12, 13, 26, 39)])
(7, 41, 23, [(1, 2, 3, 5, 10, 20, 21, 41), ..., (1, 2, 4, 8, 16, 32, 40, 41)])
(7, 42, 84, [(1, 2, 3, 4, 7, 14, 21, 42), ..., (1, 2, 4, 8, 16, 32, 40, 42)])
(7, 43, 4, [(1, 2, 3, 5, 10, 20, 23, 43), ..., (1, 2, 4, 8, 9, 17, 34, 43)])
(7, 44, 69, [(1, 2, 3, 4, 7, 11, 22, 44), ..., (1, 2, 4, 8, 16, 32, 40, 44)])
(7, 45, 14, [(1, 2, 3, 5, 10, 15, 30, 45), ..., (1, 2, 4, 8, 9, 18, 36, 45)])
(7, 46, 8, [(1, 2, 3, 5, 10, 13, 23, 46), ..., (1, 2, 4, 8, 10, 18, 36, 46)])
(7, 49, 12, [(1, 2, 3, 6, 12, 24, 25, 49), ..., (1, 2, 4, 8, 16, 32, 48, 49)])
(7, 50, 36, [(1, 2, 3, 5, 10, 15, 25, 50), ..., (1, 2, 4, 8, 16, 32, 48, 50)])
(7, 51, 4, [(1, 2, 3, 6, 12, 24, 27, 51), ..., (1, 2, 4, 8, 16, 17, 34, 51)])
(7, 52, 38, [(1, 2, 3, 5, 8, 13, 26, 52), ..., (1, 2, 4, 8, 16, 32, 48, 52)])
(7, 54, 16, [(1, 2, 3, 6, 9, 18, 27, 54), ..., (1, 2, 4, 8, 16, 18, 36, 54)])
(7, 56, 32, [(1, 2, 3, 4, 7, 14, 28, 56), ..., (1, 2, 4, 8, 16, 32, 48, 56)])
(7, 60, 24, [(1, 2, 3, 5, 10, 15, 30, 60), ..., (1, 2, 4, 8, 16, 20, 40, 60)])
(7, 65, 2, [(1, 2, 4, 8, 16, 32, 33, 65), (1, 2, 4, 8, 16, 32, 64, 65)])
(7, 66, 4, [(1, 2, 4, 8, 16, 17, 33, 66), ..., (1, 2, 4, 8, 16, 32, 64, 66)])
(7, 68, 6, [(1, 2, 4, 8, 9, 17, 34, 68), ..., (1, 2, 4, 8, 16, 32, 64, 68)])
(7, 72, 18, [(1, 2, 3, 6, 9, 18, 36, 72), ..., (1, 2, 4, 8, 16, 32, 64, 72)])
(7, 80, 10, [(1, 2, 3, 5, 10, 20, 40, 80), ..., (1, 2, 4, 8, 16, 32, 64, 80)])
(7, 96, 6, [(1, 2, 3, 6, 12, 24, 48, 96), ..., (1, 2, 4, 8, 16, 32, 64, 96)])
(7, 128, 1, [(1, 2, 4, 8, 16, 32, 64, 128)])
(8, 47, 220, [(1, 2, 3, 4, 7, 10, 20, 27, 47), ..., (1, 2, 4, 8, 12, 13, 26, 39, 47)])
(8, 53, 205, [(1, 2, 3, 5, 6, 12, 24, 29, 53), ..., (1, 2, 4, 8, 16, 32, 48, 52, 53)])
(8, 55, 156, [(1, 2, 3, 4, 7, 11, 22, 33, 55), ..., (1, 2, 4, 8, 16, 18, 36, 54, 55)])
(8, 57, 173, [(1, 2, 3, 4, 7, 14, 28, 29, 57), ..., (1, 2, 4, 8, 16, 32, 48, 56, 57)])
(8, 58, 352, [(1, 2, 3, 4, 7, 11, 18, 29, 58), ..., (1, 2, 4, 8, 16, 32, 48, 56, 58)])
(8, 59, 37, [(1, 2, 3, 4, 7, 14, 28, 31, 59), ..., (1, 2, 4, 8, 16, 17, 34, 51, 59)])
(8, 61, 91, [(1, 2, 3, 5, 7, 14, 28, 33, 61), ..., (1, 2, 4, 8, 16, 20, 40, 60, 61)])
(8, 62, 233, [(1, 2, 3, 4, 7, 14, 17, 31, 62), ..., (1, 2, 4, 8, 16, 20, 40, 60, 62)])
(8, 63, 87, [(1, 2, 3, 4, 7, 14, 21, 42, 63), ..., (1, 2, 4, 8, 16, 20, 21, 42, 63)])
(8, 67, 23, [(1, 2, 3, 4, 8, 16, 32, 35, 67), ..., (1, 2, 4, 8, 16, 32, 64, 66, 67)])
(8, 69, 29, [(1, 2, 3, 5, 8, 16, 32, 37, 69), ..., (1, 2, 4, 8, 16, 32, 64, 68, 69)])
(8, 70, 134, [(1, 2, 3, 4, 7, 14, 21, 35, 70), ..., (1, 2, 4, 8, 16, 32, 64, 68, 70)])
(8, 73, 49, [(1, 2, 3, 6, 9, 18, 36, 37, 73), ..., (1, 2, 4, 8, 16, 32, 64, 72, 73)])
(8, 74, 104, [(1, 2, 3, 5, 8, 16, 21, 37, 74), ..., (1, 2, 4, 8, 16, 32, 64, 72, 74)])
(8, 75, 32, [(1, 2, 3, 5, 10, 15, 25, 50, 75), ..., (1, 2, 4, 8, 16, 24, 25, 50, 75)])
(8, 76, 161, [(1, 2, 3, 4, 8, 11, 19, 38, 76), ..., (1, 2, 4, 8, 16, 32, 64, 72, 76)])
(8, 77, 4, [(1, 2, 4, 5, 9, 18, 36, 41, 77), ..., (1, 2, 4, 8, 9, 17, 34, 68, 77)])
(8, 78, 68, [(1, 2, 3, 5, 8, 13, 26, 39, 78), ..., (1, 2, 4, 8, 16, 24, 26, 52, 78)])
(8, 81, 36, [(1, 2, 3, 5, 10, 20, 40, 41, 81), ..., (1, 2, 4, 8, 16, 32, 64, 80, 81)])
(8, 82, 54, [(1, 2, 3, 5, 10, 20, 21, 41, 82), ..., (1, 2, 4, 8, 16, 32, 64, 80, 82)])
(8, 83, 4, [(1, 2, 3, 5, 10, 20, 40, 43, 83), ..., (1, 2, 4, 8, 16, 17, 33, 66, 83)])
(8, 84, 161, [(1, 2, 3, 4, 7, 14, 21, 42, 84), ..., (1, 2, 4, 8, 16, 32, 64, 80, 84)])
(8, 85, 8, [(1, 2, 3, 5, 10, 20, 40, 45, 85), ..., (1, 2, 4, 8, 16, 17, 34, 68, 85)])
(8, 86, 8, [(1, 2, 3, 5, 10, 20, 23, 43, 86), ..., (1, 2, 4, 8, 16, 18, 34, 68, 86)])
(8, 88, 98, [(1, 2, 3, 4, 7, 11, 22, 44, 88), ..., (1, 2, 4, 8, 16, 32, 64, 80, 88)])
(8, 90, 48, [(1, 2, 3, 5, 10, 15, 30, 45, 90), ..., (1, 2, 4, 8, 16, 18, 36, 72, 90)])
(8, 92, 12, [(1, 2, 3, 5, 10, 13, 23, 46, 92), ..., (1, 2, 4, 8, 16, 20, 36, 72, 92)])
(8, 97, 14, [(1, 2, 3, 6, 12, 24, 48, 49, 97), ..., (1, 2, 4, 8, 16, 32, 64, 96, 97)])
(8, 98, 28, [(1, 2, 3, 6, 12, 24, 25, 49, 98), ..., (1, 2, 4, 8, 16, 32, 64, 96, 98)])
(8, 99, 4, [(1, 2, 3, 6, 12, 24, 48, 51, 99), ..., (1, 2, 4, 8, 16, 32, 33, 66, 99)])
(8, 100, 62, [(1, 2, 3, 5, 10, 15, 25, 50, 100), ..., (1, 2, 4, 8, 16, 32, 64, 96, 100)])
(8, 102, 12, [(1, 2, 3, 6, 12, 24, 27, 51, 102), ..., (1, 2, 4, 8, 16, 32, 34, 68, 102)])
(8, 104, 52, [(1, 2, 3, 5, 8, 13, 26, 52, 104), ..., (1, 2, 4, 8, 16, 32, 64, 96, 104)])
(8, 108, 34, [(1, 2, 3, 6, 9, 18, 27, 54, 108), ..., (1, 2, 4, 8, 16, 32, 36, 72, 108)])
(8, 112, 41, [(1, 2, 3, 4, 7, 14, 28, 56, 112), ..., (1, 2, 4, 8, 16, 32, 64, 96, 112)])
(8, 120, 40, [(1, 2, 3, 5, 10, 15, 30, 60, 120), ..., (1, 2, 4, 8, 16, 32, 40, 80, 120)])
(8, 129, 2, [(1, 2, 4, 8, 16, 32, 64, 65, 129), (1, 2, 4, 8, 16, 32, 64, 128, 129)])
(8, 130, 4, [(1, 2, 4, 8, 16, 32, 33, 65, 130), ..., (1, 2, 4, 8, 16, 32, 64, 128, 130)])
(8, 132, 6, [(1, 2, 4, 8, 16, 17, 33, 66, 132), ..., (1, 2, 4, 8, 16, 32, 64, 128, 132)])
(8, 136, 8, [(1, 2, 4, 8, 9, 17, 34, 68, 136), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136)])
(8, 144, 25, [(1, 2, 3, 6, 9, 18, 36, 72, 144), ..., (1, 2, 4, 8, 16, 32, 64, 128, 144)])
(8, 160, 12, [(1, 2, 3, 5, 10, 20, 40, 80, 160), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160)])
(8, 192, 7, [(1, 2, 3, 6, 12, 24, 48, 96, 192), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192)])
(8, 256, 1, [(1, 2, 4, 8, 16, 32, 64, 128, 256)])
(9, 71, 1258, [(1, 2, 3, 4, 7, 8, 16, 32, 39, 71), ..., (1, 2, 4, 8, 16, 32, 64, 68, 70, 71)])
(9, 79, 621, [(1, 2, 3, 4, 7, 9, 18, 36, 43, 79), ..., (1, 2, 4, 8, 16, 24, 26, 52, 78, 79)])
(9, 87, 507, [(1, 2, 3, 4, 7, 10, 20, 40, 47, 87), ..., (1, 2, 4, 8, 16, 24, 28, 29, 58, 87)])
(9, 89, 471, [(1, 2, 3, 4, 7, 11, 22, 44, 45, 89), ..., (1, 2, 4, 8, 16, 32, 64, 80, 88, 89)])
(9, 91, 359, [(1, 2, 3, 4, 7, 11, 22, 44, 47, 91), ..., (1, 2, 4, 8, 16, 24, 25, 50, 75, 91)])
(9, 93, 306, [(1, 2, 3, 4, 7, 14, 17, 31, 62, 93), ..., (1, 2, 4, 8, 16, 20, 36, 72, 92, 93)])
(9, 94, 643, [(1, 2, 3, 4, 7, 10, 20, 27, 47, 94), ..., (1, 2, 4, 8, 16, 24, 26, 52, 78, 94)])
(9, 95, 180, [(1, 2, 3, 4, 7, 11, 22, 44, 51, 95), ..., (1, 2, 4, 8, 16, 20, 21, 37, 74, 95)])
(9, 101, 270, [(1, 2, 3, 5, 6, 12, 24, 48, 53, 101), ..., (1, 2, 4, 8, 16, 32, 64, 96, 100, 101)])
(9, 103, 99, [(1, 2, 3, 5, 7, 12, 24, 48, 55, 103), ..., (1, 2, 4, 8, 16, 32, 34, 68, 102, 103)])
(9, 105, 332, [(1, 2, 3, 4, 7, 14, 21, 35, 70, 105), ..., (1, 2, 4, 8, 16, 32, 64, 96, 104, 105)])
(9, 106, 533, [(1, 2, 3, 5, 6, 12, 24, 29, 53, 106), ..., (1, 2, 4, 8, 16, 32, 64, 96, 104, 106)])
(9, 107, 30, [(1, 2, 3, 5, 8, 13, 26, 52, 55, 107), ..., (1, 2, 4, 8, 16, 32, 33, 66, 99, 107)])
(9, 109, 125, [(1, 2, 3, 5, 8, 13, 26, 52, 57, 109), ..., (1, 2, 4, 8, 16, 32, 36, 72, 108, 109)])
(9, 110, 531, [(1, 2, 3, 4, 7, 11, 22, 33, 55, 110), ..., (1, 2, 4, 8, 16, 32, 36, 72, 108, 110)])
(9, 111, 88, [(1, 2, 3, 5, 8, 16, 21, 37, 74, 111), ..., (1, 2, 4, 8, 16, 32, 36, 37, 74, 111)])
(9, 113, 135, [(1, 2, 3, 4, 7, 14, 28, 56, 57, 113), ..., (1, 2, 4, 8, 16, 32, 64, 96, 112, 113)])
(9, 114, 512, [(1, 2, 3, 4, 7, 14, 28, 29, 57, 114), ..., (1, 2, 4, 8, 16, 32, 64, 96, 112, 114)])
(9, 115, 41, [(1, 2, 3, 4, 7, 14, 28, 56, 59, 115), ..., (1, 2, 4, 8, 16, 32, 33, 66, 99, 115)])
(9, 116, 619, [(1, 2, 3, 4, 7, 11, 18, 29, 58, 116), ..., (1, 2, 4, 8, 16, 32, 64, 96, 112, 116)])
(9, 117, 86, [(1, 2, 3, 5, 7, 14, 28, 56, 61, 117), ..., (1, 2, 4, 8, 16, 17, 34, 50, 100, 117)])
(9, 118, 96, [(1, 2, 3, 4, 7, 14, 28, 31, 59, 118), ..., (1, 2, 4, 8, 16, 32, 34, 68, 102, 118)])
(9, 119, 20, [(1, 2, 3, 4, 7, 14, 28, 56, 63, 119), ..., (1, 2, 4, 8, 16, 17, 34, 68, 102, 119)])
(9, 121, 120, [(1, 2, 3, 5, 10, 15, 30, 60, 61, 121), ..., (1, 2, 4, 8, 16, 32, 40, 80, 120, 121)])
(9, 122, 259, [(1, 2, 3, 5, 7, 14, 28, 33, 61, 122), ..., (1, 2, 4, 8, 16, 32, 40, 80, 120, 122)])
(9, 123, 64, [(1, 2, 3, 5, 10, 15, 30, 60, 63, 123), ..., (1, 2, 4, 8, 16, 32, 40, 41, 82, 123)])
(9, 124, 419, [(1, 2, 3, 4, 7, 14, 17, 31, 62, 124), ..., (1, 2, 4, 8, 16, 32, 40, 80, 120, 124)])
(9, 125, 48, [(1, 2, 3, 5, 10, 15, 25, 50, 75, 125), ..., (1, 2, 4, 8, 16, 24, 25, 50, 100, 125)])
(9, 126, 310, [(1, 2, 3, 4, 7, 14, 21, 42, 63, 126), ..., (1, 2, 4, 8, 16, 32, 40, 42, 84, 126)])
(9, 131, 23, [(1, 2, 3, 4, 8, 16, 32, 64, 67, 131), ..., (1, 2, 4, 8, 16, 32, 64, 128, 130, 131)])
(9, 133, 21, [(1, 2, 3, 5, 8, 16, 32, 64, 69, 133), ..., (1, 2, 4, 8, 16, 32, 64, 128, 132, 133)])
(9, 134, 58, [(1, 2, 3, 4, 8, 16, 32, 35, 67, 134), ..., (1, 2, 4, 8, 16, 32, 64, 128, 132, 134)])
(9, 135, 32, [(1, 2, 3, 5, 10, 15, 30, 45, 90, 135), ..., (1, 2, 4, 8, 9, 18, 36, 45, 90, 135)])
(9, 137, 21, [(1, 2, 4, 8, 9, 16, 32, 64, 73, 137), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 137)])
(9, 138, 74, [(1, 2, 3, 5, 8, 16, 32, 37, 69, 138), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 138)])
(9, 140, 269, [(1, 2, 3, 4, 7, 14, 21, 35, 70, 140), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 140)])
(9, 145, 67, [(1, 2, 3, 6, 9, 18, 36, 72, 73, 145), ..., (1, 2, 4, 8, 16, 32, 64, 128, 144, 145)])
(9, 146, 128, [(1, 2, 3, 6, 9, 18, 36, 37, 73, 146), ..., (1, 2, 4, 8, 16, 32, 64, 128, 144, 146)])
(9, 147, 24, [(1, 2, 3, 6, 9, 18, 36, 72, 75, 147), ..., (1, 2, 4, 8, 16, 32, 48, 49, 98, 147)])
(9, 148, 179, [(1, 2, 3, 5, 8, 16, 21, 37, 74, 148), ..., (1, 2, 4, 8, 16, 32, 64, 128, 144, 148)])
(9, 149, 4, [(1, 2, 4, 5, 9, 18, 36, 72, 77, 149), ..., (1, 2, 4, 8, 16, 17, 33, 66, 132, 149)])
(9, 150, 116, [(1, 2, 3, 5, 10, 15, 25, 50, 75, 150), ..., (1, 2, 4, 8, 16, 32, 48, 50, 100, 150)])
(9, 152, 234, [(1, 2, 3, 4, 8, 11, 19, 38, 76, 152), ..., (1, 2, 4, 8, 16, 32, 64, 128, 144, 152)])
(9, 153, 14, [(1, 2, 3, 6, 9, 18, 36, 72, 81, 153), ..., (1, 2, 4, 8, 16, 17, 34, 68, 136, 153)])
(9, 154, 8, [(1, 2, 4, 5, 9, 18, 36, 41, 77, 154), ..., (1, 2, 4, 8, 16, 18, 34, 68, 136, 154)])
(9, 156, 144, [(1, 2, 3, 5, 8, 13, 26, 39, 78, 156), ..., (1, 2, 4, 8, 16, 32, 48, 52, 104, 156)])
(9, 161, 29, [(1, 2, 3, 5, 10, 20, 40, 80, 81, 161), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 161)])
(9, 162, 99, [(1, 2, 3, 5, 10, 20, 40, 41, 81, 162), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 162)])
(9, 163, 4, [(1, 2, 3, 5, 10, 20, 40, 80, 83, 163), ..., (1, 2, 4, 8, 16, 32, 33, 65, 130, 163)])
(9, 164, 89, [(1, 2, 3, 5, 10, 20, 21, 41, 82, 164), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 164)])
(9, 165, 8, [(1, 2, 3, 5, 10, 20, 40, 80, 85, 165), ..., (1, 2, 4, 8, 16, 32, 33, 66, 132, 165)])
(9, 166, 8, [(1, 2, 3, 5, 10, 20, 40, 43, 83, 166), ..., (1, 2, 4, 8, 16, 32, 34, 66, 132, 166)])
(9, 168, 256, [(1, 2, 3, 4, 7, 14, 21, 42, 84, 168), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 168)])
(9, 170, 24, [(1, 2, 3, 5, 10, 20, 40, 45, 85, 170), ..., (1, 2, 4, 8, 16, 32, 34, 68, 136, 170)])
(9, 172, 12, [(1, 2, 3, 5, 10, 20, 23, 43, 86, 172), ..., (1, 2, 4, 8, 16, 32, 36, 68, 136, 172)])
(9, 176, 127, [(1, 2, 3, 4, 7, 11, 22, 44, 88, 176), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 176)])
(9, 180, 108, [(1, 2, 3, 5, 10, 15, 30, 45, 90, 180), ..., (1, 2, 4, 8, 16, 32, 36, 72, 144, 180)])
(9, 184, 16, [(1, 2, 3, 5, 10, 13, 23, 46, 92, 184), ..., (1, 2, 4, 8, 16, 32, 40, 72, 144, 184)])
(9, 193, 16, [(1, 2, 3, 6, 12, 24, 48, 96, 97, 193), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 193)])
(9, 194, 32, [(1, 2, 3, 6, 12, 24, 48, 49, 97, 194), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 194)])
(9, 195, 4, [(1, 2, 3, 6, 12, 24, 48, 96, 99, 195), ..., (1, 2, 4, 8, 16, 32, 64, 65, 130, 195)])
(9, 196, 44, [(1, 2, 3, 6, 12, 24, 25, 49, 98, 196), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 196)])
(9, 198, 12, [(1, 2, 3, 6, 12, 24, 48, 51, 99, 198), ..., (1, 2, 4, 8, 16, 32, 64, 66, 132, 198)])
(9, 200, 92, [(1, 2, 3, 5, 10, 15, 25, 50, 100, 200), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 200)])
(9, 204, 24, [(1, 2, 3, 6, 12, 24, 27, 51, 102, 204), ..., (1, 2, 4, 8, 16, 32, 64, 68, 136, 204)])
(9, 208, 66, [(1, 2, 3, 5, 8, 13, 26, 52, 104, 208), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 208)])
(9, 216, 60, [(1, 2, 3, 6, 9, 18, 27, 54, 108, 216), ..., (1, 2, 4, 8, 16, 32, 64, 72, 144, 216)])
(9, 224, 50, [(1, 2, 3, 4, 7, 14, 28, 56, 112, 224), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 224)])
(9, 240, 60, [(1, 2, 3, 5, 10, 15, 30, 60, 120, 240), ..., (1, 2, 4, 8, 16, 32, 64, 80, 160, 240)])
(9, 257, 2, [(1, 2, 4, 8, 16, 32, 64, 128, 129, 257), (1, 2, 4, 8, 16, 32, 64, 128, 256, 257)])
(9, 258, 4, [(1, 2, 4, 8, 16, 32, 64, 65, 129, 258), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 258)])
(9, 260, 6, [(1, 2, 4, 8, 16, 32, 33, 65, 130, 260), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 260)])
(9, 264, 8, [(1, 2, 4, 8, 16, 17, 33, 66, 132, 264), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 264)])
(9, 272, 10, [(1, 2, 4, 8, 9, 17, 34, 68, 136, 272), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 272)])
(9, 288, 33, [(1, 2, 3, 6, 9, 18, 36, 72, 144, 288), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 288)])
(9, 320, 14, [(1, 2, 3, 5, 10, 20, 40, 80, 160, 320), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320)])
(9, 384, 8, [(1, 2, 3, 6, 12, 24, 48, 96, 192, 384), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384)])
(9, 512, 1, [(1, 2, 4, 8, 16, 32, 64, 128, 256, 512)])
(10, 127, 2661, [(1, 2, 3, 4, 7, 8, 15, 30, 60, 67, 127), ..., (1, 2, 4, 8, 16, 32, 40, 42, 84, 126, 127)])
(10, 139, 916, [(1, 2, 3, 4, 7, 10, 17, 34, 68, 71, 139), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 138, 139)])
(10, 141, 1786, [(1, 2, 3, 4, 7, 10, 20, 27, 47, 94, 141), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 140, 141)])
(10, 142, 3903, [(1, 2, 3, 4, 7, 8, 16, 32, 39, 71, 142), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 140, 142)])
(10, 143, 861, [(1, 2, 3, 4, 7, 10, 17, 34, 68, 75, 143), ..., (1, 2, 4, 8, 16, 32, 36, 37, 74, 111, 143)])
(10, 151, 705, [(1, 2, 3, 4, 7, 9, 18, 36, 72, 79, 151), ..., (1, 2, 4, 8, 16, 32, 48, 50, 100, 150, 151)])
(10, 155, 607, [(1, 2, 3, 4, 7, 11, 18, 36, 72, 83, 155), ..., (1, 2, 4, 8, 16, 32, 48, 49, 98, 147, 155)])
(10, 157, 684, [(1, 2, 3, 5, 7, 12, 19, 38, 76, 81, 157), ..., (1, 2, 4, 8, 16, 32, 48, 52, 104, 156, 157)])
(10, 158, 1906, [(1, 2, 3, 4, 7, 9, 18, 36, 43, 79, 158), ..., (1, 2, 4, 8, 16, 32, 48, 52, 104, 156, 158)])
(10, 159, 569, [(1, 2, 3, 4, 8, 16, 19, 35, 70, 89, 159), ..., (1, 2, 4, 8, 16, 32, 48, 52, 53, 106, 159)])
(10, 167, 176, [(1, 2, 3, 4, 7, 10, 20, 40, 80, 87, 167), ..., (1, 2, 4, 8, 16, 32, 34, 66, 132, 166, 167)])
(10, 169, 1034, [(1, 2, 3, 4, 7, 14, 21, 42, 84, 85, 169), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 168, 169)])
(10, 171, 690, [(1, 2, 3, 4, 7, 14, 21, 42, 84, 87, 171), ..., (1, 2, 4, 8, 16, 32, 48, 56, 57, 114, 171)])
(10, 173, 205, [(1, 2, 3, 5, 7, 14, 21, 42, 84, 89, 173), ..., (1, 2, 4, 8, 16, 32, 36, 68, 136, 172, 173)])
(10, 174, 1686, [(1, 2, 3, 4, 7, 10, 20, 40, 47, 87, 174), ..., (1, 2, 4, 8, 16, 32, 48, 56, 58, 116, 174)])
(10, 175, 266, [(1, 2, 3, 4, 7, 14, 21, 35, 70, 105, 175), ..., (1, 2, 4, 8, 16, 32, 36, 37, 69, 138, 175)])
(10, 177, 462, [(1, 2, 3, 4, 7, 11, 22, 44, 88, 89, 177), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 176, 177)])
(10, 178, 1210, [(1, 2, 3, 4, 7, 11, 22, 44, 45, 89, 178), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 176, 178)])
(10, 179, 83, [(1, 2, 3, 4, 7, 11, 22, 44, 88, 91, 179), ..., (1, 2, 4, 8, 16, 32, 48, 49, 98, 147, 179)])
(10, 181, 439, [(1, 2, 3, 5, 6, 11, 22, 44, 88, 93, 181), ..., (1, 2, 4, 8, 16, 32, 36, 72, 144, 180, 181)])
(10, 182, 1289, [(1, 2, 3, 4, 7, 11, 22, 44, 47, 91, 182), ..., (1, 2, 4, 8, 16, 32, 48, 50, 100, 150, 182)])
(10, 183, 254, [(1, 2, 3, 4, 7, 11, 22, 44, 88, 95, 183), ..., (1, 2, 4, 8, 16, 32, 36, 37, 73, 146, 183)])
(10, 185, 263, [(1, 2, 3, 5, 8, 16, 21, 37, 74, 111, 185), ..., (1, 2, 4, 8, 16, 32, 40, 72, 144, 184, 185)])
(10, 186, 1011, [(1, 2, 3, 4, 7, 14, 17, 31, 62, 93, 186), ..., (1, 2, 4, 8, 16, 32, 40, 72, 144, 184, 186)])
(10, 187, 72, [(1, 2, 3, 4, 7, 11, 22, 44, 88, 99, 187), ..., (1, 2, 4, 8, 16, 32, 40, 41, 73, 146, 187)])
(10, 188, 1153, [(1, 2, 3, 4, 7, 10, 20, 27, 47, 94, 188), ..., (1, 2, 4, 8, 16, 32, 48, 52, 104, 156, 188)])
(10, 189, 267, [(1, 2, 3, 4, 7, 14, 21, 42, 63, 126, 189), ..., (1, 2, 4, 8, 16, 32, 33, 41, 74, 148, 189)])
(10, 190, 608, [(1, 2, 3, 4, 7, 11, 22, 44, 51, 95, 190), ..., (1, 2, 4, 8, 16, 32, 40, 42, 74, 148, 190)])
(10, 197, 209, [(1, 2, 3, 5, 6, 12, 24, 48, 96, 101, 197), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 196, 197)])
(10, 199, 70, [(1, 2, 3, 5, 7, 12, 24, 48, 96, 103, 199), ..., (1, 2, 4, 8, 16, 32, 64, 66, 132, 198, 199)])
(10, 201, 312, [(1, 2, 3, 4, 8, 16, 32, 35, 67, 134, 201), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 200, 201)])
(10, 202, 729, [(1, 2, 3, 5, 6, 12, 24, 48, 53, 101, 202), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 200, 202)])
(10, 203, 57, [(1, 2, 3, 5, 10, 15, 25, 50, 100, 103, 203), ..., (1, 2, 4, 8, 16, 32, 64, 65, 130, 195, 203)])
(10, 205, 167, [(1, 2, 3, 5, 10, 15, 25, 50, 100, 105, 205), ..., (1, 2, 4, 8, 16, 32, 64, 68, 136, 204, 205)])
(10, 206, 295, [(1, 2, 3, 5, 7, 12, 24, 48, 55, 103, 206), ..., (1, 2, 4, 8, 16, 32, 64, 68, 136, 204, 206)])
(10, 207, 70, [(1, 2, 3, 5, 8, 16, 32, 37, 69, 138, 207), ..., (1, 2, 4, 8, 16, 32, 64, 68, 69, 138, 207)])
(10, 209, 180, [(1, 2, 3, 5, 8, 13, 26, 52, 104, 105, 209), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 208, 209)])
(10, 210, 1075, [(1, 2, 3, 4, 7, 14, 21, 35, 70, 105, 210), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 208, 210)])
(10, 211, 30, [(1, 2, 3, 5, 8, 13, 26, 52, 104, 107, 211), ..., (1, 2, 4, 8, 16, 32, 64, 65, 130, 195, 211)])
(10, 212, 937, [(1, 2, 3, 5, 6, 12, 24, 29, 53, 106, 212), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 208, 212)])
(10, 213, 30, [(1, 2, 3, 5, 8, 13, 26, 52, 104, 109, 213), ..., (1, 2, 4, 8, 16, 32, 33, 49, 82, 164, 213)])
(10, 214, 88, [(1, 2, 3, 5, 8, 13, 26, 52, 55, 107, 214), ..., (1, 2, 4, 8, 16, 32, 64, 66, 132, 198, 214)])
(10, 215, 26, [(1, 2, 3, 5, 10, 15, 25, 50, 100, 115, 215), ..., (1, 2, 4, 8, 16, 17, 33, 66, 132, 198, 215)])
(10, 217, 192, [(1, 2, 3, 6, 9, 18, 27, 54, 108, 109, 217), ..., (1, 2, 4, 8, 16, 32, 64, 72, 144, 216, 217)])
(10, 218, 375, [(1, 2, 3, 5, 8, 13, 26, 52, 57, 109, 218), ..., (1, 2, 4, 8, 16, 32, 64, 72, 144, 216, 218)])
(10, 219, 98, [(1, 2, 3, 6, 9, 18, 27, 54, 108, 111, 219), ..., (1, 2, 4, 8, 16, 32, 64, 72, 73, 146, 219)])
(10, 220, 1096, [(1, 2, 3, 4, 7, 11, 22, 33, 55, 110, 220), ..., (1, 2, 4, 8, 16, 32, 64, 72, 144, 216, 220)])
(10, 221, 58, [(1, 2, 3, 5, 8, 13, 26, 52, 104, 117, 221), ..., (1, 2, 4, 8, 16, 24, 25, 49, 98, 196, 221)])
(10, 222, 310, [(1, 2, 3, 5, 8, 16, 21, 37, 74, 111, 222), ..., (1, 2, 4, 8, 16, 32, 64, 72, 74, 148, 222)])
(10, 225, 251, [(1, 2, 3, 4, 7, 14, 28, 56, 112, 113, 225), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 224, 225)])
(10, 226, 320, [(1, 2, 3, 4, 7, 14, 28, 56, 57, 113, 226), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 224, 226)])
(10, 227, 25, [(1, 2, 3, 4, 7, 14, 28, 56, 112, 115, 227), ..., (1, 2, 4, 8, 16, 32, 64, 65, 130, 195, 227)])
(10, 228, 1012, [(1, 2, 3, 4, 7, 14, 28, 29, 57, 114, 228), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 224, 228)])
(10, 229, 16, [(1, 2, 3, 5, 7, 14, 28, 56, 112, 117, 229), ..., (1, 2, 4, 8, 16, 32, 33, 66, 98, 196, 229)])
(10, 230, 116, [(1, 2, 3, 4, 7, 14, 28, 56, 59, 115, 230), ..., (1, 2, 4, 8, 16, 32, 64, 66, 132, 198, 230)])
(10, 231, 28, [(1, 2, 3, 4, 7, 14, 28, 56, 112, 119, 231), ..., (1, 2, 4, 8, 16, 32, 33, 66, 132, 198, 231)])
(10, 232, 894, [(1, 2, 3, 4, 7, 11, 18, 29, 58, 116, 232), ..., (1, 2, 4, 8, 16, 32, 64, 128, 192, 224, 232)])
(10, 233, 4, [(1, 2, 4, 5, 9, 14, 28, 56, 112, 121, 233), ..., (1, 2, 4, 8, 16, 17, 33, 50, 100, 200, 233)])
(10, 234, 304, [(1, 2, 3, 5, 7, 14, 28, 56, 61, 117, 234), ..., (1, 2, 4, 8, 16, 32, 34, 68, 100, 200, 234)])
(10, 236, 159, [(1, 2, 3, 4, 7, 14, 28, 31, 59, 118, 236), ..., (1, 2, 4, 8, 16, 32, 64, 68, 136, 204, 236)])
(10, 238, 76, [(1, 2, 3, 4, 7, 14, 28, 56, 63, 119, 238), ..., (1, 2, 4, 8, 16, 32, 34, 68, 136, 204, 238)])
(10, 241, 165, [(1, 2, 3, 5, 10, 15, 30, 60, 120, 121, 241), ..., (1, 2, 4, 8, 16, 32, 64, 80, 160, 240, 241)])
(10, 242, 329, [(1, 2, 3, 5, 10, 15, 30, 60, 61, 121, 242), ..., (1, 2, 4, 8, 16, 32, 64, 80, 160, 240, 242)])
(10, 243, 93, [(1, 2, 3, 5, 10, 15, 30, 60, 120, 123, 243), ..., (1, 2, 4, 8, 16, 32, 64, 80, 81, 162, 243)])
(10, 244, 457, [(1, 2, 3, 5, 7, 14, 28, 33, 61, 122, 244), ..., (1, 2, 4, 8, 16, 32, 64, 80, 160, 240, 244)])
(10, 245, 48, [(1, 2, 3, 5, 10, 15, 30, 60, 120, 125, 245), ..., (1, 2, 4, 8, 16, 32, 48, 49, 98, 196, 245)])
(10, 246, 194, [(1, 2, 3, 5, 10, 15, 30, 60, 63, 123, 246), ..., (1, 2, 4, 8, 16, 32, 64, 80, 82, 164, 246)])
(10, 248, 609, [(1, 2, 3, 4, 7, 14, 17, 31, 62, 124, 248), ..., (1, 2, 4, 8, 16, 32, 64, 80, 160, 240, 248)])
(10, 249, 8, [(1, 2, 3, 5, 10, 20, 40, 43, 83, 166, 249), ..., (1, 2, 4, 8, 16, 17, 33, 66, 83, 166, 249)])
(10, 250, 168, [(1, 2, 3, 5, 10, 15, 25, 50, 75, 125, 250), ..., (1, 2, 4, 8, 16, 32, 48, 50, 100, 200, 250)])
(10, 252, 700, [(1, 2, 3, 4, 7, 14, 21, 42, 63, 126, 252), ..., (1, 2, 4, 8, 16, 32, 64, 80, 84, 168, 252)])
(10, 255, 24, [(1, 2, 3, 5, 10, 15, 30, 60, 120, 135, 255), ..., (1, 2, 4, 8, 16, 17, 34, 68, 85, 170, 255)])
(10, 259, 23, [(1, 2, 3, 4, 8, 16, 32, 64, 128, 131, 259), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 258, 259)])
(10, 261, 21, [(1, 2, 3, 5, 8, 16, 32, 64, 128, 133, 261), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 260, 261)])
(10, 262, 58, [(1, 2, 3, 4, 8, 16, 32, 64, 67, 131, 262), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 260, 262)])
(10, 265, 21, [(1, 2, 4, 8, 9, 16, 32, 64, 128, 137, 265), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 264, 265)])
(10, 266, 50, [(1, 2, 3, 5, 8, 16, 32, 64, 69, 133, 266), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 264, 266)])
(10, 268, 101, [(1, 2, 3, 4, 8, 16, 32, 35, 67, 134, 268), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 264, 268)])
(10, 270, 136, [(1, 2, 3, 5, 10, 15, 30, 45, 90, 135, 270), ..., (1, 2, 4, 8, 16, 18, 36, 72, 90, 180, 270)])
(10, 273, 25, [(1, 2, 4, 8, 9, 17, 34, 68, 136, 137, 273), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 272, 273)])
(10, 274, 50, [(1, 2, 4, 8, 9, 16, 32, 64, 73, 137, 274), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 272, 274)])
(10, 276, 135, [(1, 2, 3, 5, 8, 16, 32, 37, 69, 138, 276), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 272, 276)])
(10, 280, 448, [(1, 2, 3, 4, 7, 14, 21, 35, 70, 140, 280), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 272, 280)])
(10, 281, 4, [(1, 2, 4, 8, 9, 17, 34, 68, 136, 145, 281), ..., (1, 2, 4, 8, 16, 17, 33, 66, 132, 264, 281)])
(10, 289, 87, [(1, 2, 3, 6, 9, 18, 36, 72, 144, 145, 289), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 288, 289)])
(10, 290, 168, [(1, 2, 3, 6, 9, 18, 36, 72, 73, 145, 290), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 288, 290)])
(10, 291, 28, [(1, 2, 3, 6, 9, 18, 36, 72, 144, 147, 291), ..., (1, 2, 4, 8, 16, 32, 64, 96, 97, 194, 291)])
(10, 292, 217, [(1, 2, 3, 6, 9, 18, 36, 37, 73, 146, 292), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 288, 292)])
(10, 293, 4, [(1, 2, 4, 5, 9, 18, 36, 72, 144, 149, 293), ..., (1, 2, 4, 8, 16, 32, 33, 65, 130, 260, 293)])
(10, 294, 80, [(1, 2, 3, 6, 9, 18, 36, 72, 75, 147, 294), ..., (1, 2, 4, 8, 16, 32, 64, 96, 98, 196, 294)])
(10, 296, 258, [(1, 2, 3, 5, 8, 16, 21, 37, 74, 148, 296), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 288, 296)])
(10, 297, 14, [(1, 2, 3, 6, 9, 18, 36, 72, 144, 153, 297), ..., (1, 2, 4, 8, 16, 32, 33, 66, 132, 264, 297)])
(10, 298, 8, [(1, 2, 4, 5, 9, 18, 36, 72, 77, 149, 298), ..., (1, 2, 4, 8, 16, 32, 34, 66, 132, 264, 298)])
(10, 300, 264, [(1, 2, 3, 5, 10, 15, 25, 50, 75, 150, 300), ..., (1, 2, 4, 8, 16, 32, 64, 96, 100, 200, 300)])
(10, 304, 307, [(1, 2, 3, 4, 8, 11, 19, 38, 76, 152, 304), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 288, 304)])
(10, 306, 48, [(1, 2, 3, 6, 9, 18, 36, 72, 81, 153, 306), ..., (1, 2, 4, 8, 16, 32, 34, 68, 136, 272, 306)])
(10, 308, 12, [(1, 2, 4, 5, 9, 18, 36, 41, 77, 154, 308), ..., (1, 2, 4, 8, 16, 32, 36, 68, 136, 272, 308)])
(10, 312, 248, [(1, 2, 3, 5, 8, 13, 26, 39, 78, 156, 312), ..., (1, 2, 4, 8, 16, 32, 64, 96, 104, 208, 312)])
(10, 321, 33, [(1, 2, 3, 5, 10, 20, 40, 80, 160, 161, 321), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320, 321)])
(10, 322, 66, [(1, 2, 3, 5, 10, 20, 40, 80, 81, 161, 322), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320, 322)])
(10, 323, 4, [(1, 2, 3, 5, 10, 20, 40, 80, 160, 163, 323), ..., (1, 2, 4, 8, 16, 32, 64, 65, 129, 258, 323)])
(10, 324, 194, [(1, 2, 3, 5, 10, 20, 40, 41, 81, 162, 324), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320, 324)])
(10, 325, 8, [(1, 2, 3, 5, 10, 20, 40, 80, 160, 165, 325), ..., (1, 2, 4, 8, 16, 32, 64, 65, 130, 260, 325)])
(10, 326, 8, [(1, 2, 3, 5, 10, 20, 40, 80, 83, 163, 326), ..., (1, 2, 4, 8, 16, 32, 64, 66, 130, 260, 326)])
(10, 328, 124, [(1, 2, 3, 5, 10, 20, 21, 41, 82, 164, 328), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320, 328)])
(10, 330, 24, [(1, 2, 3, 5, 10, 20, 40, 80, 85, 165, 330), ..., (1, 2, 4, 8, 16, 32, 64, 66, 132, 264, 330)])
(10, 332, 12, [(1, 2, 3, 5, 10, 20, 40, 43, 83, 166, 332), ..., (1, 2, 4, 8, 16, 32, 64, 68, 132, 264, 332)])
(10, 336, 369, [(1, 2, 3, 4, 7, 14, 21, 42, 84, 168, 336), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320, 336)])
(10, 340, 48, [(1, 2, 3, 5, 10, 20, 40, 45, 85, 170, 340), ..., (1, 2, 4, 8, 16, 32, 64, 68, 136, 272, 340)])
(10, 344, 16, [(1, 2, 3, 5, 10, 20, 23, 43, 86, 172, 344), ..., (1, 2, 4, 8, 16, 32, 64, 72, 136, 272, 344)])
(10, 352, 156, [(1, 2, 3, 4, 7, 11, 22, 44, 88, 176, 352), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 320, 352)])
(10, 360, 200, [(1, 2, 3, 5, 10, 15, 30, 45, 90, 180, 360), ..., (1, 2, 4, 8, 16, 32, 64, 72, 144, 288, 360)])
(10, 368, 20, [(1, 2, 3, 5, 10, 13, 23, 46, 92, 184, 368), ..., (1, 2, 4, 8, 16, 32, 64, 80, 144, 288, 368)])
(10, 385, 18, [(1, 2, 3, 6, 12, 24, 48, 96, 192, 193, 385), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 385)])
(10, 386, 36, [(1, 2, 3, 6, 12, 24, 48, 96, 97, 193, 386), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 386)])
(10, 387, 4, [(1, 2, 3, 6, 12, 24, 48, 96, 192, 195, 387), ..., (1, 2, 4, 8, 16, 32, 64, 128, 129, 258, 387)])
(10, 388, 50, [(1, 2, 3, 6, 12, 24, 48, 49, 97, 194, 388), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 388)])
(10, 390, 12, [(1, 2, 3, 6, 12, 24, 48, 96, 99, 195, 390), ..., (1, 2, 4, 8, 16, 32, 64, 128, 130, 260, 390)])
(10, 392, 60, [(1, 2, 3, 6, 12, 24, 25, 49, 98, 196, 392), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 392)])
(10, 396, 24, [(1, 2, 3, 6, 12, 24, 48, 51, 99, 198, 396), ..., (1, 2, 4, 8, 16, 32, 64, 128, 132, 264, 396)])
(10, 400, 126, [(1, 2, 3, 5, 10, 15, 25, 50, 100, 200, 400), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 400)])
(10, 408, 40, [(1, 2, 3, 6, 12, 24, 27, 51, 102, 204, 408), ..., (1, 2, 4, 8, 16, 32, 64, 128, 136, 272, 408)])
(10, 416, 80, [(1, 2, 3, 5, 8, 13, 26, 52, 104, 208, 416), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 416)])
(10, 432, 95, [(1, 2, 3, 6, 9, 18, 27, 54, 108, 216, 432), ..., (1, 2, 4, 8, 16, 32, 64, 128, 144, 288, 432)])
(10, 448, 59, [(1, 2, 3, 4, 7, 14, 28, 56, 112, 224, 448), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 384, 448)])
(10, 480, 84, [(1, 2, 3, 5, 10, 15, 30, 60, 120, 240, 480), ..., (1, 2, 4, 8, 16, 32, 64, 128, 160, 320, 480)])
(10, 513, 2, [(1, 2, 4, 8, 16, 32, 64, 128, 256, 257, 513), (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 513)])
(10, 514, 4, [(1, 2, 4, 8, 16, 32, 64, 128, 129, 257, 514), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 514)])
(10, 516, 6, [(1, 2, 4, 8, 16, 32, 64, 65, 129, 258, 516), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 516)])
(10, 520, 8, [(1, 2, 4, 8, 16, 32, 33, 65, 130, 260, 520), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 520)])
(10, 528, 10, [(1, 2, 4, 8, 16, 17, 33, 66, 132, 264, 528), ..., (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 528)])
]]

py script/min_add_ver2.py @在已知数据中列出囗最少加法囗于首个紧致区间上
((1, 191), 190, [0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 7, 5, 6, 6, 7, 6, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 8, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7, 8, 8, 8, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 8, 8, 8, 8, 9, 7, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 9, 9, 7, 8, 8, 8, 8, 9, 8, 9, 8, 9, 9, 9, 8, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 10, 7, 8, 8, 9, 8, 9, 9, 9, 8, 9, 9, 10, 9, 10, 10, 10, 8, 9, 9, 9, 9, 9, 9, 10, 9, 9, 9, 10, 9, 10, 10, 10, 8, 9, 9, 9, 9, 9, 9, 10, 9, 10, 9, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 9, 10, 10, 10, 10, 10, 10])
    # '输出用于搜索OEIS'

[[[
https://oeis.org/A003313
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A003313		Length of shortest addition chain for n.
(Formerly M0255)		59
0, 1, 2, 2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 4, 5, 5, 6, 5, 6, 6, 6, 5, 6, 6, 6, 6, 7, 6, 7, 5, 6, 6, 7, 6, 7, 7, 7, 6, 7, 7, 7, 7, 7, 7, 8, 6, 7, 7, 7, 7, 8, 7, 8, 7, 8, 8, 8, 7, 8, 8, 8, 6, 7, 7, 8, 7, 8, 8, 9, 7, 8, 8, 8, 8, 8, 8, 9, 7, 8, 8, 8, 8, 8, 8, 9, 8, 9, 8, 9, 8, 9, 9, 9, 7, 8, 8, 8, 8 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,3

COMMENTS	
Equivalently, minimal number of multiplications required to compute the n-th power.

REFERENCES	
Bahig, Hatem M.; El-Zahar, Mohamed H.; Nakamula, Ken; Some results for some conjectures in addition chains, in Combinatorics, computability and logic, pp. 47-54, Springer Ser. Discrete Math. Theor. Comput. Sci., Springer, London, 2001.

D. Bleichenbacher and A. Flammenkamp, An Efficient Algorithm for Computing Shortest Addition Chains, Preprint, 1997.

A. Flammenkamp, Drei Beitraege zur diskreten Mathematik: Additionsketten, No-Three-in-Line-Problem, Sociable Numbers, Diplomarbeit, Bielefeld 1991.

Gashkov, S. B. and Kochergin, V. V.; On addition chains of vectors, gate circuits and the complexity of computations of powers [translation of Metody Diskret. Anal. No. 52 (1992), 22-40, 119-120; 1265027], Siberian Adv. Math. 4 (1994), 1-16.

Gioia, A. A. and Subbarao, M. V., The Scholz-Brauer problem in addition chains, II, in Proceedings of the Eighth Manitoba Conference on Numerical Mathematics and Computing (Univ. Manitoba, Winnipeg, Man., 1978), pp. 251-274, Congress. Numer., XXII, Utilitas Math., Winnipeg, Man., 1979.

D. E. Knuth, The Art of Computer Programming, vol. 2, Seminumerical Algorithms, 2nd ed., Fig. 14 on page 403; 3rd edition, 1998, p. 465.

D. E. Knuth, website, further updates to Vol. 2 of TAOCP.

Rabin, Michael O., and Shmuel Winograd. "Fast evaluation of polynomials by rational preparation." Communications on Pure and Applied Mathematics25.4 (1972): 433-458. See Table p. 455.

N. J. A. Sloane and Simon Plouffe, The Encyclopedia of Integer Sequences, Academic Press, 1995 (includes this sequence).

LINKS	
D. W. Wilson and Antoine Mathys, Table of n, a(n) for n = 1..100000 (10001 terms from D. W. Wilson)
    https://oeis.org/A003313/b003313.txt

F. Bergeron, J. Berstel, S. Brlek, C Duboc, Addition chains using continued fractions, J. Algorithms 10 (1989), 403-412.

Daniel Bleichenbacher, Efficiency and Security of Cryptosystems based on Number Theory. PhD Thesis, Diss. ETH No. 11404, Zürich 1996. See p. 61.

Alfred Brauer, On addition chains Bull. Amer. Math. Soc. 45, (1939). 736-739.

Peter Downey, Benton Leong, and Ravi Sethi, Computing sequences with addition chains SIAM J. Comput. 10 (1981), 638-646.

M. Elia and F. Neri, A note on addition chains and some related conjectures, (Naples/Positano, 1988), pp. 166-181 of R. M. Capocelli, ed., Sequences, Springer-Verlag, NY 1990.

Christian Elsholtz et al., Upper bound on length of addition chain, Math Overflow, Sep 18 2015.

P. Erdős, Remarks on number theory. III. On addition chains, Acta Arith. 6 1960 77-81.

Achim Flammenkamp, Shortest addition chains

A. A. Gioia, M. V. Subbarao, and M. Sugunamma, The Scholz-Brauer problem in addition chains, Duke Math. J. 29 1962 481-487.

Anastasiya Gorodilova, Sergey Agievich, Claude Carlet, Evgeny Gorkunov, Valeriya Idrisova, Nikolay Kolomeec, Alexandr Kutsenko, Svetla Nikova, Alexey Oblaukhov, Stjepan Picek, Bart Preneel, Vincent Rijmen, Natalia Tokareva, Problems and solutions of the Fourth International Students' Olympiad in Cryptography NSUCRYPTO, arXiv:1806.02059 [cs.CR], 2018.

R. L. Graham, A. C.-C. Yao, F. F. Yao, Addition chains with multiplicative cost Discrete Math. 23 (1978), 115-119.

D. Knuth, Letter to N. J. A. Sloane, date unknown

D. E. Knuth, See the achain-all program

D. P. McCarthy, Effect of improved multiplication efficiency on exponentiation algorithms derived from addition chains Math. Comp. 46 (1986), 603-608.

Alec Mihailovs, Notes on using Flammenkamp's tables

Jorge Olivos, On vectorial addition chains J. Algorithms 2 (1981), 13-21.

Hugo Pfoertner, Addition chains

Kari Ragnarsson, Bridget Eileen Tenner, Obtainable Sizes of Topologies on Finite Sets, Oct 06 2008, Journal of Combinatorial Theory, Series A 117 (2010) 138-151.

Arnold Schönhage, A lower bound for the length of addition chains Theor. Comput. Sci. 1 (1975), 1-12.

Edward G. Thurber, The Scholz-Brauer problem on addition chains Pacific J. Math. 49 (1973), 229-242.

Edward G. Thurber, On addition chains l(mn)<=l(n)-b and lower bounds for c(r) Duke Math. J. 40 (1973), 907-913.

Edward G. Thurber, Addition chains and solutions of l(2n)=l(n) and l(2^n-1)=n+l(n)-1, Discrete Math., Vol. 16 (1976), 279-289.

Edward G. Thurber, Addition chains-an erratic sequence Discrete Math. 122 (1993), 287-305.

Edward G. Thurber, Efficient generation of minimal length addition chains, SIAM J. Comput. 28 (1999), 1247-1263.

W. R. Utz, A note on the Scholz-Brauer problem in addition chains, Proc. Amer. Math. Soc. 4, (1953). 462-463.

Emanuel Vegh, A note on addition chains, J. Combinatorial Theory Ser. A 19 (1975), 117-118.

Eric Weisstein's World of Mathematics, Addition Chain

Eric Weisstein's World of Mathematics, Scholz Conjecture

C. T. Whyburn, A note on addition chains Proc. Amer. Math. Soc. 16 1965 1134.

Index to sequences related to the complexity of n

FORMULA	
a(n*m) <= a(n)+a(m). In particular, a(n^k) <= k * a(n). - Max Alekseyev, Jul 22 2005

For all n >= 2, a(n) <= (4/3)*floor(log_2 n) + 2. - Jonathan Vos Post, Oct 08 2008

From Achim Flammenkamp, Oct 26 2016: (Start)

a(n) <= 9/log_2(71) log_2(n), for all n.

It is conjectured by D. E. Knuth, K. Stolarsky et al. that for all n: floor(log_2(n)) + ceiling(log_2(v(n))) <= a(n). (End)

a(n) <= A014701(n). - Charles R Greathouse IV, Jan 03 2018

EXAMPLE	
For n < 149 and for many higher values of n, a(n) is the depth of n in a tree whose first 6 levels are shown below. The path from the root of the tree to n gives an optimal addition chain. (See Knuth, Vol. 2, Sect. 4.6.3, Fig. 14 and Ex. 5):

                  1

                  |

                  2

                 / \

                /   \

               /     \

              /       \

             /         \

            3           4

           / \           \

          /   \           \

         /     \           \

        /       \           \

       5         6           8

      / \        |         /   \

     /   \       |        /     \

    7    10      12      9       16

   /    /  \    /  \    /  \    /  \

  14   11  20  15  24  13  17  18  32

E.g., a(15) = 5 and an optimal chain for 15 is 1, 2, 3, 6, 12, 15.

It is not possible to extend the tree to include the optimal addition chains for all n. For example, the chains for 43, 77, and 149 are incompatible. See the link to Achim Flammenkamp's web page on addition chains.

CROSSREFS	
Cf. A003064, A003065, A005766, A230528, A014701.

Sequence in context: A334200 A128998 A137813 * A353058 A277608 A117497

Adjacent sequences:  A003310 A003311 A003312 * A003314 A003315 A003316

KEYWORD	
nonn,nice,look

AUTHOR	
N. J. A. Sloane

EXTENSIONS	
More terms from Jud McCranie, Nov 01 2001

STATUS	
approved

Last modified September 23 04:03 EDT 2022. Contains 356909 sequences. (Running on oeis4.)
]]]
[[
https://oeis.org/A003313
    D. W. Wilson and Antoine Mathys, Table of n, a(n) for n = 1..100000 (10001 terms from D. W. Wilson)
        https://oeis.org/A003313/b003313.txt
    wget 'https://oeis.org/A003313/b003313.txt' -O '最少加法.txt'
    view /storage/emulated/0/Download/wget_/最少加法.txt
    !du -hs /storage/emulated/0/Download/wget_/最少加法.txt
        868K
    !cp /storage/emulated/0/Download/wget_/最少加法.txt script/最短加链囗数据列表[1..=10_0000][A003313][oeis.org].txt
    view script/最短加链囗数据列表[1..=10_0000][A003313][oeis.org].txt
    e ../../python3_src/nn_ns/math_nn/numbers/shortest_addition_chain_length.py
        # length_of_shortest_addition_chain_for_pint
    !mkdir script/data__avoid_vim_search/
    !mv script/最短加链囗数据列表[1..=10_0000][A003313][oeis.org].txt script/data__avoid_vim_search/
    view script/data__avoid_vim_search/最短加链囗数据列表[1..=10_0000][A003313][oeis.org].txt
]]


py script/min_add_ver2.py ,iter_growing_rngss5final_sum2num_adds
[[
(0, [(1, 2)])
(1, [(1, 3)])
(2, [(1, 5)])
(3, [(1, 7), (8, 9)])
(4, [(1, 11), (12, 13), (16, 17)])
(5, [(1, 19), (20, 21), (24, 25), (32, 33)])
(6, [(1, 29), (30, 31), (32, 35), (36, 37), (40, 41), (48, 49), (64, 65)])
(7, [(1, 47), (48, 53), (54, 55), (56, 57), (60, 61), (64, 67), (68, 69), (72, 73), (80, 81), (96, 97), (128, 129)])
(8, [(1, 71), (72, 79), (80, 87), (88, 89), (90, 91), (92, 93), (96, 101), (102, 103), (104, 105), (108, 109), (112, 113), (120, 121), (128, 131), (132, 133), (136, 137), (144, 145), (160, 161), (192, 193), (256, 257)])
(9, [(1, 127), (128, 139), (140, 141), (144, 151), (152, 155), (156, 157), (160, 167), (168, 169), (170, 171), (172, 173), (176, 177), (180, 181), (184, 185), (192, 197), (198, 199), (200, 201), (204, 205), (208, 209), (216, 217), (224, 225), (240, 241), (256, 259), (260, 261), (264, 265), (272, 273), (288, 289), (320, 321), (384, 385), (512, 513)])
(10, [(1, 191), (192, 223), (224, 235), (236, 237), (238, 239), (240, 247), (248, 251), (252, 253), (255, 263), (264, 267), (268, 269), (270, 271), (272, 275), (276, 277), (280, 282), (288, 295), (296, 299), (300, 301), (304, 305), (306, 307), (308, 309), (312, 313), (320, 327), (328, 329), (330, 331), (332, 333), (336, 337), (340, 341), (344, 345), (352, 353), (360, 361), (368, 369), (384, 389), (390, 391), (392, 393), (396, 397), (400, 401), (408, 409), (416, 417), (432, 433), (448, 449), (480, 481), (512, 515), (516, 517), (520, 521), (528, 529)])
]]
py script/min_add_ver2.py ,加载下载的数据并调用 :iter_growing_rngss5final_sum2num_adds > ~/my_tmp/out4py/min_add_ver2.py.加载下载的数据并调用.iter_growing_rngss5final_sum2num_adds.out.txt
view /sdcard/0my_files/tmp/out4py/min_add_ver2.py.加载下载的数据并调用.iter_growing_rngss5final_sum2num_adds.out.txt
!du -hs /sdcard/0my_files/tmp/out4py/min_add_ver2.py.加载下载的数据并调用.iter_growing_rngss5final_sum2num_adds.out.txt
    312KB
    vs 868KB:特别分散，即使 按条件(最少加法(n) <= upper4num_adds)求n的区间




[[[[[推导定理:
[是加法链 :: [int] -> bool]
[最少加法 :: pint -> uint]
[最小加法链集 :: pint -> {加法链}]
    # [最小加法链集 :: pint -> {sorted[pint]}]
[us :: [int]]:
    [是加法链(us) =[def]= [
        [len(us) >= 1]
        [us[0] == 1]
        [is_strict_sorted(us)]
        [[@k <- [1..<len(us)]] -> [?i,j <- [0..<k]] -> [us[i]+us[j]==us[k]]]
        ]]
[所有加法链 :: {加法链}]
[所有加法链 =[def]= {us :: [int] | [是加法链(us)]}]

[m>=1]:
    [最少加法(m) =[def]= min{len(us) | [us :<- 所有加法链][us[-1] == m]}]
    [最小加法链集(m) =[def]= {us | [us :<- 所有加法链][len(us) == 最少加法(m)]}]


整数:型如(2**k)，最少加法:k
整数:型如(2**i+2**j){i>j}，最少加法:i+1

[@[m>=1] -> @[n>=1] -> [最少加法(m*n) <= 最少加法(m)+最少加法(n)]]
[@[m>=1] -> @[n>=1] -> [最少加法(m+n) <= 1+最少加法(m)+最少加法(n)]]
[@[k>=0] -> @[m>=1] -> [最少加法(m) <= k] -> [m <= 2**k]]
    证明:极限翻倍
[@[k>=0] -> @[m>=1] -> [m > 2**k] -> [最少加法(m) > k]]
    证明:逆否
[@[k>=0] -> [最少加法(2**k) == k]]
[@[j>=0] -> @[i>j] -> [最少加法(2**i+2**j) == i+1]]
    [[证明:
        !![@[k>=0] -> @[m>=1] -> [m > 2**k] -> [最少加法(m) > k]]
        [最少加法(2**i+2**j) > i]
        [最少加法(2**i+2**j) >= i+1]
        !![@[m>=1] -> @[n>=1] -> [最少加法(m*n) <= 最少加法(m)+最少加法(n)]]
        !![0<=j<i]
        [最少加法(2**i+2**j) == 最少加法((2**(i-j)+1)*2**j) <= 最少加法(2**(i-j)+1)+最少加法(2**j)]
        !![@[m>=1] -> @[n>=1] -> [最少加法(m+n) <= 1+最少加法(m)+最少加法(n)]]
        [最少加法(2**(i-j)+1) <= 1+最少加法(2**(i-j))+最少加法(1) == 1+最少加法(2**(i-j))]
        !![@[k>=0] -> [最少加法(2**k) == k]]
        [最少加法(2**i+2**j) <= 最少加法(2**(i-j)+1)+最少加法(2**j) <= 1+最少加法(2**(i-j))+最少加法(2**j) <= 1+(i-j)+j == i+1]
        !![最少加法(2**i+2**j) >= i+1]
        [最少加法(2**i+2**j) == i+1]
    ]]

[@[m>=1] -> [floor_log2(m) <= 最少加法(m) <= floor_log2(m) + bin(m).count('1')-1]]
[@[k>=1] -> @[i>=0] -> [最少加法(k*2**i) <= 最少加法(k)+i]]

不成立:最小加法链囗下限的乘法因子猜想=[def]=???[@[m>=1] -> @[n>=1] -> [最少加法(m*n) >= 最少加法(m)+[n>=2]]]
    在已知数据中测试囗最小加法链囗下限的乘法因子猜想
    [存在反例513=171*3,最少加法(513)==10==最少加法(171)]
不成立:最小加法链囗偶数猜想=[def]=???[@[k>=1] -> @[i>=0] -> [最少加法(k*2**i) == 最少加法(k)+i]]
    可能的反例候选:比如:126==5**3+1==53*2
    在已知数据中测试囗最小加法链囗偶数猜想
    ===后续:发现反例:
    [存在反例382==191*2,最少加法(382)==11==最少加法(191)]
    [191==0b1100_0000-1==0b1011_1111]
    [382==191*2==0b1011_11110]
py script/min_add_ver2.py ,在已知数据中测试囗最小加法链囗偶数猜想
    #所有已知数据通过测试！
    #但测试没通过 后来下载的数据，见下面
py script/min_add_ver2.py ,在已知数据中测试囗最小加法链囗下限的乘法因子猜想
((513, 10), (171, 10))
    #已知数据有唯一反例！
(10, 513, 2, [(1, 2, 4, 8, 16, 32, 64, 128, 256, 257, 513), (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 513)])
(10, 171, 690, [(1, 2, 3, 4, 7, 14, 21, 42, 84, 87, 171), ..., (1, 2, 4, 8, 16, 32, 48, 56, 57, 114, 171)])
py script/min_add_ver2.py ,加载下载的数据并调用 :在已知数据中测试囗最小加法链囗偶数猜想
    # [1..=10**5]中共有266个本原反例
[[
((382, 11), (191, 11))
((1402, 13), (701, 13))
((1486, 13), (743, 13))
((2222, 14), (1111, 14))
((2778, 14), (1389, 14))
((2958, 14), (1479, 14))
((4206, 15), (2103, 15))
((4430, 15), (2215, 15))
((4750, 15), (2375, 15))
((5362, 15), (2681, 15))
((5902, 15), (2951, 15))
((8562, 16), (4281, 16))
((8846, 16), (4423, 16))
((8982, 16), (4491, 16))
((9486, 16), (4743, 16))
((10674, 16), (5337, 16))
((11034, 16), (5517, 16))
((11790, 16), (5895, 16))
((12638, 17), (6319, 17))
((12734, 17), (6367, 17))
((12982, 17), (6491, 17))
((13406, 17), (6703, 17))
((13502, 17), (6751, 17))
((14494, 17), (7247, 17))
((14638, 17), (7319, 17))
((14926, 17), (7463, 17))
((14962, 17), (7481, 17))
((15142, 17), (7571, 17))
((15502, 17), (7751, 17))
((15818, 17), (7909, 17))
((15986, 17), (7993, 17))
((16086, 17), (8043, 17))
((16166, 17), (8083, 17))
((16538, 17), (8269, 17))
((16850, 17), (8425, 17))
((17074, 17), (8537, 17))
((17678, 17), (8839, 17))
((17706, 17), (8853, 17))
((17942, 17), (8971, 17))
((18958, 17), (9479, 17))
((20962, 17), (10481, 17))
((21298, 17), (10649, 17))
((22042, 17), (11021, 17))
((22966, 18), (11483, 18))
((23006, 18), (11503, 18))
((23566, 17), (11783, 17))
((24230, 18), (12115, 18))
((24266, 18), (12133, 18))
((24382, 18), (12191, 18))
((24526, 18), (12263, 18))
((24830, 18), (12415, 18))
((25082, 18), (12541, 18))
((25406, 18), (12703, 18))
((25914, 18), (12957, 18))
((26106, 18), (13053, 18))
((26510, 18), (13255, 18))
((26878, 18), (13439, 18))
((27346, 18), (13673, 18))
((27598, 18), (13799, 18))
((27636, 18), (13818, 18))
((28974, 18), (14487, 18))
((29482, 18), (14741, 18))
((29514, 18), (14757, 18))
((29838, 18), (14919, 18))
((30246, 18), (15123, 18))
((31002, 18), (15501, 18))
((31562, 18), (15781, 18))
((31922, 18), (15961, 18))
((32022, 18), (16011, 18))
((32294, 18), (16147, 18))
((33050, 18), (16525, 18))
((33102, 18), (16551, 18))
((33506, 18), (16753, 18))
((33618, 18), (16809, 18))
((34346, 18), (17173, 18))
((35342, 18), (17671, 18))
((35370, 18), (17685, 18))
((35862, 18), (17931, 18))
((36574, 19), (18287, 19))
((37726, 19), (18863, 19))
((37902, 18), (18951, 18))
((41278, 19), (20639, 19))
((41826, 18), (20913, 18))
((42546, 18), (21273, 18))
((44058, 18), (22029, 18))
((44750, 19), (22375, 19))
((44822, 19), (22411, 19))
((44906, 19), (22453, 19))
((44910, 19), (22455, 19))
((45626, 19), (22813, 19))
((45850, 19), (22925, 19))
((45918, 19), (22959, 19))
((45938, 19), (22969, 19))
((46050, 19), (23025, 19))
((46078, 19), (23039, 19))
((46506, 19), (23253, 19))
((46958, 19), (23479, 19))
((47118, 18), (23559, 18))
((47454, 19), (23727, 19))
((47758, 19), (23879, 19))
((47854, 19), (23927, 19))
((47958, 19), (23979, 19))
((47986, 19), (23993, 19))
((48014, 19), (24007, 19))
((48058, 19), (24029, 19))
((48098, 19), (24049, 19))
((48338, 19), (24169, 19))
((48382, 19), (24191, 19))
((48422, 19), (24211, 19))
((48458, 19), (24229, 19))
((48498, 19), (24249, 19))
((48910, 19), (24455, 19))
((48946, 19), (24473, 19))
((49038, 19), (24519, 19))
((49094, 19), (24547, 19))
((49726, 19), (24863, 19))
((50038, 19), (25019, 19))
((50042, 19), (25021, 19))
((50174, 19), (25087, 19))
((50534, 19), (25267, 19))
((50550, 19), (25275, 19))
((50750, 19), (25375, 19))
((51122, 19), (25561, 19))
((51382, 19), (25691, 19))
((51734, 19), (25867, 19))
((52798, 19), (26399, 19))
((53006, 19), (26503, 19))
((53034, 19), (26517, 19))
((53118, 19), (26559, 19))
((53342, 19), (26671, 19))
((53630, 19), (26815, 19))
((54154, 19), (27077, 19))
((54610, 19), (27305, 19))
((54854, 19), (27427, 19))
((55118, 19), (27559, 19))
((55156, 19), (27578, 19))
((55170, 19), (27585, 19))
((55850, 19), (27925, 19))
((57502, 19), (28751, 19))
((57646, 19), (28823, 19))
((57934, 19), (28967, 19))
((58510, 19), (29255, 19))
((58594, 19), (29297, 19))
((58950, 19), (29475, 19))
((59662, 19), (29831, 19))
((59698, 19), (29849, 19))
((60454, 19), (30227, 19))
((61966, 19), (30983, 19))
((61978, 19), (30989, 19))
((62354, 19), (31177, 19))
((62690, 19), (31345, 19))
((62886, 19), (31443, 19))
((63794, 19), (31897, 19))
((63894, 19), (31947, 19))
((64550, 19), (32275, 19))
((66074, 19), (33037, 19))
((66126, 19), (33063, 19))
((66466, 19), (33233, 19))
((66914, 19), (33457, 19))
((68650, 19), (34325, 19))
((69114, 20), (34557, 20))
((70670, 19), (35335, 19))
((70698, 19), (35349, 19))
((71702, 19), (35851, 19))
((73102, 20), (36551, 20))
((73578, 20), (36789, 20))
((73726, 20), (36863, 20))
((74558, 20), (37279, 20))
((74670, 20), (37335, 20))
((75166, 20), (37583, 20))
((75262, 20), (37631, 20))
((75710, 20), (37855, 20))
((75790, 19), (37895, 19))
((76094, 20), (38047, 20))
((76526, 20), (38263, 20))
((76782, 20), (38391, 20))
((77246, 20), (38623, 20))
((77742, 20), (38871, 20))
((77758, 20), (38879, 20))
((78262, 20), (39131, 20))
((78318, 20), (39159, 20))
((79454, 20), (39727, 20))
((80246, 20), (40123, 20))
((80638, 20), (40319, 20))
((81274, 20), (40637, 20))
((82494, 20), (41247, 20))
((82882, 19), (41441, 19))
((83554, 19), (41777, 19))
((84206, 20), (42103, 20))
((84430, 20), (42215, 20))
((84442, 20), (42221, 20))
((85042, 19), (42521, 19))
((85370, 20), (42685, 20))
((85466, 20), (42733, 20))
((85606, 20), (42803, 20))
((85886, 20), (42943, 20))
((86462, 20), (43231, 20))
((87002, 20), (43501, 20))
((87646, 20), (43823, 20))
((87834, 20), (43917, 20))
((87994, 20), (43997, 20))
((88014, 20), (44007, 20))
((88050, 20), (44025, 20))
((88090, 19), (44045, 19))
((88446, 20), (44223, 20))
((88634, 20), (44317, 20))
((88654, 20), (44327, 20))
((89014, 20), (44507, 20))
((89242, 20), (44621, 20))
((89466, 20), (44733, 20))
((89754, 20), (44877, 20))
((90550, 20), (45275, 20))
((90922, 20), (45461, 20))
((90966, 20), (45483, 20))
((91106, 20), (45553, 20))
((91130, 20), (45565, 20))
((91194, 20), (45597, 20))
((91438, 20), (45719, 20))
((91674, 20), (45837, 20))
((91762, 20), (45881, 20))
((91774, 20), (45887, 20))
((91874, 20), (45937, 20))
((92002, 20), (46001, 20))
((93006, 20), (46503, 20))
((93146, 20), (46573, 20))
((93242, 20), (46621, 20))
((93806, 20), (46903, 20))
((93994, 20), (46997, 20))
((94174, 20), (47087, 20))
((94222, 19), (47111, 19))
((94522, 20), (47261, 20))
((94734, 20), (47367, 20))
((94838, 20), (47419, 20))
((94862, 20), (47431, 20))
((94958, 20), (47479, 20))
((95118, 20), (47559, 20))
((95374, 20), (47687, 20))
((95502, 20), (47751, 20))
((95694, 20), (47847, 20))
((95854, 20), (47927, 20))
((96014, 20), (48007, 20))
((96098, 20), (48049, 20))
((96142, 20), (48071, 20))
((96226, 20), (48113, 20))
((96382, 20), (48191, 20))
((96526, 20), (48263, 20))
((96590, 20), (48295, 20))
((96806, 20), (48403, 20))
((96842, 20), (48421, 20))
((96882, 20), (48441, 20))
((97166, 20), (48583, 20))
((97338, 20), (48669, 20))
((97614, 20), (48807, 20))
((97806, 20), (48903, 20))
((97842, 20), (48921, 20))
((97990, 20), (48995, 20))
((98008, 20), (49004, 20))
((98174, 20), (49087, 20))
((98858, 20), (49429, 20))
((99150, 20), (49575, 20))
((99306, 20), (49653, 20))
((99314, 20), (49657, 20))
((99390, 20), (49695, 20))
((99730, 20), (49865, 20))
((99958, 20), (49979, 20))
((99962, 20), (49981, 20))
]]
py script/min_add_ver2.py ,加载下载的数据并调用 :在已知数据中测试囗最小加法链囗下限的乘法因子猜想
    # [1..=10**5]中共有(531对)本原反例
    #      其中共有2*(2对) 针对素因子[2,3]
    #      其中共有266个『偶数猜想』本原反例
    # 输出共533行，含有非数据行:num_failure_prime_factors_ge2/2行,all_prime_factors_failure__nonempty/0行
    #  『/, [^23],』搜索得:素因子5共6行
    #       ((16385, 15), 5, (3277, 15))
    #  『/), \d\d\+, (』搜索得:无
    #   素因子只有[2,3,5]
    #       ==>> 素因子3共259==(533-2 -266 -6)行
    #       验证:『/, 3,』『259n』『n』:确认！
[[
((382, 11), 2, (191, 11))
((513, 10), 3, (171, 10))
((1026, 11), 3, (342, 11))
((1281, 12), 3, (427, 12))
((1402, 13), 2, (701, 13))
((1486, 13), 2, (743, 13))
((2049, 12), 3, (683, 12))
((2052, 12), 3, (684, 12))
((2222, 14), 2, (1111, 14))
((2562, 13), 3, (854, 13))
((2565, 13), 3, (855, 13))
((2778, 14), 2, (1389, 14))
((2958, 14), 2, (1479, 14))
((3333, 14), 3, (1111, 14))
((3585, 14), 3, (1195, 14))
((4098, 13), 3, (1366, 13))
((4101, 14), 3, (1367, 14))
((4104, 13), 3, (1368, 13))
((4206, 15), 2, (2103, 15))
((4353, 14), 3, (1451, 14))
((4430, 15), 2, (2215, 15))
((4750, 15), 2, (2375, 15))
((5121, 14), 3, (1707, 14))
((5124, 14), 3, (1708, 14))
((5130, 14), 3, (1710, 14))
((5362, 15), 2, (2681, 15))
((5902, 15), 2, (2951, 15))
((7170, 15), 3, (2390, 15))
((8193, 14), 3, (2731, 15))
((8196, 14), 3, (2732, 14))
((8202, 15), 3, (2734, 15))
((8208, 14), 3, (2736, 14))
((8562, 16), 2, (4281, 16))
((8706, 15), 3, (2902, 15))
((8846, 16), 2, (4423, 16))
((8982, 16), 2, (4491, 16))
((9486, 16), 2, (4743, 16))
((10242, 15), 3, (3414, 15))
((10245, 15), 3, (3415, 15))
((10248, 15), 3, (3416, 15))
((10260, 15), 3, (3420, 15))
((10674, 16), 2, (5337, 16))
((11034, 16), 2, (5517, 16))
((11265, 16), 3, (3755, 16))
((11790, 16), 2, (5895, 16))
((12609, 16), 3, (4203, 16))
((12638, 17), 2, (6319, 17))
((12734, 17), 2, (6367, 17))
((12813, 16), 3, (4271, 16))
((12982, 17), 2, (6491, 17))
((13406, 17), 2, (6703, 17))
((13502, 17), 2, (6751, 17))
((14340, 16), 3, (4780, 16))
((14343, 16), 3, (4781, 16))
((14494, 17), 2, (7247, 17))
((14638, 17), 2, (7319, 17))
((14926, 17), 2, (7463, 17))
((14962, 17), 2, (7481, 17))
((15142, 17), 2, (7571, 17))
((15502, 17), 2, (7751, 17))
((15818, 17), 2, (7909, 17))
((15986, 17), 2, (7993, 17))
((16086, 17), 2, (8043, 17))
((16166, 17), 2, (8083, 17))
((16385, 15), 5, (3277, 15))
((16386, 15), 3, (5462, 16))
((16389, 16), 3, (5463, 16))
((16392, 15), 3, (5464, 15))
((16404, 16), 3, (5468, 16))
((16416, 15), 3, (5472, 15))
((16449, 16), 3, (5483, 16))
((16538, 17), 2, (8269, 17))
((16850, 17), 2, (8425, 17))
((17074, 17), 2, (8537, 17))
((17409, 16), 3, (5803, 16))
((17412, 16), 3, (5804, 16))
((17678, 17), 2, (8839, 17))
((17706, 17), 2, (8853, 17))
((17942, 17), 2, (8971, 17))
((18957, 17), 3, (6319, 17))
((18958, 17), 2, (9479, 17))
((18993, 17), 3, (6331, 17))
((19149, 17), 3, (6383, 17))
((19473, 17), 3, (6491, 17))
((20481, 16), 3, (6827, 16))
((20484, 16), 3, (6828, 16))
((20490, 16), 3, (6830, 16))
((20496, 16), 3, (6832, 16))
((20520, 16), 3, (6840, 16))
((20673, 17), 3, (6891, 17))
((20962, 17), 2, (10481, 17))
((21015, 17), 3, (7005, 17))
((21298, 17), 2, (10649, 17))
((22017, 17), 3, (7339, 17))
((22042, 17), 2, (11021, 17))
((22530, 17), 3, (7510, 17))
((22966, 18), 2, (11483, 18))
((23006, 18), 2, (11503, 18))
((23566, 17), 2, (11783, 17))
((24230, 18), 2, (12115, 18))
((24266, 18), 2, (12133, 18))
((24382, 18), 2, (12191, 18))
((24526, 18), 2, (12263, 18))
((24801, 17), 3, (8267, 17))
((24830, 18), 2, (12415, 18))
((24993, 17), 3, (8331, 17))
((25082, 18), 2, (12541, 18))
((25089, 17), 3, (8363, 17))
((25137, 17), 3, (8379, 17))
((25218, 17), 3, (8406, 17))
((25406, 18), 2, (12703, 18))
((25605, 17), 3, (8535, 17))
((25617, 17), 3, (8539, 17))
((25626, 17), 3, (8542, 17))
((25914, 18), 2, (12957, 18))
((26106, 18), 2, (13053, 18))
((26510, 18), 2, (13255, 18))
((26631, 17), 3, (8877, 17))
((26637, 17), 3, (8879, 17))
((26878, 18), 2, (13439, 18))
((27346, 18), 2, (13673, 18))
((27598, 18), 2, (13799, 18))
((27636, 18), 2, (13818, 18))
((28677, 17), 3, (9559, 17))
((28680, 17), 3, (9560, 17))
((28686, 17), 3, (9562, 17))
((28974, 18), 2, (14487, 18))
((29482, 18), 2, (14741, 18))
((29514, 18), 2, (14757, 18))
((29838, 18), 2, (14919, 18))
((30246, 18), 2, (15123, 18))
((31002, 18), 2, (15501, 18))
((31562, 18), 2, (15781, 18))
((31922, 18), 2, (15961, 18))
((32022, 18), 2, (16011, 18))
((32294, 18), 2, (16147, 18))
((32769, 16), 3, (10923, 17))
((32770, 16), 5, (6554, 16))
((32772, 16), 3, (10924, 17))
((32778, 17), 3, (10926, 17))
((32784, 16), 3, (10928, 16))
((32808, 17), 3, (10936, 17))
((32832, 16), 3, (10944, 16))
((32898, 17), 3, (10966, 17))
((33050, 18), 2, (16525, 18))
((33102, 18), 2, (16551, 18))
((33345, 17), 3, (11115, 17))
((33506, 18), 2, (16753, 18))
((33618, 18), 2, (16809, 18))
((34346, 18), 2, (17173, 18))
((34818, 17), 3, (11606, 17))
((34824, 17), 3, (11608, 17))
((34833, 17), 3, (11611, 17))
((35342, 18), 2, (17671, 18))
((35370, 18), 2, (17685, 18))
((35862, 18), 2, (17931, 18))
((36574, 19), 2, (18287, 19))
((37377, 18), 3, (12459, 18))
((37726, 19), 2, (18863, 19))
((37902, 18), 2, (18951, 18))
((37905, 18), 3, (12635, 18))
((37911, 18), 3, (12637, 18))
((37986, 18), 3, (12662, 18))
((38298, 18), 3, (12766, 18))
((38913, 18), 3, (12971, 18))
((38919, 18), 3, (12973, 18))
((40962, 17), 3, (13654, 17))
((40965, 17), 3, (13655, 18))
((40968, 17), 3, (13656, 17))
((40977, 18), 3, (13659, 18))
((40980, 17), 3, (13660, 17))
((40983, 18), 3, (13661, 18))
((40989, 18), 3, (13663, 18))
((40992, 17), 3, (13664, 17))
((41001, 18), 3, (13667, 18))
((41013, 18), 3, (13671, 18))
((41025, 18), 3, (13675, 18))
((41040, 17), 3, (13680, 17))
((41061, 18), 3, (13687, 18))
((41121, 18), 3, (13707, 18))
((41157, 18), 3, (13719, 18))
((41217, 18), 3, (13739, 18))
((41278, 19), 2, (20639, 19))
((41313, 18), 3, (13771, 18))
((41346, 18), 3, (13782, 18))
((41826, 18), 2, (20913, 18))
((42009, 18), 3, (14003, 18))
((42030, 18), 3, (14010, 18))
((42501, 18), 3, (14167, 18))
((42546, 18), 2, (21273, 18))
((43521, 18), 3, (14507, 18))
((44034, 18), 3, (14678, 18))
((44037, 18), 3, (14679, 18))
((44049, 18), 3, (14683, 18))
((44055, 18), 3, (14685, 18))
((44058, 18), 2, (22029, 18))
((44058, 18), 3, (14686, 18))
num_failure_prime_factors_ge2:44058: [2 <= 2 <= 4]
((44750, 19), 2, (22375, 19))
((44822, 19), 2, (22411, 19))
((44906, 19), 2, (22453, 19))
((44910, 19), 2, (22455, 19))
((45057, 18), 3, (15019, 18))
((45060, 18), 3, (15020, 18))
((45069, 18), 3, (15023, 18))
((45626, 19), 2, (22813, 19))
((45850, 19), 2, (22925, 19))
((45918, 19), 2, (22959, 19))
((45938, 19), 2, (22969, 19))
((46050, 19), 2, (23025, 19))
((46078, 19), 2, (23039, 19))
((46506, 19), 2, (23253, 19))
((46958, 19), 2, (23479, 19))
((47109, 18), 3, (15703, 18))
((47118, 18), 2, (23559, 18))
((47118, 18), 3, (15706, 18))
num_failure_prime_factors_ge2:47118: [2 <= 2 <= 3]
((47127, 18), 3, (15709, 18))
((47454, 19), 2, (23727, 19))
((47758, 19), 2, (23879, 19))
((47854, 19), 2, (23927, 19))
((47958, 19), 2, (23979, 19))
((47986, 19), 2, (23993, 19))
((48014, 19), 2, (24007, 19))
((48058, 19), 2, (24029, 19))
((48098, 19), 2, (24049, 19))
((48338, 19), 2, (24169, 19))
((48382, 19), 2, (24191, 19))
((48422, 19), 2, (24211, 19))
((48458, 19), 2, (24229, 19))
((48498, 19), 2, (24249, 19))
((48910, 19), 2, (24455, 19))
((48946, 19), 2, (24473, 19))
((49038, 19), 2, (24519, 19))
((49094, 19), 2, (24547, 19))
((49155, 17), 5, (9831, 17))
((49473, 18), 3, (16491, 18))
((49602, 18), 3, (16534, 18))
((49713, 18), 3, (16571, 18))
((49726, 19), 2, (24863, 19))
((49761, 18), 3, (16587, 18))
((49953, 18), 3, (16651, 18))
((49986, 18), 3, (16662, 18))
((50038, 19), 2, (25019, 19))
((50042, 19), 2, (25021, 19))
((50174, 19), 2, (25087, 19))
((50178, 18), 3, (16726, 18))
((50193, 18), 3, (16731, 18))
((50241, 18), 3, (16747, 18))
((50274, 18), 3, (16758, 18))
((50436, 18), 3, (16812, 18))
((50534, 19), 2, (25267, 19))
((50550, 19), 2, (25275, 19))
((50750, 19), 2, (25375, 19))
((51122, 19), 2, (25561, 19))
((51201, 18), 3, (17067, 18))
((51210, 18), 3, (17070, 18))
((51213, 18), 3, (17071, 18))
((51225, 18), 3, (17075, 18))
((51234, 18), 3, (17078, 18))
((51252, 18), 3, (17084, 18))
((51382, 19), 2, (25691, 19))
((51734, 19), 2, (25867, 19))
((52798, 19), 2, (26399, 19))
((53006, 19), 2, (26503, 19))
((53034, 19), 2, (26517, 19))
((53118, 19), 2, (26559, 19))
((53253, 18), 3, (17751, 18))
((53262, 18), 3, (17754, 18))
((53265, 18), 3, (17755, 18))
((53274, 18), 3, (17758, 18))
((53342, 19), 2, (26671, 19))
((53630, 19), 2, (26815, 19))
((54154, 19), 2, (27077, 19))
((54610, 19), 2, (27305, 19))
((54854, 19), 2, (27427, 19))
((55118, 19), 2, (27559, 19))
((55156, 19), 2, (27578, 19))
((55170, 19), 2, (27585, 19))
((55850, 19), 2, (27925, 19))
((56589, 19), 3, (18863, 19))
((57345, 18), 3, (19115, 18))
((57351, 18), 3, (19117, 18))
((57354, 18), 3, (19118, 18))
((57360, 18), 3, (19120, 18))
((57372, 18), 3, (19124, 18))
((57502, 19), 2, (28751, 19))
((57646, 19), 2, (28823, 19))
((57934, 19), 2, (28967, 19))
((58510, 19), 2, (29255, 19))
((58594, 19), 2, (29297, 19))
((58950, 19), 2, (29475, 19))
((59662, 19), 2, (29831, 19))
((59698, 19), 2, (29849, 19))
((60454, 19), 2, (30227, 19))
((60945, 19), 3, (20315, 19))
((61966, 19), 2, (30983, 19))
((61978, 19), 2, (30989, 19))
((62354, 19), 2, (31177, 19))
((62690, 19), 2, (31345, 19))
((62886, 19), 2, (31443, 19))
((63501, 19), 3, (21167, 19))
((63794, 19), 2, (31897, 19))
((63894, 19), 2, (31947, 19))
((64550, 19), 2, (32275, 19))
((65538, 17), 3, (21846, 18))
((65540, 17), 5, (13108, 17))
((65541, 18), 3, (21847, 18))
((65544, 17), 3, (21848, 18))
((65553, 18), 3, (21851, 18))
((65556, 18), 3, (21852, 18))
((65568, 17), 3, (21856, 17))
((65601, 18), 3, (21867, 18))
((65616, 18), 3, (21872, 18))
((65664, 17), 3, (21888, 17))
((65793, 18), 3, (21931, 18))
((65796, 18), 3, (21932, 18))
((66074, 19), 2, (33037, 19))
((66126, 19), 2, (33063, 19))
((66466, 19), 2, (33233, 19))
((66561, 18), 3, (22187, 18))
((66690, 18), 3, (22230, 18))
((66914, 19), 2, (33457, 19))
((68229, 19), 3, (22743, 19))
((68613, 19), 3, (22871, 19))
((68650, 19), 2, (34325, 19))
((69114, 20), 2, (34557, 20))
((69633, 18), 3, (23211, 18))
((69636, 18), 3, (23212, 18))
((69648, 18), 3, (23216, 18))
((69666, 18), 3, (23222, 18))
((70670, 19), 2, (35335, 19))
((70698, 19), 2, (35349, 19))
((71697, 19), 3, (23899, 19))
((71702, 19), 2, (35851, 19))
((71937, 19), 3, (23979, 19))
((73102, 20), 2, (36551, 20))
((73578, 20), 2, (36789, 20))
((73726, 20), 2, (36863, 20))
((74241, 19), 3, (24747, 19))
((74558, 20), 2, (37279, 20))
((74625, 19), 3, (24875, 19))
((74670, 20), 2, (37335, 20))
((74754, 19), 3, (24918, 19))
((74757, 19), 3, (24919, 19))
((75045, 19), 3, (25015, 19))
((75166, 20), 2, (37583, 20))
((75262, 20), 2, (37631, 20))
((75710, 20), 2, (37855, 20))
((75789, 19), 3, (25263, 19))
((75790, 19), 2, (37895, 19))
((75801, 19), 3, (25267, 19))
((75810, 19), 3, (25270, 19))
((75813, 19), 3, (25271, 19))
((75822, 19), 3, (25274, 19))
((75825, 19), 3, (25275, 19))
((75972, 19), 3, (25324, 19))
((76094, 20), 2, (38047, 20))
((76293, 19), 3, (25431, 19))
((76305, 19), 3, (25435, 19))
((76526, 20), 2, (38263, 20))
((76596, 19), 3, (25532, 19))
((76782, 20), 2, (38391, 20))
((77246, 20), 2, (38623, 20))
((77742, 20), 2, (38871, 20))
((77758, 20), 2, (38879, 20))
((77826, 19), 3, (25942, 19))
((77829, 19), 3, (25943, 19))
((77838, 19), 3, (25946, 19))
((78262, 20), 2, (39131, 20))
((78318, 20), 2, (39159, 20))
((78849, 19), 3, (26283, 19))
((79454, 20), 2, (39727, 20))
((80246, 20), 2, (40123, 20))
((80638, 20), 2, (40319, 20))
((81274, 20), 2, (40637, 20))
((81921, 18), 3, (27307, 19))
((81924, 18), 3, (27308, 18))
((81927, 19), 3, (27309, 19))
((81930, 18), 3, (27310, 19))
((81933, 19), 3, (27311, 19))
((81936, 18), 3, (27312, 18))
((81954, 19), 3, (27318, 19))
((81957, 19), 3, (27319, 19))
((81960, 18), 3, (27320, 18))
((81963, 19), 3, (27321, 19))
((81966, 19), 3, (27322, 19))
((81969, 19), 3, (27323, 19))
((81978, 19), 3, (27326, 19))
((81984, 18), 3, (27328, 18))
((81987, 19), 3, (27329, 19))
((82002, 19), 3, (27334, 19))
((82017, 19), 3, (27339, 19))
((82026, 19), 3, (27342, 19))
((82050, 19), 3, (27350, 19))
((82053, 19), 3, (27351, 19))
((82080, 18), 3, (27360, 18))
((82083, 19), 3, (27361, 19))
((82113, 19), 3, (27371, 19))
((82122, 19), 3, (27374, 19))
((82242, 19), 3, (27414, 19))
((82245, 19), 3, (27415, 19))
((82305, 19), 3, (27435, 19))
((82314, 19), 3, (27438, 19))
((82434, 19), 3, (27478, 19))
((82437, 19), 3, (27479, 19))
((82494, 20), 2, (41247, 20))
((82593, 19), 3, (27531, 19))
((82626, 19), 3, (27542, 19))
((82692, 19), 3, (27564, 19))
((82755, 19), 3, (27585, 19))
((82851, 19), 3, (27617, 19))
((82882, 19), 2, (41441, 19))
((83554, 19), 2, (41777, 19))
((83973, 19), 3, (27991, 19))
((83991, 19), 3, (27997, 19))
((84009, 19), 3, (28003, 19))
((84018, 19), 3, (28006, 19))
((84060, 19), 3, (28020, 19))
((84206, 20), 2, (42103, 20))
((84430, 20), 2, (42215, 20))
((84442, 20), 2, (42221, 20))
((84993, 19), 3, (28331, 19))
((85002, 19), 3, (28334, 19))
((85035, 19), 3, (28345, 19))
((85042, 19), 2, (42521, 19))
((85370, 20), 2, (42685, 20))
((85466, 20), 2, (42733, 20))
((85606, 20), 2, (42803, 20))
((85886, 20), 2, (42943, 20))
((86462, 20), 2, (43231, 20))
((87002, 20), 2, (43501, 20))
((87042, 19), 3, (29014, 19))
((87045, 19), 3, (29015, 19))
((87057, 19), 3, (29019, 19))
((87646, 20), 2, (43823, 20))
((87834, 20), 2, (43917, 20))
((87994, 20), 2, (43997, 20))
((88014, 20), 2, (44007, 20))
((88050, 20), 2, (44025, 20))
((88065, 19), 3, (29355, 19))
((88068, 19), 3, (29356, 19))
((88074, 19), 3, (29358, 19))
((88090, 19), 2, (44045, 19))
((88098, 19), 3, (29366, 19))
((88107, 19), 3, (29369, 19))
((88110, 19), 3, (29370, 19))
((88116, 19), 3, (29372, 19))
((88446, 20), 2, (44223, 20))
((88634, 20), 2, (44317, 20))
((88654, 20), 2, (44327, 20))
((89014, 20), 2, (44507, 20))
((89242, 20), 2, (44621, 20))
((89466, 20), 2, (44733, 20))
((89754, 20), 2, (44877, 20))
((90114, 19), 3, (30038, 19))
((90117, 19), 3, (30039, 19))
((90120, 19), 3, (30040, 19))
((90123, 19), 3, (30041, 19))
((90138, 19), 3, (30046, 19))
((90550, 20), 2, (45275, 20))
((90922, 20), 2, (45461, 20))
((90966, 20), 2, (45483, 20))
((91106, 20), 2, (45553, 20))
((91130, 20), 2, (45565, 20))
((91194, 20), 2, (45597, 20))
((91438, 20), 2, (45719, 20))
((91674, 20), 2, (45837, 20))
((91762, 20), 2, (45881, 20))
((91774, 20), 2, (45887, 20))
((91874, 20), 2, (45937, 20))
((92002, 20), 2, (46001, 20))
((93006, 20), 2, (46503, 20))
((93146, 20), 2, (46573, 20))
((93242, 20), 2, (46621, 20))
((93806, 20), 2, (46903, 20))
((93994, 20), 2, (46997, 20))
((94174, 20), 2, (47087, 20))
((94209, 19), 3, (31403, 19))
((94218, 19), 3, (31406, 19))
((94221, 19), 3, (31407, 19))
((94222, 19), 2, (47111, 19))
((94236, 19), 3, (31412, 19))
((94254, 19), 3, (31418, 19))
((94522, 20), 2, (47261, 20))
((94734, 20), 2, (47367, 20))
((94838, 20), 2, (47419, 20))
((94862, 20), 2, (47431, 20))
((94958, 20), 2, (47479, 20))
((95118, 20), 2, (47559, 20))
((95374, 20), 2, (47687, 20))
((95502, 20), 2, (47751, 20))
((95694, 20), 2, (47847, 20))
((95854, 20), 2, (47927, 20))
((96014, 20), 2, (48007, 20))
((96098, 20), 2, (48049, 20))
((96142, 20), 2, (48071, 20))
((96226, 20), 2, (48113, 20))
((96382, 20), 2, (48191, 20))
((96526, 20), 2, (48263, 20))
((96590, 20), 2, (48295, 20))
((96806, 20), 2, (48403, 20))
((96842, 20), 2, (48421, 20))
((96882, 20), 2, (48441, 20))
((97166, 20), 2, (48583, 20))
((97338, 20), 2, (48669, 20))
((97614, 20), 2, (48807, 20))
((97806, 20), 2, (48903, 20))
((97842, 20), 2, (48921, 20))
((97990, 20), 2, (48995, 20))
((98008, 20), 2, (49004, 20))
((98174, 20), 2, (49087, 20))
((98305, 18), 5, (19661, 18))
((98310, 18), 5, (19662, 18))
((98817, 19), 3, (32939, 19))
((98858, 20), 2, (49429, 20))
((98913, 19), 3, (32971, 19))
((98946, 19), 3, (32982, 19))
((99009, 19), 3, (33003, 19))
((99150, 20), 2, (49575, 20))
((99204, 19), 3, (33068, 19))
((99306, 20), 2, (49653, 20))
((99314, 20), 2, (49657, 20))
((99390, 20), 2, (49695, 20))
((99393, 19), 3, (33131, 19))
((99426, 19), 3, (33142, 19))
((99522, 19), 3, (33174, 19))
((99730, 20), 2, (49865, 20))
((99873, 19), 3, (33291, 19))
((99906, 19), 3, (33302, 19))
((99958, 20), 2, (49979, 20))
((99962, 20), 2, (49981, 20))
((99972, 19), 3, (33324, 19))
]]

上面多是:
    [[???] -> [最少加法(n) <= ???]] 型定理
急需:
    [[???] -> [最少加法(n) >= ???]] 型定理
    ===:
    [[最少加法(n) <= ???] -> [???]] 型定理
    [最少加法囗反函数囗下限(m;[0..=???]) == ???] 型定理
        #枚举极大值

[@[m>=2] -> [最少加法(m) >= 1+min{最少加法(n) | [n :<- [(m+1)//2..=m-1]]}]]
[@[m>=2] -> [最少加法(m) >= min{(最少加法(n)+2-[?[ls :<- 最小加法链集(n)] -> [(m-n) <- ls]]) | [n :<- [(m+1)//2..=m-1]]}]]
    [@[m>=2] -> [最少加法(m) >= min{(最少加法(n)+1+[@[ls :<- 最小加法链集(n)] -> [not$ [(m-n) <- ls]]]) | [n :<- [(m+1)//2..=m-1]]}]]
[@[k>=0] -> [[最少加法(2**k) == k][最小加法链集(2**k) == {[2**i | [i :<- [0..=k]]]}]]]
    #增强:[@[k>=0] -> [最少加法(2**k) == k]]

#正整数加法: 比特1的总数控制
[n >= 1]:
    [正整数二进制编码中一的数量(n) =[def]= bin(n).count('1')]
    [pint2num_1bits(n) := 正整数二进制编码中一的数量(n)]
[@[m,n >= 1] -> [pint2num_1bits(m+n) <= pint2num_1bits(m)+pint2num_1bits(n)]]
[@[m,n >= 1] -> [m>=n] -> [pint2num_1bits(m+n) <= pint2num_1bits(m)+pint2num_1bits(n) -[floor_log2(m+n) > floor_log2(m)]*(1+floor_log2(m)-floor_log2(n))]]

[@[m>=2] -> [
    [最少加法(m) >= 1]
    [[ls :<- 最小加法链集(m)] -> [
        [len(ls) == 1+最少加法(m) >= 2]
        [is_sorted(ls)]
        [ls[-1] == m]
        [m/2 <= ls[-2] < m]
        [(m-ls[-2]) <- ls[:-1]]
        ]]
    ]]
[us :: {int{>=2}}]:
    [次极大数集囗最小加法链(us) =[def]= {ls[-2] | [m :<- us][ls :<- 最小加法链集(m)]}]
[@[m>=2] -> [min(次极大数集囗最小加法链({m})) >= m/2]]

[us :: [uint]]:
    [最少加法囗反函数(us) =[def]= {n <- [1..] | [最少加法(n) <- us]}]
[m>=1][us :: [uint]]:
    [最少加法囗反函数囗下限(m;us) =[def]= {n <- [m..] | [最少加法(n) <- us]}]
[m>=1][N>=0]:
    [最少加法囗反函数囗下限囗上限(m;N) =[def]= 最少加法囗反函数囗下限(m;[0..=N])]
[@[N>=0] -> @[m>=1] -> @[n >= m] -> [[n <- 最少加法囗反函数囗下限囗上限(m;N)] <-> [最少加法(n) <= N]]]
[@[N>=0] -> @[m>=1] -> @[n >= m] -> [not$ [n <- 最少加法囗反函数囗下限囗上限(m;N)]] -> [最少加法(n) >= N+1]]

!![@[m>=2] -> [min(次极大数集囗最小加法链({m})) >= m/2]]
[@[i>=0] -> @[j>=0] -> [次极大数集囗最小加法链(最少加法囗反函数囗下限囗上限(2**(i+1);j+1)) |<=| 最少加法囗反函数囗下限囗上限(2**i;j)]]

[@[i>=0] -> [最少加法囗反函数囗下限囗上限(2**(i+1);i) == {}]]
[@[i>=0] -> [最少加法囗反函数囗下限囗上限(2**i;i) == {2**i}]]
[已证明]:[@[i>=0] -> [最少加法囗反函数囗下限囗上限(2**i;i+1) == {2**i} \-/ {2**i+2**j | [j :<- [0..=i]]}]]
    #[j==i] --> 2**(i+1)
    #见下面证明

[最小加法链集(1) == {[1]}]
[已证明]:[@[i>=0] -> [
    [最少加法囗反函数囗下限囗上限(2**i;i) == {2**i}]
        # ==>> [最少加法囗反函数囗下限囗上限(2**(i+1);i) == {}]
    [最少加法囗反函数囗下限(2**i;[i+1]) == 最少加法囗反函数囗下限囗上限(2**i;i+1) \-\ 最少加法囗反函数囗下限囗上限(2**i;i) == {2**i+2**j | [j :<- [0..=i]]}]
    [最小加法链集(2**i) == {[2**j | [j <- [0..=i]]]}]
    [@[j <- [0..=i]] -> [m := 2**i+2**j] -> [
        [最小加法链集(m)
        == (if j == i-3 then {ls++[(2*m///3),m] | [ls :<- 最小加法链集(m///3)]} else {})
            # m==(3*2**j)*3
            # [0b1001 == 9]
            # (4, 9, 3, [(1, 2, 3, 6, 9), (1, 2, 4, 5, 9), (1, 2, 4, 8, 9)])
                # (1,2,3,6,9)
                # 以下两个在『加法交换律』下是等价类:(1+4+4)==9
                # (1,2,4,8,9)
                # (1,2,4,5,9)
                #
        \-/(if 1 <= j < i then {ls++[m] | [ls :<- 最小加法链集(m///2)]} else {})
            # m==(2**(i-1)+2**(j-1))*2
            #   在『乘法交换律』下，与 其他上下分支 是 等价类
        \-/(if j <= i-2 then {ls++[(2**(i-1)+2**j),m] | [ls :<- 最小加法链集(2**(i-1))]} else {})
            # m==(2**(i-1)+2**j)+(2**(i-1))
            #   在『加法交换律』下，与 下面 m==2**i+2**j 是等价类
        \-/{ls++[m] | [ls :<- 最小加法链集(2**i)]}
            # m==2**i+2**j

        ]
        [次极大数集囗最小加法链({m})
        == (if j == i-3 then {(2*m///3)} else {})
        \-/(if 1 <= j < i then {(m///2)} else {})
        \-/(if j <= i-2 then {(2**(i-1)+2**j)} else {})
        \-/{2**i}
        ]
        ]]
    [次极大数集囗最小加法链(最少加法囗反函数囗下限(2**i;[i+1])) == \-/~ [({[j == i-3]?:(2*m///3), [1 <= j < i]?:(m///2), [j <= i-2]?:(2**(i-1)+2**j), 2**i}) | [j :<- [0..=i]] -> [m := 2**i+2**j]]]
    ]]
    [[证明:归纳法:
    * [i==0]:
        [最少加法囗反函数囗下限囗上限(2**i;i+1) \-\ 最少加法囗反函数囗下限囗上限(2**i;i)
        == 最少加法囗反函数囗下限囗上限(1;1) \-\ 最少加法囗反函数囗下限囗上限(1;0)
        == {1,2} \-\ {0}
        == {2}
        == {2**0+2**0}
        == {2**i+2**j | [j :<- [0..=i]]}
        ]
    * [i>=1][@[_i <- [0..<i]] -> [最少加法囗反函数囗下限(2**i_;[i_+1]) == ({2**i_+2**j | [j :<- [0..=i_]]})]]:
        !![@[i>=0] -> @[j>=0] -> [次极大数集囗最小加法链(最少加法囗反函数囗下限囗上限(2**(i+1);j+1)) |<=| 最少加法囗反函数囗下限囗上限(2**i;j)]]
        [次极大数集囗最小加法链(最少加法囗反函数囗下限囗上限(2**i;i+1)) |<=| 最少加法囗反函数囗下限囗上限(2**(i-1);i) == ({2**(i-1)} \-/ {2**(i-1)+2**j | [j :<- [0..=(i-1)]]})] #归纳法
        [m :<- 最少加法囗反函数囗下限囗上限(2**i;i+1)][ls :<- 最小加法链集(m)]:
            !!最少加法囗反函数囗下限囗上限 定义
            [m <- [2**i..]][最少加法(m) <= i+1]
            [m >= 2**i >= 2**1 == 2]
            [最少加法(m) >= 1]
            [len(ls) == 1+最少加法(m) >= 2]
            [ls[-1] == m]
            [n := ls[-2]] #m某链 的 次极大数
            [n <- ({2**(i-1)} \-/ {2**(i-1)+2**j | [j :<- [0..=(i-1)]]})]
            !![@[m>=2] -> [min(次极大数集囗最小加法链({m})) >= m/2]]
            [n >= m/2]
            [m <= 2*n]
            [[分支:
            * [n == 2**(i-1)]:
                [m <= 2*n == 2**i]
                !![m >= 2**i]
                [m == 2**i]
                [m == n+n] #ok
                [ls[:-1] <- 最小加法链集(n)]
                [最少加法(n) == i-1]
                [最少加法(m) == 1+最少加法(n) == i]

            * [j :<- [0..<=(i-1)]][n == 2**(i-1)+2**j]:
                [n+n > 2**i] #m存在
                !!归纳法
                [最少加法(n) == i]
                [len(ls[:-1]) >= 1+最少加法(n) == i+1]
                [len(ls) >= i+2]
                [最少加法(m) == len(ls) -1 >= i+1]
                !![最少加法(m) <= i+1]
                [最少加法(m) == i+1]
                [len(ls) == i+2]
                !![最少加法(2**i) == i]
                [m =!= 2**i]
                !![m >= 2**i]
                [m > 2**i]

                [len(ls[:-1]) == 最少加法(m) == i+1 == 1+最少加法(n)]
                [ls[:-1] <- 最小加法链集(n)]
                [最少加法(n) == i >= 1]
                [n >= 2]
                [len(ls) >= 3]
                [w := ls[-3]] #n某链 的 次极大数
                !![次极大数集囗最小加法链(最少加法囗反函数囗下限(2**i;[i+1])) == \-/~ [({[j == i-3]?:(2*m///3), [1 <= j < i]?:(m///2), [j <= i-2]?:(2**(i-1)+2**j), 2**i}) | [j :<- [0..=i]] -> [m := 2**i+2**j]]] #其实只是单个，替换{m:=n,i:=i-1}
                !!归纳法 递归:
                [w <- {[j == i-4]?:(2*n///3), [1 <= j < i-1]?:(n///2), [j <= i-3]?:(2**(i-2)+2**j), 2**(i-1)}]

                * [j == (i-1)]:
                    [n == 2**i]
                    [w <- {2**(i-1)}]
                    !![@[k>=0] -> [[最少加法(2**k) == k][最小加法链集(2**k) == {[2**i | [i :<- [0..=k]]]}]]]
                    !![ls[:-1] <- 最小加法链集(n)]
                    [ls[:-1] == [2**k | [k :<- [0..=i]]]]
                    [m <- {2**i+2**k | [k :<- [0..=i]]}] #ok#非平凡
                        #含 (n+n)

                * [j < (i-1)]:
                    !![n == 2**(i-1)+2**j]
                    [2**(i-1) < n < 2**i]
                    !![w <- {[j == i-4]?:(2*n///3), [1 <= j < i-1]?:(n///2), [j <= i-3]?:(2**(i-2)+2**j), 2**(i-1)}]
                    !![j < (i-1)]
                    * [j==i-4][w==(2*n///3)]:
                        [n==9*2**j]
                        [n+w==n*(1+2/3)==15*2**j < 16*2**j == 2**(j+4) == 2**i]
                        [m == n+n == 18*2**j > 2**i] #ok
                    * [1 <= j < i-1][w==(n///2)]:
                        [n+w == n*(1+1/2) == n*3/2]
                        [n+w < 2**i]:
                            <==> [n < 2**(i+1)*1/3]
                            !![1/3 == 0b0.01_01_01_...]
                            !![n == 2**(i-1)+2**j]
                            <==> [j <= i-3]
                        [[j > i-3] <==> [n+w >= 2**i]]
                        !![1 <= j < i-1]
                        [[j == i-2 >= 1] <==> [n+w >= 2**i]]
                        * [1 <= j <= i-3]
                            [m == n+n > 2**i] #ok
                        * [j==i-2][i>=3]:
                            !![len(ls) == i+2]
                            [len(ls) == i+2 >= 5]
                            [u := ls[-4]]
                            [最少加法(u) <= len(ls[:-3])-1 == len(ls) -3 -1 == i-2]
                            [u <= 2**(i-2)]
                            [n+u <= 2**(i-1) +2**j +2**(i-2) == 2**i]
                            !![m > 2**i]
                            [m <- {n+n, n+w}]
                            [n+w == n+n/2 == 2**(i-1) +2**j +2**(i-2) +2**(j-1) == 2**(i-1) +2**(i-2) +2**(i-2) +2**(i-3) == 2**i +2**(i-3)]
                            [m <- {2**i+2**(i-1), 2**i +2**(i-3)}] #ok#非平凡

                    * [j <= i-3][w==(2**(i-2)+2**j)]:
                        [n+w == 2**(i-1) +2**j +2**(i-2) +2**j == 2**(i-1) +2**(i-2) +2**(j+1) <= 2**(i-1) +2**(i-2) +2**(i-3 +1) <= 2**i]
                        !![m > 2**i]
                        [m == n+n] #ok
                    * [w==2**(i-1)]:
                        [n+w == 2**(i-1) +2**j +2**(i-1) == 2**i +2**j > 2**i]
                        [m <- {n+n, n+w}]
                        [m <- {2**i+2**(j+1), 2**i+2**j}] #ok#非平凡
            ]]分支
            ===
            [[分支摘要:非平凡的m #除了[m==n+n]
            * [j :<- [0..<=(i-1)]][n == 2**(i-1)+2**j]:
                [w := ls[-3]] #n某链 的 次极大数
                * [j == (i-1)]:
                    [m <- {2**i+2**k | [k :<- [0..=i]]}] #ok#非平凡
                        #按比特位拆分
                * [j==i-2][i>=3]:
                    [m <- {2**i+2**(i-1), 2**i +2**(i-3)}] #ok#非平凡
                        #[m==(n///2)*3] #[9==3*3]
                * [w==2**(i-1)]:
                    [m <- {2**i+2**(j+1), 2**i+2**j}] #ok#非平凡
                        #『加法交换律』:[m==(w+2**j)+w==(w+w)+2**j]
            ]]分支摘要

        证毕！
    ]]
[@[i,j,k::int] -> [i>j>k>=0] -> [最少加法(2**i+2**j+2**k) == i+2]]
    [[证明:
    !![@[i>=0] -> [最少加法囗反函数囗下限囗上限(2**i;i+1) == {2**i} \-/ {2**i+2**j | [j :<- [0..=i]]}]]
    !![@[N>=0] -> @[m>=1] -> @[n >= m] -> [not$ [n <- 最少加法囗反函数囗下限囗上限(m;N)]] -> [最少加法(n) >= N+1]]
        # 替换{N:=i+1, m:=2**i, n:=(2**i+2**j+2**k)}
    [最少加法(2**i+2**j+2**k) >= i+2]

    !![@[m>=1] -> [floor_log2(m) <= 最少加法(m) <= floor_log2(m) + bin(m).count('1')-1]]
        # 替换{m:=(2**i+2**j+2**k)}
    [最少加法(2**i+2**j+2**k) <= i+3-1 == i+2]
    !![最少加法(2**i+2**j+2**k) >= i+2]
    [最少加法(2**i+2**j+2**k) == i+2]
    ]]
[not$ [@[i,j,s,t::int] -> [i>j>s>t>=0] -> [最少加法(2**i+2**j+2**s+2**t) == i+3]]]
    [[证明:
    [最少加法(15)==5]
        # (5, 15, 4, [(1, 2, 3, 5, 10, 15), (1, 2, 3, 6, 9, 15), (1, 2, 3, 6, 12, 15), (1, 2, 4, 5, 10, 15)])
        # [15==2**3+2**2+2**1+2**0]
    ]]

[@[m>=1] -> [num_1bits_of_m := bin(m).count('1')] -> [floor_log2(m) + min(3,num_1bits_of_m)-1 <= 最少加法(m) <= floor_log2(m) + num_1bits_of_m-1]]
    # 增强: [@[m>=1] -> [floor_log2(m) <= 最少加法(m) <= floor_log2(m) + bin(m).count('1')-1]]

[[尝试寻找反例:最小加法链囗偶数猜想:
    #通过程序搜索下载的数据，已发现反例，见上面
    [[bug:一个错误的反例:[{(171,2*171), (2*171, 3*171+171)}两者中有一反例]
        原来以为(4*171==3*171+171)，但此拆分并不合理，[not$ [171 <- 最小加法链集(3*171)]]
    ]]bug:一个错误的反例
    [[
    [2%3==-1]
    [k :: uint]:
        [2**(2*k+1)%3==-1]
        [(2**(2*k+1)+1)%3==0]
        [0b1_00_00_..._00_1///3 == 0b0_01_01_..._01_1]
        !![@[m>=1] -> [num_1bits_of_m := bin(m).count('1')] -> [floor_log2(m) + min(3,num_1bits_of_m)-1 <= 最少加法(m) <= floor_log2(m) + num_1bits_of_m-1]]
        * [k>=1]:
            [最少加法((2**(2*k+1)+1)///3) >= (2*k-1) +min(3,k+1)-1 == (2*k-1) +min(2,k)]
            * [k==1]:
                [最少加法((2**(2*k+1)+1)///3) == (2*k-1) +min(2,k) == 2*k-1 +k == 3*k-1 == 2]
            * [k>=2]:
                [最少加法((2**(2*k+1)+1)///3) == (2*k-1) +min(2,k) == 2*k-1 +2 == 2*k+1]
        * [k==0]:
            [最少加法((2**(2*k+1)+1)///3) == 最少加法(1) == 0 >= -1 == (2*k-1) +min(2,k)]
        [最少加法((2**(2*k+1)+1)///3) >= [k==0]0 +[k==1]2 +[k>=2](2*k+1)]
        #(2**i+2**j)型:
        [最少加法(2**(2*k+1)+1) == 2*k+2]
        # 没用！下限估值太小:[下限估值(最少加法((2**(2*k+1)+1)///3)) <= 2*k+1 < 2*k+2]
        [k==4]:
            [最少加法(171) == 最少加法((2**(2*k+1)+1)///3) >= (2*k+1) == 9]
                #检验:[最少加法(171) == 10]
                # [最少加法(513) == 最少加法(2**9+1) == 10 == 2*k+2]
    ]]
]]


]]]]]推导定理

TODO:
e script/min_add_ver3.py
  等价归类:
    割点:乘法拆分:乘法交换律
    出度为1的点可省略:加法交换律
    混合？比如:m*n+1
      #不算: (a*b)*c+(a*b)==(a*b)*(c+1)
      局部串并联两端分割
  等价归类后的加法链表达:
    ???


#]]]'''



]]]]]]]

=========20220923:
[[[[[[[ver3:
view script/min_add_ver3.py
等价类...
]]]]]]]



[[[[[[[ @20220925:www_download_pdf
shortest addition chain program source code
  view script/min_add_ver2.py
  view script/min_add_ver3.py
view /sdcard/0my_files/book/math/addition_chains/[additionchains.com]st.cpp

[[
https://math.paperswithcode.com/paper/on-the-shortest-addition-chain-of-numbers-of
  https://arxiv.org/pdf/2108.07720v5.pdf
  On the shortest addition chain of numbers of special forms
  wget 'https://arxiv.org/pdf/2108.07720v5.pdf' -O 'On the shortest addition chain of numbers of special forms(2021)(T. AGAMA).pdf'
  wget 无法下载?
  [[
  [最少加法(2**n-1) <= O(1.5*n) = O(1.5*floor_log2(2**n-1))]
  这结果还不如：
    [最少加法(m) <= O(1.33*floor_log2(m))]
    [最少加法(m) <= O(1.46*floor_log2(m))]
      <<==
        https://oeis.org/A003313
        [最少加法(n) <= floor_log2(n)*4//3 +2]
        [最少加法(n) <= floor_log_(71;n**9)]
  ]]

http://wwwhomes.uni-bielefeld.de/achim/addition_chain.html
  非常多信息、数据
http://additionchains.com/
  也不错
  http://additionchains.com/st.cpp
  ===
  https://www.sciencedirect.com/science/article/pii/S0012365X20303861
    https://www.sciencedirect.com/science/article/pii/S0012365X20303861/pdfft?md5=1ced526251333e825a447351cea41581&pid=1-s2.0-S0012365X20303861-main.pdf
    wget 'https://www.sciencedirect.com/science/article/pii/S0012365X20303861/pdfft?md5=1ced526251333e825a447351cea41581&pid=1-s2.0-S0012365X20303861-main.pdf' -O 'Addition chains, vector chains, and efficient computation(2021)(Edward G.Thurber).pdf'
    wget -U 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0'       'https://www.sciencedirect.com/science/article/pii/S0012365X20303861/pdfft?md5=1ced526251333e825a447351cea41581&pid=1-s2.0-S0012365X20303861-main.pdf' -O 'Addition chains, vector chains, and efficient computation(2021)(Edward G.Thurber).pdf'
    ===上面url有问题，浏览器只能下载80KB，次次如此，改为以下:
    https://www.researchgate.net/publication/347774866_Addition_chains_vector_chains_and_efficient_computation
      https://www.researchgate.net/publication/347774866_Addition_chains_vector_chains_and_efficient_computation/fulltext/5febd54645851553a004f79a/Addition-chains-vector-chains-and-efficient-computation.pdf
    [[
    修剪条件:改进了『Efficient generation of minimal length addition chains(Edward G. Thurber)(1999).pdf』
    [最少加法囗多输出(ls)==最少乘法囗可交换半群多变量单项式(es)]
      # 含有ls中所有元素的加链的最小长度 == 生成(II xs[i]**es[i] {i})所需要的最少乘法步骤(可将es视作 向量，泛化 加链 定义，以len(es)个 单位轴向量 开头)

    ]]

  ===
  Altman H (2014), "Internal Structure of Addition Chains: Well-Ordering", arXiv preprint arXiv:1409.1627.
    Internal Structure of Addition Chains--Well-Ordering(2014)(Altman).pdf
    https://www.arxiv-vanity.com/papers/1409.1627/
    https://ui.adsabs.harvard.edu/abs/2014arXiv1409.1627A/abstract#:~:text=Internal%20Structure%20of%20Addition%20Chains%3A%20Well-Ordering%20Altman%2C%20Harry,is%20called%20the%20length%20of%20the%20addition%20chain.
        https://ui.adsabs.harvard.edu/link_gateway/2014arXiv1409.1627A/EPRINT_PDF
    [[
    [@[n>=1] -> ?[K >= 0] -> @[k>=K] -> [最少加法(2**k*n)-k == 最少加法(2**K*n)-K]]
    ]]
  ===
  Clift NM (2011), "Calculating Optimal Addition Chains", Computing. New York, NY, USA, March, 2011. Vol. 91(3), pp. 265-284. Springer-Verlag New York, Inc..
    Calculating Optimal Addition Chains(2011)(Clift).pdf
    https://link.springer.com/content/pdf/10.1007%2Fs00607-010-0118-8.pdf
    or?:https://www.semanticscholar.org/paper/Calculating-optimal-addition-chains-Clift/85362d764afc4853442c0634bcbe7511254ef953
    [[
    单点计算 稍次，强在 范围计算: [@[L,U,s::uint] -> 约束[@目标n <- [L,U]][num_small_steps(n) =[def]= 最少加法(n)-floor_log2(n)][num_small_steps(n) <= 指定最大值s]]
      单点搜索 必然 搜索到 其他n，即 不完全的有效加链前缀 大量重复(单点搜索不同目标n时)
    [?[n>=1] -> [最少加法(2*n) < 最少加法(n)]]
      [[n==191] -> [最少加法(2*n) == 最少加法(n)]]
      [[n==30958077] -> [最少加法(4*n) == 最少加法(2*n) == 最少加法(n)]]
      [[n==375494703] -> [34 == 最少加法(2*n) < 最少加法(n) == 35]]
      [[n <- [1..<5784689]] -> [最少加法(2**n-1) <= 最少加法(n)+n-1]]
      [[n <- [1..=64]] -> [最少加法(2**n-1) == 最少加法(n)+n-1]]
    [(1,2,3,4,7)是7的一条 最短加链，其中4=2+2=1+3，即 其实是 具象加法表达式的某种等价类]
    [移除 出度为一 的 点，得到 简化图] # 跟我的想法一样！
    [简化图 反转有向边指向 得到 对偶图 也是 同一个数 的 加链]
    我的盲点:
      [@讫点 -> [len{起点 | [重复度<起点,讫点> >= 2]} <= 1]]

    ]]
  ===
  Bergeron F, Berstel J, Brlek S and Duboc C (1989), "Addition chains using continued fractions", Journal of Algorithms. Vol. 10(3), pp. 403-412. Elsevier.
    Addition chains using continued fractions(1989)(Bergeron).pdf
    http://www-igm.univ-mlv.fr/~berstel/Articles/1989AdditionChainDuboc.pdf
    泛化:x**a --> x**a*y**b
      加链 泛化: [pint]/从零开始 --> [(uint, uint)]/从负一开始
        [1;...,a] --> [(0,1),(1,0); .., (a,b)]
      有理数a/b的 连分数(有限)
      fst(泛化版加链<连分数拼接>) == 很短加链<a>

  ===
  Walter CD (1998), "Exponentiation using division chains", IEEE Transactions on Computers. Vol. 47(7), pp. 757-765. IEEE.
      Addition-subtraction–chain exponentiation If both multiplication and division are allowed, then an addition-subtraction chain may be used to obtain even fewer total multiplications+divisions (where subtraction corresponds to division). However, the slowness of division compared to multiplication makes this technique unattractive in general.
      加减链 可用于 椭圆曲线加密

  ===
  Bahig HM and Bahig HM (2011), "A new strategy for generating shortest addition sequences", Computing. Vol. 91(3), pp. 285-306. Springer.
    An addition sequence problem is given a set of numbers X = {n 1, n 2, . . . , n m }, what is the minimal number of additions needed to compute all m numbers starting from 1? This problem is NP-complete. In this paper, we present a branch and bound algorithm to generate an addition sequence with a minimal number of elements for a set X by using a new strategy. Then we improve the generation by generalizing some results on addition chains (m = 1) to addition sequences and finding what we will call a presumed upper bound for each n j , 1 ≤ j ≤ m, in the search tree.
    泛化 最少加法-->最少加法囗多输出

  ===
  Fu-guo D and Yu-rong L (2008), "A novel shortest addition chains algorithm based on Euclid algorithm", Proceeding of WiCom (2008 4th International Conference on Wireless Communications, Networking and Mobile Computing). , pp. 4757-4761.
    This paper studies shortest addition chains algorithm of modular exponentiation, modifies the expression of modular exponentiation according to Euclid algorithm, transform the process of solving the shortest addition chains of a large integer into solving that of three much smaller integers, then greatly saves the time and space of the process, and ensures that the length of new shortest addition chains is as short as that of classical algorithm. Algorithm analysis and a lot of experiment results show that the new algorithm based on Euclid algorithm is more efficient than traditional algorithm of shortest addition chains.
      x**e%M
      pow(x,e,M)并不一定要 先求(x**e)
        我猜:
          找出合适的(d,fs), 使得[(e+phi_M*d)==II(fs)]
          找出合适的fs, 使得[e%phi_M==II(fs)%phi_M]
          找出合适的(a,b,c), 使得[gcd(a*b,phi_M)==1][e*inv_mod_(phi_M;a*b)%phi_M==c]

  ===
  Bergeron F, Berstel J and Brlek S (1989), "A unifying approach to the generation of addition chains", In Proc. XV Latin American Conf. on Informatics, Santiago, Chile July. , pp. 10-14.
    xxx 搜到别的:
    https://www.researchgate.net/publication/266286413_Efficient_computation_of_addition_chains
      https://www.researchgate.net/profile/Francois-Bergeron-4/publication/266286413_Efficient_computation_of_addition_chains/links/56a5681c08aef91c8c14f57b/Efficient-computation-of-addition-chains.pdf
      Efficient-computation-of-addition-chains(1994)(Bergeron).pdf
      [[
      非最短加链
      使用 连分数展开，见上面『Addition chains using continued fractions(1989)(Bergeron).pdf』
        其实是 见上面:最少乘法囗可交换半群多变量单项式 的 双变量情形，二维向量版加链
      ]]

  ===
  Bernstein DJ (2006), "Differential addition chains", URL: http://cr.yp.to/ecdh/diffchain-20060219.pdf
    Differential addition chains(2006)(Bernstein).pdf
    [[
    非标准版加链:
      要求:[(P-Q) in [...,Q,...,P,...,P+Q,...]]
    ]]
  ===
  ===
TODO:下载:[[
  ===
  Altman HJ (2014), "Integer complexity, addition chains, and well-ordering". Thesis at: University of Michigan.
  Mani K and Viswambari M (2017), "A New Method of Generating Optimal Addition Chain Based on Graph", International Journal of Mathematical Sciences and Computing. Vol. 3(2), pp. 37-54.

  Knuth DE and Papadimitriou CH (1981), "Duality in addition chains", Bulletin of the European Association for Theoretical Computer Science. Vol. 13, pp. 2-4.
  Flammenkamp DBA (1997), "An Efficient Algorithm for Computing Shortest Addition Chains"



  ===
  Koziel B, Azarderakhsh R, Jao D and Mozaffari-Kermani M (2016), "On Fast Calculation of Addition Chains for Isogeny-Based Cryptography"
  Park CS, Lee M-K and Kim DK (2005), "New computation paradigm for modular exponentiation using a graph model", In International Symposium on Stochastic Algorithms. , pp. 170-179.
  Bahig HM (2006), "Improved generation of minimal addition chains", Computing. Vol. 78(2), pp. 161-172. Springer.
  Mani MK (2013), "Generation of Addition Chain using Deterministic Division Based Method", International Journal of Computer Science & Engineering Technology. Vol. 1(4), pp. 553-560.
  Bahig HM and Nakamula K (2003), "erratum to Some properties of nonstar steps in addition chains and new cases where the Scholz conjecture is true [J. algorithms 42 (2002) 304-316]", Journal of Algorithms. Vol. 47(1), pp. 60-61. Academic Press, Inc..
  De Rooij P (1994), "Efficient exponentiation using precomputation and vector addition chains", In Workshop on the Theory and Application of of Cryptographic Techniques. , pp. 389-399.
  Kim DK and Lee M-K (2006), "A COMPUTATION MODEL FOR MODULAR EXPONENTIATION USING GRAPH REPRESENTATION", MITA 2006. , pp. 487-490.
  Knuth DE (1969), "Calculations on Addition Chains"
  Adamu Muhammad Noma Mohamad Afendee Mohamed AM and Zulkarnain ZA (2016), "An Initial Solution for Addition Chain Optimization Problem", Journal of Engineering and Applied Sciences. (11), pp. 640-643.
  Fuguo D, Pingqin W and Lei F (2011), "Addition Chains Algorithm Based on Fast Fourier Transform", JDCTA: International Journal of Digital Content Technology and its Applications. Vol. 5(2), pp. 149-157.
]]
验证『最短加链长度』上限很简单:给出 加链就行
  但如何验证其下限而避免在此搜索最短2

https://koasas.kaist.ac.kr/bitstream/10203/447/1/102.Finding%20Shorter%20AdditionSubtraction-Chains.pdf
  允许减法
  未下载

https://www.researchgate.net/publication/274478803_An_Efficient_Algorithm_for_Finding_Optimal_Addition_Chains
  https://www.researchgate.net/publication/274478803_An_Efficient_Algorithm_for_Finding_Optimal_Addition_Chains/fulltext/57a3df2308aefe6167a93b8c/An-Efficient-Algorithm-for-Finding-Optimal-Addition-Chains.pdf
  wget 'https://www.researchgate.net/publication/274478803_An_Efficient_Algorithm_for_Finding_Optimal_Addition_Chains/fulltext/57a3df2308aefe6167a93b8c/An-Efficient-Algorithm-for-Finding-Optimal-Addition-Chains.pdf' -O 'An-Efficient-Algorithm-for-Finding-Optimal-Addition-Chains(2013)(Daxin Zhu,Xiaodong Wang).pdf'
  缺少字体:ArialNarrow
  [[
  ===卧槽！发现是抄袭自『'Efficient generation of minimal length addition chains(Edward G. Thurber)(1999).pdf'』
  渐深迭代-深度优先-大数优先-提前修剪-回溯算法
    def 修剪条件((e,odd):=目标n==2**e*odd,a:=当前加链前缀最后项ls[-1],L:=len(ls)-1,d:=min(最大允许深度,已发现的最短加链长度))=:
      assert 1 <= a < n
      if a*2**(d-L) < n:
        #剩下的部分加链全部翻倍
        return bad
      #if d-L >= e+2:
      if d-(L+1) > e:
          #论文里:
          # ls = [..., a; b, 余下不可能全翻倍...][:L]
          #     b过后的部分 超过e个，不可能全部翻倍:!![not$ [2**(d-L) \\\ n]]
          # ls = [..., a, 极限2*a, 不翻倍3*a, 余下全翻倍...][:L]
          x = (3*a)*2**(d-L-2)

      if 0:
        [[还不如 原论文！
        if d-L+[a%2==0] > e and d-L >= 1:
          #我:
          #剩下的部分加链不可能全部翻倍:!![not$ [2**(d-L+[a%2==0]) \\\ n]]
          # ls = [..., a-1, a, 不翻倍(2*a-1), 余下全翻倍, ...][:L]
          x = (2*a-1)*2**(d-L-1)
          #or:
        if d-L+[a%2==0] > e and d-L >= 2:
          if L == 1:
            assert a==1
            assert n >= 2
            #assert d-L >= e+1-[a%2==0] == e+1 >= 1
            # ==>>上面 if补充:『and d-L >= 2:』
            x = (3*a)*2**(d-L-2)
          else:
            x = (max(3*a,2*(a+ls[-1])))*2**(d-L-2)
        ]]
      if x < n:
        return bad
      return ok
  ]]

https://thesai.org/Downloads/Volume11No12/Paper_58-An_Evolutionary_Algorithm_for_Short_Addition_Chains.pdf
  wget 'https://thesai.org/Downloads/Volume11No12/Paper_58-An_Evolutionary_Algorithm_for_Short_Addition_Chains.pdf' -O 'An Evolutionary Algorithm for Short Addition Chains(2020)(Hazem M. Bahig).pdf'
  次优解-非确定性-遗传算法

https://oeis.org/A003313
  Edward G. Thurber, Efficient generation of minimal length addition chains, SIAM J. Comput. 28 (1999), 1247-1263.
    https://epubs.siam.org/doi/10.1137/S0097539795295663
      https://epubs.siam.org/doi/epdf/10.1137/S0097539795295663
      wget 'https://epubs.siam.org/doi/epdf/10.1137/S0097539795295663' -O 'Efficient generation of minimal length addition chains(1999)(Edward G. Thurber).pdf'
      无法下载
    改用:
      http://wwwhomes.uni-bielefeld.de/achim/siam_thurber.pdf
      wget 'http://wwwhomes.uni-bielefeld.de/achim/siam_thurber.pdf' -O 'Efficient generation of minimal length addition chains(Edward G. Thurber)(1999).pdf'
    good!!!建立 修剪条件，但已有 改进版:『Addition chains, vector chains, and efficient computation(2021)(Edward G.Thurber).pdf』
    未证明:[最少加法(n) >= (floor_log2(n)+ceil_log2(count_num_1bits_of_uint(n)))]
      但:已证明:++前提[[n <=327678]or[count_num_1bits_of_uint(n)<=16]]
        [2**18 < 0b1001111111111111110 == (5*2**15-1)*2 == 327678 < 2**19]
    已证明:[最少加法(n) >= ceil(log2(n)+log2(count_num_1bits_of_uint(n)) -2.13)]
      [最少加法(n)
      >= ceil(log2(n)+log2(count_num_1bits_of_uint(n)) -2.13)
      == ceil_log2(n*count_num_1bits_of_uint(n)/2**2.13)
      >= ceil_log2(n*count_num_1bits_of_uint(n)*10**15//ceil(10**15*2**2.13))
      >= ceil_log2(n*count_num_1bits_of_uint(n)*10**15//4377174805042959)
      >= ceil_log2(n*count_num_1bits_of_uint(n)*10**15//4377174805042959)
      ]
      [4377174805042958 < (10**15*(2**2.13)) < 4377174805042959]
      [Decimal('2')**Decimal('-2.12316463') > Decimal('0.229542845299186') == 229542845299186/10**15]
        #真的吗？毕竟是 带精度限制的浮点数计算，如何检验真实性？
        #
      [最少加法(n)
      >= ceil(log2(n)+log2(count_num_1bits_of_uint(n)) -2.12316463)
      == ceil_log2(n*count_num_1bits_of_uint(n)*2**-2.12316463)
      >= ceil_log2(n*count_num_1bits_of_uint(n)*229542845299186//10**15)
      ]
    [[
    http://wwwhomes.uni-bielefeld.de/achim/addition_chain.html
    ===
    ℓ(n) >= λ(n)+log2(v(n))
    This famous lower bound was formulated first a bit differently by Stolarsky 1969 (p. 680, Lemma 10) [5] and nearly proved 1974 by Schönhage who showed that ℓ(n) >= log2(n)+log2(v(n))-2.123164629... holds for each n [7]. Thurber showed 1973 that it holds for all n with v(n) <= 16. In October 2008 Clift confirmed the conjecture for all n <= 2^64 and in September 2019 he confirmed it for all n with ℓ(n) - λ(n) <= 5.
    ]]
    [[
    >>> q
    4377174805042958
    >>> q**100 < 2**213*10**1500 < (q+1)**100
    True

    [2.123164629 < e < 2.123164630]
    ce8 = 212316463
from seed.math.floor_ceil import floor_log2, floor_log_, ceil_log2, floor_kth_root_, ceil_kth_root_
    ]]
[ceil(10**k*pow(2**(ceil(e*10**8)), 1/10**8))
== ceil(10**k*pow(2**ce8, 1/10**8))
== ceil(pow((10**k)**(10**8)*2**ce8, 1/10**8))
== ceil(pow(10**(k*10**8)*2**ce8, 1/10**8))
== ceil_kth_root_(10**8, 10**(k*10**8)*2**ce8)
== ceil_kth_root_(10**8, (10**(k*10**8)) << ce8)
  * [k==10]:
    == ceil_kth_root_(10**8, (10**(10**9)) << ce8)
      #太慢！
]
>>> Decimal('2')**Decimal('-2.12316463')
Decimal('0.2295428452991860082601533507')
>>> Decimal('0.229542845299186')*10**15
Decimal('229542845299186.0000000000000')
>>>

[Decimal('2')**Decimal('-2.12316463') > Decimal('0.229542845299186') == 229542845299186/10**15]

]]
[[
!mkdir /sdcard/0my_files/book/math/addition_chains/
e /sdcard/0my_files/book/math/addition_chains/[additionchains.com]st.cpp
view /sdcard/0my_files/book/math/addition_chains/[additionchains.com]st.cpp
.../txt_phone/txt $ cd ~/my_home/book/math/addition_chains/
~/.../math/addition_chains $ ls
'Addition chains, vector chains, and efficient computation(2021)(Edward G.Thurber).pdf'
'An Evolutionary Algorithm for Short Addition Chains(2020)(Hazem M. Bahig).pdf'
'An-Efficient-Algorithm-for-Finding-Optimal-Addition-Chains(2013)(Daxin Zhu,Xiaodong Wang).pdf'
'Efficient generation of minimal length addition chains(1999)(Edward G. Thurber).pdf'
'On the shortest addition chain of numbers of special forms(2021)(T. AGAMA).pdf'
'[additionchains.com]st.cpp'

ls  ~/my_home/book/math/addition_chains/
'Addition chains using continued fractions(1989)(Bergeron).pdf'
'Addition chains, vector chains, and efficient computation(2021)(Edward G.Thurber).pdf'
'An Evolutionary Algorithm for Short Addition Chains(2020)(Hazem M. Bahig).pdf'
'An-Efficient-Algorithm-for-Finding-Optimal-Addition-Chains(2013)(Daxin Zhu,Xiaodong Wang).pdf'
'Calculating Optimal Addition Chains(2011)(Clift).pdf'
'Differential addition chains(2006)(Bernstein).pdf'
'Efficient generation of minimal length addition chains(1999)(Edward G. Thurber).pdf'
'Efficient-computation-of-addition-chains(1994)(Bergeron).pdf'
'Internal Structure of Addition Chains--Well-Ordering(2014)(Altman).pdf'
'On the shortest addition chain of numbers of special forms(2021)(T. AGAMA).pdf'
'[additionchains.com]st.cpp'


]]

[[[
http://wwwhomes.uni-bielefeld.de/achim/addition_chain.html
===
Shortest Addition Chains
Introduction
A finite sequence of positive integers a0, a1, ..., ar is called an addition chain iff for each element ai, but the first a0 which equals 1, there exist elements in the sequence with smaller indices j and k such that ai = aj + ak [1].
Preciser this is called an addition chain of length r for its last number ar. It can be interpreted like calculating n = ar starting from 1 by addition of only previous calculated numbers. Let us restrict the definition a bit more: addition chains should be strictly monotonic increasing. This can be achieved by reordering and dropping multiple numbers. As a consequence a1=2 and a2=3 or 4 always (as long as r > 1). Now ask for the minimal length of an addition chain for a given number n and call this value ℓ(n). If we demand that j or k equals i-1 for all positive indices i -- each ai in the chain requires the previous ai-1, we call such a chain a star-chain and denote its minimal length by ℓ*(n) [2]. All addition chains for a given number n which have minimal length are called shortest addition chains (for its last/largest number).
I highly recommand Knuth's survey in section 4.6.3, "Evaluation of Powers", of The Art of Computer Programming, Volume 2: Seminumerical Algorithmus (3. edition appeared 1997, 2nd. ed. 1981, 1st ed. 1968) [6]. To illustrate shortest addition chains for each n < 149 one may track the path from the root 1 to the corresponding node n in the following tree:
Addition Chain Tree
Such a tree can't be extended gapless to larger n because in the triple 43, 77, 149 any two numbers exclude the third for a shortest addition chain representation in a common tree.
Lower and Upper Bounds of ℓ(n)
Write n in its binary representation and denote by v(n) the number of ones in this representation and by λ(n) the binary logarithm of n rounded to the next integer down in the case it is not already integer (floor-function). Then it is obvious through construction of an addition chain according by the russian multiplication, that ℓ(n) <= λ(n) + v(n) - 1. An open conjecture states a lower limit of λ(n) + log2(v(n)).
Notation
Notice: The definitions of v(n) and λ(n) are given in the previous paragraph.
s(n)
the number of small steps of n defined as the difference of the length of its shortest addition chain and the binary logarithm (rounded down).
s(n) = ℓ(n)-λ(n)
Doubling step
ai = ai-1 + ai-1
Star step
ai = ai-1 + aj with j < i
Small step
λ(ai) = λ(ai-1)
Standard step
ai = aj + ak with i > j > k
L(r)
the set of numbers which have a shortest addition chain of length r
L(r) = { i: ℓ(i)=r }
d(r)
the number of numbers which have a shortest addition chain of length r
d(r) = | L(r) |
c(r)
the smallest number which has a shortest addition chain of length r
c(r) = min L(r)
2r
the largest number which has an addition chain of length r
2^r = max L(r) holds trivally
m(r)
the median of numbers which have a shortest addition chain of length r
m(r) = med L(r)
μ(r)
the arithmetric average of numbers which have a shortest addition chain of length r
μ(r) = 1/d(r) ∑i ∈ L(r) i
g(r)
the geometric average of numbers which have a shortest addition chain of length r
g(r) = exp( 1/d(r) ∑i ∈ L(r) ln i )
p(r)
the "most probable" number which has a shortest addition chain of length r
p(r) = j: fr(j) = maxh fr(h) with fr(i) = ∑k ∈ N |{ j ∈ L(r): |i-j|=k }|/4k = ∑j ∈ L(r) 4-|i-j|
The base 4 of the power in the preceeding formula can be replaced by every C >= 2, but if C < 2 a different value for p(r) could be achieved.
Moreover for all i and for all C > 1 holds fr(i) < (C+1)/(C-1) . Furthermore p(r) equals the median of a maximal subset of L(r) which is convex, compact or connected, i.e. it is an interval. For the values r <= 43 but r ∈ {8,12,17,37,41,...} this maximal interval is unique. Of cource in the case the number of elements of the interval is even, p(r) may be the upper-median or the lower-median.
σ(r)
the standard deviation of the numbers which have a shortest addition chain of length r
σ2(r) = 1/d(r) ∑i ∈ L(r) i2 - μ(r)2
Table of Characterizing Values
r	c(r)	s(c(r))	v(c(r))	μ(r)	g(r)	m(r)	p(r)	σ(r)	d(r)	L(r)
0	1	0	1	1.0	1.0	1=	1	0	1	{1}
1	2	0	1	2.0	2.0	2=	2	0	1	{2}
2	3	1	2	3.5	3.5	3+	3+	0.5	2	{3,4}
3	5	1	2	6.3	6.2	6=	6	1.2	3	{5,6,8}
4	7	2	3	10.8	10.4	10=	10	3.1	5	{7,9,10,12,16}
5	11	2	3	18.2	17.3	17=	14	6.1	9	{11,13,14,15,17,18,20,24,32}
6	19	2	3	31.7	30.1	28=	26	11.4	15	L(6)
7	29	3	4	54.5	51.3	49+	43	21.3	26	L(7)
8	47	3	5	94.6	88.5	84+	84	39.0	44	L(8)
9	71	3	4	162.4	151.0	147+	116	70.5	78	L(9)
10	127	4	7	283.1	262.8	248+	230	125.6	136	L(10)
11	191	4	7	491.5	456.1	435+	455	220.8	246	L(11)
12	379	4	7	869.8	809.4	781+	840	387.5	432	L(12)
13	607	4	7	1535.4	1429.4	1372+	1136	682.3	772
14	1087	4	7	2725.8	2540.0	2461+	2028	1201.5	1382
15	1903	5	9	4855.4	4527.9	4379=	4047	2122.4	2481
16	3583	5	11	8672.1	8097.2	7813+	6832	3748.3	4490
17	6271	5	9	15571.7	14570.0	14101+	12048	6611.3	8170
18	11231	5	11	28094.6	26343.0	25641+	24096	11694.2	14866
19	18287	5	10	50861.7	47784.4	46466+	48156	20748.0	27128
20	34303	5	11	92379.2	86937.2	84764+	89120	36960.6	49544
21	65131	6	12	168192.7	158468.7	154745=	146480	66224.1	90371
22	110591	6	15	306531.6	289025.3	282128+	290858	119165.8	165432
23	196591	6	16	559476.7	527913.7	514285=	520240	215048.9	303475
24	357887	6	15	1023051.3	966288.1	942710=	1155126	388500.7	558275
25	685951	6	15	1874869.1	1772876.3	1732716+	2310196	702737.4	1028508
26	1176431	6	14	3443135.0	3259501.8	3191985+	2801503	1273563.8	1896704
27	2211837	6	16	6333417.2	6001516.0	5881151=	5612462	2313684.8	3501029
28	4169527	7	17	11667084.1	11064752.4	10848521+	9412704	4214352.7	6465774
29	7624319	7	15	21516285.2	20418193.4	20044424+	16905070	7697737.3	11947258
30	14143037	7	16	39714338.9	37704137.9	37013874=	41615456	14098404.4	22087489
31	25450463	7	15	73345796.7	69658962.3	68327129+	83230816	25868797.8	40886910
32	46444543	7	18	135563778.8	128804664.5	126581547+	132022368	47516034.6	75763102
33	89209343	7	18	250780403.5	238406628.4	234114742=	284950635	87306215.8	140588339
34	155691199	7	16	464437430.4	441801858.5	434295820+	397507456	160480246.5	261070184
35	298695487	7	19	861008497.7	819556624.5	806226455+	680509066	295231414.7	485074788
36	550040063	7	17	1597540092.7	1521468390.3	1497772642+	1511488768	543803958.6	901751654
37	994660991	8	18	2966374165.4	2826488080.1	2781892623+	2662728064	1002951179.8	1677060520
38	1886023151	8	19	5511624121.5	5253825354.5	5175290925=	6428295372	1852301542.4	3119775195
39	3502562143	8	18	10246077258.4	9769781638.2	9633929370+	12856590540	3426060760.9	5804404206
40	6490123999	8	21	19053169915.2	18171553433.7	17903170643=	25713180876	6344960374.9	10804952217
41	11889505663	8	21	35442346436.6	33810106974.4	33316133124=	38569771212	11759089688.4	20125814259
42	22899028607	8	21	65956820829.5	62937464797.8	62028411677=	72336015580	21797397230.2	37516452013
43	41866170239	8	25	122812323492.8	117232789580.2	115622740174+	115963068688	40405080341.5	69977286336
44	76086635263	8	25	228823269079.3	218514610966.6	215644577418=	203573817010	74910180542.4	130579657981
45	142771387391	8	26	426582178033.3	407515529011.2	402185339149=		138964158415.7	243724383149
46	257661019487	9	26						
47	498691112447	9	25						

In the median column the sign = means the value is unique and the character + indicates it lies between the given index and the next index with this r-value because d(r) is even.
With bold font in the previous c(r)-column the sequence of smallest numbers ni is high-lighted which need at least i= s(c(r)) small steps in their addition chain: 1,3,7,29,127,1903,65131,4169527,994660991,257661019487,....
Moreover here are the graphs of c(r) and d(r) together with an approximation function plotted. The two graphs of the quotient of c(r) and d(r) with a 1st order asymptotic approximation function and with a 2nd order approximation function. Finally the distribution of the number of shortest addition chains with fixed small step number and fixed λ(n).
Generally Solved Small Step Cases
0-small-step case
Trivial
For each n >= 0 there is exactly 1 0-small-step number in the half-open interval [2^n,2^(n+1)[ .
list of all 0-small-step numbers:
2^n
shortest chains for 0-small-step numbers:
   0(     )  1 
   1( 0, D)  @(A)

Here @(A)  means 2^A  with A a free nonnegative integer variable
1-small-step case
<= 1894 solved
count of all 1-small-step numbers
list of all 1-small-step numbers
shortest chains for 1-small-step numbers
2-small-step case
<= 1957 solved
count of all 2-small-step numbers
list of all 2-small-step numbers
shortest chains for 2-small-step numbers
3-small-step case
1991 solved
count of all 3-small-step numbers
list of all 3-small-step numbers
shortest chains for 3-small-step numbers
History: What was calculated When and by Whom
ℓ(i) with i <= 50 or v(i) <=4 , and d(r) with r <=6
calculated March 1957 by W. Hansen [3]
ℓ(i) with i <= 210 and d(r) with r <=11
reported December 1963 by D. E. Knuth
ℓ(i) with i < 2000 and d(r) with r <= 12
reported October 1968 by D. E. Knuth
ℓ(i) with i < 18269 and d(r) with r <= 15 and c(r) with r <= 18
reported May 1969 by D. E. Knuth [6]
ℓ(i) with i < 120000 and c(r) with r <= 22
computed until August 1988 by Achim
ℓ(i) with i < 217 and d(r) with r <= 20
computed April 1991 by Achim
ℓ(i) with i < 218 and d(21) and c(23)
computed until October 1991 by Achim
ℓ(i) with i <= 500000 and c(24)
computed until November 1995 by D. Bleichensbacher
ℓ(i) with i <= 720000 including c(25)
computed until end of March 1997 by Achim.
ℓ(i) with i <= 222 including c(28) and d(r) with r <= 25
computed until August 1997 by Achim.
ℓ(i) with i <= 222 and d(25) and d(26)
computed until August 2004 by Neill Clift
ℓ(i) with i <= 223 and d(27) and c(29) and c(30)
computed until September 2004 by Neill Clift
ℓ(i) with i <= 224
computed until December 2004 by Neill Clift
c(31)
computed December 2005 by Neill Clift
ℓ(i) with i <= 225
computed until April 2006 by Neill Clift
d(29), d(30) and c(32)
computed until June 2007 by Neill Clift
ℓ(229-1) = 29 + ℓ(29) - 1
proved in December 2007 by Neill Clift
ℓ(i) with i <= 226
computed until May 2008 by Neill Clift
d(31), d(32) and c(33)
computed until May 2008 by Neill Clift
ℓ(i) with i <= 227 and ℓ(i) with i <= 228 and ℓ(i) with i <= 229
computed in May 2008 by Neill Clift
d(33), c(34) and c(35)
computed in May 2008 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1, with n ∈ {31,33,...,46,48,49,50,51,52,54,56,60}
proved in May 2008 by Neill Clift
c(36), d(34) and d(35)
computed June 2008 by Neill Clift
c(37) and ℓ(i) with i <= 230
computed until July 2008 by Neill Clift
d(36)
computed in July 2008 by Neill Clift
c(38)
computed in July 2008 by Neill Clift
ℓ(i) with i <= 231
computed until August 2008 by Neill Clift
d(37)
computed in August 2008 by Neill Clift
c(39)
computed in September 2008 by Neill Clift
ℓ(i) with i <= 232
computed until October 2008 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1 with n ∈ {64,47}
proved in October 2008 by Neill Clift
d(36), d(37) and d(38)
computed in November 2008 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1 with n ∈ {53,55}
proved in November 2008 by Neill Clift
(2n-1) = n + ℓ(n) - 1 with n ∈ {57}
proved in December 2008 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1 with n ∈ {58,59}
proved in January 2009 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1 with n ∈ {61}
proved in February 2009 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1 with n ∈ {62,63}
proved until May 2009 by Neill Clift
c(40)
computed in September 2009 by Neill Clift
ℓ(i) with i <= 233
computed until October 2009 by Neill Clift
c(41)
computed in November 2009 by Neill Clift
ℓ(i) with i <= 234
computed until December 2009 by Neill Clift
c(42)
computed in May 2016 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1 with n ∈ {65,66,68,72,80,96}
proved in May 2016 by Neill Clift
ℓ(i) with i <= 235
computed until May 2016 by Neill Clift
d(39)
computed in May 2016 by Neill Clift
d(40)
computed in May 2016 by Neill Clift
c(43)
computed in September 2016 by Neill Clift
ℓ(i) with i <= 236
computed until October 2016 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1, if ℓ(n) <= 8
computed in July 2018 by Neill Clift
d(41)
computed in July 2019 by Neill Clift
c(44)
computed in July 2019 by Neill Clift
ℓ(i) with i <= 237
computed until July 2019 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1, with n <= 134 and ℓ(n)=9
computed in July 2019 by Neill Clift
ℓ(2n-1) = n + ℓ(n) - 1, if ℓ(n) <= 9
computed in September 2019 by Neill Clift
s(n) = ℓ(n) - λ(n) >= log2(v(n)), if s(n) <= 5
computed in September 2019 by Neill Clift
c(45)
computed in November 2019 by Neill Clift
c(46)
computed in February 2020 by Neill Clift
d(42)
computed in March 2020 by Neill Clift
ℓ(i) with i <= 238
computed until March 2020 by Neill Clift
d(43)
computed in March 2020 by Neill Clift
d(44)
computed in April 2020 by Neill Clift
 c(47)
computed in January 2021 by Neill Clift
 ℓ(i) with i <= 239
computed until September 2022 by Neill Clift
 d(45)
computed in September 2022 by Neill Clift
In July 2004 the data calculated 1997 by Flammenkamp was completely and independently checked. Hereby Neill Clift uncovered four ℓ(n)-errors, which he attributed to a typo in Flammenkamp's program effecting only n-values > 2500000.
On 30th May 2008, Neill Clift discovered the first and smallest n such that ℓ(n) > ℓ(2n).
Data Access
Thanks to Neill Clift's computations you can download the lengths of all shortest additions chains for n up to n=231 as bziped2 binary data of 210 MB size. The uncompressed values are coded as ℓ(n)-λ(n)-ceil(log2(v(n))) into 2 bits each which the exception of ℓ(2135101487) #. To decipher this you can download ddt.c compile it and run it as ddt inputfile linelength. You will get all values starting from 1 and broken into lines each containing linelength values onto your stdout from the base-36 alphabet (0,1,2,..,9,a,b,c,..,z) or as a 1 or 2 digit decimal value. A second helper l.c outputs ℓ(n), λ(n), s(n) and v(n) for each given input n which data is in the datafile.
You can also download all ℓ(n) with n <= 233 as bziped2 binary data of 820 MB size. Here datafile indicates the downloaded and then uncompressed data file. To display these you must also download ddt4l.c, compile it and run it as ddt4l datafile [first n [total number [linelength] ] ]. You will get all or total number-many values starting from 1 or first n and broken into lines each containing linelength values onto your stdout from the base-42 alphabet (0,1,2,..,9,a,b,c,..,z,A,B,C,..,F).
Now you can download all ℓ(n) with n <= 2expo as bziped2 binary data. Choose expo depending on your disk storage capabilities of your computer system from the following table:
max n	binary data file	compressed size	uncompressed size	online since
232	add32.4ln.bz2	417 MB	1073742360 bytes	?
233	add33.4ln.bz2	820 MB	2147484256 bytes	?
234	add34.4ln.bz2	1612 MB	4294967964 bytes	?
235	add35.4ln.bz2	3197 MB	8589935360 bytes	May 2016
236	add36.4ln.bz2	6397 MB	17179869992 bytes	Oct 2016
237	add37.4ln.bz2	12863 MB	34359739200 bytes	Jul 2019
238	add38.4ln.bz2	25854 MB	68719477576 bytes	Mar 2020
239	add39.4ln.bz2	51662 MB	137438954328 bytes	Sep 2022
To display the ℓ(n)-values you must also download ddt4ln.c, compile it and run it as ddt4ln datafile [-O?] [first n [total number [linelength] ] ]. Here datafile indicates the downloaded and then uncompressed data file. You will get all or total number-many values starting from 1 or first n and broken into lines (or pages) each containing linelength values onto your stdout. This ? after the -O controls the output format and must take values ∈ {0,1,2,3,4}. The default is 0 and means no output, but data integrity check only. Thus in generally you will need this output-option. The options -O1 and -O2 are the old formats known from ddt and ddt4l.The parameter -O4 produces a format very similar to this of the above old helper-program l.
In the case you need fast (and also random) access to ℓ(n) values it is very announing to have to calculate v(n) and λ(n) for each n. Thus here is a C-source-code to generate from add3?.4ln a new file containing either a table of s(n) values each represented by a half-byte (bits 0-3 of a byte hold the value for odd n and bits 4-7 of a byte hold it for even n) or a table of ℓ(n) values each represented by 1 byte. Of cource the new file will be of doubled size in the first case and of 4-times the size in the last case.
Look up in the database of the first 231 many ℓ(n) values
starting from index 
1
 the following 
1
 values
 Table  Raw  

The effort to compute these values up to n=220 is here visible. The number of cases checked to get ℓ(n) is plotted in red against λ(n) for each number 28 <= n < 220. In blue the number of cases are marked to compute n=c(r) and finally in dark green the average number of cases is drawn which is needed to calculate ℓ(n) for all numbers from 1 up to n (the last gives a good estimate of the average run time of the algorithm).
Generate a Shortest Addition Chain for any given number < 227

n=
1
  fast  difficult 
# The smallest n such that ℓ(n)-λ(n)-ceil(log2(v(n))) equals 0,1,2,3,4,... are 1, 29, 3691, 919627, 2135101487, ... .
A remark for the simple upper bound λ(n)-v(n)+1 of ℓ(n): The smallest n such that ℓ(n)-λ(n)+1=v(n) equals 1,2,3,4,5,... are 1, 3, 7, 29, 465, 24745, 12591273, 51544066569, ... .
For every n with ℓ(n) <=22 the number of shortest addition chains as a gziped ASCII-file of 1.8 MB size, as a sorted by n list which consists of three columns. In each row of this list are given the values for the corresponding n, ℓ(n) and number of shortest addition chains for this n. Neill Clift extended this data and put it into a file of almost 250 MB size. Thus you can download the number of shortest addition chains with ℓ(n) <=28 as a gziped ASCII-file of 74 MB.

Conjectures
ℓ(2^n-1) <= n + ℓ(n) - 1
The outstanding Scholz-Brauer-Conjecture of 1937. If ℓ(n) is achievable by a star chain then it holds. Therefore only values of n need to be considered with ℓ(n) < ℓ*(n). But the smallest of these numbers is 12509. In August 2005 Clift reported to have confirmed the Scholz-Brauer inequality for all n < 5784689. +
ℓ(2^n-1) = n + ℓ(n) - 1
This narrow related equation is proved to hold at least for all n with ℓ(n) <= 9  *.
ℓ(n) >= λ(n)+log2(v(n))
This famous lower bound was formulated first a bit differently by Stolarsky 1969 (p. 680, Lemma 10) [5] and nearly proved 1974 by Schönhage who showed that ℓ(n) >= log2(n)+log2(v(n))-2.123164629... holds for each n [7]. Thurber showed 1973 that it holds for all n with v(n) <= 16. In October 2008 Clift confirmed the conjecture for all n <= 2^64 and in September 2019 he confirmed it for all n with ℓ(n) - λ(n) <= 5.
log2(c(r)) ~ r - r/log2r
That is the 1997 stated conjecture by Flammenkamp for the asymptotic growth of c(r) outdating the 1991 given assertation that log2(c(r)) ~ r - 2log2r.
Computing ℓ(n) for given n is NP-hard.
Downey, Leony and Sethi didn't prove anything about this statement in their 1981 SIAM article. They proved a similar one, if a set of numbers is given! Many people (and even experts) overlooked this important difference! In 2002 E. Lehmann noted in his Ph.D. thesis, p 35: "Nevertheless, an exact solution to the addition chain problem remains strangely elusive. The M-ary method runs in time polylog(n) and gives a 1 + o(1) approximation. However, even if exponentially more time is allowed, poly(n), no exact algorithm is known."
d(r) <= d(r+1) <= 2d(r)
Already 1981 D. Knuth stated "there is no evident way to prove that d(r) is an increasing function in r".
+This number 5784689 = 222+97*214+65*24+97 is the smallest Non-Hansen number identified by Neill Clift in 2005 as such.
*In August 2005 Neill Clift reported to have proved equality without any further assumption for all n <= 28 and n = 30. Furthermore in December 2007 he showed equality without any further assumption even for n = 29. Moreover until May 2009 he proved it for all n <= 64 and in May 2016 for n ∈ {65,66,68,72,80,96}. Lastly in July 2018 he proved the equality with a new ground-breaking algorithm to hold for all n with ℓ(n) <= 8. He extended this equality in July 2019 to those n <= 134 with ℓ(n) = 9 and finally in September 2019 to all n with ℓ(n) = 9.
Unsorted stuff
An equivalent definition of addition chains based only on the set-theoretic definition of natural numbers: additive complexity
K. Stolarsky uses infinite addition chains in his 1969 appeared paper. Here are some basic remarks about minimal infinite addition chains.
Is there a hiden connection between finite topologic spaces and addition chains? Look here.
Moreover, here is a link to the world's leading expert web-site to find shortest addition chains quickly and thus calculating these values ℓ(n) really fast covering all the "smaller" natural numbers n -- state of the art: March 2020.
References
Arnold Scholz
"Aufgabe 253",
Jahresbericht der deutschen Mathematiker-Vereinigung V. 47, 2. Abteil.
1937 pp 41-42.
Alfred T. Brauer
"On addition chains",
Bulletin of the American Mathematical Society V. 45(10)
1939 pp 736-739.
Walter Hansen
"Zum Scholz-Brauerschen Problem",
Journal für die reine und angewandte Mathematik, V. 202
1959 pp 129-136.
Pál Erdös
"Remarks on number theory. III: On addition chains",
Acta Arith. V. 6(1)
1960 pp 77-81.
Kenneth B. Stolarsky
"A lower bound for the Scholz-Brauer problem",
Canadian Journal of Mathematics, V. 21
1969 pp 675-683.
Donald E. Knuth
The Art of Computer Programming V. 2 Seminumerical Algorithms, 1st edition,
Addison-Wesly 1969 pp 398-422.
Arnold Schönhage
"A Lower Bound for the Length of Addition Chains",
Theoretical Computer Science, V. 1(1)
1975 pp 1-12.
Bibliography with more than 230 entries.
Achim Flammenkamp
Last update: 2022-09-13 21:33:29 UTC+1
# 补偿 half-open interval ]xx,xx]
]]]
[[[
http://additionchains.com/
===
Addition Chains
Definitions
Start with a list of numbers containing initially 1. Perform a number of steps where we add two (not necessarily different) existing numbers together and add the new number to the list. If we eventually arrive at the number n we call this an addition chain for n.

So, for example, we could create the following list 1,2,3,6,9,9,12,24,18 and call this an addition chain for n=18. We will call the individual values in an addition chain elements and n the target.

We should note some things about this addition chain for 18.

It contains values bigger than n like 24. We could remove these and still have a valid addition chain.
It is not ordered by element size. We could order it by size, and this would keep the chain valid if we have eliminated elements greater than the target.
It has duplicate elements
Some elements may be constructed in more than one way (18=9+9 or 12+6).
We will assume from now on that addition chains are ordered and duplicate or values exceeding the target are removed.

Formally then an addition chain is:

  with 

We say this addition chain has length . The chain with the shortest length we call the optimal chain. We denote it's length by . Many interesting questions arise when we consider optimal chains. Lots of stuff that might seem obvious is in fact wrong. For example, it seems reasonable to assume that each step in an addition chain uses the largest element created so far or that the best way to reach  is by doubling the last element of a chain for . Both of these assumptions turn out to be false.

We define:


 
    So, it's number of 1s in the binary representation of n.


For step  of an addition chain we have two possibilities:

 and we call this a large step
 and we call this a small step
We can see from this that  and  count the number of small and large steps respectively in an optimal addition chain for .

Additionally for step  we say that:

If   is called a doubling
If  is called a star step
We define  as the number of optimal addition chains for . 

The smallest target requiring  steps in its optimal chain .

The number of targets requiring exactly  steps in their optimal chains .

We will often want to remove the ambiguity of how an addition chain element is constructed. We do this by tracking how each element is formed. I will use a hash notation to show this. For example, in this non-optimal addition chain for 4

1 2 3 4

I will use:

1 2 3 4#1,1 to show the element 4 is made from 2+2 or:

1 2 3 4#0,2 to show the element 4 is made from 1+3.

Here the hash is followed by two zero base indices into the addition chain.

 and  Tables
c(r)/d(r)

Number Of Optimal Addition Chains
Finding NMC Values

Knuth-Stolarsky Conjecture
It seems remarkable that  appears to be bounded by the small step count of the chain:


This conjecture is normally stated differently:


Cases  can be determined with simple bounds. If  then  and with  then  is the best we can do bit count wise. Knuth outlines the case for  yielding  or four cases were   (for example ).

The three-bit case was proved in [8] and the four-bit case by Knuth himself. Ed Thurber in his PhD thesis [9] proved the  case. Achim Flammenkamp in his diploma thesis [10] wrote a computer program to enumerate all numbers reachable via 3 small steps and likewise found . I wrote a program to mimic the proof technique of Ed Thurber's thesis and verified the result but could not get it to work for the case .

Using the derivative chains of Hanson transformed to graphs and making heavy use of symmetry to reduce problem size I was able to enumerate all numbers reachable with 4 and 5 small steps.

So overall we know that  for . So, for example, any number with  must have .

If this conjecture is true, it has some interesting consequences. Let's consider the number  or in binary . We have  so we expect .

We can easily see though that  since if  we could take an addition chain for  and extend it to form :

1, 2, ..., 223696213, 447392426, 671088639

We have added only large steps but  so we expect  which is a contradiction. So, we must have .

Computer searches show  achieved with the following chain:

1, 2, 3, 5, 10, 13, 23, 46, 92, 105, 210, 420, 840, 1680, 3360, 6720, 6825, 13650, 27300, 54600, 109200, 218400, 436800, 873600, 1747200, 3494400, 6988800, 13977600, 27955200, 55910400, 111820800, 223641600, 223696200, 223696213

I outline enumeration of small step chains here:

Small Step Enumeration

Scholz-Brauer Conjecture
This conjecture asserts that:


I like the following alternate bound:


To see why we might think this conjecture is true let's look at an optimal chain for  in binary:

1 10 11 110 1100 1111 11110 111100 1111000 11110000 11111111

We construct the target using only doublings and small steps that have no carries (in red). So, the bit counts of the small step elements and 1 form an addition chain for 8:

1 2 4 8

Obviously, we could take a chain for some other n and try to generate an addition chain for  using this technique. This only works though if the addition chain for n has all-star steps. Such a chain is called a star chain or a Brauer chain.

Brauer in [1] outlined the procedure to convert a Brauer chain for n into a chain for . Hansen in [2,3] generalized this for chains with a bit more flexibility ( or Hansen chains). Knuth [4] describes the Hansen algorithm via underlined elements.

Let's see this with the smallest number that has no optimal star chains (12509):

Each step must use the largest underlined entry in the chain. The last entry is underlined unconditionally. So, you must choose to underline in a way that achieves this. There can be more than one way to do it.

1, 2, 4, 8, 16, 17, 32, 64, 128, 256, 512, 1024, 1041, 2082, 4164, 8328, 12492, 12509

The red elements are forced as the next step is a doubling. One element of the two consumed by a step must be underlined. Using the same element in a doubling, forces the issue.

The blue elements are underlined because a step that consumes it also uses an underlined element that is not the largest in the list so far.

The green elements are underlined because they are consumed by a step that uses another element before the largest underlined one.

We could choose to underline or not underline the orange element as we wish.

In code checking that a chain is  I could not manage to come up with a better method than recursively trying the underlining cases for each step pruning out the invalid ones. When I discovered the first non- (non-Hansen) number I did so with buggy detection code. I had somehow convinced myself I didn't need to backtrack ever in the underlining assignment. So, I had to run the search again to make sure I had found the first one.

The first non-Hansen number is 5784689 and its 16 optimal addition chains are:

1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 49169 81937 98322 180259 360518 721036 1442072 2884144 2900545 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 49169 81937 98322 180259 360518 721036 1442072 2884144 5768288 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 49169 81937 163874 180259 360518 721036 1442072 2884144 2900545 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 49169 81937 163874 180259 360518 721036 1442072 2884144 5768288 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 65536 81937 98322 180259 360518 721036 1442072 2884144 2900545 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 65536 81937 98322 180259 360518 721036 1442072 2884144 5768288 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 65536 81937 163874 180259 360518 721036 1442072 2884144 2900545 5784689
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 16385 16401 32768 65536 81937 163874 180259 360518 721036 1442072 2884144 5768288 5784689
1 2 4 8 16 32 64 65 97 128 225 353 706 1412 2824 5648 11296 22592 45184 90368 180736 180801 361537 723074 1446148 2892296 2892393 5784689
1 2 4 8 16 32 64 65 97 128 225 353 706 1412 2824 5648 11296 22592 45184 90368 180736 180801 361537 723074 1446148 2892296 5784592 5784689
1 2 4 8 16 32 64 65 97 128 225 353 706 1412 2824 5648 11296 22592 45184 90368 180736 361472 361537 723074 1446148 2892296 2892393 5784689
1 2 4 8 16 32 64 65 97 128 225 353 706 1412 2824 5648 11296 22592 45184 90368 180736 361472 361537 723074 1446148 2892296 5784592 5784689
1 2 4 8 16 32 64 65 97 128 256 353 706 1412 2824 5648 11296 22592 45184 90368 180736 180801 361537 723074 1446148 2892296 2892393 5784689
1 2 4 8 16 32 64 65 97 128 256 353 706 1412 2824 5648 11296 22592 45184 90368 180736 180801 361537 723074 1446148 2892296 5784592 5784689
1 2 4 8 16 32 64 65 97 128 256 353 706 1412 2824 5648 11296 22592 45184 90368 180736 361472 361537 723074 1446148 2892296 2892393 5784689
1 2 4 8 16 32 64 65 97 128 256 353 706 1412 2824 5648 11296 22592 45184 90368 180736 361472 361537 723074 1446148 2892296 5784592 5784689

We can see these are non-Hansen chains by noting that the red element must be underlined because it is doubled in the production of the green element. This forces the two elements between the red and green element to not be underlined. The blue element though uses the previous element (which cannot be underlined) and an element before the red element. So, it fails to use the largest underlined element.

So, from the first non-Hansen we know the Scholz-Brauer conjecture is true for all  (assuming no programming errors). The mechanics of creating an addition chain for  from an  chain for n is best seen graphically and for this we need derivative chains.

Derivative Chains
Hansen [3] introduced derivative chains in his PhD thesis. A derivative chain represents and infinite number of addition chains with similar structure. They represent the non-doubling steps only and allow you to represent all addition chains with the same non-doubling steps with different numbers and placement of doubling steps.

So, take a couple of addition chains. Make them formal addition chains by selecting how each element is constructed (sometime and element may be made in more than one way):

1 2 4 8 16 17 33 66 99

We marked in red those elements that are doubling steps. Now for each non-doubling step we follow the chain of doublings for what it consumes till we get to non-doubled elements and form the sum from that.

So, 17 = 16 + 1 => 1 + 1 = 2. We also adjust any other element that consumes the changes elements. So, 33 = 17 + 16 => 2 + 1 = 3. then we delete the doubled elements as nothing should be using them. Programmatically I find it easier to replace the doubled elements with the undoubled values and recompute all the sums:

1 2 4 8 16 17 33 66 99

1 1 1 1   1  2   3    3   6

Yielding after deletion a derivative of 1 2 3 6.

A larger case that has non-star steps:

1 2 4 5 7 8#4,0 15 23 28 51 58 109

1 1 1 2 3 4          7 11 13 24 27   51

Yielding after deletion a derivative of 1 2 3 4 7 11 13 24 27 51.

Here are all the chains for 99 with their derivatives in curly brackets: 
 {1 2 4}    1 2 3 6 12 24 48 96 99

 {1 2 4}    1 2 4 8 16 32 33 66 99

 {1 2 3 6} 1 2 4 8 16 17 33 66 99

 {1 2 4 6} 1 2 3 6 12 24 48 51 99

Derivative chains do not have to be monotonically increasing. Here this optimal addition chain for 11 has two derivatives depending on how we form 6 = 5 + 1 or 6 = 4 + 2 and one of the derivatives contains the value 2 twice. Note also that we need the derivatives to be formal and record how they are constructed. The last 4 in the first derivative is formed by the sum of the two different 2's:

 {1 2 2 4#2,1}  {1 2 3 5} 1 2 4 5 6 11

Derivatives may also have their values decrease as we can see in this optimal chain for 29:

{1 2 3 2 5} 1 2 4 8 9 13 16 29

If we take the values in a derivative chain and have those as vertices in a graph. We have directed edges representing the two elements consumed starting at the sum source vertices and ending at the vertices representing the sum.

Each vertex then represents a set of numbers that are powers of two of a base number. These are all the numbers that would have been removed when we created the derivative. Since all but the last element in a derivative chain have associated vertices that are the source of an edge, we can encode what element is selected in an edge label. So, if the base number is  then the vertex for b represents the values . An edge with the label  selects the value . So, if we have a derivative chain for  it has  directed paths from the vertex representing 1 to the vertex for . Each path has an edge sum that represents a single bit in a potential target the derivative can generate.

Here is an example derivative graph for an optimal chain for 99. The edge labels match the algorithm for generating an addition chain for  of Brauer.



There are 99 paths from vertex 1 to vertex 99. Each path has a distinct edge label sum from 0-98. So, you can think of the single bit in the value 1 traveling all these paths to generate the value . You get the doubling count for a vertex by taking the maximal edge count for edges leaving the vertex. You use the doubling count once you know the base value to generate the appropriate number of doublings. Edge numbers tell you what element to select from the list of doublings in the addition to form a new element.

The rules for the labeling for a Brauer chain are to take the two inputs for each vertex (apart from 1). For the largest vertex input edge give it a value equal to the difference between the input and output vertex. If the input edges come from the same source, you can choose either edge from the pair. All other edges get the value zero. Let's build the addition chain for  from this graph:

1 2 3 6 7 14 28 56 63 ... 4032 4095 ... 16773120 16777215 ... 281474959933440 281474976710655 ... 2251799813685240 2251799813685247 ... 633825300114114419273374892032 633825300114114700748351602687

It is easy to prove by induction that for the vertex representing the value  has a base value of . We must also prove that this chain has  doublings. It's easy to see this by summing the vertex doubling counts. There must be one critical path that passes through the maximal doubling of each vertex. The critical path must go through an edge with a label that is the largest for all the edges leaving a vertex. Its edge sum must be . It's this property that can fail if we try to label a non-Brauer chain in this way.

Let's take the following  chain:

1 2 4 8 9 12 17 29

If we create the graph and label it like we did a Brauer chain, we get the following:



We can see this graph has no critical path. The largest edge leaving 8 is 4 but no path going through this edge can capture the largest non-zero (and only edge) leaving 9. As a result, this addition chain has 1+2+4+4+8+0+12 = 31 doublings. For an addition chain for 229-1 using this derivative graph we need 28 doublings.

We can resolve this by changing the labeling rules to work with  chains. We label the edge to the largest underlined vertex with a label equal to the other edges vertex. If both edges, go to the same place, we can select between the two as we like. The other edge gets the label 0. This algorithm generates the following labeling:



This will generate an addition chain with 1+2+4+9+0+0+12 = 28 which is the correct number. We can see again that each vertex for v will have a base value of . The critical path will be a path through the underlined vertices.

The next thought then is if we can label a non-Hansen derivative graph in such a way that we generate all the path edge sums from 0 to  and have a critical path. The idea here is to try and find another labeling algorithm that would bridge the gap created by the non-Hansen number 5784689. Let's take the following non-Hansen chain:

1 2 4 8 9 13 16 29

With this chain the first 5 values are forced to be underlined. the construction of 16 though cannot satisfy the underlining requirement and we have a non-Hansen chain. Computationally labeling the edges of a graph to satisfy the requirements seems to be very expensive. So, we need to keep the total number of paths small. Here is one such labelling:



This critical path contains vertices 1 2 4 8 16 29 with edge labels of 1+2+4+8+13 =  28. This generates the following addition chain:

1 2 3 6 12 15 30 60 120 240 255 510 1020 2040 4080 8160 8161 8191 16320 32640 65280  65535 ... 536862720 536870911

The two numbers placed inside the purple run are for vertices 9 and 13. We no longer have the property that vertex v has a base value of . 

I spent quite a bit of time labeling larger and larger graphs getting the feeling you could always seem to do it unless the graph had some structures, I thought too strange to appear in optimal addition chains.

I made a smaller graph from the non-Hansen number by deleting some doubling steps. The idea being to try and keep some structure that might be important. I ended up with this graph:



It's not possible to label this graph under the constraints that all paths must have label sums that are unique from 0-108 and have a critical path. This floored me as I didn't expect this.

I was unable to come up with a way of proving this in a simple way.

So, I searched for numbers that have structures I can prove can't be labeled. I found the monster:

1 2 4 6 12 24 48 96 192 384 396 397 768 793 1536 3072 3865 7730 15460 30920 61840 123680 247360 494720 989440 1978880 3957760 3958553 7917106 15834212 31668424 63336848 126673696 253347392 506694784 1013389568 2026779136 4053558272 8107116544 16214233088 32428466176 32428466573

It's easy to prove the problematic red numbers can prevent the graph for this addition chain having a critical path. All the addition chains for this number appear to have a similar structure. This can be seen from the partial graph:



Here the parallel edges through vertices 384, 768, 1536, 3072 mean the critical path must go through those vertices. There are two paths from 396 to 793 so to prevent a single bit that follow these paths carrying we need one of the edges in this loop to be non-zero. That edge though can't be in a path with say the vertex for 1536. So, this graph can't be labeled.

What this means is that the derivative chains for the optimal addition chains for  can never be for the target 32428466573. So, it's harder to see a relationship between  and .

Calculating Optimal Addition Chains
These seem to come up with some regularity in programming competitions. The simplest thing you must do in any program is to add the Thurber bounds [6,7]. The basic idea is simple. For an addition chain you have an array of values that is the same length as the addition chain. Each value contains a lower bound for the element in that position. So, when you create a new entry, you reject it if it is below this bound. You build the bounds at the start of searching. These work very well and pretty much any algorithm I know for calculating addition chains can benefit from the bounds.

I decided to test if we could do better than the Thurber bounds with a computer program. It generated all possible end of a chain for a target value n. It then used glpk to solve a linear equation and some inequalities in  to determine a bound. After much head scratching it turns out we could generalize the Thurber bounds in a nice way that meant divisibility by  only affected single values in the bounds rather than the entire bounding sequence. Makes coding the bounds simpler.

For an addition chain of length  for  with  odd the bounds for step  are  given by:

 
 
 
 
 

For example, some bounds:

,  not divisible by any :

n/4097	n/2049	n/1025	n/513	n/257	n/129	n/65	n/33	n/17	n/9	n/5	n/3	n/2	n
1	1	1	2	4	8	16	31	59	111 	200	333	499	998
,  is divisible by 3,9:

n/4097	n/2049	n/1025	n/513	n/257	n/129	n/65	n/33	n/18	n/9	n/6	n/3	n/2	n
1	1	1	2	4	8	16	31	56	111 	167	333	500	999
,  is divisible by 2:

n/4098	n/2050	n/1026	n/514	n/258	n/130	n/66	n/34	n/18	n/10	n/6	n/4	n/2	n
1	1	1	2	4	8	16	30	56	100 	167	250	499	998
We derive the bounds here:

https://www.sciencedirect.com/science/article/pii/S0012365X20303861
Source Code
This is the current source code I use for generating ranges of l(n) values. This is pretty rough and needs a lot of work for general consumption.

st.cpp

Bibliography
I have tried to build a list of all publications on addition chains. This is not simple because it can be difficult to draw the line between a paper on addition chains and one that uses them.

I do not include addition-subtraction chains but do include addition sequences and vector addition chains as recent work shows they are tied together.

I have tried to obtain all of these publications and only have a few missing. I would welcome any additional references or access to the stuff I do not have. The articles in red I do not have copies of.

[1] Brauer A (1939), "On addition chains", Bulletin of the American Mathematical Society. Vol. 45(10), pp. 736-739.

[2] Hansen W (1957), "Untersuchungen über die Scholz-Brauerschen Additionsketten und deren Verallgemeinerung". Thesis at: Göttingen.

[3] Hansen W (1959), "Zum Scholz-Brauerschen Problem.", Journal für die reine und angewandte Mathematik. Vol. 202, pp. 129-136.

[4] Knuth DE (1969), "The art of computer programming, 2: seminumerical algorithms, Addison Wesley", Reading, MA. , pp. 98-422.

[5] Knuth DE (1998), "The art of computer programming, 2: seminumerical algorithms, Addison Wesley", Reading, MA. , pp. 461-485.

[6] Thurber EG (1999), "Efficient Generation of Minimal Length Addition Chains", SIAM Journal on Computing. Vol. 28(4), pp. 1247-1263.

[7] Thurber EG and Clift NM, "Addition chains, vector chains, and efficient computation", Discrete Mathematics, Volume 344, Issue 2, 2021,

[8] Gioia A, Subbarao M and Sugunama M (1962), "The Scholz-Brauer problem in addition chains", Duke Math. J. Vol. 29, pp. 481-487.

[9] Thurber, E. "The Scholz-Brauer Problem on Addition Chains", University of Southern California, University of Southern California, 1971.

[10] Flammenkamp A (1991), "Drei Beiträge zur diskreten Mathematik: Additionsketten, No-Three-in-Line-Problem, Sociable Numbers". Thesis at: Diplomarbeit an der Fakultät für Mathematik, Universität Bielefeld.

Kim DK and Lee M-K (2006), "A COMPUTATION MODEL FOR MODULAR EXPONENTIATION USING GRAPH REPRESENTATION", MITA 2006. , pp. 487-490.

Aiello W and Subbarao M (1993), "A conjecture in addition chains related to Scholz’s conjecture", mathematics of computation. Vol. 61(203), pp. 17-23.

Walter CD (2012), "A duality in space usage between left-to-right and right-to-left exponentiation", In Cryptographers’ Track at the RSA Conference. , pp. 84-97.

Bahig HM and AbdElbari KA (2018), "A fast GPU-based hybrid algorithm for addition chains", Cluster Computing., aug, 2018. Springer Nature America, Inc.

Rodriguez-Cristerna A and Torres-Jimenez J (2013), "A genetic algorithm for the problem of minimal brauer chains", In Recent Advances on Hybrid Intelligent Systems. , pp. 481-500. Springer.

Rodriguez-Cristerna A and Torres-Jimenez J (2013), "A genetic algorithm for the problem of minimal brauer chains for large exponents", In Soft Computing Applications in Optimization, Control, and Recognition. , pp. 27-51. Springer.

Vázquez-Fernández E, Cadena C and Reyes-Gómez DA (2016), "A genetic algorithm with a mutation mechanism based on a Gaussian and uniform distribution to minimize addition chains for small exponents", In Evolutionary Computation (CEC), 2016 IEEE Congress on. , pp. 935-940.

Osorio-Hernández LG, Mezura-Montes E, Cruz-Cortés N and Rodriguez-Henriquez F (2009), "A genetic algorithm with repair and local search mechanisms able to find minimal length addition chains for small exponents", In 2009 IEEE Congress on Evolutionary Computation. , pp. 1422-1429.

Mohamed MA, Said M and Rushdan M (2015), "A hybrid addition chain method for faster scalar multiplication", WSEAS Transactions on Communications. Vol. 14, pp. 144-152. World Scientific and Engineering Academy and Society.

Schönhage A (1975), "A lower bound for the length of addition chains", Theoretical Computer Science. Vol. 1(1), pp. 1-12. Elsevier.

Stolarsky KB (1969), "A lower bound for the Scholz-Brauer problem", Canad. J. Math. Vol. 21, pp. 675-683.

Cottrell A (1973), "A lower bound for the Scholz-Brauer problem. preliminary report", In Notices of the American Mathematical Society. Vol. 20(5), pp. A476.

Rodriguez-Cristerna A, Torres-Jiménez J, Rivera-Islas I, Hernandez-Morales CG, Romero-Monsivais H and Jose-Garcia A (2011), "A mutation-selection algorithm for the problem of minimum brauer chains", In Mexican International Conference on Artificial Intelligence. , pp. 107-118.

Mani K and Viswambari M (2017), "A New Method of Generating Optimal Addition Chain Based on Graph", International Journal of Mathematical Sciences and Computing. Vol. 3(2), pp. 37-54.

Bahig HM and Bahig HM (2011), "A new strategy for generating shortest addition sequences", Computing. Vol. 91(3), pp. 285-306. Springer.

Mignotte M and Tall A (2011), "A note on addition chains", International Journal of Algebra. Vol. 5(6), pp. 269-274.

Vegh E (1975), "A note on addition chains", Journal of Combinatorial Theory, Series A. Vol. 19(1), pp. 117-118. Elsevier.

Whyburn C (1965), "A note on addition chains", Proceedings of the American Mathematical Society. Vol. 16(5), pp. 1134.

Elia M and Neri F (1990), "A note on addition chains and some related conjectures", In Sequences. , pp. 166-181.

Utz W (1953), "A note on the Scholz-Brauer problem in addition chains", Proceedings of the American Mathematical Society. Vol. 4(3), pp. 462-463.

Avanzi RM (2004), "A note on the signed sliding window integer recoding and a left-to-right analogue", In International Workshop on Selected Areas in Cryptography. , pp. 130-143.

Goundar RR (2007), "A Novel Multi Exponentiation Method", International Journal of Applied Mathematics. Vol. 37(2) Citeseer.

Fu-guo D and Yu-rong L (2008), "A novel shortest addition chains algorithm based on Euclid algorithm", Proceeding of WiCom (2008 4th International Conference on Wireless Communications, Networking and Mobile Computing). , pp. 4757-4761.

Herbaut F and Véron P (2010), "A public key cryptosystem based upon euclidean addition chains", In International Conference on Sequences and Their Applications. , pp. 284-297.

Giese R (1972), "A Sequence of Counterexamples of Knuth's Modification of Utz's Conjecture", In NOTICES OF THE AMERICAN MATHEMATICAL SOCIETY. Vol. 19, pp. A688.

Jose-Garcia A, Romero-Monsivais H, Hernandez-Morales CG, Rodriguez-Cristerna A, Rivera-Islas I and Torres-Jimenez J (2011), "A simulated annealing algorithm for the problem of minimal addition chains", In Portuguese Conference on Artificial Intelligence. , pp. 311-325.

Tsai Y and Chin Y (1992), "A Study of Addition Chain", In Proceedings of the National Science Council - Part A: Physical Science and Engineering. Vol. 16(6), pp. 506-514.

Tsai Y and Chin Y (1987), "A study of some addition chain problems", International Journal of Computer Mathematics. Vol. 22(2), pp. 117-134. Taylor & Francis.

Tsai Y (1985), "A study on some addition chain problems". Thesis at: National Tsing-Hua University, Hsinchu, Taiwan.

Gordon DM (1998), "A survey of fast exponentiation methods", Journal of algorithms. Vol. 27(1), pp. 129-146. Elsevier.

Bergeron F, Berstel J and Brlek S (1989), "A unifying approach to the generation of addition chains", In Proc. XV Latin American Conf. on Informatics, Santiago, Chile July. , pp. 10-14.

Bos J and Coster M (1989), "Addition chain heuristics", In Conference on the Theory and Application of Cryptology. , pp. 400-407.

Dominguez-Isidro S, Mezura-Montes E and Osorio-Hernández LG (2011), "Addition chain length minimization with evolutionary programming", In Proceedings of the 13th annual conference companion on Genetic and evolutionary computation. , pp. 59-60.

Dobkin D and Lipton RJ (1980), "Addition chain methods for the evaluation of specific polynomials", SIAM Journal on Computing. Vol. 9(1), pp. 121-125. SIAM.

Dobkin D and Lipton RJ (1978), "Addition chain methods for the evaluation of specific polynomials", In Proceedings of a Conference on Theoretical Computer Science (Univ.Waterloo, Waterloo, Ont., 1977). , pp. 146–-148.

E VEGH (1975), "Addition chains", In Notices of the American Mathematical Society. Vol. 22(1), pp. A2-A3.

Fuguo D, Pingqin W and Lei F (2011), "Addition Chains Algorithm Based on Fast Fourier Transform", JDCTA: International Journal of Digital Content Technology and its Applications. Vol. 5(2), pp. 149-157.

Thurber EG (1976), "Addition chains and solutions of l(2n)=l(n) and l(2^n-1)=n + l(n) - 1", Discrete Mathematics. Vol. 16(3), pp. 279-289. Elsevier.

Knuth D (1964), "Addition chains and the evaluation of n-th powers", Notices Am Math Soc. Vol. 11, pp. 230-231.

Abrahams J (1999), "Addition Chains as Test Trees and a Sequential Variant as the Huffman Problem". Thesis at: The Center for Discrete Mathematics and Theoretical Computer Science (DIMACS). Citeseer.

Bleichenbacher D (1999), "Addition chains for large sets", Unpublished manuscript.

Southard TH (1974), "Addition Chains for the first n squares" Center for Numerical Analysis, University of Texas at Austin.

Southard TH (1974), "Addition chains for the first n triangular numbers" Center for Numerical Analysis, University of Texas at Austin.

Kohonen J and Corander J (2014), "Addition chains meet postage stamps: Reducing the number of multiplications", Journal of Integer Sequences. Vol. 17(2), pp. 3.

Bergeron F, Berstel J, Brlek S and Duboc C (1989), "Addition chains using continued fractions", Journal of Algorithms. Vol. 10(3), pp. 403-412. Elsevier.

Parker R and Plater A (2004), "Addition chains with a bounded number of registers", Information processing letters. Vol. 90(5), pp. 247-252. Elsevier.

Van-Der Kruijssen S (2007), "Addition Chains, efficient computing of powers", Bachelor Proyect.. Thesis at: Amsterdam. Vol. 1, pp. 13-50.

Thurber EG (1993), "Addition chains—an erratic sequence", Discrete mathematics. Vol. 122(1), pp. 287-305. Elsevier.

Subbarao M (1989), "Addition chains-some results and problems", Number theory and applications. , pp. 555-574. Kluwer Academic Publishers, Dordrecht.

Orb W (1987), "Additionsketten". Thesis at: Mainz University.

Gaal P (1971), "Additionsketten in einer endlich erzeugten abelschen Gruppe". Thesis at: Zurich.

Bellman R (1963), "Advanced problem 5125", Amer. Math. Monthly. Vol. 70, pp. 765.

Chin Y and Tsai Y (1985), "Algorithms for finding the shortest addition chain", In Proceedings of national computer symposium, Kaoshiung, Taiwan, December. , pp. 1398-1414.

Lou D-C and Chang C-C (1998), "An adaptive exponentiation method", Journal of Systems and Software. Vol. 42(1), pp. 59-69. Elsevier.

Wang X-d (2001), "An Algorithm for Generating the Shortest Addition Chains", MINIMICRO SYSTEMS-SHENYANG-. Vol. 22(10), pp. 1250-1253. GAI-KAN BIAJIBU.

Coster MJ and others (1993), "An algorithm on addition chains with restricted memory"

Gashkov SB and Sergeev IS (2006), "An application of the method of additive chains to inversion in finite fields", Discrete Mathematics and Applications dma. Vol. 16(6), pp. 601-618.

Cruz-Cortés N, Rodriguez-Henriquez F and Coello CAC (2008), "An artificial immune system heuristic for generating short addition chains", IEEE Transactions on Evolutionary Computation. Vol. 12(1), pp. 1-24. IEEE.

Flammenkamp DBA (1997), "An Efficient Algorithm for Computing Shortest Addition Chains"

Wang X (2013), "An Efficient Algorithm for Finding Optimal Addition Chains", Indonesian Journal of Electrical Engineering and Computer Science. Vol. 11(11), pp. 6447-6453.

Dominguez-Isidro S and Mezura-Montes E (2011), "An Evolutionary Programming Algorithm to Find Minimal Addition Chains", In I Congreso Internacional de Ingeniería Electrónica, Instrumentación y Computación, de Junio del, Minatitlán Veracruz, México.

van Leeuwen J (1977), "An extension of Hansen's theorem for star chains", J. Reine Angew. Math. Vol. 295, pp. 203-207.

Adamu Muhammad Noma Mohamad Afendee Mohamed AM and Zulkarnain ZA (2016), "An Initial Solution for Addition Chain Optimization Problem", Journal of Engineering and Applied Sciences. (11), pp. 640-643.

Koç CK (1995), "Analysis of sliding window techniques for exponentiation", Computers & Mathematics with Applications. Vol. 30(10), pp. 17-24. Elsevier.

Park H, Park K and Cho Y (1999), "Analysis of the variable length nonzero window method for exponentiation", Computers & Mathematics with applications. Vol. 37(7), pp. 21-29. Elsevier.

Nedjah N and de Macedo Mourelle L (2006), "Ant colony optimisation for fast modular exponentiation using the sliding window method", In Swarm Intelligent Systems. , pp. 133-147. Springer.

Arpe J and Manthey B (2006), "Approximability of minimum and-circuits", In Scandinavian Workshop on Algorithm Theory. , pp. 292-303.

Arpe J and Manthey B (2009), "Approximability of minimum AND-circuits", Algorithmica. Vol. 53(3), pp. 337-357. Springer.

Scholz A (1937), "Aufgabe 253 (Problem 253)", Jahresbericht der deutschen Mathematiker-Vereinigung. Vol. 47(2), pp. 41-42.

Otto M (2001), "Brauer addition--subtraction chains". Thesis at: Diplomarbeit, Universität--Gesamthochschule Paderborn.

Clift NM (2011), "Calculating Optimal Addition Chains", Computing. New York, NY, USA, March, 2011. Vol. 91(3), pp. 265-284. Springer-Verlag New York, Inc..

Knuth DE (1969), "Calculations on Addition Chains"

Brlek A, Castéran P and Strandh R (1991), "Chaînes d'additions et structures de contrôle", In Journées JFLA91 (Gresse-en-Vercors, France).

Dimitrov VS, Jullien GA and Miller WC (2000), "Complexity and fast algorithms for multiexponentiations", IEEE Transactions on Computers. Vol. 49(2), pp. 141-147. Citeseer.

Downey P, Leong B and Sethi R (1981), "Computing sequences with addition chains", SIAM Journal on Computing. Vol. 10(3), pp. 638-646. SIAM.

von Zur Gathen J and Nöcker M (2004), "Computing special powers in finite fields", Mathematics of computation. Vol. 73(247), pp. 1499-1523.

Demetriou CA (1967), "Concerning minimal addition chains". Thesis at: University of Mississippi.

Dempster AG and Macleod M (1994), "Constant integer multiplication using minimum adders", IEE Proceedings-Circuits, Devices and Systems. Vol. 141(5), pp. 407-413. IET.

Li Y and Ma Q (2010), "Design and Implementation of Layer Extended Shortest Addition Chains Database for Fast Modular Exponentiation in RSA", In Web Information Systems and Mining (WISM), 2010 International Conference on. Vol. 1, pp. 136-139.

Bernstein DJ (2006), "Differential addition chains", URL: http://cr. yp. to/ecdh/diffchain-20060219. pdf.

Knuth DE and Papadimitriou CH (1981), "Duality in addition chains", Bulletin of the European Association for Theoretical Computer Science. Vol. 13, pp. 2-4.

McCarthy DP (1986), "Effect of improved multiplication efficiency on exponentiation algorithms derived from addition chains", Mathematics of computation. Vol. 46(174), pp. 603-608.

Bleichenbacher D (1996), "Efficiency and security of cryptosystems based on number theory" Citeseer.

Wattel E and Jensen G (1968), "Efficient calculation of powers in a semigroup", Stichting Mathematisch Centrum. Zuivere Wiskunde. (ZW 1/68), pp. 1-18. Stichting Mathematisch Centrum.

Bergeron F, Berstel J and Brlek S (1994), "Efficient computation of addition chains", Journal de théorie des nombres de Bordeaux. Vol. 6(1), pp. 21-38.

De Rooij P (1994), "Efficient exponentiation using precomputation and vector addition chains", In Workshop on the Theory and Application of of Cryptographic Techniques. , pp. 389-399.

Nedjah N and de Macedo Mourelle L (2005), "Efficient pre-processing for large window-based modular exponentiation using ant colony", In International Conference on Knowledge-Based and Intelligent Information and Engineering Systems. , pp. 640-646.

Bahig HM and Nakamula K (2003), "erratum to Some properties of nonstar steps in addition chains and new cases where the Scholz conjecture is true [J. algorithms 42 (2002) 304-316]", Journal of Algorithms. Vol. 47(1), pp. 60-61. Academic Press, Inc..

Picek S, Coello CAC, Jakobovic D and Mentens N (2016), "Evolutionary Algorithms for Finding Short Addition Chains: Going the Distance", In European Conference on Evolutionary Computation in Combinatorial Optimization. , pp. 121-137.

Dominguez-Isidro S, Mezura-Montes E and Osorio-Hernández L-G (2015), "Evolutionary programming for the length minimization of addition chains", Engineering Applications of Artificial Intelligence. Vol. 37, pp. 125-134. Elsevier.

Yacobi Y (1990), "Exponentiating faster with addition chains", In Workshop on the Theory and Application of of Cryptographic Techniques. , pp. 222-229.

Walter CD (1998), "Exponentiation using division chains", IEEE Transactions on Computers. Vol. 47(7), pp. 757-765. IEEE.

Johansen MM (2009), "Exponentiation with addition chains".

I. Bocharova BK (1995), "Fast Exponentiation in cryptography", Lecture Notes in C. Vol. 948, pp. 146-157.

Lou D-C and Chang C-C (1996), "Fast exponentiation method obtained by folding the exponent in half", Electronics Letters. Vol. 32(11), pp. 984-985. IET.

Yacobi Y (1998), "Fast exponentiation using data compression", SIAM Journal on Computing. Vol. 28(2), pp. 700-703. SIAM.

Nedjah N and de Macedo Mourelle L (2004), "Finding minimal addition chains using ant colony", In International Conference on Intelligent Data Engineering and Automated Learning. , pp. 642-647.

León-Javier A, Cruz-Cortés N, Moreno-Armendáriz MA and Orantes-Jiménez S (2009), "Finding minimal addition chains with a particle swarm optimization algorithm", In Mexican International Conference on Artificial Intelligence. , pp. 680-691.

Cruz-Cortés N, Rodriguez-Henriquez F, Juárez-Morales R and Coello CAC (2005), "Finding optimal addition chains using a genetic algorithm approach", In International Conference on Computational and Information Science. , pp. 208-215.

Picek S, Coello CAC, Jakobovic D and Mentens N (2018), "Finding short and implementation-friendly addition chains with evolutionary algorithms", Journal of Heuristics., jun, 2018. Vol. 24, pp. 457-481. Springer Nature.

Mani MK (2013), "Generation of Addition Chain using Deterministic Division Based Method", International Journal of Computer Science & Engineering Technology. Vol. 1(4), pp. 553-560.

Gelgi F and Onus M (2006), "Heuristics for minimum brauer chain problem", In International Symposium on Computer and Information Sciences. , pp. 47-54.

Datta B and Singh A (1935), "History of Hindu Mathematics" Bombay , pp. 76.

Cohen G, Naccache D, Lobstein A and Zémor G (1998), "How to improve an exponentiation black-box", In International Conference on the Theory and Applications of Cryptographic Techniques. , pp. 211-220.

Bahig HM (2006), "Improved generation of minimal addition chains", Computing. Vol. 78(2), pp. 161-172. Springer.

Möller B (2002), "Improved techniques for fast exponentiation", In International Conference on Information Security and Cryptology. , pp. 298-312.

Kochergin V (2015), "Improvement of the estimates of the computational complexity for monomials and sets of powers in Bellman’s and Knuth’s problems", Journal of Applied and Industrial Mathematics. Vol. 9(1), pp. 68-82. Springer.

Kochergin VV and Kochergin DV (2017), "IMPROVEMENT OF THE LOWER BOUND FOR THE COMPLEXITY OF EXPONENTIATION", Prikladnaya diskretnaya matematika., dec, 2017. (38), pp. 119-132. Tomsk State University.

Altman HJ (2014), "Integer complexity, addition chains, and well-ordering". Thesis at: University of Michigan.

Abbas M and Gustafsson O (2012), "Integer Linear Programming Modeling of Addition Sequences With Additional Constraints for Evaluation of Power Terms"

Flammenkamp A (1999), "Integers with a small number of minimal addition chains", Discrete mathematics. Vol. 205(1), pp. 221-227. Elsevier.

Altman H (2014), "Internal Structure of Addition Chains: Well-Ordering", arXiv preprint arXiv:1409.1627.

Nedjah N and de Macedo Mourelle L (2002), "Minimal addition chain for efficient modular exponentiation using genetic algorithms", In International Conference on Industrial, Engineering and Other Applications of Applied Intelligent Systems. , pp. 88-98.

Zantema H (1991), "Minimizing sums of addition chains", Journal of Algorithms. Vol. 12(2), pp. 281-307. Elsevier.

Olguín-Carbajal, M., Herrera-Lozada, J. C., Rivera-Zárate, I., Serrano-Talamantes, J. F., Cadena-Martínez, R., & Vásquez-Gómez, J. I. (2018), "Minimum Addition Chains Generation Using Evolutionary Strategies", Computación y Sistemas. Vol. 22(4)

Tummeltshammer P, Hoe JC and Püschel M (2004), "Multiple constant multiplication by time-multiplexed mapping of addition chains", In Proceedings of the 41st annual Design Automation Conference. , pp. 826-829.

Park CS, Lee M-K and Kim DK (2005), "New computation paradigm for modular exponentiation using a graph model", In International Symposium on Stochastic Algorithms. , pp. 170-179.

Kunihiro N and Yamamoto H (2000), "New methods for generating short addition chains", IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences. Vol. 83(1), pp. 60-67. The Institute of Electronics, Information and Communication Engineers.

Ragnarsson K and Tenner BE (2010), "Obtainable sizes of topologies on finite sets", Journal of Combinatorial Theory, Series A. Vol. 117(2), pp. 138-151. Elsevier.

Bahig HM (2008), "On a generalization of addition chains: Addition--multiplication chains", Discrete Mathematics. Vol. 308(4), pp. 611-616. Elsevier.Tsai YH and Chin YH (1992), "On Addition Chains", International Journal of Computer Mathematics. Vol. 45(3-4), pp. 145-160.

Kato H (1970), "On Addition Chains". Thesis at: University of Southern California.

Sonntag R (1978), "On Addition Chains"

Thurber EG (1973), "On addition chains 1 (mn)leq 1 (n)-b and lower bounds for c (r) ", Duke Mathematical Journal. Vol. 40(4), pp. 907-913. Duke University Press.

Gashkov S and Kochergin V (1994), "On addition chains of vectors, gate circuits and the complexity of computations of powers", Syberian Advances in Mathematics. Vol. 4(4), pp. 1-16.

Brlek S, Castéran P and Strandh R (1991), "On addition schemes", In International Joint Conference on Theory and Practice of Software Development. , pp. 379-393.

Il'in A (1965), "On additive number chains", Problemy Kibernet. Vol. 13, pp. 245-248.

Gupta OK (1992), "On Evaluation of Powers", Journal of Information and Optimization Sciences. Vol. 13(2), pp. 331-336. Taylor & Francis.

Koziel B, Azarderakhsh R, Jao D and Mozaffari-Kermani M (2016), "On Fast Calculation of Addition Chains for Isogeny-Based Cryptography"

HAYATA T and WAGATUMA M (2006), "ON TERNARY ADDITION CHAINS"

Bahig H (1998), "On the algorithms of computational number theory and their applications". Thesis at: Master Thesis, Dept. of Math., Faculty of Science, Ain Shams University, Cairo, Egypt.

Kochergin VV (2005), "On the complexity of computation of a pair of monomials in two variables", Discrete Mathematics and Applications. Vol. 15(6), pp. 547. Springer.

Kochergin V (1996), "On the complexity of computation of monomials and tuples of powers", Siberian Advances in Mathematics. Vol. 6(1), pp. 71-86.

Kochergin V (1994), "On the computation of powers sets", Discrete Mathematics and Applications. Vol. 4(2), pp. 119-128.

Yao AC-C (1976), "On the evaluation of powers", SIAM Journal on computing. Vol. 5(1), pp. 100-103. SIAM.

Pippenger N (1980), "On the evaluation of powers and monomials", SIAM Journal on Computing. Vol. 9(2), pp. 230-250. SIAM.

Pippenger N (1976), "On the evaluation of powers and related problems", In Foundations of Computer Science, 1976., 17th Annual Symposium on. , pp. 258-263.

Abbas M (2012), "On the implementation of integer and non-integer sampling rate conversion". Thesis at: Linköping University. Linköping University Electronic Press.

Mohamed MA (2011), "On the Improvement of Addition Chain in Applications to Elliptic Curve Cryptosystem Status: Submitted". Thesis at: Universiti Putra Malaysia.

Val'skii R (1959), "On the Lower Bounds of Multiplications in Evaluation of Powers", Problemy Kibernet. Vol. 2, pp. 73-74.

Bahig HM (2006), "On the Number of Minimal Addition Chains.", In CSC. , pp. 202-208.

Olivos J (1981), "On Vectorial Addition Chains.", J. Algorithms. Vol. 2(1), pp. 13-21.

Brlek S, Castéran P, Habsieger L and Mallette R (1995), "On-line evaluation of powers using Euclid's algorithm", Informatique théorique et applications. Vol. 29(5), pp. 431-450.

Kunihiro N and Yamamoto H (1997), "Optimal addition chain classified by Hamming weight". Thesis at: IEICE Technical Report, ISEC96-74.

Aquino F and Leguizamón G (2017), "Optimization of addition chains", In Computer Science & Technology Series.

Kadir MFA, Mohamed MA, Mohamad R, Mamat M and Muhammed A (2018), "Performance Comparison of Some Addition Chain Methods Based on Integer Family", In Information Science and Applications 2018., jul, 2018. , pp. 211-218. Springer Singapore.

Bernstein DJ (2002), "Pippenger's exponentiation algorithm" Citeseer.

Henry R (2010), "Pippenger’s Multiproduct and Multiexponentiation Algorithms". Thesis at: Citeseer.

Bos JNE (1992), "Practical privacy". Thesis at: Eindhoven University of Technology. Citeseer.

Goulard A (1894), "Question 393", L'Intermédiaire des Mathématiciens. Vol. 1, pp. 234.

de Jonquiéres E (1894), "Question 393 (A. Goulard)", L'Intermédiaire des Mathématiciens. Vol. 2, pp. 125-126.

Dellac H (1894), "Question 49", L'Intermédiaire des Mathématiciens. Vol. 1, pp. 20.

de Jonquiéres E (1894), "Question 49 (H. Dellac)", L'Intermédiaire des Mathématiciens. Vol. 1, pp. 162-164.

Méloni N and Hasan MA (2016), "Random Digit Representation of Integers", In ARITH 23.

Herbaut F, Liardet P-Y, Méloni N, Teglia Y and Véron P (2010), "Random Euclidean addition chain generation and its application to point multiplication", In International Conference on Cryptology in India. , pp. 238-261.

Erdös P (1960), "Remarks on number theory III. On addition chains", Acta Arithmetica. Vol. 6(1), pp. 77-81. Institute of Mathematics Polish Academy of Sciences.

Elias Y (2011), "Représentation d'un polynôme par un circuit arithmétique et chaines additives". Thesis at: Université de Montréal.

Sauerbrey J and Dietel A (1992), "Resource requirements for the application of addition chains in modulo exponentiation", In Workshop on the Theory and Application of of Cryptographic Techniques. , pp. 174-182.

Mohamed M and Atan KM (2012), "Rule Based Representation of Integer for a New Addition Chain Method", Applied Mathematical Sciences. Vol. 6(30), pp. 1497-1503.

Sautto JM, Santiago A, Bouza CN and Campos V (2016), "Scholz’s First Conjecture: A Brief Demonstration", Applied Mathematics. Vol. 7(01), pp. 70. Scientific Research Publishing.

Vallejo JMS, Moreno AS, Herrera CNB and Guzmán VC (2013), "Scholz’s Third Conjecture: A Demonstration for Star Addition Chains", Applied Mathematics. Vol. 4(10), pp. 1. Scientific Research Publishing.

Giese RP (1974), "Selected topics in addition chains". Thesis at: University of Houston.

Enge A, Hart W and Johansson F (2016), "Short addition sequences for theta functions", arXiv preprint arXiv:1608.06810.

Mohamed M, Md Said M, Mohd Atan K and Ahmad Zulkarnain Z (2011), "Shorter addition chain for smooth integers using decomposition method", International Journal of Computer Mathematics. Vol. 88(11), pp. 2222-2232. Taylor & Francis.

Straus EG (1964), "Solution to Problem 5125", Amer. Math. Monthly. Vol. 71, pp. 806-808.

Coster MJ (1990), "Some algorithms on addition chains and their complexity", Department of Computer Science [CS].. Thesis at: Centrum voor Wiskunde en Informatica, Amsterdam. (R 9024), pp. 1-69. CWI.

Hebb KR (1974), "Some problems on addition chains". Thesis at: Thesis (M. Sc.)--University of Alberta.

Bahig HM and Nakamula K (2002), "Some properties of nonstar steps in addition chains and new cases where the Scholz conjecture is true", Journal of Algorithms. Vol. 42(2), pp. 304-316. Elsevier.

Chen Y-J, Chang C-C and Yang W-P (1994), "Some properties of vectorial addition chains", International Journal of Computer Mathematics. Vol. 54(3-4), pp. 185-196. Taylor & Francis.

Bahig HM, El-Zahar MH and Nakamula K (2001), "Some Results for Some Conjectures in Addition Chains", In Combinatorics, Computability and Logic. , pp. 47-54. Springer.

Hebb K (1974), "Some results on addition chains. Preliminary report.", In Notices of the American Mathematical Society. Vol. 21(2), pp. A294-A294.

Volger H (1985), "Some results on addition/subtraction chains", Information Processing Letters. Vol. 20(3), pp. 155-160. Elsevier.

Lickteig T and Volger H (1987), "Some results on the complexity of powers", In Computation theory and logic. , pp. 249-255. Springer.

Byrne A, Crowe F, Marnane WP, Meloni N, Tisserand A and Popovici E (2007), "SPA resistant elliptic curve cryptosystem using addition chains", International Journal of High Performance Systems Architecture. Vol. 1(2), pp. 133-142. Inderscience Publishers.

Goundar R, Shiota K-i and Toyonaga M (2008), "SPA resistant scalar multiplication using golden ratio addition chain method", International Journal of Applied Mathematics. Vol. 38(2), pp. 83-88.

Bahig HM and Bahig HM (2006), "Speeding Up Evaluation of Powers and Monomials.", In FCS. , pp. 149-153.

Stam M (2003), "Speeding up subgroup cryptosystems". Thesis at: Technische Universiteit Eindhoven.

Morain F and Olivos J (1990), "Speeding up the computations on an elliptic curve using addition-subtraction chains", Informatique théorique et Applications. Vol. 24(6), pp. 531-543.

Bahig HM (2011), "Star reduction among minimal length addition chains", Computing. Vol. 91(4), pp. 335-352. Springer.

Wu Y (1995), "Strength reduction of multiplications by integer constants", ACM SIGPLAN Notices. Vol. 30(2), pp. 42-48. ACM.

Brlek S and Mallette R (1992), "Sur le calcul des chaînes d'additions optimales", Atelier de combinatoire franco-québecois (6-7 Mai 1991, Bordeaux, France). , pp. 71-85.

Semba I (1983), "Systematic Method for Determining the Number of Multiplications Required to Compute xˆ m, Where m is a Positive Integer", Journal of information processing. Vol. 6(1), pp. 31-33. 一般社団法人情報処理学会.

Mityagin A, Mironov I and Kobliner YN (2010), "Systems and methods for generating random addition chains", February 2, 2010. Google Patents.

Belaga E (1976), "THE ADDITIVE COMPLEXITY OF A NATURAL NUMBER", Soviet Mathematics Doklady. Vol. 17(1), pp. 5. American Mathematical Society..

Coster M (2000), "The Algorithm of Brun and Addition Chains"

Coster M (2000), "The Brun Algorithm for Addition Chains"

Dong F-g, Li Y-r and Li J-j (2010), "The Consistency Analysis of Addition Chains for Several Fast Algorithm of Modular Exponentiation.", JDCTA. Vol. 4(5), pp. 82-88.

McCarthy DP (1977), "The optimal algorithm to evaluate x^n using elementary multiplication methods", Mathematics of Computation. Vol. 31(137), pp. 251-256.

Gioia A and Subbarao M (1975), "The Scholz-Brauer problem in addition chains", Notices of the American Mathematical Society. Vol. 22, pp. A63-A64.

Gioia A and Subbarao M (1978), "The Scholz-Brauer problem in addition chains II", In Proc. eighth Manitoba conference on numerical math. and computing. Vol. 22, pp. 251-274.

Thurber E (1971), "The Scholz-Brauer problem on addition chains", Notices of the american Mathematical Society.

Thurber E (1973), "The Scholz-Brauer problem on addition chains", Pacific Journal of Mathematics. Vol. 49(1), pp. 229-242. Mathematical Sciences Publishers.

Val'skii R (1961), "The Smallest Number of Multiplications Necessary to Raise a Number to a Given Power", Problems of Cybernetics. Vol. 2, pp. 395-397.

Hendley SM (1954), "The theory and construction of addition chains"

Bernstein DJ (2006), "The transposition principle"

Sonntag R (1978), "Theorie der Additionsketten". Thesis at: Technische Universität Hannover.

Tummeltshammer P, Hoe JC and Puschel M (2007), "Time-multiplexed multiple-constant multiplication", IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems. Vol. 26(9), pp. 1551-1563. IEEE.

Nedjah N and de Macedo Mourelle L (2006), "Towards minimal addition chains using ant colony optimisation", Journal of Mathematical Modelling and Algorithms. Vol. 5(4), pp. 525-543. Springer.

Dimitrov V and Cooklev T (1995), "Two algorithms for modular exponentiation using nonstandard arithmetics", IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences. Vol. 78(1), pp. 82-87. The Institute of Electronics, Information and Communication Engineers.

Guy R (2004), "Unsolved problems in number theory" Vol. 1, pp. 169-171. Springer Science & Business Media.

Bergeron F and Olivos J (1989), "Vectorial addition chains using Euclid's algorithm". Thesis at: Research Report, Dpt. Math., UQAM 105.

Kunihiro N and Yamamoto H (1998), "Window and extended window methods for addition chain and addition-subtraction chain", IEICE TRANSACTIONS on Fundamentals of Electronics, Communications and Computer Sciences. Vol. 81(1), pp. 72-81. The Institute of Electronics, Information and Communication Engineers.

Кочергин ВВ (2014), "Уточнение оценок сложности вычисления одночленов и наборов степеней в задачах Беллмана и Кнута", Дискретный анализ и исследование операций. Vol. 21(6), pp. 51-72. Институт математики им. СЛ Соболева Сибирского отделения РАН.

Bahig, H.M.; Kotb, Y. An Efficient Multicore Algorithm for Minimal Length Addition Chains. Computers 2019, 8, 23.

Užarević, Josip. Postupci konstrukcije i optimizacije adicijskih lanaca. Diss. University of Zagreb. Faculty of Electrical Engineering and Computing., 2018.

Neill Clift

 
]]]
[[[
http://additionchains.com/st.cpp
===
//
// NeillClift@live.com
//
// This is the current code I use to calculate l(n) values for large ranges.
// This code has a bunch of improvements I did after I wrote my paper.
// It's Windows specific code and not really fit for general consumption. I hope to 
// add additional comments etc to make stuff clear.
// I have a newer algorithm that beats the performance for single numbers but I haven't
// figured out a way to y=run ranges yet. So this remains the best code to calculate
// large numbers of l(n) values.
//
// Load took 0:00:00.00, Heuristics took 0:00:00.10, Lowest unset 3
// s(n)<=0 took 0:00:00.00 n<=2^25, timeout=0
// Cpu=34,U=72.08%,K=4.91%,T=77.00%
// Write took 0:00:00.07, Check took 0:00:00.45
//
// Load took 0:00:00.06, Heuristics took 0:00:00.10, Lowest unset 7
// s(n)<=1 took 0:00:00.00 n<=2^25, timeout=0
// Cpu=34,U=72.06%,K=4.74%,T=76.80%
// Write took 0:00:00.07, Check took 0:00:00.45
//
// Load took 0:00:00.07, Heuristics took 0:00:00.09, Lowest unset 23
// s(n)<=2 took 0:00:00.00 n<=2^25, timeout=0
// Cpu=34,U=61.83%,K=14.73%,T=76.57%
// Write took 0:00:00.11, Check took 0:00:00.40
//
// Load took 0:00:00.06, Heuristics took 0:00:00.06, Lowest unset 127
// s(n)<=3 took 0:00:00.03 n<=2^25, timeout=0
// Cpu=34,U=71.94%,K=11.59%,T=83.53%
// Write took 0:00:00.15, Check took 0:00:00.42
//
// Load took 0:00:00.07, Heuristics took 0:00:00.07, Lowest unset 863
// s(n)<=4 took 0:00:00.53 n<=2^25, timeout=0
// Cpu=34,U=70.02%,K=8.72%,T=78.73%
// Write took 0:00:00.09, Check took 0:00:00.42
//
// Load took 0:00:00.17, Heuristics took 0:00:00.07, Lowest unset 8059
// s(n)<=5 took 0:00:24.48 n<=2^25, timeout=0
// Cpu=34,U=92.69%,K=0.29%,T=92.98%
// Write took 0:00:00.15, Check took 0:00:00.42
//
// Load took 0:00:00.15, Heuristics took 0:00:00.04, Lowest unset 245339
// s(n)<=6 took 0:03:33.17 n<=2^25, timeout=0
// Cpu=34,U=93.57%,K=0.04%,T=93.61%
// Write took 0:00:00.07, Check took 0:00:00.42
//
// Load took 0:00:00.07, Heuristics took 0:00:00.01, Lowest unset 16629503
// s(n)<=7 took 0:00:37.95 n<=2^25, timeout=62
// Cpu=34,U=85.04%,K=0.15%,T=85.19%
// Write took 0:00:00.09, Check took 0:00:00.42
//
// Load took 0:00:00.12, Heuristics took 0:00:00.00, Lowest unset 33554433
// s(n)<=8 took 0:00:04.21 n<=2^25, timeout=0
// Cpu=34,U=4.01%,K=1.01%,T=5.03%
// Write took 0:00:00.07, Check took 0:00:00.42
//
// Load took 0:00:00.12, Heuristics took 0:00:00.00, Lowest unset 33554433
// s(n)<=9 took 0:00:04.21 n<=2^25, timeout=0
// Cpu=34,U=4.00%,K=1.06%,T=5.06%
// Write took 0:00:00.07, Check took 0:00:00.40
//
//
// Load took 0:00:00.00, Heuristics took 0:01:26.68, Lowest unset 2396751
// s(n)<=8 took 0:06:10.90 n<=2^35, timeout=0
// Cpu=34,U=92.11%,K=0.07%,T=92.18%
// Write took 0:00:26.14, No check, test run
//

// Minimum number of slots left in the chain to allow us to split work.
#define MIN_SPLIT_DEPTH 4
#define MAX_CHAIN 128
#define MAX_VERTEX MAX_CHAIN
#define MAX_EDGE MAX_CHAIN

#define _CRT_SECURE_NO_WARNINGS
#define _CRT_DISABLE_PERFCRIT_LOCKS


#include "windows.h"
#include "stdio.h"
#include <omp.h>
#include <set>
#include <vector>
#include <bitset>

using namespace std;

#define QUIET

typedef unsigned __int64 NTYPE, *PNTYPE;
typedef __int64 SNTYPE;
#define NTYPE_P "%I64u"
#define LPTYPER_P "%I64u"
typedef unsigned long DWORD, *PDWORD;
typedef unsigned char LPTYPE, *PLPTYPE;
typedef unsigned long long LPTYPER, *PLPTYPER;
typedef long long SLPTYPER, *PSLPTYPER;
typedef signed char REFTYPE, *PREFTYPE;
typedef signed long long REFTYPER;

#if _DEBUG
#define ASSERT(exp) \
if (!(exp)) DebugBreak();
#else
#define ASSERT(exp)
#endif

#define MIN_VALUE ((NTYPE)1)
#define MAX_SMALL_STEPS 20
#define BITMAP_SIZE ((MaxValue + 1) / CHAR_BIT)
#define MAX_FWRITE 0x40000000

#define MAX_TREE_SIZE 10000000
#define MIN_TREE_SIZE 100

#define IDLE_TIMEOUT 100
#define EFFICIENCY_MULTIPLE 1.1

#define MIN_SPLIT_TIME (1000*60*60*24*2)
#define MIN_VC_SPLIT 10

#if _DEBUG
#define SAVE_TICK_PERIOD (1000*60)
#else
#define SAVE_TICK_PERIOD (1000*60*60)
#endif

// Define this to make the program single threaded for debugging
//#define DEBUG_THREADS

#define FLAGS_DO_RESTORE 0x001
#define FLAGS_DO_USAGE   0x002
#define FLAGS_DO_STATS   0x004
#define FLAGS_DO_FACTOR  0x008
#define FLAGS_DO_TEST    0x010
#define FLAGS_DO_PAUSE   0x020
#define FLAGS_DO_IDLE    0x040
#define FLAGS_DO_D       0x080
#define FLAGS_DO_WRITE   0x100

static DWORD Flags;

//
// Number of CPU we are running on.
//
static DWORD CpuCount = 1;

// 1 if a thread is splitting it's current work. Zero otherwise.
static ULONG SplitActive = 0;
static ULONG MaxThreads = 16;

#define MAX_THREADS (68)

static HANDLE Threads[MAX_THREADS];

static NTYPE MaxValue = (((NTYPE)1 << 37) + CHAR_BIT - 1);
static NTYPE MaxData = (((NTYPE)1 << 36) + CHAR_BIT - 1);

static PUCHAR BitMap = 0;

static PUCHAR BitMapArray[20] = {0};

static SRWLOCK plock;
static CONDITION_VARIABLE NewWorkCondVar;
static CONDITION_VARIABLE ExcessWorkCondVar;
static PNTYPE MinValues;
static LPTYPER MinValuesSize;

__declspec (thread) ULONG ThreadId = 0;

typedef struct _THREAD_CTX {
#define THREAD_SIGNAL_UPDATE_MIN 1
#define THREAD_SIGNAL_SPLIT      2
	ULONG ThreadSignal;
	UCHAR Pad[128-4];
} THREAD_CTX, *PTHREAD_CTX;

static THREAD_CTX ThreadCtx[MAX_THREADS + 1] = {0};

typedef struct _VERTEX {
	NTYPE n;
	NTYPE min;
	NTYPE minv;
	NTYPE maxv;
	REFTYPE Refs;
	BOOLEAN Doubling : 8;
	BOOLEAN Multiple : 8;
} VERTEX, *PVERTEX;

typedef struct _VAL {
	NTYPE n;
	NTYPE minv;
	LPTYPE i, j;
} VAL, *PVAL;

typedef struct _BITMASK {
	ULONG64 Mask;
} BITMASK, *PBITMASK;

typedef struct _STAT {
	NTYPE minv;
} STAT, *PSTAT;

static HANDLE ExitEvent = NULL;

typedef struct _WORK_ITEM {
	struct _WORK_ITEM *Copy;
	LIST_ENTRY ListEntry;
	PVERTEX Vertex;
	NTYPE RefsTotal;
	NTYPE LessTotal;
	BITMASK BitMask;
	ULONGLONG StartTick;
	double EfficiencyFactor;
	LPTYPER Depth;
	LPTYPER c;
	LPTYPER Refs;
	LPTYPER vc;
	LPTYPER Less;
	int ThreadId;
} WORK_ITEM, *PWORK_ITEM;

static LIST_ENTRY WorkingList;
static ULONG WorkCount = 0;
static ULONG Timeouts = 0;

#define MAX_HARD_VALUES 128
static LONG HardValuesIndex = 0;
static NTYPE HardValues[MAX_HARD_VALUES] = { 0 };

struct WorkItemComp {
	bool operator() (const PWORK_ITEM &lhs, const PWORK_ITEM &rhs) const
	{
		if (lhs->EfficiencyFactor == rhs->EfficiencyFactor) {
			return lhs < rhs;
		} else {
			return lhs->EfficiencyFactor < rhs->EfficiencyFactor;
		}
	}
};

static set<PWORK_ITEM, WorkItemComp> WorkSet;

static
void
Recurse(LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
        LPTYPER Refs, NTYPE RefsTotal, LPTYPER Less, NTYPE LessTotal, BITMASK BitMask, bool TopLevel);

VOID
FORCEINLINE
Lock ()
/*++

Acquires the global lock.

--*/
{
	AcquireSRWLockExclusive(&plock);
}

VOID
FORCEINLINE
Unlock ()
/*++

Releases the global lock.

--*/
{
	ReleaseSRWLockExclusive(&plock);
}

VOID
FORCEINLINE
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
/*++

Initialize a list head to empty.

ListHead - Address of list head to initialize.

--*/
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

BOOLEAN
FORCEINLINE
IsListEmpty(
    IN const LIST_ENTRY * ListHead
    )
/*++

Test if a list head is empty

ListHead - Address of list head to test.

--*/
{
    return (BOOLEAN)(ListHead->Flink == ListHead);
}

BOOLEAN
FORCEINLINE
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
/*++

Removes an entry from a double linked list.

Entry - Address of list entry to remove.

--*/
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

PLIST_ENTRY
FORCEINLINE
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
/*++

Removes an entry from the head of a double linked list.

ListHead - Address of list head to remove an entry from.

--*/
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    ASSERT (Entry != ListHead);
    return Entry;
}

PLIST_ENTRY
FORCEINLINE
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
/*++

Removes an entry from the tail of a double linked list.

ListHead - Address of list head to remove an entry from.

--*/
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}

VOID
FORCEINLINE
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
/*++

Inserts an entry into the tail of a double linked list.

ListHead - Address of list head to insert an entry into.

Entry - Entry to insert into the list

--*/
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


VOID
FORCEINLINE
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
/*++

Inserts an entry into the head of a double linked list.

ListHead - Address of list head to insert an entry into.

Entry - Entry to insert into the list

--*/
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}

static
void
FreeWorkItem (PWORK_ITEM WorkItem)
{
	free (WorkItem->Vertex);
	free (WorkItem);
	return;
}

static
LONG
Compare (PWORK_ITEM WorkItem1, PWORK_ITEM WorkItem2)
{
	if (WorkItem1->EfficiencyFactor < WorkItem2->EfficiencyFactor) {
		return -1;
	} else if (WorkItem1->EfficiencyFactor > WorkItem2->EfficiencyFactor) {
		return 1;
	} else {
		return 0;
	}
}

static
void
InsertWorkTree(PWORK_ITEM WorkItem)
{
	WorkSet.insert(WorkItem);
}

static
PWORK_ITEM
RemoveWorkTree(void)
{
	PWORK_ITEM WorkItem = NULL;

	if (SplitActive) {
		auto it = WorkSet.rbegin();
		if (it != WorkSet.rend()) {
			WorkItem = *it;
			WorkSet.erase(*it);
		}
	} else {
		auto it = WorkSet.begin();
		if (it != WorkSet.end()) {
			WorkItem = *it;
			WorkSet.erase(*it);
		}
	}
	return WorkItem;
}

static
LPTYPER
lambda(NTYPE n)
/*++

Calculates the floor(log2(n)) of a number

--*/
{
	unsigned long l;
	_BitScanReverse64(&l, n);
	return l;
}

static
LPTYPER
log2u(NTYPE n)
/*++

Calculates the ceil(log2(n)) of a number

--*/
{
	LPTYPER l = lambda(n);
	if ((n & (n - 1)) != 0) {
		l++;
	}
	return l;
}

static
bool
SameLog2(NTYPE n, NTYPE m)
{
	return ((n^m) <= (n&m));
}

static
bool
CanBeClearInBitMap(VERTEX &Vertex, NTYPE n)
{
	return n <= Vertex.maxv;
}

static
void
ApplyBounds(PVERTEX NewVertex, PVERTEX OldVertex, LPTYPER Depth) {
	LPTYPER i;
	for (i = 0; i <= Depth; i++) {
		if (NewVertex[i].min < OldVertex[i].min) {
			NewVertex[i].min = OldVertex[i].min;
			ASSERT(NewVertex[i].min > 0);
		}
		if (NewVertex[i].minv < OldVertex[i].minv) {
			NewVertex[i].minv = OldVertex[i].minv;
			ASSERT(NewVertex[i].minv > 0);
		}
		if (NewVertex[i].maxv > OldVertex[i].maxv) {
			NewVertex[i].maxv = OldVertex[i].maxv;
		}
	}
}

static
void
RecurseTree(PWORK_ITEM TreeItem, PVERTEX Vertex, LPTYPER Depth)
{
	for (auto it = WorkSet.begin(); it != WorkSet.end(); it++) {
		ApplyBounds((*it)->Vertex, Vertex, Depth);
	}
}

static
PUCHAR
AllocateBitMap (VOID)
{
	PUCHAR BitMap;
	BitMap = (PUCHAR)VirtualAlloc(NULL, BITMAP_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	memset (BitMap, 0, sizeof (BitMap[0])*BITMAP_SIZE);
	return BitMap;
}

static
void
ReplaceState(LPTYPER SmallSteps)
{
	CHAR Name[MAX_PATH], Name1[MAX_PATH];
	_snprintf(Name, sizeof(Name) / sizeof(Name[0]), "smallstep_" LPTYPER_P "_t.bin", SmallSteps);
	_snprintf(Name1, sizeof(Name1) / sizeof(Name1[0]), "smallstep_" LPTYPER_P ".bin", SmallSteps);

	int count = 0;
	while (!MoveFileEx(Name, Name1, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH)) {
		printf("MoveFileEx failed %d\n", GetLastError());
		Sleep(10000);
		if (count++ > 2000) {
			exit(0);
		}
	}
	count = 0;
	while (!MoveFileEx("SavedWork.txt_t", "SavedWork.txt", MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH)) {
		printf("MoveFileEx failed %d\n", GetLastError());
		Sleep(10000);
		if (count++ > 2000) {
			exit(0);
		}
	}
	
	count = 0;
	while (!MoveFileEx("Hardest.txt_t", "Hardest.txt", MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH)) {
		printf("MoveFileEx failed %d\n", GetLastError());
		Sleep(10000);
		if (count++ > 2000) {
			exit(0);
		}
	}
	
	count = 0;
	while (!MoveFileEx("SavedMin.txt_t", "SavedMin.txt", MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH)) {
		printf("MoveFileEx failed %d\n", GetLastError());
		Sleep(10000);
		if (count++ > 2000) {
			exit(0);
		}
	}

}

static
void
WriteBitmap(LPTYPER SmallSteps)
{
	FILE  *fp;
	NTYPE items, titems;
	CHAR Name[MAX_PATH];
	PUCHAR tBitMap;

	_snprintf(Name, sizeof(Name)/sizeof(Name[0]), "smallstep_" LPTYPER_P "_t.bin", SmallSteps);
	while ((fp = fopen(Name, "wbcS")) == NULL) {
		printf("Failed to create smallstep file\n");
		Sleep(5000);
	}

	if (BitMap[0] == 0) {
		printf("First element of bitmap is zero during write\n");
		exit(0);
	}
	items = (MaxValue + 1) / 8;
	tBitMap = BitMap;
	while (items > 0) {
		titems = items;
		if (items > MAX_FWRITE) {
			titems = MAX_FWRITE;
		}
		if (fwrite(tBitMap, sizeof(tBitMap[0]), titems, fp) != titems) {
			printf("fwrite failed\n");
			exit(0);
		}
		items -= titems;
		tBitMap += titems;
	}
	fflush(fp);
	fclose(fp);
}

static
BOOLEAN
IsInBitMap(NTYPE n)
{
	//int index;
	//index = (int)(n / (MaxValue / LOOKUP_STAT_SIZE));
	//if (index < LOOKUP_STAT_SIZE) {
	//	if (index == trigger) {
	//		DebugBreak();
	//	}
	//	InterlockedIncrement64(&BitMapLookup[index]);
	//}
	return (n <= MaxValue) && _bittest64((LONG64 *)BitMap, n);
}

static
BOOLEAN
IsInBitMapEx(PUCHAR BitMap, NTYPE n)
{
	return (n <= MaxValue) && _bittest64((LONG64 *)BitMap, n);
}

static
NTYPE
GetLowestUnset(VOID)
{
	static NTYPE Lowest = 1;
	while (Lowest <= MaxValue && IsInBitMap(Lowest)) {
		Lowest++;
	}
	return Lowest;
}

static
NTYPE
GetHighestUnset(VOID)
{
	static NTYPE Highest = MaxValue;
	while (Highest > 0 && IsInBitMap(Highest)) {
		Highest++;
	}
	return Highest;
}

static
NTYPE
GetLowestUnsetIndex(VOID)
{
	NTYPE Lowest;
	Lowest = GetLowestUnset();
	return Lowest / CHAR_BIT;
}

static
NTYPE
GetLowestUnsetIndexQuad(VOID)
{
	NTYPE Lowest;
	Lowest = GetLowestUnset();
	Lowest = Lowest / CHAR_BIT;
	return Lowest & ~(sizeof(LONGLONG) - 1);
}

static
void
ReadBitmap(LPTYPER SmallSteps, BOOLEAN Alternate)
{
	FILE  *fp;
	NTYPE i;
	CHAR Name[MAX_PATH];
	int inchar;

	if (Alternate) {
		_snprintf(Name, sizeof(Name)/sizeof(Name[0]), "smallstep_" LPTYPER_P "_1.bin", SmallSteps);
	} else {
		_snprintf(Name, sizeof(Name)/sizeof(Name[0]), "smallstep_" LPTYPER_P ".bin", SmallSteps);
	}
	if ((fp = fopen(Name, "rbS")) == NULL) {
		if (!Alternate) {
#if !defined (QUIET)
			printf("Failed to open smallstep file %s\n", Name);
#endif
		}
		return;
	}

#define BUFFER_SIZE (256*1024)
	PULONGLONG Buffer = new ULONGLONG[BUFFER_SIZE];
	inchar = getc(fp);
	if (inchar == 0) {
		printf("Zero first character in read bitmap\n");
	}
	i = GetLowestUnsetIndexQuad();
	_fseeki64(fp, i, SEEK_SET);
	NTYPE Limit = (MaxValue + 1) / CHAR_BIT;
	while(i < Limit) {
		size_t ReadCount = fread(Buffer, 1, BUFFER_SIZE, fp);
		ULONGLONG Remainder = ReadCount % sizeof(LONGLONG);
		if (Remainder != 0) {
			memset((PUCHAR)Buffer + ReadCount, 0, sizeof(LONGLONG) - Remainder);
			ReadCount += sizeof(LONGLONG) - Remainder;
		}
		ReadCount /= sizeof(LONGLONG);
		if (ReadCount == 0) {
			break;
		}
		for (int bi = 0;
		    bi < ReadCount && i < Limit;
			bi++, i += sizeof(Buffer[bi])) {
			InterlockedOr64((PLONGLONG)&BitMap[i], Buffer[bi]);
		}
	}
	delete[] Buffer;
	fclose(fp);

	if (!Alternate && BitMapArray[SmallSteps] == NULL) {
		BitMapArray[SmallSteps] = AllocateBitMap();
		memcpy(BitMapArray[SmallSteps], BitMap, BITMAP_SIZE);
	}

	if (Alternate) {
		DeleteFileA(Name);
	}
}

static
void
PopulateClassE (PVERTEX Vertex, NTYPE n, LPTYPER Depth, PSTAT Stat)
{
	LPTYPER i;
	NTYPE t, d, mv;

	i = Depth;
	t = n;
	if (Vertex[i].minv > n) {
		Vertex[i].minv = n;
		if (Stat != nullptr) {
			Stat[i].minv = n;
		}
	}
	ASSERT(Vertex[i].minv > 0);
	d = 2;
	while (i-- > 0) {
		mv = (t + d - 1) / d;
		if (Vertex[i].minv > mv) {
			Vertex[i].minv = mv;
			if (Stat != nullptr) {
				Stat[i].minv = n;
			}
		}
		Vertex[i].minv = min (Vertex[i].minv, mv);
		ASSERT(Vertex[i].minv > 0);
		d = 2*d - 1;
	}
	return;
}

static
void
PopulateMaxVal (PVERTEX Vertex, NTYPE n, LPTYPER Depth, PSTAT Stat)
{
	PopulateClassE (Vertex, n, Depth, Stat);
}

static
NTYPE
GetSmallest(void)
{
	static NTYPE Smallest = 1;
	NTYPE n;

	n = Smallest;
	while (n < MaxValue && IsInBitMap(n)) {
		n++;
		Smallest = n;
	}
	return n;
}

static
NTYPE
MaxSameLog2(NTYPE n)
{
	LPTYPER Shift = 1;
	NTYPE n2;
	while (true) {
		n2 = n | (n >> Shift);
		if (n2 == n) {
			break;
		}
		Shift = Shift * 2;
		ASSERT(SameLog2(n, n2));
		n = n2;
	}
	return n;
}

static
void
PopulateMaxV(PVERTEX Vertex, LPTYPER Depth, PSTAT Stat)
{
	LPTYPER i, l;
	NTYPE lim;
	NTYPE Smallest;

	for (i = 0; i <= Depth; i++) {
		Vertex[i].minv = -1;
		ASSERT(Vertex[i].minv > 0);
	}
	Smallest = GetSmallest();
	l = Depth;
	while (l > 0) {
		NTYPE n;

		n = Vertex[l].min;
		lim = min(MaxSameLog2(n), MaxValue);
		n = max(n, Smallest);
		n = max(n, MinValues[l]);
		for (; n <= lim; n++) {
			if (IsInBitMap (n)) {
				continue;
			}
			PopulateMaxVal (Vertex, n, l, Stat);
			break;
		}
		l--;
	}
	for (i = 0; i <= Depth; i++) {
		Vertex[i].min  = max(Vertex[i].min,  i + 1);
		Vertex[i].minv = max(Vertex[i].minv, i + 1);
	}
}

static
LPTYPER
bits(NTYPE n)
/*++

Calculates the number of 1 bits in a number.

--*/
{
	return (LPTYPER)__popcnt64(n);
}

static
BOOLEAN
ScanMin (PVERTEX Vertex, LPTYPER Depth, BOOLEAN ForceMaxV, PSTAT Stat)
{
    LPTYPER l;
	BOOLEAN DoneSomething;

	DoneSomething = FALSE;
	l = Depth;
	while (l > 0) {
		while ((l == Depth || Vertex[l].min * 2 < Vertex[l + 1].min || Vertex[l + 1].min > MaxValue) &&
				(IsInBitMap(Vertex[l].min) || Vertex[l].min < MIN_VALUE || Vertex[l].min < MinValues[l])) {
			Vertex[l].min++;
			DoneSomething = TRUE;
		}

		while (Vertex[l].maxv >= Vertex[l].min && IsInBitMap(Vertex[l].maxv)) {
			Vertex[l].maxv--;
		}
		NTYPE omv = MinValues[l];
		NTYPE mv = omv;
		while (IsInBitMap(mv) && mv < Vertex[l].maxv) {
			mv++;
		}
		if (mv != omv) {
			InterlockedCompareExchange64((PLONG64)&MinValues[l], mv, omv);
		}
		l--;
	}
	if (DoneSomething || ForceMaxV) {

		PopulateMaxV(Vertex, Depth, Stat);

#if !defined (QUIET)
		Lock ();
		for (i = Depth+1; i-- > 0;) {
			printf (NTYPE_P " ", Val[i].minv);
		}
		printf ("\n");
		Unlock ();
#endif
	}
	return DoneSomething;
}

static
void
SetCpuCount (DWORD Number)
{
	DWORD t;
	while (1) {
		t = CpuCount;
		if (t >= Number) {
			return;
		}
		InterlockedCompareExchange(&CpuCount, Number, t);
	}
}

static
void
PrintCpuTimeUsage(void)
{
	LARGE_INTEGER CreationTime;
    LARGE_INTEGER ExitTime;
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
	LARGE_INTEGER CurrentTime;
	LARGE_INTEGER Elapsed;

	GetSystemTimeAsFileTime((PFILETIME)&CurrentTime);

	if (!GetProcessTimes (GetCurrentProcess(),
		                  (PFILETIME)&CreationTime,
						  (PFILETIME)&ExitTime,
						  (PFILETIME)&KernelTime,
						  (PFILETIME)&UserTime)) {
	    printf ("GetProcessTimes failed %d\n", GetLastError ());
		exit (0);
	}
	Elapsed.QuadPart = (CurrentTime.QuadPart - CreationTime.QuadPart)*CpuCount;

	printf ("// Cpu=%d,U=%3.2f%%,K=%3.2f%%,T=%3.2f%%\n",
		CpuCount,
		(double)UserTime.QuadPart * 100.0/(double)Elapsed.QuadPart,
		(double)KernelTime.QuadPart * 100.0/(double)Elapsed.QuadPart,
		((double)UserTime.QuadPart + (double)KernelTime.QuadPart) * 100.0/(double)Elapsed.QuadPart);
}

static
void
MarkAsWorking(PWORK_ITEM WorkItem) 
{
	InsertTailList(&WorkingList, &WorkItem->ListEntry);
	WorkItem->ThreadId = (LPTYPE)ThreadId;
	WorkItem->StartTick = GetTickCount64();
}

static
void
UnSignalThreadSplit(int TargetIndex)
{
	if (InterlockedAnd((LONG *)&ThreadCtx[TargetIndex].ThreadSignal, ~THREAD_SIGNAL_SPLIT) & THREAD_SIGNAL_SPLIT) {
		ULONG NewValue = InterlockedDecrement(&SplitActive);
		ASSERT(NewValue == 0);
	}
}

static
void
SignalThreadSplit(int TargetIndex)
{
	ASSERT(TargetIndex != 0);
	if (InterlockedCompareExchange(&SplitActive, 1, 0) == 0) {
		InterlockedOr((LONG *)&ThreadCtx[TargetIndex].ThreadSignal, THREAD_SIGNAL_SPLIT);
	}
}

static
double
SplitMostEfficient()
{
	int TargetIndex = 0;
	double Best = 0.0;
	PLIST_ENTRY ListEntry;
	PWORK_ITEM WorkItem;

	if (WorkSet.size() < MIN_TREE_SIZE) {
		for (ListEntry = WorkingList.Flink; ListEntry != &WorkingList; ListEntry = ListEntry->Flink) {
			WorkItem = CONTAINING_RECORD(ListEntry,WORK_ITEM, ListEntry);
			if (WorkItem->EfficiencyFactor > Best) {
				Best = WorkItem->EfficiencyFactor;
				TargetIndex = WorkItem->ThreadId;
				ASSERT(TargetIndex != 0);
			}
		}
		if (TargetIndex != 0) {
			SignalThreadSplit(TargetIndex);
		}
	}
	return Best;
}

static
void
SignalAnyInefficientActive(double EfficiencyFactor)
{
	PLIST_ENTRY ListEntry;
	PWORK_ITEM WorkItem;
	int TargetIndex;

	if (SplitActive == 0) {
		for (ListEntry = WorkingList.Flink; ListEntry != &WorkingList; ListEntry = ListEntry->Flink) {
			WorkItem = CONTAINING_RECORD(ListEntry, WORK_ITEM, ListEntry);
			if (WorkItem->EfficiencyFactor < EfficiencyFactor) {
				TargetIndex = WorkItem->ThreadId;
				SignalThreadSplit(TargetIndex);
				break;
			}
		}
	}
}

static
double
GetBestEfficiencyForRunning() {
	PLIST_ENTRY ListEntry;
	PWORK_ITEM WorkItem;
	double Best = 0.0;

	Lock();
	for (ListEntry = WorkingList.Flink; ListEntry != &WorkingList; ListEntry = ListEntry->Flink) {
		WorkItem = CONTAINING_RECORD(ListEntry,WORK_ITEM, ListEntry);
		if (WorkItem->EfficiencyFactor > Best) {
			Best = WorkItem->EfficiencyFactor;
		}
	}
	Unlock();

	return Best;
}

static
PWORK_ITEM
AllocWorkItem(LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth, LPTYPER Refs, NTYPE RefsTotal,
	          LPTYPER Less, NTYPE LessTotal, BITMASK BitMask)
{
	PWORK_ITEM WorkItem;

	WorkItem = new WORK_ITEM;
	WorkItem->Vertex = new VERTEX[Depth + 1];
	memcpy(WorkItem->Vertex, Vertex, sizeof(Vertex[0]) * (Depth + 1));
	WorkItem->c = c;
	WorkItem->vc = vc;
	WorkItem->Depth = Depth;
	WorkItem->Refs = Refs;
	WorkItem->RefsTotal = RefsTotal;
	WorkItem->Less = Less;
	WorkItem->LessTotal = LessTotal;
	WorkItem->EfficiencyFactor = (double)(RefsTotal + LessTotal) / ((NTYPE)1 << (c + Refs - 1 + Less));
	WorkItem->BitMask = BitMask;
	WorkItem->Copy = nullptr;
	return WorkItem;
}

static
DWORD
WINAPI
ThreadWorker (LPVOID Arg)
{
    PWORK_ITEM WorkItem, LastWorkItem = NULL;
	BOOLEAN ExitThread = FALSE;
	static ULONG ProcNum = 0;
	ULONG Num;

    //
    // Lower priority so as to not interfere with system
    //
	if (Flags & FLAGS_DO_IDLE) {
		if (!SetThreadPriority(GetCurrentThread(),
			THREAD_PRIORITY_IDLE)) {
			printf("SetThreadPriority failed %u\n", GetLastError());
		}
	}

	LPTYPER Depth = (LPTYPER)Arg;

	//
    // Select a processor to run on
    //
    Num = InterlockedIncrement(&ProcNum) - 1;

#if _DEBUG
//	if (Num > 0) {
//		return 0;
//	}
#endif

	ThreadId = Num + 1;
	SetCpuCount (ThreadId);

    while (1) {

		Lock ();
		while (1) {
			SplitMostEfficient();
			WorkItem = RemoveWorkTree();
			if (WorkItem != NULL) {
				MarkAsWorking(WorkItem);
				break;
			} else {
				if (WorkCount == 0) {
					break;
				}
				if (!SleepConditionVariableSRW(&NewWorkCondVar, &plock, IDLE_TIMEOUT, 0)) {
					UnSignalThreadSplit(ThreadId);
					Timeouts++;
				}
			}
		}
		Unlock ();

		if (WorkCount == 0) {
			break;
		}

		if (LastWorkItem != NULL) {
			ASSERT (WorkItem->Depth == LastWorkItem->Depth);
			ApplyBounds(WorkItem->Vertex, LastWorkItem->Vertex, WorkItem->Depth);
		}


		ScanMin (WorkItem->Vertex, WorkItem->Depth, FALSE, nullptr);
		PWORK_ITEM Copy = AllocWorkItem(WorkItem->c, WorkItem->Vertex, WorkItem->vc, WorkItem->Depth,
                                        WorkItem->Refs, WorkItem->RefsTotal,
			                            WorkItem->Less, WorkItem->LessTotal, WorkItem->BitMask);
		Lock();
		WorkItem->Copy = Copy;
		Unlock();

		Recurse (WorkItem->c, WorkItem->Vertex, WorkItem->vc,
			     WorkItem->Depth, WorkItem->Refs,
			     WorkItem->RefsTotal, WorkItem->Less, WorkItem->LessTotal, WorkItem->BitMask, true);

		UnSignalThreadSplit(ThreadId);

		if (LastWorkItem != 0) {
			FreeWorkItem(LastWorkItem->Copy);
			FreeWorkItem(LastWorkItem);
		}

		Lock ();
		RemoveEntryList(&WorkItem->ListEntry);
		Unlock ();
		ULONG NewValue = InterlockedDecrement(&WorkCount);

		if (NewValue == 0) {
			SetEvent(ExitEvent);
		}
	    if (WorkSet.size() <= MAX_TREE_SIZE) {
			WakeConditionVariable(&ExcessWorkCondVar);
		}
	    LastWorkItem = WorkItem;
	}
	if (LastWorkItem != 0) {
		FreeWorkItem(LastWorkItem->Copy);
		FreeWorkItem(LastWorkItem);
	}
    return 0;
}

static
VOID
QueueWork (LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
		   LPTYPER Refs, NTYPE RefsTotal, LPTYPER Less, NTYPE LessTotal, BITMASK BitMask)
{
    PWORK_ITEM WorkItem;

    WorkItem = AllocWorkItem (c, Vertex, vc, Depth,
		                      Refs, RefsTotal, Less, LessTotal, BitMask);

	ULONG NewValue = InterlockedIncrement(&WorkCount);

	Lock ();
	InsertWorkTree(WorkItem);
	Unlock ();

	WakeConditionVariable(&NewWorkCondVar);

	if (WorkSet.size() > MAX_TREE_SIZE && SplitActive) {
		Lock();
		while (WorkSet.size() > MAX_TREE_SIZE) {
			SleepConditionVariableSRW(&ExcessWorkCondVar, &plock, 0, 0);
		}
		Unlock();
	}
}

static
void
InitThreads (void)
{
	//ULONG index;
    InitializeListHead(&WorkingList);

	InitializeConditionVariable(&NewWorkCondVar);
	InitializeConditionVariable(&ExcessWorkCondVar);

	InitializeSRWLock(&plock);

	ExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (ExitEvent == NULL) {
        printf ("CreateEvent failed %d\n", GetLastError ());
        exit (EXIT_FAILURE);
    }
	SYSTEM_INFO SystemInfo;
	GetSystemInfo(&SystemInfo);
	MaxThreads = SystemInfo.dwNumberOfProcessors + 2;
	if (MaxThreads >= MAX_THREADS) {
		printf("Processors %d but compiled for less\n", MaxThreads);
		exit(0);
	}
	omp_set_num_threads(SystemInfo.dwNumberOfProcessors);
#if defined(DEBUG_THREADS)
	MaxThreads = 1;
#endif
}

static
void
StartThreads(LPTYPER Depth) {
	DWORD i, id;
	for (i = 0; i < MaxThreads; i++) {
        Threads[i] = CreateThread (NULL, 0, ThreadWorker, (LPVOID)Depth, 0, &id);
        if (Threads[i] == NULL) {
            printf ("CreateThread failed %d\n", GetLastError ());
            exit (EXIT_FAILURE);
        }
    }

}

static
void
PrintWorkItem(FILE *fp, PWORK_ITEM WorkItem)
{
	fprintf(fp, LPTYPER_P " " LPTYPER_P " " LPTYPER_P " " LPTYPER_P " " LPTYPER_P " " LPTYPER_P " ",
		WorkItem->Depth, WorkItem->c, WorkItem->Refs, WorkItem->vc,
		(LPTYPER)0, WorkItem->Less);
	fprintf(fp, NTYPE_P " " NTYPE_P " " NTYPE_P " ", WorkItem->RefsTotal, WorkItem->LessTotal, WorkItem->BitMask.Mask);
	for (LPTYPER i = 0; i < WorkItem->vc; i++) {
		fprintf(fp, NTYPE_P " %d %d %d ", WorkItem->Vertex[i].n, WorkItem->Vertex[i].Refs, WorkItem->Vertex[i].Doubling,
			WorkItem->Vertex[i].Multiple);
	}
	fprintf(fp, "\n");
}

static
void
PrintWorkTree(FILE *fp)
{
	for (auto it = WorkSet.begin(); it != WorkSet.end(); it++) {
		PrintWorkItem(fp, *it);
	}
}

static
void
FlushWork(void)
{
	PLIST_ENTRY ListEntry;
	PWORK_ITEM WorkItem;
	FILE  *fp;

	while ((fp = fopen("SavedWork.txt_t", "wcS")) == NULL) {
		printf("Failed to create saved work file\n");
		Sleep(5000);
	}

	LPTYPER BestIndex = 0;
	ULONGLONG BestTick = -1;
	for (ListEntry = WorkingList.Flink; ListEntry != &WorkingList; ListEntry = ListEntry->Flink) {
		WorkItem = CONTAINING_RECORD(ListEntry, WORK_ITEM, ListEntry);
		if (WorkItem->Copy != NULL) {
			PrintWorkItem(fp, WorkItem->Copy);
		} else {
			PrintWorkItem(fp, WorkItem);
		}
		if (BestTick > WorkItem->StartTick) {
			BestIndex = WorkItem->ThreadId;
			BestTick = WorkItem->StartTick;
		}
	}
	PrintWorkTree(fp);

	fflush(fp);
	fclose(fp);

	while ((fp = fopen("Hardest.txt_t", "wcS")) == NULL) {
		printf("Failed to create hardest file\n");
		Sleep(5000);
	}
	for (int i = 0; i < MAX_HARD_VALUES; i++) {
		fprintf(fp, NTYPE_P "\n", HardValues[i]);
	}
	fflush(fp);
	fclose(fp);

	while ((fp = fopen("SavedMin.txt_t", "wcS")) == NULL) {
		printf("Failed to create saved min values file\n");
		Sleep(5000);
	}
	for (LPTYPER i = 0; i < MinValuesSize; i++) {
		fprintf(fp, NTYPE_P "\n", MinValues[i]);
	}
	fflush(fp);
	fclose(fp);

	ULONGLONG CurrentTick = GetTickCount64();
	if (BestIndex != 0 && CurrentTick - BestTick > MIN_SPLIT_TIME) {
		SignalThreadSplit((int)BestIndex);
	}
}

static void ReadMinValues(bool Alternate)
{
	FILE *fp;
	if ((fp = fopen(Alternate ? "SavedMin_1.txt" : "SavedMin.txt", "rS")) != NULL) {
		NTYPE mv;
		int vals;
		int i = 0;
		while ((vals = fscanf_s(fp, NTYPE_P, &mv)) != EOF) {
			while (true) {
				NTYPE ov = MinValues[i];
				if (ov >= mv) {
					break;
				}
				if (InterlockedCompareExchange64((LONG64 *)&MinValues[i], mv, ov) == ov) {
					printf("Updating min values at step %d from " NTYPE_P " to " NTYPE_P "\n",
						i, ov, mv);
					break;
				}
			}
			i++;
		}
		fclose(fp);
	}
}

static
void
SignalUpdateMin() {
	DWORD i;
	for (i = 1; i < MaxThreads + 1; i++) {
		if (i != ThreadId) {
			InterlockedOr((LONG *)&ThreadCtx[i].ThreadSignal, THREAD_SIGNAL_UPDATE_MIN);
		}
	}
}

static
void
WriteAndReplaceState(LPTYPER SmallSteps)
{
	Lock();
	WriteBitmap(SmallSteps);
	FlushWork();
	Unlock();

	ReplaceState(SmallSteps);
}

static
void
ExitThreads(LPTYPER SmallSteps)
{
	ULONG i;

	if (WorkCount > 0) {
		while (1) {
			DWORD WaitStatus = WaitForSingleObject(ExitEvent, SAVE_TICK_PERIOD);
			if (WaitStatus == WAIT_FAILED) {
				printf("WaitForSingleObject failed %d\n", GetLastError());
				exit(EXIT_FAILURE);
			} else if (WaitStatus == WAIT_TIMEOUT) {
				ReadBitmap(SmallSteps, TRUE);
				if (SmallSteps > 0) {
					ReadBitmap(SmallSteps - 1, TRUE);
				}
				ReadMinValues(true);
				WriteAndReplaceState(SmallSteps);
				SignalUpdateMin();
			} else {
				break;
			}
		}
	}
	
	WakeAllConditionVariable(&NewWorkCondVar);

	for (i = 0; i < MaxThreads; i++) {
	    if (WaitForSingleObject (Threads[i], INFINITE) == WAIT_FAILED) {
		    printf ("WaitForSingleObject failed %d\n", GetLastError ());
			exit (EXIT_FAILURE);
	    }
		if (!CloseHandle (Threads [i])) {
		    printf ("CloseHandle failed %d\n", GetLastError ());
			exit (EXIT_FAILURE);
		}
	}
}

static
BOOLEAN
OnlyOneBit (NTYPE n)
{
	if (n&(n-1)) {
		return FALSE;
	} else {
		return TRUE;
	}
}

static
LPTYPER
lbin (NTYPE n)
/*++

Calculates the upper bound of l(n) via the binary method.

--*/
{
   LPTYPER b;

   b = bits (n);
   return lambda(n) + b - 1;
}

static
LPTYPER
sbin4 (NTYPE n)
/*++

Calculates the upper bound of l(n) via the 4-ary method.

--*/
{
    NTYPE t;
    LPTYPER b;
	BOOLEAN Got3;

	b = 0;
	Got3 = FALSE;
	for (t = n; t >= 4;) {
		if ((t&1) == 0) {
			t >>= 1;
			continue;
		}
		Got3 |= ((t&3) == 3);
		b++;
		t >>= 2;
	}
	if (Got3) {
		b++;
	}
	if (t >= 2) {
		if (t != 3 || !Got3) {
			b++;
		}
	}

    return b;
}

static
LPTYPER
sbin8 (NTYPE n)
/*++

Calculates the upper bound of l(n) via the 8-ary method.

--*/
{
    NTYPE t;
    LPTYPER b, d;
	NTYPE DigitsSeen;
	const char DigitChain[4][16]={
		{-1,  0, -1,  1, -1,  1, -1,  1, -1,  2, -1,  2, -1,  2, -1, 2},
		{-1, -1,  1,  1, -1, -1,  2,  2, -1, -1,  2,  2, -1, -1,  2, 2},
		{-1, -1, -1, -1,  1,  1,  1,  1, -1, -1, -1, -1,  2,  2,  2, 2},
		{-1, -1, -1, -1, -1, -1, -1, -1,  2,  2,  2,  2,  2,  2,  2, 2}};


	DigitsSeen = 0;
	b = 0;
	d = 0;
	for (t = n; t > 0;) {
		if ((t & 1) == 0) {
			t >>= 1;
			continue;
		}
		d = (LPTYPE)(t&7) / 2;
		DigitsSeen |= ((NTYPE)1<<d);
		b++;
		t >>= 3;
	}
	ASSERT (DigitChain[d][DigitsSeen] != -1);
	b += DigitChain[d][DigitsSeen];
    return b - 1;
}

static
LPTYPER
s_upper (NTYPE n)
/*++

Quick upper bound function for s(n). We try binary and 3-ary methods.

n - Target number we wish to calculate s(n) for

--*/
{
    LPTYPER b4, b8;
    b4 = sbin4(n);
	b8 = sbin8(n);
	return min(b4,b8);
}

void
binprint(NTYPE n) {
	if (n > 1) {
		binprint(n/2);
	}
	printf(NTYPE_P, n%2);
}

typedef struct TOKEN_TABLE {
	union {
		char diff[4];
		int all;
	} u;
	char value;
} TOKEN_TABLE;


class lKnown {
	NTYPE Start, End;
	const size_t BufferSize = 1024 * 128;
	unsigned char *Buffer;
	FILE *fp;
	TOKEN_TABLE Lookup[256];
	unsigned int LookupSize;

public:
	lKnown()
	{
		Buffer = new unsigned char[BufferSize];
		if ((fp = fopen("add36.4ln", "rbS")) == NULL) {
			printf("can't open add36.4ln\n");
			exit(0);
		}
		fread(&LookupSize, sizeof(LookupSize), 1, fp);
		if (LookupSize > 256) {
			printf("Bad lookup table size %d\n", LookupSize);
			exit(0);
		}
		for (unsigned int i = 0; i < LookupSize; i++) {
			fread(&Lookup[i].u.all, sizeof(Lookup[i].u.all), 1, fp);
		}
		Start = 0;
		End = 0;
	}
	~lKnown()
	{
		fclose(fp);
	}

	LPTYPE s(NTYPE n)
	{
		if (n < Start || n > End) {
			if (n != End + 1) {
				long long Offset = (n - 1) / 4 + (LookupSize + 1) * 4;
				_fseeki64(fp, Offset, SEEK_SET);
				Start = ((n - 1) & ~(NTYPE)3) + 1;
			} else {
				Start = End + 1;
			}
			size_t len = fread(Buffer, sizeof(Buffer[0]), BufferSize, fp);
			if (len == 0) {
				return -1;
			}
			End = Start + len * 4 - 1;
		}
		NTYPE diff = n - Start;
		unsigned char c = Buffer[diff / 4];
		unsigned int offset = diff % 4;
		if (c >= LookupSize) {
			printf("Bad token %d in data. Max is %d", c, LookupSize - 1);
			DebugBreak();
			exit(0);
		}
		return log2u(bits(n)) + Lookup[c].u.diff[offset];
	}

	LPTYPE l(NTYPE n)
	{
		LPTYPER ln = s(n);
		if (ln != -1) {
			ln += lambda(n);
		}
		return ln;
	}
};

static
void
CheckResults(LPTYPER SmallSteps)
{
	BOOLEAN Bad = FALSE;
	volatile NTYPE BadValue = 0;
	SNTYPE UpperCheck = min(MaxValue, MaxData);
#pragma omp parallel
	{
		lKnown lookup;
		CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;

#pragma omp for schedule(static)
		for (SNTYPE n = 1; n <= UpperCheck; n++) {
			LPTYPE s = lookup.s(n);
			if (s != (LPTYPE)-1) {
				if (IsInBitMap(n)) {
					if (s > SmallSteps) {
						if (Flags & FLAGS_DO_STATS) {
							Bad = TRUE;
							while (1) {
								NTYPE t = BadValue;
								if ((NTYPE)n < t || t == 0) {
									InterlockedCompareExchange64((LONG64 *)&BadValue, n, t);
								} else {
									break;
								}
							}
						} else {
							Lock();
							GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &ConsoleScreenBufferInfo);
							SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_RED);
							printf("Bad value in bitmap " NTYPE_P ". Bit set in map.\n", n);
							SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), ConsoleScreenBufferInfo.wAttributes);
							Unlock();
							//DebugBreak();
						}
					}
				} else {
					if (s <= SmallSteps) {
						if (Flags & FLAGS_DO_STATS) {
							Bad = TRUE;
							while (1) {
								NTYPE t = BadValue;
								if ((NTYPE)n < t || t == 0) {
									InterlockedCompareExchange64((LONG64 *)&BadValue, n, t);
								} else {
									break;
								}
							}
						} else {
							Lock();
							GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &ConsoleScreenBufferInfo);
							SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), BACKGROUND_RED);
							printf("Bad value in bitmap " NTYPE_P ". Bit not set in map.\n", n);
							SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), ConsoleScreenBufferInfo.wAttributes);
							Unlock();
							//DebugBreak();
							//					First = FALSE;
						}
					}
				}
			}
		}
	}
	if (Flags & FLAGS_DO_STATS) {
		if (Bad) {
			printf("Bitmap appears incomplete because of " NTYPE_P "\n", BadValue);
		} else {
			printf("Bitmap appears complete\n");
		}
	}
}

static
VOID
SetInBitMap (NTYPE n)
{
	if (n <= MaxValue) {
		_interlockedbittestandset64((LONG64 *)BitMap, n);
	}
}

static
VOID
ShiftBitmap(LPTYPER SmallSteps)
{
	UCHAR Value;
	NTYPE NewValue;
	SNTYPE j;
	PUCHAR Prev;
	BOOLEAN NeedSameSmall;
	NTYPE Lowest;
	NTYPE StartIndex;

	if (SmallSteps <= 0) {
		return;
	}
	Prev = BitMapArray[SmallSteps - 1];
	if (Prev == NULL) {
		return;
	}

	StartIndex = GetLowestUnsetIndex();
	if (StartIndex > 0) {
		StartIndex--;
	}
	NewValue = 0;
	for (NTYPE i = StartIndex; i < (MaxValue + 1) / CHAR_BIT; i++) {
		Value = Prev[i];
		NewValue = Value | (Value<<1) | (Value<<2) | NewValue;
		BitMap[i] |= (UCHAR)NewValue;
		NewValue >>= CHAR_BIT;
	}

	Lowest = GetLowestUnset();
	{
		for (j = 3; j <= (SNTYPE)MaxValue; j = j * 2 - 1) {
#pragma omp parallel
			{
#pragma omp for schedule(static)
			for (SNTYPE n = ((Lowest + j - 1) / j) * j; n <= (SNTYPE)MaxValue; n += j) {
				if (!IsInBitMap(n)) {
						NTYPE i = n / j;
						if (IsInBitMapEx(Prev, i)) {
							NeedSameSmall = FALSE;
						} else if (IsInBitMap(i)) {
							NeedSameSmall = TRUE;
						} else {
							continue;
						}
						if (!NeedSameSmall || SameLog2(i * (j - 1) * 2, n)) {
							SetInBitMap(n);
						}
					}
				}
			}
		}
	}
}

static
VOID
AddHeuristics(LPTYPER SmallSteps)
{
	SNTYPE StartValue;
	SNTYPE EndValue;
	SNTYPE Lowest;

	Lowest = GetLowestUnset();
	
#pragma omp parallel
	{
#pragma omp for schedule(static)
		for (SNTYPE n = Lowest | 1; n <= (SNTYPE)MaxValue; n += 2) {
			if (!IsInBitMap(n)) {
				if (s_upper(n) <= SmallSteps) {
					SetInBitMap(n);
				}
			}
		}
	}

	for (StartValue = 2; StartValue <= (SNTYPE)MaxValue; StartValue *= 2) {
		EndValue = min((StartValue - 1) * 2, (SNTYPE)MaxValue);
		if (EndValue < Lowest) {
			continue;
		}
#pragma omp parallel
		{
#pragma omp for schedule(static)
			for (SNTYPE n = StartValue; n <= EndValue; n += 2) {
				if (!IsInBitMap(n)) {
					if (IsInBitMap(n / 2)) {
						SetInBitMap(n);
					}
				}
			}
		}
	}
}

static
NTYPE
MinimumNumber(LPTYPER ll2, LPTYPER SmallSteps)
{
	NTYPE Value;
	if (ll2 > 2 * SmallSteps) {
		Value = ((NTYPE)1 << (ll2 - SmallSteps)) + ((NTYPE)1 << SmallSteps) - 1;
	} else if (ll2 >= SmallSteps) {
		Value = ((NTYPE)1 << (ll2 - SmallSteps + 1)) - 1;
	} else {
		Value = ll2 + 1;
	}
	return max(Value, ll2 + 1);
}

static
LPTYPER
PopulateMax (PVERTEX Vertex, LPTYPER Depth, LPTYPER SmallSteps, BOOLEAN ForceMaxV, PSTAT Stat)
{
	LPTYPER i;
	Vertex[Depth].min = MinimumNumber(Depth, SmallSteps);
	Vertex[Depth].min = max(Vertex[Depth].min, MIN_VALUE);
	for (i = Depth; i-- > 0;) {
		Vertex[i].min = ((Vertex[i+1].min + 1) / 2);
		ASSERT(Vertex[i].min <= MaxValue);
		ASSERT(Vertex[i].min <= MinimumNumber(i, SmallSteps));
	}

	while (Vertex[Depth].min > MaxValue) {
		Depth--;
		MinValuesSize--;
		Vertex[Depth].min = max(Vertex[Depth].min, MIN_VALUE);
	}

#if !defined (QUIET)
	for (i = Depth+1; i-- > 0;) {
		printf (NTYPE_P " ", Val[i].min);
	}
	printf ("\n");
#endif
	for (i = 0; i <= Depth; i++) {
		MinValues[i] = max(MinValues[i], Vertex[i].min);
	}

	for (i = 0; i <= Depth; i++) {
		if (i < SmallSteps) {
			Vertex[i].maxv = 0;
		} else {
			Vertex[i].maxv = min(((NTYPE)1<<(i - SmallSteps + 1)) - 1, MaxValue);
		}
	}
	ScanMin (Vertex, Depth, ForceMaxV, Stat);

	return Depth;
}

static
void
BitMaskSet(BITMASK &BitMask, NTYPE Bit)
{
	ASSERT(Bit >= 0 && Bit <= 63);
	BitMask.Mask |= (ULONG64)1 << Bit;
	//_bittestandset64((LONG64 *)&BitMask.Mask, Bit);
}

static
void
BitMaskClear(BITMASK &BitMask, NTYPE Bit)
{
	ASSERT(Bit >= 0 && Bit <= 63);
	ASSERT(BitMask.Mask & ((NTYPE)1<<Bit));
	BitMask.Mask &= ~((NTYPE)1<<Bit);
}

static
BOOLEAN
BitMaskFindHighestBelow(BITMASK BitMask, LPTYPER Highest, LPTYPER *hv)
{
	DWORD Index;
	LONG64 Mask, ClearMask;

	ASSERT(Highest >= 0 && Highest <= 63);
	ClearMask = ((NTYPE)1<<Highest)-1;
	Mask = BitMask.Mask & ClearMask;
	if (_BitScanReverse64(&Index, Mask)) {
		ASSERT(Index >= 0 && Index < Highest);
		*hv = (LPTYPE)Index;
		return TRUE;
	} else {
		return FALSE;
	}
}

static
BOOLEAN
BitMaskFindHighest(BITMASK BitMask, LPTYPER *hv)
{
	DWORD Index;

	if (_BitScanReverse64(&Index, BitMask.Mask)) {
		ASSERT(Index >= 0);
		*hv = (LPTYPER)Index;
		return TRUE;
	} else {
		return FALSE;
	}
}

static
bool
GetNext(PVERTEX NextVertex, NTYPE NextValue, LPTYPER Index, LPTYPER &pRefs, NTYPE &pRefsTotal, LPTYPER &pLess, NTYPE &pLessTotal,
	    BITMASK &pBitMask, NTYPE &pTotal, PVERTEX Vertex, LPTYPER c, LPTYPER Depth)
{
	pTotal = pTotal + NextValue;
	REFTYPE NewRefs = NextVertex->Refs + 1;
	if (NewRefs <= 0) {
		if (NewRefs == 0) {
			BitMaskClear(pBitMask, Index);
		}
		ASSERT(pRefs > 0);
		pRefs = pRefs - 1;
		pRefsTotal = pRefsTotal - NextValue;
	} else if (NextValue <= pLessTotal) {
		ASSERT(pLess == 1);
		ASSERT(pLessTotal > 0);
		pLess = 0;
		pLessTotal = 0;
	} 
	LPTYPER EndC = c + pRefs + pLess;
	ASSERT(EndC <= Depth);
	if (pTotal + pRefsTotal + pLessTotal < Vertex[EndC].min) {
		return FALSE;
	}
	NextVertex->Refs = NewRefs;
	return TRUE;
}

static
bool
StartGetNext(PVERTEX NextVertex, NTYPE NextValue, LPTYPER Index, LPTYPER &pRefs, NTYPE &pRefsTotal, LPTYPER &pLess, NTYPE &pLessTotal,
	BITMASK &pBitMask, NTYPE &pTotal, PVERTEX Vertex, LPTYPER c, LPTYPER Depth)
{
	pTotal = NextValue;
	REFTYPE NewRefs = NextVertex->Refs + 1;
	if (NewRefs <= 0) {
		if (NewRefs == 0) {
			BitMaskClear(pBitMask, Index);
		}
		ASSERT(pRefs > 0);
		pRefs = pRefs - 1;
		pRefsTotal = pRefsTotal - NextValue;
	} else if (NextValue <= pLessTotal) {
		ASSERT(pLess == 1);
		ASSERT(pLessTotal > 0);
		pLess = 0;
		pLessTotal = 0;
	}
	LPTYPER EndC = c + pRefs + pLess - 1;
	ASSERT(EndC <= Depth);
	if (NextValue + pRefsTotal + pLessTotal < Vertex[EndC].min) {
		return FALSE;
	}
	NextVertex->Refs = NewRefs;
	return TRUE;
}

static
void
RemRef(PVERTEX Vertex)
{
	Vertex->Refs--;
}

static
bool
ReadAndQueueWork(FILE *fp, LPTYPER Depth, PVERTEX Vertex)
{
	int tDepth, tc, tRefs, tvc, tSmallSteps, tLess;
	NTYPE tRefsTotal, tLessTotal, tBitMask;
	BITMASK BitMask;
	if (fscanf_s(fp, "%d %d %d %d %d %d ", &tDepth, &tc, &tRefs, &tvc, &tSmallSteps, &tLess) == EOF) {
		return false;
	}
	if (tDepth != Depth) {
		printf("Bad depth count of %d should be " LPTYPER_P " in saved work file\n", tDepth, Depth);
		exit(0);
	}
	if (tc < 0 || tc > (int)Depth) {
		printf("Bad c = %d\n", tc);
		exit(0);
	}
	if (tRefs < 0) {
		printf("Bad Refs = %d\n", tRefs);
		exit(0);
	}
	if (tLess < 0 || tLess > 1) {
		printf("Bad Less = %d\n", tRefs);
		exit(0);
	}
	fscanf_s(fp, NTYPE_P " " NTYPE_P " " NTYPE_P " ", &tRefsTotal, &tLessTotal, &tBitMask);
	for (LPTYPER i = 0; i < (LPTYPER)tvc; i++) {
		NTYPE tn;
		int tDoubling, tMultiple, tRefs1;
		fscanf_s(fp, NTYPE_P " %d %d %d ", &tn, &tRefs1, &tDoubling, &tMultiple);
		Vertex[i].n = tn;
		Vertex[i].Refs = tRefs1;
		Vertex[i].Doubling = tDoubling;
		Vertex[i].Multiple = tMultiple;
	}
	fscanf(fp, "\n");
	BitMask.Mask = tBitMask;
	QueueWork(tc, Vertex, tvc, tDepth, tRefs, tRefsTotal, tLess, tLessTotal, BitMask);
	return true;
}

static
void
ReadOldWork(LPTYPER Depth, PVERTEX Vertex, LPTYPER SmallSteps)
{
	FILE *fp;
	fp = fopen("SavedWork.txt", "rS");
	if (fp == nullptr) {
		printf("Failed to open SavedWork.txt to load old work\n");
		exit(0);
	}
	while (ReadAndQueueWork(fp, Depth, Vertex)) {
	}
	fclose(fp);

	ReadMinValues(false);
}

static
void
NewValue(PVERTEX Vertex, NTYPE n, LPTYPER Slot, LPTYPER Depth, LPTYPE vc);

static
void
NewValueFound(PVERTEX Vertex, NTYPE n, LPTYPER Slot, LPTYPER Depth, LPTYPE vc)
{
	NTYPE n1, no;
	LPTYPER j;

	//ULONG Index = InterlockedIncrement(&HardValuesIndex) & (MAX_HARD_VALUES - 1);
	//HardValues[Index] = n;

	ASSERT (n <= MaxValue);
	__assume(n <= MaxValue);
	if (n <= MaxValue /2) {
		no = n * 2;
		Vertex[vc + 1].n = no;
		NewValue(Vertex, no, Slot + 1, Depth, vc + 1);
		no = no * 2;
		for (j = 3; j <= MaxValue / no; j = j * 2 - 1) {
			n1 = n * j;
			if (SameLog2(n1, no)) {
				Vertex[vc + 1].n = n1;
				NewValue(Vertex, n1, Slot + lambda(j) + 1, Depth, vc + 1);
				no = no * 2;
			} else {
				break;
			}
		}
	}
	ASSERT(Slot <= Depth);
	if (Vertex[Slot].min == n) {
        if (ScanMin (Vertex, Depth, FALSE, nullptr)) {
			SignalUpdateMin();
	    }
	}
}

int BuildVertexPaths(VAL Val[], int VertexEnd, int VertexStart, int PathVertexList[], int PathVertexListIndex, int PathVertexListLength, bitset<MAX_VERTEX> &VertexSet)
{
	if (VertexEnd < VertexStart) {
		return 0;
	} else if (VertexEnd == VertexStart) {
		for (int i = 0; i < PathVertexListIndex; i++) {
			VertexSet.set(PathVertexList[i]);
		}
		return 1;
	} else {
		if (PathVertexListIndex >= PathVertexListLength) {
			std::printf("Overflow of PathVertexList\n");
			exit(0);
		}
		PathVertexList[PathVertexListIndex] = Val[VertexEnd].i;
		int Paths = BuildVertexPaths(Val, Val[VertexEnd].i, VertexStart, PathVertexList, PathVertexListIndex + 1, PathVertexListLength, VertexSet);
		if (Val[VertexEnd].i == Val[VertexEnd].j) {
			Paths *= 2;
		} else {
			if (Paths <= 1 || !VertexSet.test(Val[VertexEnd].j)) {
				PathVertexList[PathVertexListIndex] = Val[VertexEnd].j;
				Paths += BuildVertexPaths(Val, Val[VertexEnd].j, VertexStart, PathVertexList, PathVertexListIndex + 1, PathVertexListLength, VertexSet);
			}
		}
		return Paths;
	}
}

typedef struct _DISJOINT_VERTEX {
	LPTYPE VertexA, VertexB;
} DISJOINT_VERTEX, *PDISJOINT_VERTEX;

BOOLEAN
WalkVertex(VAL Val[], LPTYPE d, bitset<MAX_VERTEX> &DisjointVertex)
{
	LPTYPE v;
	if (d > 0) {
		v = Val[d].i;
		bool WasSet = DisjointVertex.test(v);
		DisjointVertex.set(v, false);
		if (DisjointVertex.any()) {
			if (WasSet) {
				WalkVertex(Val, v, DisjointVertex);
			}
			v = Val[d].j;
			WasSet = DisjointVertex.test(v);
			if (WasSet) {
				DisjointVertex.set(v, false);
				if (DisjointVertex.any()) {
					WalkVertex(Val, v, DisjointVertex);
				} else {
					return FALSE;
				}
			}
		} else {
			return FALSE;
		}
	}
	return TRUE;
}

void FindDisjointVerticies(VAL Val[], LPTYPE d, vector<DISJOINT_VERTEX> &DisjointVertexList)
{
	DisjointVertexList.clear();
	for (LPTYPE i = 1; i <= d; i++) {
		bitset<MAX_VERTEX> DisjointVertex = bitset<MAX_VERTEX>();
		for (LPTYPE j = 0; j < i; j++) {
			DisjointVertex.set(j);
		}
		if (!WalkVertex(Val, i, DisjointVertex)) {
			continue;
		}
		for (LPTYPE j = 0; j < i; j++) {
			if (DisjointVertex.test(j)) {
				DISJOINT_VERTEX dj;
				dj.VertexA = i;
				dj.VertexB = j;
				DisjointVertexList.push_back(dj);
			}
		}
	}
}

bool SearchForConflict(vector<bitset<MAX_VERTEX>> &VertexSets, bitset<MAX_VERTEX> &NonZeroSet, vector<DISJOINT_VERTEX> &DisjointVertexList)
{
	for (bitset<MAX_VERTEX> VertexSet : VertexSets) {
		if ((VertexSet & NonZeroSet).any()) {
			continue;
		}
		for (LPTYPER NewVertex = 0; NewVertex < MAX_VERTEX; NewVertex++) {
			if (VertexSet.test(NewVertex)) {
				NonZeroSet.set(NewVertex);
				bool Worked = SearchForConflict(VertexSets, NonZeroSet, DisjointVertexList);
				NonZeroSet.set(NewVertex, false);
				if (Worked) {
					return true;
				}
			}
		}
		return false;
	}
	for (DISJOINT_VERTEX dv : DisjointVertexList) {
		if (NonZeroSet.test(dv.VertexA) && NonZeroSet.test(dv.VertexB)) {
			return false;
		}
	}
	return true;
}

bool CheckChain(PVAL Val, LPTYPE c)
{
	c--;
	vector<DISJOINT_VERTEX> DisjointVertexList;
	FindDisjointVerticies(Val, c, DisjointVertexList);
	if (DisjointVertexList.size() == 0) {
		return true;
	}

	vector<bitset<MAX_VERTEX>> VertexSets = vector<bitset<MAX_VERTEX>>();
	for (LPTYPE start = 0; start < c - 1; start++) {
		for (LPTYPE end = start + 1; end <= c; end++) {
			bitset<MAX_VERTEX> VertexSet = bitset<MAX_VERTEX>();
			int PathVertexList[MAX_CHAIN];
			LPTYPE t = BuildVertexPaths(Val, end, start, PathVertexList, 0, MAX_CHAIN, VertexSet);

			if (t <= 1) {
				continue;
			}
			bool found = false;
			for (LPTYPE Vertex = 0; Vertex < c; Vertex++) {
				if (VertexSet.test(Vertex)) {
					found = false;
					for (DISJOINT_VERTEX dv : DisjointVertexList) {
						if (Vertex == dv.VertexA || Vertex == dv.VertexB) {
							found = true;
							break;
						}
					}
					if (!found) {
						break;
					}
				}
			}
			if (found) {
				VertexSets.push_back(VertexSet);
			}
		}
	}
	bitset<MAX_VERTEX> NonZeroSet;
	return SearchForConflict(VertexSets, NonZeroSet, DisjointVertexList);
}

bool
FindChains(PVAL Val, LPTYPE c, PVERTEX Vertex, LPTYPE vc, NTYPE n)
{
	bool RetVal = false;
	for (int i = c - 1; i >= 0; i--) {
		for (int j = i; j >= 0; j--) {
			NTYPE t = Val[i].n + Val[j].n;
			if (t < Val[c].minv) {
				if (i == j) {
					return RetVal;
				}
				break;
			}
			if (t > Vertex[vc].n) {
				continue;
			}
			Val[c].n = t;
			Val[c].i = i;
			Val[c].j = j;
			LPTYPE newvc = vc;
			if (t == Vertex[vc].n) {
				newvc++;
				if (t == n) {
					RetVal = CheckChain(Val, c + 1);
					if (RetVal) {
						return RetVal;
					}
					Lock();
					static NTYPE x = -1;
					if (n < x) {
						x = n;
						for (int i = 0; i <= c; i++) {
							if (i == 0 || i == c) {
								printf(NTYPE_P " ", Val[i].n);
							} else {
								printf(NTYPE_P "*" NTYPE_P " ", Val[i].n, Val[Val[i].i].n);
							}
						}
						printf("\n");
					}
					Unlock();
					continue;
				}
			}
			RetVal = FindChains(Val, c + 1, Vertex, newvc, n);
			if (RetVal) {
				return RetVal;
			}
		}
	}
	return RetVal;
}

void AddLimits(PVAL Val, LPTYPER Slot, NTYPE n)
{
	LPTYPER i;
	NTYPE t, divisor;
	NTYPE lastRemainder, remainder, lastDivisor;

	i = Slot;
	t = n;
	if (Val[i].minv < n) {
		Val[i].minv = n;
	}
	while ((t & 1) == 0) {
		if (i == 0) {
			return;
		}
		i--;
		t = t / 2;
		if (Val[i].minv < t) {
			Val[i].minv = t;
		}
	}

	divisor = 2;
	lastRemainder = 1;
	while (i-- > 0) {
		remainder = t % divisor;
		NTYPE nm;
		if (lastRemainder == 0) {
			lastDivisor *= 2;
			nm = (t + lastDivisor - 1) / lastDivisor;
		} else {
			nm = (t + divisor - 1) / divisor;
		}
		nm = max(nm, i + 1);
		if (Val[i].minv < nm) {
			Val[i].minv = nm;
		}
		lastRemainder = remainder;
		lastDivisor = divisor;
		divisor = 2 * divisor - 1;
	}
	return;

}

bool AnalyzeChain(PVERTEX Vertex, NTYPE n, LPTYPER Slot, LPTYPE vc)
{
	if (Vertex[vc].n != n) {
		DebugBreak();
	}
	bool RetVal = true;
	PVAL Val = new _VAL[Slot + 1];
	for (int i = 0; i <= Slot; i++) {
		Val[i].minv = 0;
	}
	NTYPE t = n;
	for (int i = Slot; (int)i >= 0; i--) {
		if (vc > 0 && Val[i].minv <= Vertex[vc].n) {
			AddLimits(Val, i, Vertex[vc].n);
			vc--;
		}
	}
	Val[0].n = 1;
	RetVal = FindChains(Val, 1, Vertex, 2, n);
	if (!RetVal) {
		Lock();
		static int st = 0;
		if (st++ < 10) {
			printf(NTYPE_P "\n", n);
		}
		Unlock();
	}
	delete[] Val;
	return RetVal;
}

static
void
NewValue(PVERTEX Vertex, NTYPE n, LPTYPER Slot, LPTYPER Depth, LPTYPE vc)
{
	ASSERT(n <= MaxValue);
	__assume(n <= MaxValue);
	if (!IsInBitMap(n)) {
		//if (!AnalyzeChain(Vertex, n, Slot, vc)) {
		//	return;
		//}
		SetInBitMap(n);
		NewValueFound(Vertex, n, Slot, Depth, vc);
	}
}

typedef enum {
	MULTIPLE_NONE            = 0,
	MULTIPLE_SINGLE          = 1,
	MULTIPLE_DOUBLE          = 2,
	MULTIPLE_DOUBLING_LOCKED = 3,
	MULTIPLE_USED            = 4
} MULTIPLE, *PMULTIPLE;

static
NTYPE
SumBitMap() {
	NTYPE Total = 0, i;
	for (i = 1; i < (MaxValue + 1) / 8; i++) {
		Total += bits(BitMap[i]);
	}
	return Total;
}

static
BOOLEAN
HandleSignal(LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
	  	     LPTYPER Refs, NTYPE RefsTotal, LPTYPER Less, NTYPE LessTotal, BITMASK BitMask) {
	ULONG Value;
	BOOLEAN RetVal;

	RetVal = FALSE;
	Value = ThreadCtx[ThreadId].ThreadSignal;
	if (((Value&THREAD_SIGNAL_SPLIT) != 0 && c + MIN_SPLIT_DEPTH <= Depth) || vc < MIN_VC_SPLIT) {
		QueueWork (c, Vertex, vc, Depth, Refs, RefsTotal, Less, LessTotal, BitMask);
		RetVal = TRUE;
	} else if ((Value&THREAD_SIGNAL_UPDATE_MIN) != 0) {
		InterlockedAnd((LONG *)&ThreadCtx[ThreadId].ThreadSignal, ~THREAD_SIGNAL_UPDATE_MIN);
		ScanMin(Vertex, Depth, FALSE, nullptr);
	}
	return RetVal;
}

void PrintChain(LPTYPER SmallSteps, LPTYPER c, PVERTEX Vertex, LPTYPER vc)
{
	LPTYPER i, j;
	Lock();
	printf(LPTYPER_P " " LPTYPER_P ") ", c, SmallSteps);
	for (i = 0, j = 0; i < vc; i++) {
		printf(NTYPE_P, Vertex[i].n);
	}
	printf("\n");
	Unlock();
}

BOOLEAN
Search(NTYPE Values[], LPTYPER c, LPTYPER Depth, NTYPE Match[], LPTYPE mc)
{
	LPTYPE i, j;
	if (c >= Depth) {
		return FALSE;
	}
	for (i = 0; i < c; i++) {
		for (j = 0; j <= i; j++) {
			Values[c] = Values[i] + Values[j];
			if (Values[c] <= Values[c-1]) {
				continue;
			}
			if (Values[c] > Match[0]) {
				continue;
			} else if (Values[c] == Match[0]) {
				if (mc == 1) {
					return TRUE;
				}
				if (Search(Values, c + 1, Depth, &Match[1], mc - 1)) {
					return TRUE;
				}
			} else {
				if (Search(Values, c + 1, Depth, Match, mc)) {
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

static
NTYPE
CalcLimit(NTYPE LastValue, NTYPE Total, PVERTEX Vertex, LPTYPER c, LPTYPER Depth)
{
	ULONG r;
	NTYPE minv;
	LPTYPER Index = c;
	PVERTEX NextVal;

	ASSERT(Index <= Depth);
	NextVal = &Vertex[Index];
	if (Total >= LastValue && Total >= NextVal->minv) {
		return 1;
	}
	if (LastValue < NextVal->minv) {
		ASSERT(NextVal->minv > Total);
		return NextVal->minv - Total;
	}
	//
	// Since we had two refs on LastValue we have 2*LastValue <= MaxValue
	// If LastValue could live in Vertex[Index] then Index + 1 <= Depth

	NextVal++;
	Index++;
	ASSERT(Index <= Depth);
	if (LastValue < NextVal->minv) {
		return min((NextVal->minv + 1 - Total) / 2, LastValue - Total);
	}

	r = 3;
	NextVal++;
	Index++;
	ASSERT(Index <= Depth);
	while (LastValue >= NextVal->minv) {
		Index++;
		NextVal++;
		r++;
		ASSERT(Index <= Depth);
	}
	ASSERT(NextVal->minv > Total);
	ASSERT(LastValue > Total);
	minv = min((NextVal->minv + r - 1 - Total) / r, (LastValue + r - 2 - Total) / (r - 1));
	return minv;
}


static
NTYPE
CalcLimitStart(NTYPE LastValue, PVERTEX Vertex, LPTYPER c, LPTYPER Depth)
{
	ULONG r;
	NTYPE minv;
	LPTYPER Index = c;
	PVERTEX NextVal;

	// Refs must be >= 2 so Vertex[c] must be valid.
	ASSERT(Index <= Depth);
	NextVal = &Vertex[Index];
	if (LastValue < NextVal->minv) {
		return (NextVal->minv + 1) / 2;
	}

	// LastValue >= NextVal->minv and since Refs >= 2 we have 2*LastValue <= MaxValue
	// So we must be able to Look at the next slot with checking Index against Depth.
	r = 3;
	Index++;
	NextVal++;
	ASSERT(Index <= Depth);
	while (LastValue >= NextVal->minv) {
		Index++;
		r++;
		NextVal++;
		ASSERT(Index <= Depth);
	}
	minv = min((NextVal->minv + r - 1) / r, (LastValue + 1 + r - 2) / (r - 1));
	return minv;
}

static
LPTYPER FindLess(PVERTEX Vertex, LPTYPER hv, NTYPE LessTotal)
{
	LPTYPER low = 1;
	LPTYPER mid;

	if (Vertex[hv].n <= LessTotal) {
		return hv;
	}
	while (1) {
		mid = (low + hv) / 2;
		if (Vertex[mid].n < LessTotal) {
			low = mid;
		} else if (Vertex[mid].n > LessTotal) {
			hv = mid;
		} else {
			return mid;
		}
	}
}

static
void
ValidateRefs(PVERTEX Vertex, LPTYPER vc, LPTYPER Refs, NTYPE RefsTotal, BITMASK BitMask)
{
#if _DEBUG
	LPTYPE tRefs;
	NTYPE tRefsTotal;
	BITMASK tBitMask;
	LPTYPE i;

	tRefs = 0;
	tRefsTotal = 0;
	tBitMask.Mask = 0;
	for (i = 0; i < vc; i++) {
		if (Vertex[i].Refs < 0) {
			tRefs += -Vertex[i].Refs;
			tRefsTotal += -Vertex[i].Refs * Vertex[i].n;
			BitMaskSet(tBitMask, i);
		}
	}
	ASSERT(tRefs == Refs);
	ASSERT(tRefsTotal == RefsTotal);
	ASSERT(tBitMask.Mask == BitMask.Mask);
#endif
}

static
void
RecurseInterVertex (LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
		 LPTYPER Refs, NTYPE RefsTotal, LPTYPER hv, MULTIPLE Multiple, NTYPE Total,
		 LPTYPER Less, NTYPE LessTotal, BITMASK BitMask);

static
void
DoForcedReferences(PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
		           NTYPE Total, NTYPE RefsTotal, LPTYPER Less, NTYPE LessTotal)
{
	LPTYPER hv;
	NTYPE LastTotal;

	LastTotal = Total + RefsTotal;
	if (Less == 0) {
		if (CanBeClearInBitMap(Vertex[Depth], LastTotal)) {
			Vertex[vc].n = LastTotal;
			NewValue(Vertex, LastTotal, Depth, Depth, vc);
		}
		return;
	}

	hv = FindLess(Vertex, vc - 1, LessTotal);
	ASSERT(Vertex[hv].n == LessTotal);
	for (LPTYPER LastVertex = hv; (SLPTYPER)LastVertex >= 0; LastVertex--) {
		NTYPE FinalTotal = LastTotal + Vertex[LastVertex].n;
		if (FinalTotal < Vertex[Depth].minv) {
			return;
		}
		if (CanBeClearInBitMap(Vertex[Depth], FinalTotal)) {
			Vertex[vc].n = FinalTotal;
			NewValue(Vertex, FinalTotal, Depth, Depth, vc);
		}
	}
}

static
void
DoForcedReferencesFromVertex(PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
                             NTYPE RefsTotal, LPTYPER Less, NTYPE LessTotal)
{
	DoForcedReferences(Vertex, vc, Depth, 0, RefsTotal, Less, LessTotal);
}

static
void
RecurseInterVertex (LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
		 LPTYPER Refs, NTYPE RefsTotal, LPTYPER hv, MULTIPLE Multiple, NTYPE Total,
		 LPTYPER Less, NTYPE LessTotal, BITMASK BitMask)
{
	PVERTEX NextVertex;
	NTYPE Limit;
	BOOLEAN OldMultiple, AddSumWorked;
	BITMASK VcMask;

	ASSERT(c + Refs + Less - 1 <= Depth);
	if (c + Refs + Less - 1 == Depth) {
		if ((BitMask.Mask>>(hv + 1)) == 0) {
			DoForcedReferences(Vertex, vc, Depth, Total, RefsTotal, Less, LessTotal);
		}
		return;
	}
	VcMask.Mask = (NTYPE)1<<vc;
	ASSERT (c <= Depth);
	ASSERT (vc-1 <= Depth);
	Limit = CalcLimit(Vertex[vc - 1].n, Total, Vertex, c, Depth);
	NextVertex = &Vertex[hv];
	NTYPE NextValue = NextVertex->n;
	AddSumWorked = TRUE;
	LPTYPER NewC = c + 1;
	while (1) {
		NTYPE NewRefsTotal;
		LPTYPER NewRefs;
		BITMASK NewMask;
		NTYPE NewTotal;
		LPTYPER NewHv;

		if (NextValue < Limit) {
			break;
		}
		if ((Multiple >= MULTIPLE_DOUBLE && Multiple != MULTIPLE_USED) && NextVertex->Doubling) {
			goto next;
		}
		NewMask = BitMask;
		NewRefs = Refs;
		NewRefsTotal = RefsTotal;
		NewTotal = Total;
		if (GetNext(NextVertex, NextValue, hv, NewRefs, NewRefsTotal, Less, LessTotal, NewMask, NewTotal, Vertex, c, Depth)) {
			if (NewTotal + NewRefsTotal <= MaxValue) {
				MULTIPLE NewMultiple;
				if (Multiple <= MULTIPLE_DOUBLE) {
					NewMultiple = (MULTIPLE)((int)Multiple + 1);
				} else {
					NewMultiple = Multiple;
				}
				OldMultiple = NextVertex->Multiple;
				if (NewMultiple == MULTIPLE_DOUBLE) {
					NextVertex->Multiple = TRUE;
				}

				if (Vertex[vc - 1].n < NewTotal) {
					NTYPE NewVertexRefsTotal;
					LPTYPER NewVertexRefs;
					BITMASK NewVertexMask;
					ASSERT (vc <= Depth);
					Vertex[vc].n = NewTotal;
					Vertex[vc].Refs = -2;
					Vertex[vc].Doubling = (NextValue * 2 == NewTotal);
					Vertex[vc].Multiple = FALSE;
					if (NewRefs + Less == 0 && CanBeClearInBitMap(Vertex[NewC - 1], NewTotal)) {
						NewValue(Vertex, NewTotal, NewC - 1, Depth, vc);
					}
					NewVertexRefsTotal = NewRefsTotal + 2 * NewTotal;
					NewVertexRefs = NewRefs + 2;
					ASSERT(NewC + NewRefs + Less == NewC + NewVertexRefs + Less - 2);
					ASSERT((((NTYPE)0)-1) > MaxValue * 3); // No overflow check needed
					if (NewVertexRefsTotal <= MaxValue && NewC + NewRefs + Less <= Depth) {
						if (NewVertexRefsTotal + LessTotal >= Vertex[NewC + NewRefs + Less].min) {
							ASSERT(NewC + NewRefs == NewC + NewVertexRefs - 2);
							if (NewC + NewRefs + Less == Depth) {
								DoForcedReferencesFromVertex(Vertex, vc + 1, Depth,
									                         NewVertexRefsTotal, Less, LessTotal);
							} else {
								ASSERT(NewC + NewRefs + Less < Depth);
								NewVertexMask.Mask = NewMask.Mask | VcMask.Mask;
								ValidateRefs(Vertex, vc + 1, NewVertexRefs, NewVertexRefsTotal, NewVertexMask);
								Recurse(NewC, Vertex, vc + 1, Depth, NewVertexRefs, NewVertexRefsTotal, Less, LessTotal, NewVertexMask, false);
							}
						}
					}
				}
				if (NewC <= Depth) {
					NewHv = hv;
					if (NewMultiple >= MULTIPLE_DOUBLING_LOCKED || OldMultiple) {
						ASSERT(NewMultiple >= MULTIPLE_DOUBLING_LOCKED || NewMultiple == MULTIPLE_SINGLE);
						if (NewMultiple == MULTIPLE_SINGLE) {
							NewMultiple = MULTIPLE_NONE;
						}
						if (hv == 0) {
							goto SkipRecurse;
						}
						NewHv = hv - 1;
					}
					RecurseInterVertex(NewC, Vertex, vc, Depth, NewRefs, NewRefsTotal, NewHv, NewMultiple, NewTotal, Less, LessTotal, NewMask);
				SkipRecurse:;
				}
				NextVertex->Multiple = OldMultiple;
			}
			RemRef(NextVertex);
		} else {
			AddSumWorked = FALSE;
		}
		ValidateRefs(Vertex, vc, Refs, RefsTotal, BitMask);

next:
		if (hv == 0) {
			break;
		}
		if (Multiple > MULTIPLE_SINGLE) {
			if (Multiple != MULTIPLE_USED) {
				Multiple = MULTIPLE_DOUBLING_LOCKED;
			}
		} else if (Multiple == MULTIPLE_SINGLE && NextVertex->Doubling) {
			Multiple = MULTIPLE_USED;
		} else {
			Multiple = MULTIPLE_NONE;
		}
		if (AddSumWorked) {
			hv--;
			NextVertex--;
		} else {
			if (!BitMaskFindHighestBelow(BitMask, hv, &hv)) {
				if (Less == 0) {
					break;
				}
				hv = FindLess(Vertex, hv - 1, LessTotal);
				AddSumWorked = TRUE;
			}

			ASSERT(hv >= 0 && hv <= Depth);
			NextVertex = &Vertex[hv];
		}
		NextValue = NextVertex->n;
	}
}

static
void
Recurse(LPTYPER c, PVERTEX Vertex, LPTYPER vc, LPTYPER Depth,
	    LPTYPER Refs, NTYPE RefsTotal, LPTYPER Less, NTYPE LessTotal, BITMASK BitMask, bool TopLevel)
{
	LPTYPER hv;
	NTYPE Limit;
	PVERTEX NextVertex;
	NTYPE Total;
	NTYPE Solutions;
	BOOLEAN RetVal;
	BOOLEAN StartSumWorked;
	MULTIPLE NewMultiple;
	BOOLEAN Offset = FALSE;

	Solutions = 0;
	if (!TopLevel) {
		if (ThreadCtx[ThreadId].ThreadSignal != 0 || vc < MIN_VC_SPLIT) {
			RetVal = HandleSignal(c, Vertex, vc, Depth, Refs, RefsTotal, Less, LessTotal, BitMask);
			if (RetVal) {
				return;
			}
		}
	}

	if (vc >= 3) {
		if (Vertex[vc - 2].n == Vertex[vc - 3].n * 3 && Vertex[vc - 2].Refs == 1) {
			if ((Vertex[vc - 1].n == Vertex[vc - 2].n * 3 && Vertex[vc - 3].Refs == 1) ||
				(Vertex[vc - 1].n == Vertex[vc - 3].n * 10 && Vertex[vc - 3].Refs == 2)) {
				ASSERT(LessTotal <= Vertex[vc - 3].n);
				Refs++;
				RefsTotal += Vertex[vc - 2].n;
				if (RefsTotal > MaxValue) {
					return;
				}
				Vertex[vc - 2].Refs -= 2;
				BitMaskSet(BitMask, vc - 2);
				Offset = TRUE;
			}
		}
	}

	if (Refs == 2 && Less == 0 && Vertex[vc - 1].n > 3) {
		Less = 1;
		LessTotal = Vertex[vc - 1].n;
	}
	ValidateRefs(Vertex, vc, Refs, RefsTotal, BitMask);

	hv = vc - 1;
	ASSERT(c <= Depth);
	NextVertex = &Vertex[hv];

	NTYPE NextValue = NextVertex->n;
	if (c + Refs + Less - 2 == Depth) {
		if (RefsTotal + LessTotal >= Vertex[Depth].min) {
			DoForcedReferencesFromVertex(Vertex, vc, Depth, RefsTotal, Less, LessTotal);
		}
		goto RevertOffset;
	}
	if (Vertex[c + Refs - 1].min > 2 * (RefsTotal - NextValue)) {
		Limit = NextValue;
	} else {
		ASSERT(Refs >= 2);
		Limit = CalcLimitStart(NextValue, Vertex, c, Depth);
	}

	StartSumWorked = TRUE;
	while (1) {
		BITMASK NewMask;
		LPTYPER NewRefs;
		NTYPE NewRefsTotal;
		LPTYPER NewHv;

		ValidateRefs(Vertex, vc, Refs, RefsTotal, BitMask);
		NewMask = BitMask;
		NewRefs = Refs;
		NewRefsTotal = RefsTotal;
		if (StartGetNext(NextVertex, NextValue, hv, NewRefs, NewRefsTotal, Less, LessTotal, NewMask,
			             Total, Vertex, c, Depth)) {
			if (Total + NewRefsTotal <= MaxValue) {
				if (NextVertex->Multiple) {
					NewHv = hv - 1;
					if ((SLPTYPER)NewHv < 0) {
						goto SkipRecurse;
					}
					if (NextVertex->Doubling) {
						NewMultiple = MULTIPLE_USED;
					} else {
						NewMultiple = MULTIPLE_NONE;
					}
				} else {
					NewHv = hv;
					NewMultiple = MULTIPLE_SINGLE;
				}
				RecurseInterVertex(c, Vertex, vc, Depth, NewRefs, NewRefsTotal, NewHv, NewMultiple, Total, Less, LessTotal, NewMask);
			SkipRecurse:;
			}
			RemRef(NextVertex);
		} else {
			StartSumWorked = FALSE;
		}
		ValidateRefs(Vertex, vc, Refs, RefsTotal, BitMask);
		if (hv == 0) {
			break;
		}
		if (StartSumWorked) {
			hv--;
			NextVertex--;
		} else {
			if (!BitMaskFindHighestBelow(BitMask, hv, &hv)) {
				if (Less == 0) {
					break;
				}
				hv = FindLess(Vertex, hv - 1, LessTotal);
				StartSumWorked = TRUE;
			}
			ASSERT(hv >= 0 && hv <= Depth);
			NextVertex = &Vertex[hv];
		}
		NextValue = NextVertex->n;
		if (NextValue < Limit) {
			break;
		}
	}
RevertOffset:;
	if (Offset) {
		Vertex[vc-2].Refs += 2;
		Refs--;
		RefsTotal -= Vertex[vc-2].n;
		BitMaskClear(BitMask, vc - 2);
	}
}

void
CalcRefsEtc(PVERTEX Vertex, LPTYPER vc, LPTYPER *pRefs, NTYPE *pRefsTotal, BITMASK *pBitMask)
{
	LPTYPER Refs, i, Multiple;
	NTYPE RefsTotal;
	BITMASK BitMask;
	Refs = 0;
	RefsTotal = 0;
	BitMask.Mask = 0;
	for (i = 0; i < vc; i++) {
		if (Vertex[i].Refs < 0) {
			Multiple = -Vertex[i].Refs;
			RefsTotal += Multiple * Vertex[i].n;
			Refs += Multiple;
			BitMaskSet(BitMask, i);
		}
	}
	*pRefs = Refs;
	*pRefsTotal = RefsTotal;
	*pBitMask = BitMask;
}

void
QueueInitialWorkers(LPTYPER Depth, PVERTEX Vertex, LPTYPER SmallSteps)
{
	LPTYPER c, vc, Refs, Less;
	NTYPE RefsTotal, LessTotal;
	BITMASK BitMask;

	Less = 0;
	LessTotal = 0;
	Vertex[0].n = 1;
	Vertex[0].Refs = -2;
	Vertex[0].Doubling = FALSE;
	Vertex[0].Multiple = FALSE;
	if (SmallSteps > 0) {
		if ((Flags & FLAGS_DO_TEST) != 0 && SmallSteps > 3) {
			for (int i = 0; i < 10; i++) {
#define TEST_VERTEX_COUNT 4
				for (int i = 0; i < TEST_VERTEX_COUNT; i++) {
					if (i == 0) {
						Vertex[i].n = 1;
					} else {
						Vertex[i].n = 3 * Vertex[i - 1].n;
					}
					if (i > 0) {
						Vertex[i - 1].Refs = 0;
						Vertex[i - 1].Multiple = TRUE;
					}
					Vertex[i].Refs = -2;
					Vertex[i].Multiple = FALSE;
					Vertex[i].Doubling = FALSE;
				}
				c = 3 * (TEST_VERTEX_COUNT - 1);
				vc = TEST_VERTEX_COUNT;
				Vertex[0].Refs = -1;
				CalcRefsEtc(Vertex, vc, &Refs, &RefsTotal, &BitMask);
				QueueWork(c, Vertex, vc, Depth, Refs, RefsTotal, Less, LessTotal, BitMask);
			}
		} else {
			Vertex[1].n = 2;
			Vertex[1].Refs = -2;
			Vertex[1].Multiple = FALSE;
			Vertex[1].Doubling = TRUE;
			Vertex[1].n = 2;
			Vertex[0].Multiple = TRUE;
			Vertex[0].Refs = -1;
			c = 2;
			vc = 2;
			CalcRefsEtc(Vertex, vc, &Refs, &RefsTotal, &BitMask);
			ASSERT(Refs == 3 && RefsTotal == 5);
			QueueWork(c, Vertex, vc, Depth, Refs, RefsTotal, Less, LessTotal, BitMask);
			Vertex[1].n = 3;
			Vertex[1].Refs = -2;
			Vertex[1].Multiple = FALSE;
			Vertex[1].Doubling = FALSE;
			Vertex[0].Multiple = TRUE;
			if (SmallSteps > 1) {
				Vertex[0].Refs = -1;
			} else {
				Vertex[0].Refs = 0;
			}
			c = 3;
			vc = 2;
			CalcRefsEtc(Vertex, vc, &Refs, &RefsTotal, &BitMask);
			QueueWork(c, Vertex, vc, Depth, Refs, RefsTotal, Less, LessTotal, BitMask);
		}
	} else {
		c = 1;
		vc = 1;
		CalcRefsEtc(Vertex, vc, &Refs, &RefsTotal, &BitMask);
		ASSERT(Refs == 2 && RefsTotal == 2);
		QueueWork(c, Vertex, vc, Depth, Refs, RefsTotal, Less, LessTotal, BitMask);
	}
}

DWORD
Hours(DWORD Elapsed)
{
	return Elapsed / (1000 * 60 * 60);
}

DWORD
Minutes(DWORD Elapsed)
{
	return (Elapsed / (1000 * 60)) % 60;
}

DWORD
Seconds(DWORD Elapsed)
{
	return (Elapsed / 1000) % 60;
}

DWORD
Hundredths(DWORD Elapsed)
{
	return (Elapsed / 10) % 100;
}

static
void
process_parameters(int argc, char *argv[], ULONG &Flags, LPTYPER &SmallSteps)
{
	char c, *p;
	BOOLEAN GotSmallSteps = FALSE;

	Flags = 0;
	SmallSteps = 0;

	while (--argc) {
		p = *++argv;
		if (*p == '/' || *p == '-') {
			while (c = *++p) {
				switch (toupper(c)) {
				case 'D':
					Flags |= FLAGS_DO_D;
					break;
				case 'F':
					Flags |= FLAGS_DO_FACTOR;
					break;
				case 'I':
					Flags |= FLAGS_DO_IDLE;
					break;
				case 'P':
					Flags |= FLAGS_DO_PAUSE;
					break;
				case 'R':
					Flags |= FLAGS_DO_RESTORE;
					break;
				case 'S':
					Flags |= FLAGS_DO_STATS;
					break;
				case 'T':
					Flags |= FLAGS_DO_TEST;
					break;
				case 'M':
					if (argc > 0) {
						argc--;
						p = *++argv;
						MaxValue = ((NTYPE)1 << (LPTYPER)atoi(p)) + CHAR_BIT - 1;
						p = "\0";
					}
					break;
				case 'W':
					Flags |= FLAGS_DO_WRITE;
					break;
				case 'H':
				default:
					Flags = FLAGS_DO_USAGE;
					return;
				}
			}
		} else {
			if (!GotSmallSteps) {
				SmallSteps = (LPTYPER)atoi(p);
				GotSmallSteps = TRUE;
			} else {
				Flags = FLAGS_DO_USAGE;
			}
		}
	}

	return;
}

static
void
do_usage(void)
{
	printf("st -m x [-f] SmallSteps // Do the factor method on multiple bitmaps\n");
	printf("st -m x [-p] SmallSteps // Pause between steps for performance measurment\n");
	printf("st -m x [-r] SmallSteps // Restore prior saved state\n");
	printf("st -m x [-i] SmallSteps // Run at idle priority\n");
	printf("st -m x [-s] // Print statistics on unfound numbers\n");
	printf("st -m x [-t] // Do a performance test run\n");
	printf("st -m x // Run with a bitmap size of 2^x\n");
	printf("st -d   // Calculate d(r) values from bitmaps\n");
	printf("st -w // write addxx.4ln file out\n");
	printf("st -h\n");
}

static
void
PrintStats(PVERTEX Vertex, LPTYPER Depth, PSTAT Stat)
{
	for (LPTYPER l2 = 0; l2 <= lambda(MaxValue); l2++) {
		ULONGLONG Found;
		NTYPE Start = NTYPE(1) << l2;
		NTYPE End = Start * 2 - 1;
		if (End > MaxValue) {
			End = MaxValue;
		}
		Found = 0;
		for (NTYPE n = Start; n <= End; n++) {
			if (!IsInBitMap(n)) {
				Start = n + 1;
				printf(NTYPE_P " l2=" LPTYPER_P " bits=" LPTYPER_P "\n", n, l2, bits(n));
				Found++;
				if (Found > 10) {
					break;
				}
			}
		}
		Found = 0;
		for (NTYPE n = End; n >= Start; n--) {
			if (!IsInBitMap(n)) {
				printf(NTYPE_P " l2=" LPTYPER_P " bits=" LPTYPER_P "\n", n, l2, bits(n));
				Found++;
				if (Found > 10) {
					break;
				}
			}
		}
	}
	for (LPTYPER i = 0; i <= Depth; i++) {
		printf("min: " NTYPE_P "\n", Vertex[i].min);
	}
	for (LPTYPER i = 0; i <= Depth; i++) {
		printf("minv: " NTYPE_P " " NTYPE_P "\n", Vertex[i].minv, Stat[i].minv);
	}
	for (LPTYPER i = 0; i <= Depth; i++) {
		NTYPE Range;
		if (Vertex[i].maxv < Vertex[i].minv) {
			Range = 0;
		} else {
			Range = Vertex[i].maxv - Vertex[i].minv + 1;
			Range = Range / (CHAR_BIT * 1024);
		}
		printf("maxv: " NTYPE_P " " NTYPE_P "k\n", Vertex[i].maxv, Range);
	}
}

static void DoFactor(LPTYPER SmallSteps)
{
	NTYPE Lowest = GetLowestUnset();
	for (LPTYPER FirstSmallSteps = 2; FirstSmallSteps + 2 <= SmallSteps; FirstSmallSteps++) {
#pragma omp parallel
		{
#pragma omp for schedule(static)
			for (SNTYPE First = 7; First <= (SNTYPE)MaxValue / 7; First++) {
				if (IsInBitMapEx(BitMapArray[FirstSmallSteps], First) && !IsInBitMapEx(BitMapArray[FirstSmallSteps - 1], First)) {
					for (NTYPE Second = Lowest / First; Second <= MaxValue / First; Second++) {
						LPTYPER Remaining = SmallSteps - FirstSmallSteps;
						NTYPE Target = First * Second;
						if (!IsInBitMap(Target)) {
							if (lambda(Target) > lambda(First) + lambda(Second)) {
								Remaining--;
							}
							if (IsInBitMapEx(BitMapArray[Remaining], Second)) {
								SetInBitMap(Target);
							}
						}
					}
				}
			}
		}
	}
}

class lFromBitMap {
#define SMALL_STEP_FILES 8
#define SMALL_STEP_FILES_START 2
	FILE *fp[SMALL_STEP_FILES + 1];
	unsigned char c[SMALL_STEP_FILES + 1];
	NTYPE n;

public:
	const LPTYPER BadValue = (LPTYPER)-1;

	lFromBitMap()
	{
		for (int i = 0; i <= SMALL_STEP_FILES; i++) {
			CHAR Name[MAX_PATH];

			_snprintf(Name, sizeof(Name) / sizeof(Name[0]), "smallstep_%d.bin", i);
			if ((fp[i] = fopen(Name, "rbcS")) == NULL) {
				printf("Failed to open smallstep file %s\n", Name);
				exit(0);
			}
		}
		n = 0;
		for (int i = 0; i <= SMALL_STEP_FILES; i++) {
			c[i] = _getc_nolock(fp[i]);
		}
	}

	~lFromBitMap()
	{
		for (int i = 0; i <= SMALL_STEP_FILES; i++) {
			fclose(fp[i]);
		}
	}

	LPTYPER l(NTYPE n)
	{
		LPTYPE l = s(n);
		if (l != BadValue) {
			l += lambda(n);
		}
		return l;
	}

	LPTYPER s(NTYPE n)
	{
		if (n < this->n || n >= this->n + CHAR_BIT) {
			ASSERT(n == this->n + CHAR_BIT);
			for (int i = 0; i <= SMALL_STEP_FILES; i++) {
				int ci = _getc_nolock(fp[i]);
				if (ci == EOF) {
					return BadValue;
				}
				c[i] = ci;
			}
			this->n = n;
		}
		LPTYPER bit = n % CHAR_BIT;
		for (int i = 0; i <= SMALL_STEP_FILES; i++) {
			if ((c[i] & (1 << bit)) != 0) {
				return i;
			}
		}
		return BadValue;
	}
};

static void DoWrite(void)
{
	FILE  *fp;
	NTYPE n;
	TOKEN_TABLE Lookup[6 * 6 * 6 * 6] = { 0 };
	int LookupLength = 0;

	if ((fp = fopen("add36.4ln", "wb")) == NULL) {
		printf("can't open %s\n", "add36.4ln");
		exit(0);
	}
	fwrite(&LookupLength, sizeof(LookupLength), 1, fp);


	for (int pass = 0; pass <= 1; pass++) {
		lFromBitMap lb;
		for (n = 1; ; n += 4) {
			int diff[4];
			int index = 0;
			for (int d = 0; d < 4; d++) {
				LPTYPER s = lb.s(n + d);
				if (s == lb.BadValue) {
					goto NextPass;
				}
				diff[d] = s - log2u(bits(n + d));
				index = index * 6 + diff[d];
			}
			if (Lookup[index].u.all == 0) {
				if (index != 0 || LookupLength == 0) {
					printf("%3d<->", LookupLength);
					for (int i = 3; i >= 0; i--) {
						printf("%d", diff[i]);
						Lookup[index].u.diff[i] = diff[i];
					}
					printf(" " NTYPE_P "\n", n);
					Lookup[index].value = LookupLength++;
					fwrite(&Lookup[index].u.all, sizeof(Lookup[index].u.all), 1, fp);
				}
			}
			if (pass == 1) {
				putc(Lookup[index].value, fp);
			}
		}
	NextPass:;
	}
	_fseeki64(fp, 0, SEEK_SET);
	fwrite(&LookupLength, sizeof(LookupLength), 1, fp);
	fclose(fp);
	printf("Output " NTYPE_P " values\n", n - 1);
}

static void CalculateDr(void)
{
#define SMALL_STEP_FILES 8
	FILE *fp[SMALL_STEP_FILES + 1];
#define SMALL_STEP_FILES_START 2

	for (int i = SMALL_STEP_FILES_START; i <= SMALL_STEP_FILES; i++) {
		CHAR Name[MAX_PATH];

		_snprintf(Name, sizeof(Name) / sizeof(Name[0]), "smallstep_%d.bin", i);
		if ((fp[i] = fopen(Name, "rbcS")) == NULL) {
			printf("Failed to open smallstep file %s\n", Name);
			exit(0);
		}
	}
	NTYPE n = 0;
	NTYPE Dr[100] = { 0 };
	NTYPE Prob[100] = { 0 };
	bool Unk[100] = { false };
	LPTYPER DrL = 0;
	int FileUpperLimit = SMALL_STEP_FILES;
	LPTYPE l2 = 0;
	NTYPE l2Limit = 0;
	NTYPE s2Limit = 3;
	NTYPE limit = min(l2Limit, s2Limit);
	while (Unk[l2] == false) {
		unsigned char c[SMALL_STEP_FILES + 1];
		c[0] = 0;
		c[1] = 0;
		for (int i = FileUpperLimit; i >= SMALL_STEP_FILES_START; i--) {
			int iv = _getc_nolock(fp[i]);
			if (iv == EOF) {
				iv = 0;
				fclose(fp[i]);
				fp[i] = NULL;
				FileUpperLimit--;
			}
			c[i] = iv;
		}
		for (int b = 0; b < CHAR_BIT; b++, n++) {
			if (n == limit) {
				if (n == l2Limit) {
					if (n == 0) {
						l2 = 0;
						l2Limit = 2;
						c[0] = 2;
						c[1] = 2;
						limit = min(l2Limit, s2Limit);
						continue;
					}
					c[0] |= 1 << b;
					c[1] |= 1 << b;
					l2++;
					l2Limit *= 2;
					if (l2 > DrL && Dr[l2] > 0 && !Unk[l2]) {
						printf("d(%d) = " NTYPE_P "\n", DrL, Dr[DrL]);
						DrL++;
					}
				} else if (n == s2Limit) {
					c[1] |= 1 << b;
					s2Limit = (s2Limit | (s2Limit - 1)) + 1;
					while (bits(s2Limit) < 2) {
						s2Limit++;
					}
				}
				limit = min(l2Limit, s2Limit);
			}
			LPTYPER l = l2;
			bool Found = false;
			for (int i = 0; i <= FileUpperLimit; i++) {
				if (c[i] & (1 << b)) {
					l = l + i;
					Found = true;
					break;
				}
			}
			if (!Found) {
				for (int i = FileUpperLimit + 1; i <= SMALL_STEP_FILES; i++) {
					if (Unk[l + i] == false) {
						if (i < log2u(bits(n))) {
							continue;
						}
						Unk[l + i] = true;
						Prob[l + i] = n;
						printf(NTYPE_P " is problematic for d(%d) with %d small steps\n", n, l + i, i);
					} else {
						break;
					}
				}
			} else {
				Dr[l]++;
			}
		}
	}
	LPTYPER l = lambda(n);
	for (int i = l + min(bits(n), 2) - 1; i < 100; i++) {
		if (Unk[i] != true && Dr[i] > 0) {
			printf(NTYPE_P " is problematic for d(%d) with %d small steps\n", n, i, i - l);
			Unk[i] = true;
		}
	}

	for (int i = DrL; i < 100; i++) {
		if (!Unk[i] && Dr[i] != 0) {
			printf("d(%d) = " NTYPE_P "\n", i, Dr[i]);
		}
	}
}

int __cdecl main(int argc, char **argv)
{
	LPTYPER SmallSteps, Depth, i;
	DWORD StartTime, Elapsed;
	PVERTEX Vertex;

	process_parameters(argc, argv, Flags, SmallSteps);

	if (SmallSteps > MAX_SMALL_STEPS) {
		printf("Maximum small steps exceeded\n");
		exit(0);
	}
	if (Flags & FLAGS_DO_USAGE) {
		do_usage();
		exit(0);
	}

	BitMapArray[SmallSteps] = BitMap = AllocateBitMap();

	BitMap[0] |= 2;

#if !defined (QUIET)
	printf("%d small steps, NTYPE %d bits, max = " NTYPE_P "\n",
		SmallSteps, sizeof(NTYPE)*CHAR_BIT, MaxValue);
#endif

	ThreadId = 0;
	InitThreads();

	Depth = SmallSteps + lambda(MaxValue);
	if (Depth >= sizeof(BITMASK) * CHAR_BIT) {
		printf("Too many chain elements for bit mask\n");
		exit(0);
	}
	Vertex = new _VERTEX[Depth + 1];
	MinValues = new NTYPE[Depth + 1];
	MinValuesSize = Depth + 1;
	memset(MinValues, 0, sizeof(NTYPE) * (Depth + 1));
	StartTime = GetTickCount();
	LPTYPER StartSmallSteps;
	if ((Flags & FLAGS_DO_STATS) != 0 || SmallSteps == 0) {
		StartSmallSteps = SmallSteps;
	} else if (Flags & FLAGS_DO_FACTOR) {
		StartSmallSteps = 0;
	} else {
		StartSmallSteps = SmallSteps - 1;
	}
	if (Flags & FLAGS_DO_PAUSE) {
		printf("Hit return to start bitmap read\n");
		getc(stdin);
	}
	if (Flags & FLAGS_DO_D) {
		CalculateDr();
		exit(0);
	} else if (Flags & FLAGS_DO_WRITE) {
		DoWrite();
		exit(0);
	} else {
		for (i = StartSmallSteps; i <= SmallSteps; i++) {
#if !defined (QUIET)
			printf("Reading bitmap for %d small steps\n", i);
#endif
			ReadBitmap(i, FALSE);
		}
	}

	PSTAT Stat = nullptr;
	if ((Flags & FLAGS_DO_STATS) == 0) {
		if (Flags & FLAGS_DO_PAUSE) {
			printf("\nHit return to start bitmap shift\n");
			getc(stdin);
		}
		ShiftBitmap(SmallSteps);

		Elapsed = GetTickCount() - StartTime;
		printf("// Load took %u:%02u:%02u.%02u\a\a", Hours(Elapsed), Minutes(Elapsed), Seconds(Elapsed), Hundredths(Elapsed));

		StartTime = GetTickCount();

		if (Flags & FLAGS_DO_PAUSE) {
			printf("\nHit return to start bitmap heuristics\n");
			getc(stdin);
		}
		AddHeuristics (SmallSteps);

		Elapsed = GetTickCount() - StartTime;
		printf(", Heuristics took %u:%02u:%02u.%02u, Lowest unset " NTYPE_P "\a\a\n", Hours(Elapsed), Minutes(Elapsed), Seconds(Elapsed),
			   Hundredths(Elapsed), GetLowestUnset());

		StartTime = GetTickCount ();
	} else {
		Stat = new _STAT[Depth + 1];
		memset(Stat, 0, (Depth + 1) * sizeof(_STAT));
	}
	if (Flags & FLAGS_DO_FACTOR) {
		DoFactor(SmallSteps);
	}

	if (Flags & FLAGS_DO_PAUSE) {
		printf("Hit return to start populate max\n");
		getc(stdin);
	}
	Depth = PopulateMax (Vertex, Depth, SmallSteps, TRUE, Stat);

	if (Flags & FLAGS_DO_STATS) {
		PrintStats(Vertex, Depth, Stat);
		CheckResults(SmallSteps);
		exit(0);
	}
	if (Flags & FLAGS_DO_PAUSE) {
		printf("\nHit return to start search\n");
		getc(stdin);
	}
	if (Flags & FLAGS_DO_RESTORE) {
		ReadOldWork(Depth, Vertex, SmallSteps);
	} else {
		QueueInitialWorkers(Depth, Vertex, SmallSteps);
	}
	//memset((void *)BitMapLookup, 0, sizeof(BitMapLookup));
	StartThreads(Depth);

#if !defined (QUIET)
	printf ("Last index " NTYPE_P "\n", CurrentIndex);
#endif

	ExitThreads(SmallSteps);

	if (WorkSet.size() != 0) {
		printf("WorkSet not empty! %d\n", (int)WorkSet.size());
	}

	Elapsed = GetTickCount () - StartTime;
	printf ("// s(n)<=" LPTYPER_P " took %u:%02u:%02u.%02u n<=2^" LPTYPER_P ", timeout=%d\n",
		    SmallSteps, Hours(Elapsed), Minutes(Elapsed), Seconds(Elapsed), Hundredths(Elapsed), lambda(MaxValue), Timeouts);
	PrintCpuTimeUsage();

	StartTime = GetTickCount ();
	WriteAndReplaceState(SmallSteps);
	Elapsed = GetTickCount () - StartTime;
	printf("// Write took %u:%02u:%02u.%02u, ", Hours(Elapsed), Minutes(Elapsed), Seconds(Elapsed), Hundredths(Elapsed));
	if ((Flags & FLAGS_DO_TEST) == 0) {
		StartTime = GetTickCount ();
		CheckResults(SmallSteps);
		Elapsed = GetTickCount () - StartTime;
		printf("Check took %u:%02u:%02u.%02u\n", Hours(Elapsed), Minutes(Elapsed), Seconds(Elapsed), Hundredths(Elapsed));
	} else {
		printf("No check, test run\n");
	}
	printf("//\n");
}
]]]
]]]]]]]
