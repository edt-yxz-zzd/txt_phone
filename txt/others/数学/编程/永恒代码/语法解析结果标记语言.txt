语法解析结果标记语言.txt
  <- 可运行于任何平台的语言.txt
  -> 字符串内部转义.txt



空间:公/私
纵/横/深
  深:标记语言 本身，所解析的语言
  空间的纵横，标记语言的纵横

语法解析结果标记语言
标记语言:
  目标:
    用于保存 语法解析结果
    并非给人直接读写
    由于是面向程序:
      无需冗余信息
        如：HTML tag 在结尾重复一遍
      应支持简单的手写编译器
  功能:
    文本文件
    支持空间
      定义 默认空间名
    支持简名映射:
      空间昵称简名 类名简名 分支名简名
      映射表: 简名 -> 原名
      内部映射表 或 外部映射表/外部配置
      %内部简名
      %%外部简名 #实时外部简名
      %%%不解简名 #推后外部简名
      %^简名 #解析顺序:内 外 不解
    支持外部配置
      昵称/外部引用 可先在文件内部映射到 简名
      空间昵称/实时外部引用 的 实际定义 由 外部配置文件 提供
      外部配置文件 在哪？由外部应用决定
      但可提供建议和解释:
        建议:外表配置文件 叫什么，在哪里
        解释:引入 哪些名称，简名 是什么，类型/接口 是什么，用途，其约束头文件/输出接口文件 是什么，在哪里...
    支持嵌套
      ###########################
      ####outdate:空间昵称=外部自由共享路径*横向作者昵称/(私人空间路径*横向所用工具名*纵向版本信息/)+
      ###########################
      #空间昵称=再分配昵称区:::私人信息管理区:::可操作路径区
      #     再分配昵称区=(自由共享路径*横向作者实体多维昵称/)+
      #     私人信息管理区=(私人空间路径*横向工具项目多维信息*纵向版本多维信息/)+
      #     可操作路径区=/(/名)*
      #     多维信息=str|{str:多维信息}
      #     多维昵称=(昵称,登记多维信息)|{str:多维昵称}
      #     ####昵称 意味着 实体对虚名的竞争，名称仅用于区分实体，无实在意义，由外部应用自行解释，可被配置，可被等效重命名。与 别名/引用名/引入名/简名 比较，昵称-外部解释，其他-内部解释/定义
      #     ####再分配:实体之下有实体，登记/注册 的信息 也只是 昵称
      #     ####可操作:语言内部可操作。而前面的，都是外部应用介入解释的
      ###########################
      # 类名=名(.名)*
      # 类名=%名(.名)*
      # 分支名=名(.名)*
      # 分支名=%名(.名)*
      # 类名:用途/数据目的，读取后的数据的静态类型
      # 分支名:数据由文本表达时所用的构造子//协议/方法
      #     协议-听起来更像独立于 类名 的东西
      #     构造子-类似Haskell，隶属于类名
      # 树引用名::类名=类名.构造子(数据)
      ###########################
      #树引用名=推荐树引用名
      #树引用名=推荐树引用名:自动编号
      #树引用名=:自动编号
      ###########################
      (树构造子:
        #树构造子 不是 空间 数据 分支名
        #树构造子 是 本标记语言 树 分支名
        #以下是 树构造子=空间树 的情形
        #还可以是各数据类型相应的 包装树/盒子树
        #   包装 深度类型 的 深度盒
        #   包装 文本 的 文本盒
        #   无需 空间名...

        ####深度语言数据纵横区
        #深/本标记语言:内建注释区/高层描述区/带外信息/辅助信息
        #   树引用名=空间名:类名:分支名:
        #   手动vs自动
        #   手动 ==>> 必要vs可选
        , 必要内建信息:{str:str}
          , 空间名
            # 空间名 = 空间昵称简名(/名)*
            # 空间昵称简名 ==>> 空间昵称(/名)*
          , 类名
          , 分支名
        , 自动内建信息:{str:str}
          , 自动编号:str
              #被不断重写，只具临时意义
        , 可选内建信息:{str:str}
          , 推荐树引用名:str
              #经过无数次各种目标导向的重命名后，我们依旧能看到它
          , 树注释::str
              #用本标记语言写作的作者(可能是应用软件)，对本树的注释

        #纵:本标记语言的前向兼容区/方言+未来版本
          , 纵向命名深度属性区::{语言版本功能:深度类型}
        #横:本标记语言的定制子类，以适用于不同用途，如:针对被解析语言进行定制
          , 横向命名深度属性区::{语言应用目的:深度类型}
        #依值的类型分隔#必然都是已命名的
        #深度类型 =
        #   ({str:str}
        #   ,{str:[str]}
        #   ,{str:{str:str}}
        #   ,{str:子树}
        #   ,{str:[子树]}
        #   ,{str:{str:子树}}
        #   ,{str:深度类型}
        #   ,{str:[深度类型]}
        #   ,{str:{str:深度类型}}
        #   )
        # 子树=树构造子(深度类型)
        #   即：树 是 深度类型 的定制版
        # 深度类型 为何长这样？
        #   基本类型 只有 str
        #   结构类型:
        #       tuple, list, dict
        #       但 tuple 的元素类型各异，位置各异，重复数各异，除非 允许类似python的动态类型，否则无法编译
        #       解决:假设 所有tuple的所有元素类型，其实只有有限的类型
        #           将tuple中类型相同的元素合并一起，形成 命名属性区；将这些有限的不同类型的属性区合并在一起，形成新的tuple，即是 深度类型
        #   有了类型a，我们可能需要很多个[a]
        #   有了类型a，我们可能需要命名它{str:a}
        #   我们可能需要嵌套结构:深度类型
        #   我们可能需要一个定制版的嵌套结构:树
        #       有明确语义，使用 语法糖
        #       唯一的对象类型，可循环引用
        #

        ####空间数据纵横区[由空间作者决定是否可选]
        #我/树/对象:引用区/内容区/数据区
        , 无名文本索引区::[str]
        , 命名文本属性区::{str:str}
        , 无名子树索引区::[子树]
        , 命名子树属性区::{str:子树}
        , 无名深度索引区::[深度类型]
        , 命名深度属性区::{str:深度类型}
        #纵:未来区/前向兼容区/扩展区/方言特色添加区/各版本特色功能区/该空间作者的追加
        , 纵向命名子树属性区::{空间版本功能:子树}
        #横:额外区/额外注释区/其他应用软件读写区/不在 该空间作者的设计之内
        , 横向命名子树属性区::{空间应用目的:子树}
        )

      使用 前逗号分隔: [,1,2,3] {,1:2,3:4}

    支持内部引用
      树引用: 支持数据循环/有向无环图
        无名的话，只能支持树结构，连 有向无环图 都不支持
      文本引用: 语法糖，符号化

      引用:
        无糖:
          引用树:
            @树引用名
              #自动命名每棵被引用的树
          实时外部引用:
            #由外部应用软件实时提供
            #类似于编译C语言时，编译选项:『-Dxxx=yyy』
            @@外部树引用名
            $$外部文本引用名
          =====
          不能 引用内部文本:
            所有文本引用 直接展开
          无 推后外部引用:
            直接改写为树，用树表达此要求
        低糖:
          引用文本:
            $树引用名{'属性名"}
              #仅单层
          推后外部引用:
            @@@外部树引用名
            $$$外部文本引用名
        加糖:
          引用树:
            @树引用扩展名
              树引用扩展名=
                |树引用名
                |树引用扩展名.属性名
                |树引用扩展名{'属性名"}
                |树引用扩展名[索引号]
                #未来区
                |树引用扩展名{{|'空间版本功能"|}}
                #额外区
                |树引用扩展名{{-'空间应用目的"-}}
          引用文本:
            $文本引用名
              #引用 文本引用定义区 中的定义
            $树引用扩展名.属性名
            $树引用扩展名{'属性名"}
            $树引用扩展名[索引号]
              #前面是引用树，只有最后是引用文本

        昵称/名称
          #直接，无需前缀
      定义:
        有 唯一性要求，解析时检查
        允许 程序 自动重命名，仅是文件内部临时使用

        (树引用名=...)
        (=标准空间,文件内部解释,文本引用名定义,'文本引用定义区", [], {文本引用名=文本, ...}, [])
        (=标准空间,文件内部解释,空间昵称说明,'空间昵称说明区", [], {空间昵称=说明, ...}, [])

    数据类型: 文本
      仅用于树的头部
      无其他类型
      无糖两种:
        'xxx"
        ff'\$$文本引用名/"
          实时外部引用
      加糖三种:
        去引号:
          regex'/\S*'
          regex'.+[^.=]*'
            {,.属性=/值,...}
        格式化:
          f'\$文本引用名/"

      但:
        (=标准空间,简单数据,文本,'", [], {数据=文本}, [])
        (=标准空间,简单数据,整数,'", [], {数据=文本}, [])
        (=标准空间,复杂数据,数组,'", [], {}, [...数据...])

        (=标准空间,复杂数据,自带类型,'", [], {}, [
          ,(=.类型,'", [], {}, [
            ,@整数数组
            ])

          ,(=.数据,'", [], {}, [
            ,...数据...
            ])
          ])


        (整数=标准空间,复杂数据,类型,'", [], {类型名='整数"}, [])
        (整数数组=标准空间,复杂数据,类型,'", [], {类型名='数组"}, [@整数])

        (箭头=标准空间,复杂数据,类型,'", [], {类型名='箭头"}, [])

        (类型=标准空间,复杂数据,类型类型,'", [], {类型类型名='类型"}, [])
        (类型箭头=标准空间,复杂数据,类型类型,'", [], {类型类型名='类型箭头"}, [])




