文件属性、逻辑系统、递归控制

内属性、外属性
	内属性：
		由文件内容衍生的属性
			可确定性校验的结果
			但是！！
				什么是“文件内容”？
				文件内容=文件的抽象值
				抽象程度可以多高？
						如：自然语言文本的翻译
							即说明文本有比字符串更高的抽象结构
				通常，文件版本管理系统直接将文件当作“字节文件”
					人们在传输过程中也这么认为
				可是若文件本身是文本文件，只当成字节文件的话，可能在不同编码的解读下出现多个合法文本造成歧义。
				所以文本文件本身必须指定编码
					即文本文件的“文件内容”虽然只是文本
						但以某种存储格式保存时，必须包含“字符编码”信息
		文件内容：
			*文本：文本长度，文本摘要
				假设存在一个已知的统一和谐的完全的抽象字符集
					文本抽象内容::[抽象字符]{文本长度}
				但任何时刻，都不存在这样的抽象字符集，必须指定一个具体的字符子集及其整数编码
					文本传输内容=(字符的整数编码方案，内容::[整数%字符集的大小(字符的整数编码方案)]{文本长度})
					文本摘要<字符的整数编码方案>(文本传输内容)
				在特定系统下，必须采用某种存储格式以保存，即使用存储编码
					文本存储内容=(字符的整数编码方案，存储单元大小，整数存储编码<字符集的大小(字符的整数编码方案), 存储单元大小>，内容::[整数%存储单元大小]{文本存储长度})
			*非文本：存储长度、存储摘要
				存储内容::[整数%存储单元大小]{存储长度}
		文件类型、文件格式(同时多个)：
			*文本：编码
				脚本？语言标准？
				此时，存储格式 是外属性：传输 可变
			*多媒体？？
				虽然是数字化的模拟信息，但由于其格式大多针对“字节”优化，高效地(时间或空间)无损转换存储格式
			*非文本：存储格式、传输格式
				字节？
				传输情形下 如何保持？
					看来 非文本文件 只能在同“存储格式”的系统间传输
						除非有更明确的更抽象的表达
					文本文件 无此障碍
				传输时为外属性
				存储时为内属性
	外属性：
		？？修改时间-复制、解压、下载 不变
			这是一个十分稳定的属性
			？？是外部定义的内属性？？但显然可手动改
				或者：“应当”保持不变的外属性？？但文件修改后必需改
		创建时间
			复制、解压、下载 变
		脚本执行程序：
			错误示例：linux shell竟然在文件内部指定！！
			即使env+symlink也说不通
		绝对路径
			
	cmake
		见：逻辑系统
		逻辑对象vs实际对象
		依赖关系vs执行程序
		文件类型vs文件名后缀
		内属性vs外属性
			内属性
				文件类型：
					目标文件
					静态库
					动态库
				依赖关系
					编译
					链接
			外属性
				文件名后缀：
					.o .obj
					.a, .lib
					.so, .dll
				执行程序
					编译器
					链接器



私有命名空间
	见：密码学/公钥起止.txt
	用公钥作为空间名
	将命名空间的更新终止日期(私人信息)编码入公钥中
		日期过后，时间戳服务不再提供为该命名空间的更新文件打戳
	之后再想更新，可用新空间继承旧空间。




逻辑系统
	=对象+关系+推导规则
	为了能且快地判断是否和谐，规则需要仔细挑选
	为了能前向兼容，推不出的关系将来可能被添加，除非显式声明禁用
	当下不存在的对象并不一定不存在，将来可能添加，除非显式声明不存在
	逻辑系统本身是另一个逻辑系统中的对象
	逻辑对象是不变的
	但我们有时希望看起来可变

	子集拆分：“=+=”
	结构拆分：“=*=”
	集合小于等于：“<:”
	集合属于：“<=”
	注意：
		a =*= c
		b =+= c
		==>>
			a <: c  #唯一的结构成员属于c
			b == c  #唯一的拆分子集是c

	逻辑对象
		=+= 值 | 命名对象
	命名对象
		=+= 原子对象 | 复合对象
	原子对象
		=*= 名
		=+= 内建对象
		没有声明，只出现在原子关系中
	复合对象
		=*= 声明 * 值版本? * 值
		=+= 恒量对象 | 过程对象
		此值是：
			*缺省
			*示例用值
				不用于推导
				只用于检查约束的有效性
				完全值 或 示例如何通过其他对象形式值构建
		#若有必要可在值约束中声明实际值如何通过其他对象形式值构建
	示例版本
		=*= 对象版本 * 值版本
	恒量对象
		=*= 恒量对象声明 * 值版本? * 值
		=+= 间接恒量对象 | 直接恒量对象
		对象版本一般指其声明的版本
		恒量是指声明恒定，对象无版本
	过程对象
		=*= 过程对象声明 * 值版本? * 不完全值
	间接恒量对象
		=*= 恒量对象声明 * 值版本? * 不完全值
	直接恒量对象
		=*= 恒量对象声明 * 值版本? * 完全值
		=+= 推导用直接恒量对象 | 自动实例化用直接恒量对象
	自动实例化用直接恒量对象
		=*= 恒量对象声明 * 值版本 * 完全值
		此完全值不能用于推导，只能用于其他对象值的系统内自动补完及不完全值的系统外部实现的自动补完部分。
		#直接 是指 用于外部实现的自动补完部分
		#由于不能用于推导，故不得直接硬编码该值于源代码逻辑控制中，但编译器可使用该值。
		#比如：C中struct的大小必须用sizeof，因为struct出现在头文件中只用于方便编译器工作，如无特别说明，不能简单认为永远不变。
		#若有必要可在值约束中声明实际值以用于推导，这就是 推导用直接恒量对象
		??????
		这个东西既然不能用于推导，那就只是“实现”的一部分，根本不该出现在这里！！用外部文件保存它！！
	推导用直接恒量对象
		=*= 恒量对象声明 * 完全值

	逻辑系统本身是一个过程对象
	恒量对象声明
		=*= 名 * 恒量对象约束
	过程对象声明
		=*= 名 * 对象版本 * 过程对象约束
	过程对象约束(名,对象版本)->逻辑命题
		取过程对象(名,对象版本)->过程对象
		取命名对象(名)->命名对象 #最新版
		取复合对象声明(复合对象)->声明
		取对象值(对象)->对象形式值
			#由于 复合对象的值 不一定出现在 逻辑系统中，此取值可能只是一种形式，或者说取出的是 不完全值。
			#只能取出形式值！
			#若有必要可在值约束中声明实际值以用于推导

	恒量对象约束
		=*= 值约束 * 横向约束
		为何直接常量对象还需要除值结构类型以外的约束，一是注释，二是检查防错
	过程对象约束
		=*= 值约束 * 横向约束 * 纵向约束
	值约束
		=*= 值结构类型 *,值成员间关系
	横向约束
		本对象 与 本版本系统中在本对象声明前声明的其他对象之间的关系
			见：临时动态版本
		其他对象版本：
			*缺省无印
				某个系统版本下的相应版本
			*今及后
				无同一系统版本要求，只要各对象版本大于等于自身今版即可
			*以小组的形式声明要求曾同属某个系统版本
				同一对象可能在不同小组中对应不同系统版本
		作用于本系统今及后的所有版本下任何对象在该版系统中的版本(最新版之间)

	纵向约束
		对本对象未来版本的约束
			包括对未来约束的约束：
				版本终止(最终版)
				版本号的取名方式
				...
		#系统隐含的约束是未来版的约束必须更严格，未来类只能是子类
		#系统需指明自身所有父版本，则系统中的任一对象的所有父版本也随之确定


	值 =+= 名 | 声明 | 对象形式值 | 对象版本 | 值版本 | 值结构类型 | 逻辑命题 | ...
	值 =+= 完全值 | 不完全值
	不完全值 =+= 示例用完全值 | 依赖对象形式值的真不完全值(缺省即是自身形式值)
	

	关系
		关系 作用于 对象 或 值(含 对象声明)
		为何对象不是值？
			名 到 对象 的对应依赖于系统及其版本
			值 只能保存 名，不能保存 对象
			值 是 实际值
			对象 是 概念值
				可能同时指代多个(未来) 对象版本*实现版本 的对象实际值
				对象值 是 符合约束的可能值，但问题是各个对象值并不无关，系统中所有对象的值空间由“关系”刻画，相对复杂，不能简单用对象可能值的集合来代表对象。

	系统版本：对象版本递增 或 增加新对象 或 新关系
		同一个版本内的增加新对象或新关系(C头文件语句递增) 或 无序兼容融合(多个C头文件独立定义)
			==>> 临时动态版本
	版本递增，有向无环
	只增数据结构
		只增数组
			梅森素数数列
			素数数列
			圆周率的连分数
		只增有向图
			版本
		只增集合
			梅森素数集合#部分已知梅森素数未知其真实次序，无法落户 梅森素数数列。
		只增空间
		只增映射





递归控制
	未知的输入函数(通过接口)无法控制
		但很多函数是可控的，如：子类覆盖虚函数
	接口声明：类、模块
	接口之内的依赖：
		控制 实现继承 的递归
		接口内分组分层，层组之间的依赖在接口中声明，须是有向无环
		super可增加一个参数：设定最外层的派生类
			甚至可以细化到特定层组使用特定最外类
	接口之间的依赖：
		要求有向无环依赖，颗粒可细化至层组
		循环依赖的那一部分，它们的实现将被强制要求一改同改。
			不循环也可手动要求如此
				如：__eq__ __hash__





