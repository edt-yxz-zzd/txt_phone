
e others/数学/编程/永恒代码/毛病纟异常bug-try-catch.txt
  mv -iv others/数学/编程/永恒代码/try-except毛病纟异常.txt others/数学/编程/永恒代码/毛病纟异常bug-try-catch.txt
view others/数学/编程/永恒代码/多况态真值+输出暨异常归类.txt


[[
摘要:
正常返回vs意图异常vs冷宫异常
  <==>
  * 可靠值==(可靠输出值|可靠错误值)
    保证 回顾性兼容
  * 不可靠值==(意图待办值|低层错误值|低层待办值)

===
可靠值:(正常返回|意图异常)
  正常返回%显式返回
  意图异常%显式抛出
不可靠值:冷宫异常:(意图待办值|低层不可靠值)
  冷宫异常@人工抛出
  冷宫异常@继承抛出
===
低层可靠值:(低层正常返回%自动捕获|低层意图异常@人工捕获)
低层不可靠值:(低层冷宫异常%不可捕获|低层意图异常@未被捕获)

===
本层冷宫异常 <<== 低层正常返回%自动捕获,低层意图异常@人工捕获,低层意图异常@未被捕获,低层冷宫异常%不可捕获
本层可靠值 <<== 低层正常返回%自动捕获,低层意图异常@人工捕获

===
低层不可靠值%(不可捕获|未被捕获) ==>> 本层冷宫异常@继承抛出
低层可靠值%(自动捕获|人工捕获) ==>> (本层可靠值%(显式返回|显式抛出)|本层冷宫异常@人工抛出)
===
*低层不可靠值%(不可捕获|未被捕获) ==>> 本层冷宫异常@继承抛出
  *低层冷宫异常%不可捕获 ==>> 本层冷宫异常@继承抛出
  *低层意图异常@未被捕获 ==>> 本层冷宫异常@继承抛出
*低层可靠值%(自动捕获|人工捕获) ==>> (本层可靠值%(显式返回|显式抛出)|本层冷宫异常@人工抛出)
  *低层意图异常@人工捕获 ==>> (本层正常返回%显式返回|本层意图异常%显式抛出|本层冷宫异常@人工抛出)
  *低层正常返回%自动捕获 ==>> (本层正常返回%显式返回|本层意图异常%显式抛出|本层冷宫异常@人工抛出)

]]
<<==:

[[
异常的必要性 来源于 对象构造
  构造失败 只能 抛出异常
  特别是 C++，在 栈帧上 直接构造 对象，连 返回nullptr的可能都没有

也许起源于:函数中断:进程中断...


困境冫封装纟框架化:
  毛病出在当下函数的组织形式:结构化，但 只提供 当前层的return
    低层函数的返回值 还得经过 当前函数 转发
    这也是 异常出现的需求之一吧？

]]

[[

逻辑上，异常有多个层次:
    通常，用户只关心:最浅层
用户关注某一类型异常(catch)，但同类型异常可以在意外之地触发
    这是逻辑错误，逻辑错误 都是 要命的严重错误
避免此类错误:
    与每一条语句处声明许可异常列表:
        f()
          ->^ KeyError|AttributeError

比如:
def __iter__(sf, /):
    yield f()
        # unexpected:^StopIteration
    return 999
        # expected:^StopIteration
def __getattr__(sf, /):
    x.y
        # unexpected:^AttributeError
    return 999
        # expected:no-AttributeError
def __getitem__(sf, /):
    f()
        # unexpected:^KeyError
    return 999
        # expected:no-KeyError
]]

[[
其他异常不行，AttributeError也不见得行，低层函数的异常不是本身的异常（？我附庸的附庸不是我的附庸？）
<<==:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/3.2.html
The hasattr() function works by calling getattr() and detecting whether an exception is raised. This technique allows it to detect methods created dynamically by __getattr__() or __getattribute__() which would otherwise be absent from the class dictionary. Formerly, hasattr would catch any exception, possibly masking genuine errors. Now, hasattr has been tightened to only catch AttributeError and let other exceptions pass through:

>>> class A:
...     @property
...     def f(self):
...         return 1 // 0
...
>>> a = A()
>>> hasattr(a, 'f')
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
(Discovered by Yury Selivanov and fixed by Benjamin Peterson; bpo-9666.)
]]

[[
程序升级，意味着 输入输出 更改
通常保证 回顾性兼容

但 所谓『回顾性兼容』显然 只是指『兼容正常模式』
* 返回值 保持不变 或者 升级为 子类
* 特定指明的异常 保持不变 或者 升级为 子类

而 未显式声明的异常:
  *可能改变异常类型(比如:改变优先次序，哪种异常先触发 不明确)
  *可能改变异常信息(默认供人参考，而非程序解读，不可靠)
  *可能被取消成为正常返回值(扩展输出 或 扩展输入)

只有 返回值 是 确定兼容的
异常十分不可靠，不仅异常参数不可靠，异常类型也不可靠(次序)，而且即使异常类型相同，也无法保证这是作者意图的异常而非低层传播的异常
  最终，异常 不能被后续代码可靠地解读，只能供人参考，不能看作是 接口的一部分
  除非 语言级别的支持:将所有 未经声明 允许 传播 的 意图异常 统统 打入 冷宫异常(区别于:意图异常)
  <==> 每个语句进行判定:指明允许传播的 意图异常
  <==> 只有 函数体内 显式抛出的异常 才是 意图异常 (声明传播 低层异常 等价于此)
  <==> 无异常语言 检查函数输出 是否为 错误...


正常返回vs意图异常vs冷宫异常
<==> 返回: (可靠输出值|意图异常值|低层异常值)

<==> 返回: (可靠输出值|可靠错误值|意图待办值|低层错误值|低层待办值)
  异常值-->(错误值|待办值)
  其中:
    * 可靠值==(可靠输出值|可靠错误值)
      保证 回顾性兼容
    * 不可靠值==(意图待办值|低层错误值|低层待办值)
      * 待办值 在 将来升级版中可能更新为 可靠输出值 或 可靠错误值，所以 (意图待办值|低层待办值)不可靠
      * 低层错误值 为 实现细节，在 将来升级版中可能采用新算法，所以 低层错误值 不可靠

不可靠值(意图待办值|低层错误值|低层待办值) 不该 被程序自动化区分处理，只有 主函数 有权 问询交互处理

输入 可升级为 超集，并保持 回顾性兼容==>>所有 检查输入型异常 都是 待办型异常(非 意图型异常)(参数个数不匹配，址引不匹配，属性名不匹配，类型不匹配，...，前置条件不成立)

不过:异常 打包了 源代码的出错现场信息(语言级别支持)，这是通常的 返回值 所不能及的
  C 『__FILE__』『__LINE__』
]]


[[
view ../lots/NOTE/C/__FILE__.txt
===
C 『__FILE__』『__LINE__』
===
/sdcard/0my_files/book/lang/C/The C Library Reference Guide(1997)(Eric Huss).pdf
    file:///C|/Documents%20and%20Settings/sshaikot/Desktop/c_guide/c_guide/1.7.html (4 of 5)4/1/2008 8:39:51 AM

===
C Guide--1.7 Preprocessing Directives

1.7.4 #line
The #line directive allows the current line number and the apparent name of the current sourcecode filename to be changed.
Syntax:
    #line line-number filename
Note that if the filename is not given, then it stays the same. The line number on the current line is one greater than the number of new-line characters (so the first line number is 1).
Examples:
    #line 50 user.c
    #line 23

1.7.5 #error
The #error directive will cause the compiler to halt compiling and return with the specified error message.
Syntax:
    #error message
Examples:
    #ifndef VERSION
    #error Version number not specified.
    #endif

1.7.7 Predefined Macros
The following macros are already defined by the compiler and cannot be changed.
    __LINE__
        A decimal constant representing the current line number.
    __FILE__
        A string representing the current name of the source code file.
    __DATE__
        A string representing the current date when compiling began for the current source file. It is in the format "mmm dd yyyy", the same as what is generated by the asctime function.
    __TIME__
        A string literal representing the current time when cimpiling began for the current source file. It is in the format "hh:mm:ss", the same as what is generated by the asctime function.
    __STDC__
        The decimal constant 1. Used to indicate if this is a standard C compiler.

2.1 assert.h
The assert header is used for debugging purposes.
Macros:
    assert();
External References:
    NDEBUG

2.1.1 assert
Declaration:
    void assert(int expression);
The assert macro allows diagnostic information to be written to the standard error file.
If expression evaluates to 0 (false), then the expression, sourcecode filename, and line number are sent to the standard error, and then calls the abort function. If the identifier NDEBUG ("no debug") is defined with #define NDEBUG then the macro assert does nothing.
Common error outputting is in the form:
    Assertion failed: expression, file filename, line line-number
Example:
    #include<assert.h>
    void open_record(char *record_name)
    { assert(record_name!=NULL);
      /* Rest of code */
    }
    int main(void)
    { open_record(NULL);
    }

]]

