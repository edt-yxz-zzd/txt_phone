
e others/数学/编程/永恒代码/操作符-数字前缀编码.txt

[[
用户标识,基本数据字面值,保留字(内建关键字,用户关键字)
基本数据字面值 := regex"0\S*|\d+"
    方案一:有痛点:字符串:str->s->z: regex"0z([^\s@^]|[@]\d*([^+]|$)|[@]\d*[+]|[^][-]|[^][.]|[^][#]|[^]u([0-9a-fA-F]*)(h[0-9a-fA-F]*)*n)*"
    方案一:串联无效:字符串:str->s->z: regex"0z([^\s@^]|[@]\d*[.]\d*[-]|[@]\d*[^+-]|[@]\d*[+]|[^][-]|[^][.]|[^][#]|[^]u([0-9a-fA-F]*)(h[0-9a-fA-F]*)*n)*[@]\d*[-]"
      方案二:简单没痛点:字符串:str->s->z: regex"0z([^\s^]|[^][+]|[^][-]|[^][.]|[^][#]|[^]u([0-9a-fA-F]*)(h[0-9a-fA-F]*)*n)*"
      ===
      方案一:有痛点:痛点: 编码后，字符串 不能串联:
          pre-encoded: "@5" ++ "6+"
          encoded: "@5" ++ "6+"
          pre-decoded: "@56+"
          decoded: "@55+"
        若是 要求 "@\d*$"或"^\d*+"也编码，则同一字符串有不同编码结果 或者 串联已编码串后 无法解码！
      ===
      decode direction:
      方案一:有痛点:不利串联:str"@+" ==>> "^"
        或 方案二:简单没痛点:str"^+" ==>> "^"
            方案二，编码后再次编码，每次固定增长s.count('^')个字符，只比 常见方案"^^"/"\\"的指数增长 好一点
            方案一，编码后再次编码，增长越来越少
      str"^-" ==>> " "
      str"^#" ==>> "\t"
      str"^." ==>> "\n"
      #str"^;" ==>> "\""
      #str"^," ==>> "\'"
      ===
      方案一:encode direction:
      str: "^" --> "@+" --> "@0+" --> "@1+" --> ... --> "@9+" --> "@00+" --> "@01+"
      regex"[@]9{n}[+]" --> regex"[@]00{n}[+]"
      regex"[^]\d*[1-9]0{n}[+]" ==>> regex"[^]\d*[0-8]9{n}[+]"
      ===
      方案一:串联无效:encode direction:
      regex"[@]\d*[-]$" --> 同上加一
      regex"[@]\d*[-](?!$)" --> 编码后禁止此型字串 regex"[@][.]\d*[-](?!$)"
      regex"[@]\d*[.]\d*[-]" --> 『.』前同上加一
      ===

    字节串:hex:byte->b->p:regex"0p(_*[0-9a-fA-F]{2})*"
    字节串:base64:64->6->g:regex"0pg[A-Za-z0-9-_]*"
      view ../../python3_src/py_stdlib_api.txt
        base64.urlsafe_b64encode()
        但除去 后缀填充『=』
    字节串:a85:64->6->g:regex"0pg[A-Za-z0-9-_]*"
        base64.a85encode
        字母表次序[!-u]
        每4字节 -> 5单元%85
        大端序:都是:bytes,ascii%85
    字节串:b85:64->6->g:regex"0pg[A-Za-z0-9-_]*"
        base64.b85encode
        字母表次序[0-9A-Za-z!#$%&()*+-;<=>?@^_`{|}~]
            #补偿\[
            除去10个:r''' "',./:[\]'''
            #补偿]
        每4字节 -> 5单元%85
        大端序:都是:bytes,ascii%85
    整数:十进制:regex"(0[+-]+)?(0(_*0)*|[1-9](_*\d)*)"
    整数:十六进制:regex"(0[+-]+)?0x[0-9a-fA-F](_*[0-9a-fA-F])*"
    整数:八进制:regex"(0[+-]+)?0c[0-7](_*[0-7])*"
    整数:二进制:regex"(0[+-]+)?0b[01](_*[01])*"
    浮点数:
用户标识 := regex"\D\S+" /-\ regex"\S+"
保留字 := regex"[1-9]\d*\D\S+" /-\ regex"\S+"
  用户关键字 := regex"[1-9]\D\S+" /-\ regex"\S+"
  内建括号 := regex"[1-9]{3}\D\S+" /-\ regex"\S+"
  原貌关键字 := regex"(66|99)\D\S+" /-\ regex"\S+"
  "6.*" "9.*" 括号
    "6\D.*" "9\D.*" 用户括号，不要求 匹配(后缀相同)，作为 额外信息 (自定义 部分 匹配)
    "66\D.*" "99\D.*" 原貌括号，要求 匹配(后缀相同)
  "2.*" 单操作数左侧操作符/前缀操作符
  "5.*" 单操作数右侧操作符/后缀操作符
  "3.*" 双操作数操作符/中间操作符
  "96.*" 关联多操作符-连结操作符:
  "696.*" 关联多操作符-起始操作符:
        a if b else c
          a 96if b 96else c
        if b then a else c
          696if b 96then a 96else c
        do .. od
          696do .. 969od
        @a. P b
        ?a. P b
  "8.*" 分隔符/逗号
  1/4/7
  "7.*" 单词注释
  "76.*" 嵌套注释起始符 #要求 里面 括号 完整 # 要不要求 负载匹配？
  "79.*" 嵌套注释结束符
  "766.*" 原貌注释起始符
  "799.*" 原貌注释结束符
    vs:
      "6.*" "9.*" 括号
      "66.*" "99.*" 嵌套完整原貌括号
      "666.*" "999.*" 原貌括号


矩阵分隔符:平坦化:
  :,;! 四进制数

  0 1 2 3
  : , ; !
  :: :, :; :!
  ,: ,, ,; ,!
  ;: ;, ;; ;!
  !: !, !; !!
  ::: ::, ::; ::!

]]
