抽象数据结构

===============内建？无结构？数？
	程序逻辑：bool
	传输字长：byte
	执行字长：word
	引用字长：ref
	函数字长：func
	人类文本：str=(字符集,其编码方案,字符串)
	数学整数


基本：
	无限：整数
	有限：剩余类
结构：
	数组
	元组
		n元组
		？？员组？胞组？序列？坐标
	集合
	映射
	双射
	单调数组
	？？有序集合
		*时序集合
		*排序集合
	===============命名不够统一，需要重建
	员=成员
	胞=元素

	筐#容器
		筐[型]
	静态约束
		...
	动态操作
		堆
		栈
		队
	数据结构
		数组
			O(1)
			概念是列+O(1)取操作-->数组
		链表
			O(i)
		树
			O(log n)


	元素约束：
		集：元素唯一
			集[型]{划分}
		射：元素为二元组，键值唯一
			射[入型,出型]{入型划分}
			射vs列vs函数vs集
				？？静态概念均是射？？
					元素 是何型？
					除非射的元素型是出型
					似无不可？只是与Python.Mapping.iter不兼容
				动态插删：列概念上的键值对变化颇大
				函数是完全函数，射只是不完全函数(KeyError)
		回：
			回[入型,出型]{入型划分,出型划分}
		序：元素全序
			序[型]{全序}

	组合方法：
		列#贯串
			正则表达式：重复
			列<:射
			列[型]{长}
		相#象
			联合
				同一个表达型，不同解码对应不同抽象型
				一个存储值，多个抽象值
				不同解释，不同编码
				如：同一数组，解为不同矩阵
			Haskell.newtype
			C.union=前缀+填充
			允许对每一抽象值独立约束
		兼#且
			共同子类
				同一解释，同一编码
			交集
			正则表达式：交
			兼 {型...}
		比#并、或、加
			(型+值)可定子型
			集合划分，互斥子集
			互斥并集
			正则表达式：互斥并
			？比<:射？
			#比[射[值，型]]
			比 {标签：型...}
		邻#连叠合积
			元组
			直积
			正则表达式：加
			邻[型...]
	值约束：
		...
		斥
			集合减

	列=胞列=数组
	邻=员列=元组
	列且集=时序集合=数组且集合<:双射
	序且集=排序集合=有序数组且集合<:单调双射






