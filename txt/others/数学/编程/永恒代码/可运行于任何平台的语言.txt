
可运行于任何平台的语言.txt
  -> 语法解析结果标记语言.txt
    -> 字符串内部转义.txt



index
  索引
    下标/附标
    指针
  检索/查找
  变址
  标引

归纳法 induction
归纳的 inductive
co-inductive




【可运行于任何平台的语言】
  假设 平台 是另一门编程语言【平台语言】
  *对平台需求少:
    要求:极少数据类型及函数
      基本数据类型
      [obj]
      {str:obj}
      (空间昵称::str, 类名::str, 分支名::str, args::[str], kwargs::{str:str}, body::[Either str this]) # 解析标记文件
          #===我的自由格式标记语言
      # 循环结构？垃圾回收？如何避免？如何声明只使用树状结构(inductive datatype)？只能是 只读 数据类型+直接求值（非惰性求值）#lambda？
        json?
    不用或少用 IO
      仅仅是计算器？
      加载 模块？读取 文件？
      系统调用？数据类型的方法调用
    要求:极简语言 虚拟机
      【极简语言】也是一种【可运行于任何平台的语言】
        极简: 最底层的
        极简语言 地位相当于 机器语言/字节码
        极简汇编语言 是更高级的语言
        以下 某某器 是指 极简语言模块
        极简语言模块===极简语言文本
      虚拟机==执行极简语言模块的平台语言函数
        ==极简语言模块执行函数
  *自带
    虚拟机调用库:
      各种标准框架语言解析函数:
        标记语言
          我的自由格式标记语言#见上面
          我的缩进前缀标记语言
          xml
          json
        CFG #后析器
        regex #先析器
    带状态嵌套的先析器
      :: 方言相应的带状态嵌套的先析器脚本 -> 方言文件 -> 方言切分文件
      要点:为了后续的『上下文无关』，这里必须处理有限的上下文约束
      常见对象: xml/python
        xml tag 要求嵌套能力及保存变量于各层，字符串相等比较
        python/Haskell 缩进 要求 比上面多一条:求字符串共同前缀
    上下文无关语法的通用后析器
      :: 方言相应的上下文无关语法文本 -> 方言切分文件 -> 方言标记文件
    标记文件通用变换器
      :: 标记变换语言文本 -> 标记语言文本 -> 标记语言文本
      #降糖器/过译器
      标记变换语言 #xslt？
    虚拟机脚本执行器
      虚拟机脚本语言 地位相当于 shell/bat
    无糖极简汇编语言汇编器
      无糖极简汇编语言
      无糖:
        最基础 最标准最正规 唯一官方语言
        最符合抽象概念中的应有的数据结构
        无需更多加工
          如:无糖C++，所有标识均去歧义，即附加:空间名/类名/函数签名/定义编号(定义所在的作用域的编号)
      加糖:
        加语法糖
        方言 #无糖官话 是 方言 之一
  *自举
    #？C的宏 是怎么回事？是对『方言切分文件』进行变换，还是边展开宏边切分？
    方言翻译过程:
      方言升糖器
        :: 大方言文本 -> 细方言文本
        如：从注释中，提出帮助文档信息
        如：前向兼容格式解析时跳过未知区域，新格式的解析只需在旧格式解析结果里深化解析
        不过，这些显然不适用于通过『无糖官话』中传的翻译过程，只得另行翻译，以下不再提及
      方言除糖器
        :: 方言文本 -> 无糖官话文本
        == 无糖退译器 . 方言标记文件除糖器 . 方言解析器
      方言翻译器
        :: 高级方言文本 -> 低级方言文件
        = 无糖斜译器 . 方言标记文件除糖器 . 方言解析器
        = 退译器 . 无糖过译器 . ...降糖器... . 方言后析器 . 方言先析器

      解析器 :: 方言文本 -> 方言标记文件
        #可逆: 后译器
        先析器 :: 方言文本 -> 方言切分文件
        后析器 :: 方言切分文件 -> 方言标记文件

      降糖器 :: 高糖标记文件 -> 低糖标记文件
        #多个降糖器使方言逐步正规化
      方言标记文件除糖器 :: 方言标记文件 -> 无糖官话标记文件

      斜译器 :: 高级方言标记文件 -> 低级方言文本
        过译器 :: 高级方言标记文件 -> 低级方言标记文件
        退译器 :: 方言标记文件 -> 方言文本
      无糖斜译器 :: 无糖高级语言标记文件 -> 低级方言文本


    编译器生成过程:
      方言编译器
        :: 方言文本 -> 极简语言模块
        = 极简汇编语言汇编器 . 方言后编器 . 方言解析器
        = 极简汇编语言汇编器 . 无糖后编器 . 方言标记文件除糖器 . 方言后析器 . 方言先析器
        = 极简汇编语言汇编器 . 无糖后编器 . 标记文件通用变换器 方言相应的标记文件除糖变换文件 . 上下文无关语法的通用后析器 方言相应的上下文无关语法文本 . 带状态嵌套的先析器 方言相应的带状态嵌套的先析器脚本

      #见上面: 解析器 :: 方言文本 -> 方言标记文件
      后编器 :: 方言标记文件 -> 极简汇编语言文本
        #后编器===斜译器<目标语言=极简汇编语言>

    无糖编译器 :: 无糖官话文本 -> 极简语言模块
      无糖后编器 :: 无糖官话标记文件 -> 极简汇编语言文本
        #无糖后编器===无糖斜译器<目标语言=极简汇编语言>

          #
      编译器自举链:
        [极简语言] -> 无糖极简汇编语言 -> 极简汇编语言 -> 低级语言 -> ... 中间语言 ... -> 高级语言
      自举过程:
        ====
        假设已有:
          低级语言编译器
          低级语言写的无糖高级语言编译器的源代码
        则可得:
          无糖高级语言编译器
        ====
        假设已有:
          无糖官话编译器
          无糖官话写的方言除糖器的源代码
        则可得:
          方言除糖器
          方言编译器
        ====
        假设已有:
          低级语言编译器
          低级语言写的无糖后编器的源代码

          无糖极简汇编语言汇编器
          无糖极简汇编语言写的极简汇编语言汇编器的源代码

          标记文件通用变换器
          上下文无关语法的通用后析器
          带状态嵌套的先析器

          方言相应的标记文件除糖变换文件
          方言相应的上下文无关语法文本
          方言相应的带状态嵌套的先析器脚本
        则可得:
          方言编译器
            方言解析器
              方言先析器
              方言后析器
            方言后编器
              方言标记文件除糖器
              无糖后编器
            极简汇编语言汇编器
        ====
        实有:
          无糖极简汇编语言汇编器
          标记文件通用变换器
          上下文无关语法的通用后析器
          带状态嵌套的先析器
          ===可用外部高级语言实现
          ===再用外部自定制编译器翻译为『极简汇编语言文本』
          ===最后用外部自定制汇编器生成『极简语言模块』
        仍需:
          无糖极简汇编语言写的极简汇编语言汇编器的源代码
          所有 无糖高级语言:
            低一级语言写的无糖后编器的源代码
          所有 高级方言:
            方言相应的标记文件除糖变换文件
            方言相应的上下文无关语法文本
            方言相应的带状态嵌套的先析器脚本

        ====

    自举编译器:
      



