编程任务无用技巧书目:
  #通过问题，打发时间
  组合问题:
    重复数差分列表 -> 已排序的所有排列
    [uint] -> sorted{[uint]}
    [uint] -> iter sorted{[uint]}
    @[ls::[uint]] -> iter sorted{[uint%len(ls)]{sum . acc $ ls}}
    ==>> 类型，如何描述约束？lambda
    ==>> 问题转化，数据的正规标准化/约束去除(为何是 重复数+紧致自然数+差分，编码)，并转化为更基本的问题
    ==>> obj.__iter__
      mk_st :: ... -> st
      generator :: st -> Maybe (st, o)
      #mk_st2 :: ... -> (st,o)
      generator2 :: i -> st -> Maybe (st, o)
      ===data+func => 如何传递数据与函数，打包则对象，分离则外挂(显式参数动态传入，隐参数动态传入(静态外挂，动态领域with)，隐参数静态空降)
      抽象是共性抽取.txt
      类接口
      正方形 矩形 读写
      树/图 接口: 棋盘状态 多，文件系统 失控
      垃圾回收，引用计数
        循环引用？垃圾回收
          指针必须被完全封装，运行时必须知道对象实体的属性类型
            * 只有一种类型
              只有一种对象在内存的表达模式/协议
            * 绝对静态类型
              由出发节点的静态类型可推出所有子对象的类型
              *分支信息 辅助 识别类型
              *直至 只有一种类型
            * 对象打包类型指针
          连通图算法，背景实时并行
          由于指针被完全封装，可实现 内存碎片整理
        嵌入式引用计数
        外挂代理引用计数
        全局地址映射表 :: {伪地址:(引用计数,实际指针)}
          引用 并非实际指针，而是 映射表的键
          连通图/finger_tree
          图 的 增量更新 持久性数据结构
            考虑下 functional 图 的 实现形式
            非树情形 显然不能用 节点直连的方案
            要么 边 抽象化，要么 节点引用 重定位
          作为一个只读量，Haskell的值时怎么由lazy expr变成whnf(weak_head_normal_form)的？
            肯定进行了某种就地修改，如何保证是原子操作？如何阻止其他线程重复计算(虽无害正确性但有害效率)
      动态类型/静态类型
        类型泛化次序
          子类对象可当作父类对象用
            对象指针依静态类型自动变换
              如：作为参数传入
                如：指针相等比较
          子接口对象即是父接口对象
          空间提升+抽象参数细化+...
        多态方案
          编译时多态，模版实例化，代码爆炸
          类体系多态
            子类对象实体包含父类对象实体
          接口多态
            接口+实现+对象引用(对象实体在堆上)
          ADT类型参数多态
            由于 类型参数 静态未知 动态不可得，故 其对象完全不被读写
            一般与 外挂指针 连用，用作 隐参数
            ADT数据类型 有时会将 外挂的接口函数表指针 与 数据 一起打包，形成一个类型关系保证
        接口函数表的传递方案
          静态类型决定
          动态指针
            打包指针:
              与数据捆绑
              不可变动
              因为随时可能有函数访问，一旦修改，后果难测
            外挂指针:
              作为隐含参数 与 数据 一起 传入 工作函数
              依 静态类型所声明的 工作函数的需求 自动更新 接口函数表
  连分数:
    符号计算
    相加
    ==>> ?geometry compute?
    一元多项式的根
    现实测量的数据 精度有限
      显微镜的观测尺寸虽小，但对于提高百米赛道的精度毫无帮助。
      高精度运算无用
  多项式分解:
    线性多项式
      矩阵
        比 数组的数组 有更强约束
        平面，复数，矩阵，vs RGB A 像素图像
        平面 vs 线
          无序(两面？) vs 线性有序，两个方向
          图形不相似 vs 线段皆相似
    G基
    有限域上分解
    整数域上分解
    domain上分解
    一元多项式的根
  图论
    树
    平面图
  knot
    编制knot表
  lambda
    输入 输出 成 算法
    太难读懂，需要类型
    类型论
    formal proof 形式证明？
    lazy strict 导致(++)的实现算法不同
    组合算子 避免 变量 #终止:参数不足
      combinator
      Y = fixed point operator
        g = Y f
        [g `fixed_point_of` f] <==> [f g === g]
        Y f = g = f g =.f (Y f) = f (f (f (f (...))))

        #first curry f
        #second def z: z z = f (z z)
        #then y f = z z
        f :: yf -> (i->o)
        y :: f -> (i->o)
        e = i->o  # expected
        (f (y f)) = e = y f = f e
        f :: e -> e
        y :: (e -> e) -> e
        e = z z = z2e z
        z = z2e = z2e_2e = z2e_2e_2e
          = ((...->e)->e)
        y f = e = z z = f e = f (z z)
          = h2hh z
          = h2hh $ \z-> f (z z)
          = h2hh $ \z-> f $ \i->(z z) i
          where
            h2hh h = h h
        (define (Y r)
          ((lambda (f) (f f))
            (lambda (f) (r (lambda (x) ((f f) x))))))

  数据结构
    B_tree
      原子更新.txt
    finger_tree
      队列
      排序
      range_set
    安全区-避免 999+1-1+1-1
  编译
    通用汇编语言.txt
    字符串转义方案.txt
      预防多次转义长度爆炸
    正则表达式
      有限状态机
    上下文无关语法
      LL
      LR
      Earley
    识别器
      Monad
        分离pure/IO
  加密
    定长加密
    变长加密
    散列压缩
    ...
  编码
    RMQ
    整数编码.txt
    枚举iter 排列/w..word/...
  容器
    序列
    集合
    队列
    映射/词典
      vs 函数
        无区别
        打印出来？



