
并非仅是关于2_3_4_tree，重点考虑所有泛化可能及稳定情形

===见最后 三对变量相等简化情形:
  可知 2_3_tree 就够用了
    虽然 2_3_tree 不稳定
    但 2_3_4_tree 也不稳定
  要求稳定性的话: 2_3_4_5_6_tree
===简化情形
  三对变量相等简化情形
  两对变量相等简化情形
    存储块简化情形
===见下面:泛化建议:
  『使用偶数q及m』
  例:p=n=1, x=2, q=m=s=r=6
  例:p=n=2, x=2, q=m=s=r=8








2_3_4_tree
2-3-4 tree
=====
B-tree
multiway search tree

=====2_3_4_tree
#n-node: (n-1) values, n-subtree #分叉数比元素数多一#多一路
#same-depth     #平衡
#sorted         #素序，其实不必要#或者 其实指的就是 位序 而非 素序？
• Every node (leaf or internal) is a 2-node, 3-node or a 4-node, and holds one, two, or three data elements, respectively.
• All leaves are at the same depth (the bottom level).
• All data is kept in sorted order.
=====



=====
=====以下 泛化2_3_4_tree，即B-tree

=====性质/要求/约束
  *多一路
  *平衡
  *插入删除所依的 位序 是 根中位序/向右根中元素遍历序
  *可选 稳定性:
    互逆修改(插入-删除)，交替进行时，平均的更新节点数为O(1) #注意:单次操作最坏情况O(log n)
    ==>> 上溢或下溢更新后的节点(或 新建的节点:分裂出的/合并的/新根)处于 安全区
      #一般不考虑被更新的各层中的最上层
    安全区: 下一次修改的影响将无法跨过本节点




=====
树节点 往上:
  根节点:无父节点
  非根节点:有父节点
树节点 往下:
  叉节点:
    子节点为叉节点或拳节点
    子节点为丫节点或末节点
    ===
    芽节点=根叉节点
    丫节点=非根叉节点
    ===
  拳节点:
    子节点为叶节点
    子节点为鳞节点
    ===
    独节点=根拳节点
    末节点=非根拳节点
    ===
  叶节点:
    无子节点
    ===
    卵节点=根叶节点
    鳞节点=非根叶节点
      ==父节点为拳节点
    ===
根节点=整树根节点=卵节点|独节点|芽节点
  注意:
    删除元素 产生的 下溢 可能蔓延到 根节点
    根节点 无兄弟节点进行 下溢合并
    为简单故，非空根节点的元素数由1开始
    故将 根叉节点 与 非根叉节点 明确区分开
    同理，将 根拳节点 与 非根拳节点 明确区分开
    由于 根叶节点 的实现形式 可能并入 根拳节点，而与 非根叶节点 不同，故也将它俩明确区分开

叶节点
  无子节点的节点
  实际上不存在
  只存在于概念中/null/None/empty-tree
  因为每一个元素必有前后两棵子树，必有前后两个叶节点<<==multiway
拳节点
  叶节点的父节点
  因为叶节点实际并不存在，所以拳节点只是一个元素数组
  *独节点=根拳节点
  *末节点=非根拳节点
叉节点
  拳节点或叉节点的父节点
  元素数组+子树数组
=====
view others/数学/编程/术语/我的术语.txt
==>>:
#B-tree:两个子节点之间夹份数据
树节点:按有无父节点分类:欤根
  根节点:无父节点
  子节点:非根节点:有父节点
树节点:按有无子节点分类:欤叶
  叶节点:无子节点
  父节点:非叶节点:有子节点
树节点:按有无数据分类:欤胖
  瘦节点:叶节点|链节点:无数据
  胖节点:叉节点|拳节点:有数据
    #若允许独子:则存在无数据而有子节点的节点:非叉暨非拳暨非叶==>>链节点
[欤叉+欤叶+欤拳+欤链==1]
[欤叉+欤拳==欤胖=!=欤瘦==欤叶+欤链]
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,0,0,0,1)]:肘节点=子链节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,0,0,1,0)]:末节点=子拳节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,0,1,0,0)]:鳞节点=子叶节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,1,0,0,0)]:丫节点=子叉节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,0,0,0,1)]:臂节点=根链节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,0,0,1,0)]:独节点=根拳节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,0,1,0,0)]:卵节点=根叶节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,1,0,0,0)]:芽节点=根叉节点






=====位序
#先后:从左向右的先后
  根先位序
  根中位序
  根后位序

=====元素遍历序
#正向
  向右根先元素遍历序
  向右根中元素遍历序
  向右根后元素遍历序
#反向
  向左根先元素遍历序=反转 向右根后元素遍历序
  向左根中元素遍历序=反转 向右根中元素遍历序
  向左根后元素遍历序=反转 向右根先元素遍历序

=====性质
依 根中位序:
  叶节点 与 元素 交替，开头结尾均是叶节点

  根 是叉节点:
    只考虑元素，必是 末节点/叉节点 中的元素 交替
  任意非空子树 开头结尾均是末节点中的元素

  叉节点中的元素，其相邻元素必在以该叉节点为根的子树中
  插入删除 依 根中位序:
    注意:
      叶节点总数比元素总数多一
        插入删除元素必然要插入删除叶节点
      叶节点并不是叉节点的子节点
        插入删除叶节点必然影响某个拳节点(新建/消失/修改)
      ==>>
        插入元素应转化为指定叶节点来插入
        删除元素应转化为删除拳节点中的元素

    元素位置=
      非叶节点+元素数组的下标
      元素的左叶节点 #类似数组下标，元素依左下标，最右下标越界

    删除 叉节点中的元素 <==> 交换相邻元素，删除 末节点中的元素，下溢处理
    插入 元素，插入的位置可用 叶节点 表示
    插入元素到 非空树 <==> 插入元素到 拳节点，上溢分裂

=====






=====
假设:
  末节点:含[p..q]个元素
    1 <= p <= q
    [可选 稳定性]:
      [p+1..q-1] 是拳节点的安全区
      1 <= p < p+1 <= q-1
      1 <= p <= q-2
  叉节点:含[n..m]个元素
    #同上
    1 <= n <= m
    [可选 稳定性]:
      1 <= n <= m-2
  独节点:含[1..s]个元素
    1 <= s
    考虑到: 根节点 0元素 1子树 时，提拔 子树 为 根
    q <= s
    [可选 稳定性]:
      #一般不考虑被更新的各层中的最上层
      pass
  芽节点:含[1..r]个元素
    #同上
    m <= r
  #2_3_4_tree:p=n=1,q=m=r=s=3
  ====总结 基本约束
  [1 <= p <= q <= s]
  [1 <= n <= m <= r]
  [可选 稳定性]:
    [1 <= p <= q-2 <= s-2]
      # 3 <= q <= s
    [1 <= n <= m-2 <= r-2]
      # 3 <= m <= r



参数的约束:
case 整树中元素总数 of:
0:
  #empty-tree
  根 是 卵节点
1..s:
  若单层:
    根 是 独节点
s+1:
  根 是 芽节点
  若两层:
==





元素位置=
  非叶节点+元素数组的下标
  元素的左叶节点 #类似数组下标，元素依左下标，最右下标越界

删除 元素:
  要求 树非空
  指定位置-叶节点
    #删除叶节点右元素
    #保留本叶节点，但删除或右或左的叶节点
    #   若 指定叶节点是所在拳节点的最右叶节点，则 删除左叶节点
    #       否则，删除右叶节点
  删除 叉节点 元素:
    指定叶节点是所在拳节点的最右叶节点
      是整树最右叶节点时越界出错
    交换（指定叶节点，其右元素）<->（其左叶节点，其左元素）
    转化为 删除 拳节点 元素
  删除 拳节点 元素:
    指定叶节点不是所在拳节点的最右叶节点
    删除（指定叶节点，其右元素）
    若 下溢，则 进行 下溢处理

  下溢处理:
    假设 当前节点缺少z个元素
      1 <= z <= max(p,n)
    独节点:
      1->0
      变 空树

    ==
    #下溢合并
    #   假设 下溢合并 只合并两兄弟节点(加上 所夹的父元素)
    #   z <= 1

    末节点:
      1 == z
      下溢合并
      p-z +1+ [p..q] -> [2*p..p+q]
      *[max(2*p, q+1)..q+p]
        上溢分裂
        p +1+ p <= max(2*p,q+1) <= q+p <= q +1+ q
        !! 1 <= p <= q
        2*p <= q
        父节点元素数不变
      *其他情形:
        父节点元素数减一
          父节点可能需要 下溢处理 with z=1
        pass
      2*p <= q
      [可选 稳定性]:
        由于 合并后的末节点 不是 最高被修改层(父节点已被修改)，故 被要求出于 安全区 [p+1, q-1]
        注意: p+1 <= 2*p，即：合并后的末节点下限 必然安全，无需多言
        # vs 上面: *[max(2*p, q+1)..q+p]
        *[max(2*p, q)..q+p]
          上溢分裂
          p+1 +1+ p+1 <= max(2*p,q) <= q+p <= q-1 +1+ q-1
          !! 1 <= p <= q
          2*p+3 <= q
          父节点元素数不变
        *其他情形:
          父节点元素数减一
            父节点可能需要 下溢处理 with z=1
          pass
        2*p+3 <= q
      ===总结 末节点 删除
      [2*p <= q]
      [可选 稳定性]:
        [2*p+3 <= q]

    叉节点:
      1 <= z <= n # 注意:n可能是1
      由 末节点 的 下溢合并 致 父节点元素数减一 可知:
        min{z:...} == 1

      强行 令 z:=1
      *非根 叉节点 丫节点:
        为简单故，强行 令 z:=1
        同理 于 末节点 情形:
          [2*n <= m]
          [可选 稳定性]:
            [2*n+3 <= m]
      *根 叉节点 芽节点:
        芽节点 下限为1   #[1..r]
        下溢 则 提拔
        下一层为 末节点:
          q <= s
        下一层为 丫节点:
          m <= r
      ===总结 叉节点 删除
      设定:
        z=1
      [m <= r]
      [q <= s]
      [2*n <= m]
      [可选 稳定性]:
        [2*n+3 <= m]
  ===总结 删除
  设定:
    z=1
  [m <= r]
  [q <= s]
  [2*n <= m]
  [2*p <= q]
  [可选 稳定性]:
    [2*n+3 <= m]
      # 5 <= m
    [2*p+3 <= q]
      # 5 <= q




插入 元素:
  指定位置-叶节点
    #叶节点之右
    #插入新元素及新叶节点到叶节点右边
    树非空:
      <==>插入到拳节点
  只需 处理 上溢
    上溢 只需 分裂，无需 其他操作

  ==参数的约束@上溢分裂
    独节点:
      #见上面 整树中元素总数==s+1
      独节点[1..s]
        s+1 ==>> 两层:芽节点+末节点
      芽节点[1..r]
      1+(1+1)*p <= s+1 <= r+(r+1)*q
      2*(p+1) <= s+2 <= (r+1)*(q+1)
      [可选 稳定性]:
        #neednot: 1+1 +(1+1+1)*(p+1) <= s+1 <= r-1 +(r-1+1)*(q-1)
        #一般不考虑被更新的各层中的最上层
        1 +(1+1)*(p+1) <= s+1 <= r +(r+1)*(q-1)
        2*(p+2) <= s+2 <= (r+1)*q
      ===总结 独节点 插入
      [2*(p+1) <= s+2 <= (r+1)*(q+1)]
      [可选 稳定性]:
        [2*(p+2) <= s+2 <= (r+1)*q]

    末节点:
      任意树，插入元素到末节点，overflow，在平衡要求下，只能将元素排挤到父节点，父节点overflow暂不考虑的话，必须仅仅只能影响两层
      ==
      假设 (q+1)的末节点 overflow，导致 父节点 插入 t 个元素
      # 允许父节点暂时上溢
      1 <= t
      # 1 <= t <= m-n ??
      t + (t+1)*p <= q+1 <= t + (t+1)*q
      (t+1)*(p+1) <= q+2
      [可选 稳定性]:
        t + (t+1)*(p+1) <= q+1 <= t + (t+1)*(q-1)
        (t+1)*(p+2) <= q+2 <= (t+1)*q
        !! 3 <= q
        (t+1)*(p+2) <= q+2
      #t越大，p的上限越小，为简单故，可设[t=1]
      # 但考虑到还有『下溢合并后的上溢分裂』，意义不大
      ===总结 末节点 插入
      [1 <= t]
      [(t+1)*(p+1) <= q+2]
        # 2 <= 2*p <= q
      [可选 稳定性]:
        [(t+1)*(p+2) <= q+2]
          # 4 <= 2*p+2 <= q

    叉节点:
      前:插入i元素(附带 子树)
        源自 末节点/叉节点的上溢分裂
          [i0<=t] -> i1 -> i2 ... -> [?=0]
        源自 末节点/叉节点的下溢合并后的上溢分裂
          假设 下溢合并 只合并两兄弟节点(加上 所夹的父元素)
            下溢合并后，就算上溢，也只能分裂成俩，往父节点塞一个元素，o==1
            所以在此假设下，实无影响
      后:上溢分裂o (即:父叉节点插入o元素)
        0 <= o
        0==o || 1 <= no <= o
      假设 mi = max {i:...}
      假设 mo = max {limit o:...}
        # <<== 上溢分裂规模不得无限增长
        上溢分裂的特性:
          o <= i # 递减
          mo <= mi
      #err: mi == max mo t == t
      #     需考虑:下溢合并后的上溢分裂
      t <= mi

      ==
      [n..m] +i ==>> [n+i..m+i]
      1 <= i <= mi
      0==o || 1 <= no <= o <= mo <= mi

      *不上溢时:
        [n..m-i] +i ==>> [n+i..m]
        0==o
        n <= m-i
        i <= m-n
      *上溢分裂时:
        [m+1-i..m] +i ==>> [m+1..m+i]
        1 <= no <= o <= mo <= mi
        1 <= no <= mo <= mi
        *非根 丫节点 上溢分裂时:
          1 <= no <= o <= mo <= mi
          no +(no+1)*n <= m+1 <= m+i <= m+mi <= mo +(mo+1)*m
          (no+1)*(n+1) <= m+2 <= m+mi+1 <= (mo+1)*(m+1)
          [可选 稳定性]:
            no +(no+1)*(n+1) <= m+1 <= m+i <= m+mi <= mo +(mo+1)*(m-1)
            (no+1)*(n+2) <= m+2 <= m+mi+1 <= (mo+1)*m
        *根 芽节点 上溢分裂时: 1 <= o <= r
          1 <= no <= o <= mo <= r
          1 <= no <= mo <= r
      ===总结 叉节点 插入
      [1 <= no <= mo <= min(r,mi)]
      [max(t,mo) <= mi]
      [(no+1)*(n+1) <= m+2 <= m+mi+1 <= (mo+1)*(m+1)]
      [可选 稳定性]:
        [(no+1)*(n+2) <= m+2 <= m+mi+1 <= (mo+1)*m]

  ===半 总结 插入: 待除去 t,no,mo,mi
  [2*(p+1) <= s+2 <= (r+1)*(q+1)]
  [1 <= t]
  [(t+1)*(p+1) <= q+2]
    # 2 <= 2*p <= q
  [1 <= no <= mo <= min(r,mi)]
  [max(t,mo) <= mi]
  [(no+1)*(n+1) <= m+2 <= m+mi+1 <= (mo+1)*(m+1)]
  [可选 稳定性]:
    [2*(p+2) <= s+2 <= (r+1)*q]
    [(t+1)*(p+2) <= q+2]
      # 4 <= 2*p+2 <= q
    [(no+1)*(n+2) <= m+2 <= m+mi+1 <= (mo+1)*m]
  ===设 t,no,mo,mi
  t=1
  no=mo=1
  mi=1
  ===已除去 t,no,mo,mi
  ===剩余变量 在>=1的条件下简化，各约束独立简化
  ===总结 插入
  设定:
    t=1
    no=mo=1
    mi=1
  [2*(p+1) <= s+2 <= (r+1)*(q+1)]
  [2*p <= q]
  [2*n <= m]
  [可选 稳定性]:
    [2*(p+2) <= s+2 <= (r+1)*q]
    [2*p+2 <= q]
    [2*(n+2) <= m+2 <= 2*m]




待汇总:
  ====总结 基本约束
  [1 <= p <= q <= s]
  [1 <= n <= m <= r]
  [可选 稳定性]:
    [1 <= p <= q-2 <= s-2]
      # 3 <= q <= s
    [1 <= n <= m-2 <= r-2]
      # 3 <= m <= r
  ===总结 删除
  设定:
    z=1
  [m <= r]
  [q <= s]
  [2*n <= m]
  [2*p <= q]
  [可选 稳定性]:
    [2*n+3 <= m]
      # 5 <= m
    [2*p+3 <= q]
      # 5 <= q
  ===总结 插入
  设定:
    t=1
    no=mo=1
    mi=1
  [2*(p+1) <= s+2 <= (r+1)*(q+1)]
  [2*p <= q]
  [2*n <= m]
  [可选 稳定性]:
    [2*(p+2) <= s+2 <= (r+1)*q]
    [2*p+2 <= q]
    [2*(n+2) <= m+2 <= 2*m]


====总结:p,q,s,n,m,r
  设定:
    z=1
    t=1
    no=mo=1
    mi=1
    =====
  [1 <= p <= 2*p <= q <= s]
  [1 <= n <= 2*n <= m <= r]
  [s+2 <= (r+1)*(q+1)]
  [可选 稳定性]:
    [2*n+3 <= m]
      # 5 <= m
    [2*p+3 <= q]
      # 5 <= q
    [s+2 <= (r+1)*q]
====对复杂约束进行分析:
  [s+2 <= (r+1)*(q+1)]
    r >= 2*n >= 2
    (r+1)*(q+1) >= 3*q+3
    [s <= 3*q+1]时，此约束自动满足
  [可选 稳定性]:
    [s+2 <= (r+1)*q]
      r >= 2
      q >= 2
      (r+1)*q >= 3*q >= 2*q+2
      [s <= 2*q]时，此约束自动满足

====最小可能情形:
  p=n=1
  q=m=2
  s=r=2
  [可选 稳定性]:
    p=n=1
    q=m=5
    s=r=5
====三对变量相等简化情形: 只剩 p,q,s
  设定:
    p=n
    q=m
    s=r
    =====
    z=1
    t=1
    no=mo=1
    mi=1
    =====
  [1 <= p <= 2*p <= q <= s]
  [可选 稳定性]:
    [2*p+3 <= q]
      # 5 <= q
====两对变量相等简化情形: 只剩 p,q,n,m
  #见上面:对复杂约束进行分析
  设定:
    q=s
    m=r
    =====
    z=1
    t=1
    no=mo=1
    mi=1
    =====
  [1 <= p <= 2*p <= q]
  [1 <= n <= 2*n <= m]
  [可选 稳定性]:
    [2*n+3 <= m]
      # 5 <= m
    [2*p+3 <= q]
      # 5 <= q
=
====存储块简化情形:对半+稳定性+两对变量相等简化情形
  设定:
    q=可用单元数
    m=(q-1)//2
      #一半弱:元素/元素指针
      #一半强:子节点指针i
    +[稳定性]
    =====
    q=s
    m=r
    =====
    z=1
    t=1
    no=mo=1
    mi=1
    =====
  [稳定性]:
    [1 <= p == (q-3)//2]
    [m == (q-1)//2]
    [1 <= n == (m-3)//2]
    # 1 <= n
    # 5 <= m
    # 11 <= q
    # 4 <= p
=
#存储块简化情形 示例
1 block = ? word
  512 B / 8 B = 2^(9-3) = 2^6
  64 word
    #稳定性+两对变量相等简化情形
    1 word:
      #实际只需7 bit/1 byte
      *节点类型+本节点元素数
        6bit:本节点元素数
        1bit:节点类型
          叉节点|拳节点
          ====
          鳞节点 不存在
          卵节点 与 独节点 合并，由 本节点元素数 是否为零 区分
          根节点 与 非根节点 由 父节点指针 是否无效 区分

      *子树总元素数
        无用，只需记录整树总元素数即可
        有害，增加修改的节点数
      *父节点指针
        无用，平衡树的高度很小，保存当前路径在内存里即可
    拳节点:
      63:元素/元素指针
      q=s=63
      p=30
    叉节点:
      31:元素/元素指针
      32:子节点指针
      m=r=31
      n=14




合理减少节点数:
  p=n=1 最坏情况是 二叉树 节点太多
  q=m=s=r=2*p (+3)
  p=n=? 中间两层的元素数 最少有 p+(p+1)*p==p*(p+2)
  [2^10 <= p*(p+2)]:
    p >= 2^5 = 32
    q >= 64 or 67
  [2^8 <= p*(p+2)]:
    p >= 2^4 = 16
    q >= 32 or 36
  [2^7 <= p*(p+2)]:
    p >= 12
    q >= 24 or 27
  [100 <= p*(p+2)]:
    p >= 10
    q >= 20 or 23
  [2^6 <= p*(p+2)]:
    p >= 2^3 = 8
    q >= 16 or 19
  [2^4 <= p*(p+2)]:
    p >= 2^2 = 4
    q >= 8 or 11

===泛化建议:
  『使用偶数q及m』
    理由:上溢分裂时对半分:q+1 ==>> q/2 +1+ q/2
  『要求稳定性』
    理由:降低对节点的修改频率
  #『稳定性插入删除无法对称』
    2*p+3<=q
    2*p+2*x==q
    x >= 2
    上溢分裂:q+1 ==>> p+x +1+ p+x
    下限安全距离=p+x - p = x
    上限安全距离=q - (p+x) = p+x > 下限安全距离
    p越大x越小，则越不对称
    p越小，可能的节点数越多
    1/y=1+y
    1-y=y^2
    (1-y)/y = y/1
    x/(p+x) >= y
    p/x <= y
    x >= p/y > p*1.618
    2 >= 1/y
    4 >= 2/y
    5 >= 3/y
    7 >= 4/y
    x/p >= 1/y > 2/1, 5/3, 13/8, 34/21...

  例:p=n=2, x=2, q=m=s=r=8
  例:p=n=3, x=2, q=m=s=r=10

  例:p=n=1, x=2, q=m=s=r=6
  例:p=n=2, x=4, q=m=s=r=12
  例:p=n=3, x=5, q=m=s=r=16
  例:p=n=4, x=7, q=m=s=r=22
  例:p=n=8, x=13, q=m=s=r=42












