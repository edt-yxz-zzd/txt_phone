
e others/数学/编程/TODO_list/整数编码-多单元联合前缀-数目纟标准形态.txt



[数目纟标准形态纟多单元联合前缀{A,B,N;len==N*M} == B**(N*M) * A**((N-2)*(M-2)) * (A-1)**((N-2)*2)]
格式纟仅保留前缀胞纟标准形态纟多单元联合前缀: regex"6{N}([^6].{N-2}[^9])*9{N}"
<<==:






假设 表达空间规模纟存储单元 为:A*B
  A~表达空间规模纟前缀胞
  B~表达空间规模纟负载部分
  [A::uint{>=2}]
    # 见下面:[『6』=!=『9』]
  [B::uint{>=1}]
假设 长度纟前导串 为:N
  [N::uint{>=2}]
    # 见下面:『{N-2}』
格式纟仅保留前缀胞纟标准形态纟多单元联合前缀: regex"6{N}([^6].{N-2}[^9])*9{N}"
  假设前导符的前缀胞是『6』
  假设后终符的前缀胞是『9』
  [『6』=!=『9』]
  #相应地，非标准形态 即 缩减 标准形态 的 最后一个 中间环节
格式纟仅保留前缀胞纟非标准形态纟多单元联合前缀: regex"6{N}([^6].{N-2}[^9])*([^6].{0,N-3}[^9])9{N}"



假设 长度纟标准形态纟多单元联合前缀 为:L
  [L::uint{>=2*N}]
!! 格式纟仅保留前缀胞纟标准形态纟多单元联合前缀
[L%N == 0]
[M:=L///N]

==>>:
[数目纟标准形态纟多单元联合前缀{A,B,N;len==N*M} == B**(N*M) * A**((N-2)*(M-2)) * (A-1)**((N-2)*2)]

若要所有 数目纟标准形态纟多单元联合前缀 为 非平凡幂方:
  !! [A >= 2]
  ?(z,e):=>[z::uint{>=2}][e::uint{>=1}][A==z**e]

  !! [A >= 2]
  !! [A==z**e]
  !! 目标要求
  ?e0:=>[e0::uint{>=0}][A-1==z**e0]
  ?eB:=>[eB::uint{>=0}][B==z**eB]
  !! [gcd(A,A-1)==1]
  [e0 == 0]
  [A==2]
  [B==2**eB]
[数目纟标准形态纟多单元联合前缀{A:=2,B:=2**eB,N;len==N*M}
== 2**(eB*N*M) * 2**((N-2)*(M-2)) * 1**((N-2)*2)
== 2**(eB*N*M + (N-2)*(M-2))
== 2**((eB+1)*N*M +4 -2*N -2*M)
== 2**(((eB+1)*N -2)*M -2*(N-2))
]
若要所有 数目纟标准形态纟多单元联合前缀 为 2的非平凡幂方的非平凡幂方:
  [ec:=gcd{(((eB+1)*N -2)*M -2*(N-2)) | [M:<-[2..]]}]
  目标要求<==>[ec>=2]
  !! 目标要求
  !! M连续变动
  [ec == gcd(((eB+1)*N -2), 2*(N-2))]
  * [eB==0]:
    [ec == gcd((1*N -2), 2*(N-2)) == (N-2)]
    !! [ec >= 2]
    [N>=4]
  * [N==2]:
    [ec == gcd(((eB+1)*2 -2), 2*0) == (2*eB)]
    !! [ec >= 2]
    [eB>=1]
  * 无需:[eB>=1][N>=3]:
    [k:=eB//2]
    [k>=0]
    * [eB==2*k+1]:
      [ec
      == gcd((2*(k+1)*N -2), 2*(N-2))
      == gcd((2*(k+1)*N -2) -(k+1)*2*(N-2), 2*(N-2))
      == gcd(2*(2*k+1), 2*(N-2))
      == 2*gcd((2*k+1), (N-2))
      >= 2*1
      > 1
      ]
      [ec == 2*gcd((2*k+1), (N-2))]
      [ec == 2*gcd(eB, (N-2))]
    * [eB==2*k]:
      [ec
      == gcd(((2*k+1)*N -2), 2*(N-2))
      == gcd(((2*k+1)*N -2) -k*2*(N-2), 2*(N-2))
      == gcd((N-2) +4*k, 2*(N-2))
      let [g:=gcd((N-2),4*k)]
      let [qN := (N-2)///g]
      let [qK := 4*k///g]
      => [gcd(qN,qK)==1]
      => [0 =!= (qN%2+qK%2) <- {1,2}]
      == gcd(qN*g +qK*g, 2*qN*g)
      == g*gcd(qN +qK, 2*qN)
      == g*gcd(qN +qK, 2)
      == g*(qN%2+qK%2)
      ]
      [g==1]:
        [gcd((N-2),4*k) == 1]
        [N%2 == 1]
        [qN == (N-2)///g == (N-2)]
        [qK == 4*k///g == 4*k]
        [(qN%2+qK%2) == 1+0 == 1]
      !! [ec >= 2]
      [g >= 2]or[g == 1][(qN%2+qK%2)==2]
      !! [[g==1] -> [(qN%2+qK%2) == 1]]
      [g >= 2]
      [gcd((N-2),4*k) >= 2]
      [gcd((N-2),2*eB) >= 2]
      [ec == gcd((N-2),2*eB) * 2**[gde_(2;(N-2)) == gde_(2;2*eB)]]

  ==>>:
  [[ec >= 2] <-> [
  [eB==0][N>=4][ec == (N-2)]
  or
  [N==2][eB>=1][ec == (2*eB)]
  or
  [eB%2==1][ec == 2*gcd(eB, (N-2))]
  or
  [eB%2==0][gcd((N-2),2*eB) >= 2][ec == gcd((N-2),2*eB) * 2**[gde_(2;(N-2)) == gde_(2;2*eB)]]
  ]]
希望[ec%8==0]@两种常见配置:
  * 存储单元是8bit
      #字节
  * 存储单元是7bit
      #字节但只使用非ASCII字符,以兼容ASCII

* [ec%8==0][存储单元是8bit]:
  [eB==7]
  !! [eB%2==1][ec == 2*gcd(eB, (N-2))]
  [ec == 2*gcd(7, (N-2)) <- {2,14}]
  [ec%8 =!= 0]

* [ec%8==0][存储单元是7bit]:
  [eB==6]
  !! [eB%2==0][gcd((N-2),2*eB) >= 2][ec == gcd((N-2),2*eB) * 2**[gde_(2;(N-2)) == gde_(2;2*eB)]]
  [gcd((N-2),2*eB) >= 2]
  [gcd((N-2),12) >= 2]
  [N%2==0]or[N%3==0]
  !! [ec%8==0]
  [gcd((N-2),12)%4 == 0][gde_(2;(N-2)) == gde_(2;12)]
  [gde_(2;(N-2)) == 2]
  [(N-2)%8 == 4]
  [N%8 == 6]
  !! [N>=2]
  [N <- [6,14..]]
    #6+8*k
  * [N==6]:
    前导串+后终串=>6*6*2==72bit==9*8
    中间环节=>6*6+(6-2)==40bit==5*8
    [净字节数 <- [9,14..]]
      #9+5*k
    [毛字节数 <- [12,18..]]
      #12+6*k
