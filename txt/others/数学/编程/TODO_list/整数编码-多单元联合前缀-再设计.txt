[[[[[[[[[
e others/数学/编程/TODO_list/整数编码-多单元联合前缀-再设计.txt


输入::[(bit|byte|word)]
  字长 <- {1|8|W)
  比特流or字节流or字流

取首比特:
  比特流 -> echo比特流
  字节流 -> 字节首比特构成的比特流
  字流 -> 字首比特构成的比特流


以下只考虑 字首比特构成的比特流
  注意:若原本真的是 比特流，而非 字流，即[字长==W==1]，则 甚至可以 交叠 前一编码的尾定位符 与 后一编码的首定位符，重复利用，反正没有 负载/payload，见下面『尾首交叠定位符』

[[目录:
目录
摘要
编码一
编码二
xxx:bug:编码三
编码约束
负载比特数与字数的关系囗囗计算框架
编码四
编码五
]]


[[摘要:
bug?:编码一
  [编码的最小总长度==2*n+2 >=4]
  [[W==8][n==1] -> [最高负载率的极限=7/8]]
  编码一:并不满足〖编码约束::禁止异码尾首交叠〗
编码二
  * 输入为 比特流，1的计数
  * 动态字节，单向解码
xxx:bug:编码三
  出错
编码约束
  ???
  * 允许同码首尾交叠
  * 禁止异码尾首交叠
  * 禁止异码尾首交叠囗囗约定囗囗首比特流始于一终于零
编码四
  [编码的最小总长度==n+4 >=5]
  [[W==8][n==1] -> [最高负载率的极限=11/12]]
  ...最小总长度 稍大了些
编码五
  [编码的最小总长度==n+u >=4]
  [[W==8][u==n==2] -> [最高负载率的极限=7/8]]
    vs:编码一[W==8][n==1]
      * 优于 编码一
          因为 编码一 并不满足〖编码约束::禁止异码尾首交叠〗
      * 不如 编码一
          因为 编码五 要求 总长度为偶数
          编码五:11 (01)* 00
          编码一:11 0* 01
    [[退化囗对称:[u==n>=2][z:=u]:
      !! [最高负载率的极限=中部负载率=(z*W-2)/(z*W)==(1-2/W/z)]
      [[(W*z)保持不变]==>>[最高负载率的极限 也不变]]

      !! [最低负载率=(W-1)/W=(1-1/W)]
      [[[W减小,z增大][(W*z)保持不变]]==>>[[最高负载率的极限 保持不变][最低负载率 降低]]]

      [最高负载率的极限(W=8,z=2)
        == 最高负载率的极限(W=4,z=4)
        == 最高负载率的极限(W=2,z=8)
        == 最高负载率的极限(W=1,z=16)
        == 7/8
        ]
      [最低负载率(W=8,z=2)=7/8]
      [最低负载率(W=4,z=4)=3/4]
      [最低负载率(W=2,z=8)=1/2]
      [最低负载率(W=1,z=16)=0/1]
    ]]
]]






[[[bug?:since编码约束:编码一:[字长==W>=1][编码参数n >= 1]
假设 字节首比特构成的定位符 分别为:
  * 首定位符:
    (1 1{n} 0)
  * 尾定位符:
    (0 1{n})
  #[字长==W==1]比特流 情形下: 允许相邻两个码 交叠:(0 1{n+1} 0) # 定义『尾首交叠定位符』
  # [n==1]: 1101, (11 0+ 1)
假设 合法的编码的字节首比特构成的比特块 为:
  # 首定位符    ............    尾定位符
  # (1 1{n} 0)  ([01]{0,n-1})   (0 1{n})
        #弹性中部长度 <- [0..=n-1]
        #
        # (1+n+1)+[0..=n-1]+(1+n) = (2*n+3)+[0..<n]
        #弹性总长度 <- [(2*n+3)..<(3*n+3)]
        #

  # (1 1{n} 0)  ([01]{n-1} 0)*  (1{n})
  即(1 1{n})    (0 [01]{n-1})*  (0 1{n})
        #交叠共享 尾定位符的首字节的首比特
        #交叠共享 首定位符的尾字节的首比特
        #eg: (1 1{n} 0 1{n} 0)
        #刚性中部长度 <- [0,n..]
        #刚性总长度 <- [(2*n+2),(3*n+2)..]
  ==>>合并囗不对称泛化:
  * (1 1{n})    (0 [01]{n-1})*    (0 [01]{0,n-1})?  (0 1{n})
        #总长度 <- [(2*n+2),..]

==>>:
[[编码的最小总长度
[编码参数n >= 1]
[编码的最小总长度==最小刚性总长度==2*n+2 >=4]
]]
[[编码的负载率
弹性总长度 <- [(2*n+3)..<(3*n+3)]
刚性总长度 <- [(2*n+2),(3*n+2)..]
总长度 <- [(2*n+2),..]

同一情形:[弹性总长度==3*n+2] <==> [刚性总长度==3*n+2]
  <==> [弹性总长度==刚性总长度]

[字长==W>=1]
[编码参数n >= 1]

最低负载率 出现于 没有 自由的首比特[01]，即:
    * [弹性总长度==2*n+3]
    * [刚性总长度==2*n+2]
最高负载率的极限 出现于 无限总长度，即:
    * [k-->+oo][刚性总长度-->k*n+2]

[最低负载率=(W-1)/W=(1-1/W)]
  #每字损失首比特
[最高负载率的极限=刚性中部负载率=(n*W-1)/(n*W)==(1-1/W/n)]

]]
[[n取值的折衷考虑因素:
[字长==W>=1]
[编码参数n >= 1]
[编码的最小总长度==最小刚性总长度==2*n+2 >=4]
[最高负载率的极限=刚性中部负载率=(n*W-1)/(n*W)==(1-1/W/n)]

[[W==8][n==1] -> [最高负载率的极限=7/8]]
]]

]]]


[[[编码二:仅适用于[字长==W==1][编码参数n==0]#其实就是计算连续1的个数，以0为逗号
假设 字节首比特构成的定位符 分别为:
  * 首定位符:
    (0 1{n})
  * 尾定位符:
    (1{n} 0)
  #因为 [字长==W==1]比特流 情形下: 允许相邻两个码 交叠:(1{n} 0 1{n})
假设 合法的编码的字节首比特构成的比特块 为:
  # 首定位符    ............    尾定位符
  * (0 1{n,2*n} 0)
        #交叠
  * (0 1{2*n,..} 0)
  ==>>
  * (0 1{n,..} 0)
        #比特流总长度 <- [n+2,..]
        #因为[n==0]
        #比特流总长度 <- [2,..]
]]]


[[[bug:100:编码三:仅适用于[字长==W>=2][编码参数n==0]#1=>编码二
假设 字节首比特构成的定位符 分别为:
  * 首定位符:
    (10 1{n})
    即:(10)
  * 尾定位符:
    (1{n} 00)
    即:(00)
  #因为 [字长==W>=2]比特流 情形下: 避免相邻两个码 交叠:(1{n} 00 10 1{n})
假设 合法的编码的字节首比特构成的比特块 为:
  # 首定位符    ............    尾定位符
  * (100)
        #交叠
  * (10 1{n,2*n} 00) bug!!! 100 在最后！
        #交叠
  * (10 1{2*n,..} 00)
  <==>
  * (100)
        #总长度 <- [3]
  * (10 1{n,..} 00)
        #总长度 <- [n+4,..]
        #因为[n==0]
        #总长度 <- [3,..]
  <==>
  * (1 (0 1*)? 00)
        #总长度 <- [3,..]
[[编码的最小总长度
[编码参数n == 0]
[编码的最小总长度==3]
]]
[[编码的负载率
[编码的负载率=(W-1)/W=(1-1/W)]
  #每字损失首比特
]]
]]]




[[[编码约束:[字长==W>=2]
* 允许同码首尾交叠
* 禁止异码尾首交叠
* 禁止异码尾首交叠囗囗约定囗囗首比特流始于一终于零

def 前后最大交叠长度及定位(i, aaa, bbb):
    L = len(aaa)
    assert 0 <= i <= L
    for i in range(i, L+1):
      x = min(L-i,len(bbb))
      if aaa[i:i+x] == bbb[:x]:
        return x, i
    raise dead

假设 字节首比特构成的定位符 分别为:
  * 首定位符:
      bbb
  * 尾定位符:
      eee

[[(x,i) := 前后最大交叠长度及定位(0, bbb, eee)] -> [i>0][len(bbb) < i+len(eee)]]
    #允许同码首尾交叠
    #要求:[首定位符的结束位置 < 尾定位符的结束位置]
    #   若『==』，则 编码的长度固定
    #   若『>』，则 尾定位符 命名不当，也无法用于正向解码的结束定位，且 编码的长度固定
    #左右对称同理:要求:[首定位符的起始位置 < 尾定位符的起始位置]
    #

[[(x,i) := 前后最大交叠长度及定位(1, eee, bbb)] -> [i == len(eee)]]
    #禁止异码尾首交叠，因为[字长==W>=2]

[同码首尾最大交叠长度 := 前后最大交叠长度及定位(0, bbb, eee)[0]]
[编码的最小总长度 == len(bbb)+len(eee)-同码首尾最大交叠长度]

[bb_ := bbb[:len(bbb)-同码首尾最大交叠长度]]
[_x_ := eee[:同码首尾最大交叠长度]]
[_ee := eee[同码首尾最大交叠长度:]]
[eee == _x_ ++ _ee]
[bbb == bb_ ++ _x_]
[len(_ee) > 0]
[len(bb_) > 0]
[_ee[-1] =!= bb_[0]]
  #禁止异码尾首交叠，长度为1的情形，因为 皆非空串
[bbb[0] == '1'][eee[-1] == '0'][n>=1]:
  #禁止异码尾首交叠囗囗约定囗囗首比特流始于一终于零
  # bbb == 1... ++ _x_
  # eee == _x_ ++ ...0
  (bb_, _ee) <- (
    {(1+, 0+)
    #要求:[n>=1]
    ,(1+ (0{,n} 1)*, .* 0{n+1})
    ,(1{n+1} .*, (0 1{,n})* 0+)
    ...
    })
  ...
[n>=1][bbb[:n+2] == (1 1{n} 0)][eee[:-(n+2)] == (0 1{n} 0)]:
  ...
[n>=1][bbb[:n+3] == (10 1{n} 0)][eee[:-(n+2)] == (1{n} 00)]:
  [_x_ == (1{n} 0)]
  [bb_ = '10']
  [_ee = '0']
  see:编码四:[字长==W>=1][编码参数n>=1]
    vs:编码三:仅适用于[字长==W>=2][n==0]

  ...

]]]



[[[负载比特数与字数的关系囗囗计算框架:
#负载比特数与字数的关系:计算框架
[字长==W>=1]

[Lw:=字数]#总长度
[Lb:=负载比特数]
[Lhb:=负载首比特数]
[Lnhb:=非负载首比特数]
[Lb == Lhb + (W-1)*Lw == W*Lw - Lnhb]
[Lnhb + Lhb == Lw]
[(W-1)*Lw <= Lb <= W*Lw]
[Lw >= Lb/W]
[最低负载率 <= Lb/(W*Lw) <= 最高负载率的极限]
[Lb/最高负载率的极限 <= (W*Lw) <= Lb/最低负载率]
[Lb/W/最高负载率的极限 <= Lw <= Lb/W/最低负载率]
[ceil(Lb/W/最高负载率的极限) <= Lw <= floor(Lb/W/最低负载率)]
# [W==1] ==>> [最低负载率 == 1-1/W == 0] 不好用
[Lw__lowbound := max(最小总长度,ceil(Lb/W/最高负载率的极限))]


=============计算框架:
#数据
[首比特囗类别 :=
  [负载比特囗值自由
  ,格式比特囗值一
  ,格式比特囗值零
  ,格式比特囗值相反于前比特
  ,格式比特囗值相同于前比特
  ]]


#抽象方法:
[编码参数是否合法囗<编码方案>(W,编码参数;) :: bool]
  #abstractmethod
[最高负载率的极限囗<编码方案>(W,编码参数;) :: 负载率/分数]
  #abstractmethod
[最小总长度囗<编码方案>(W,编码参数;) :: Lw]
  #abstractmethod
[总长度是否合法囗<编码方案>(W,编码参数;) :: Lw -> bool]
  #abstractmethod
[字数之负载比特数囗<编码方案>(W,编码参数;) :: Lw -> Lb]
  #abstractmethod
[字数之位置之该字首比特类别囗<编码方案>(W,编码参数;) :: Lw -> idx/[0..<Lw] -> 首比特囗类别]
  #abstractmethod


#可覆盖囗具象方法:
[枚举囗合法总长度囗囗大于等于囗<编码方案>(W,编码参数;) :: Lw__lowbound -> [Lw]]
[字数之正向枚举各字首比特类别囗<编码方案>(W,编码参数;) :: Lw -> [首比特囗类别]{len=Lw}]


#具象方法:
[负载比特数之字数下界估计囗<编码方案>(W,编码参数;) :: Lb -> Lw__lowbound]
[负载比特数之字数过滤器囗<编码方案>(W,编码参数;) :: Lb -> [Lw] -> [Lw]]
[负载比特数之字数囗<编码方案>(W,编码参数;) :: Lb -> Lw]





[枚举囗合法总长度囗囗大于等于囗<编码方案>(W,编码参数;Lw__lowbound) :=
  let [Lw0 := max(最小总长度囗<编码方案>(W,编码参数;), Lw__lowbound)]
  in [Lw | [Lw :<- [Lw0..]][总长度是否合法囗<编码方案>(W,编码参数;Lw)]]
  ]

[负载比特数之字数下界估计囗<编码方案>(W,编码参数;Lb) := max(最小总长度囗<编码方案>(W,编码参数;), ceil(Lb/W/最高负载率的极限囗<编码方案>(W,编码参数;)))] #Lw__lowbound
[负载比特数之字数过滤器囗<编码方案>(W,编码参数;Lb,Lw_ls) := [Lw | [Lw :<- Lw_ls][总长度是否合法囗<编码方案>(W,编码参数;Lw)][Lb <= 字数之负载比特数囗<编码方案>(W,编码参数;Lw)]]]
[负载比特数之字数囗<编码方案>(W,编码参数;Lb) :=
  assert (W>=1 and 编码参数是否合法囗<编码方案>(W,编码参数;)) $
  assert (Lb>=0) $
  assert (Lb==0 or 最高负载率的极限囗<编码方案>(W,编码参数;)=!=0) $
  let [Lw__lowbound := 负载比特数之字数下界估计囗<编码方案>(W,编码参数;Lb)]
      # [Lw_ls := [Lw__lowbound..]]
      [Lw_ls := 枚举囗合法总长度囗囗大于等于囗<编码方案>(W,编码参数;Lw__lowbound)]
      [Lw := head $ 负载比特数之字数过滤器囗<编码方案>(W,编码参数;Lb,Lw_ls)]
  in  Lw
  ]
[字数之正向枚举各字首比特类别囗(W,编码参数;Lw) :=
  [字数之位置之该字首比特类别囗<编码方案>(W,编码参数;Lw,idx) | [idx :<- [0..<Lw]]]
  ]

]]]







[[[编码四:[字长==W>=1][编码参数n>=1]
假设 字节首比特构成的定位符 分别为:
  * 首定位符:
    (10 1{n} 0)
    [n==1]:(1010)
  * 尾定位符:
    (1{n} 00)
    [n==1]:(100)
  #比 编码三 多了个 0: 中部不再只能是全1
  # 避免相邻两个码交叠:(0 1{n} 00  10 1{n} 0)
假设 合法的编码的字节首比特构成的比特块 为:
  # 首定位符    ............    尾定位符
  * (10 1{n} 00)
        #交叠
  #err: (10 1{n} 0) (1{n} 00) 因为中间出现 首定位符
  #err: (10 1{n} 0) 0 (1{n} 00) 因为中间出现 尾定位符
  * (10 1{n} 0) 1 (1{n} 00)
  * (10 1{n} 0) 11 (1{n} 00)
  # [n==1]:(10 1{n} 0) 111 (1{n} 00)
  # [n>=2]:(10 1{n} 0) 1 [01] 1 (1{n} 00)
  * [n==1]:(1010) (11 [01])* 1{,2} 1 (100)
  # [n==2]:(10110) 1 (0 [01])* [01]? 1 (1100)
  * [n>=2]:(10 1{n} 0) 1 ([01]{n-2} 0 [01])* [01]{,n-1} 1 (1{n} 00)
        # 因为 最后 (... 0 [01]{,n} 1 (1{n} 00)) 若要 凑出(0 1{n} 0)/(1{n} 00) 是不可能的 ==>> 不出现 首定位符/新的尾定位符
  <==>
  * (10 1{n} 00)
        #总长度 <- [n+4]
  * [n==1]:(1010) (11 [01])* 1{,2} 1 (100)
        #总长度 <- [8..]
  * [n>=2]:(10 1{n} 0) 1 (1{n} 00)
        #总长度 <- [2*n+6]
  * [n>=2]:(10 1{n} 0) 1 ([01]{n-2} 0 [01])* [01]{,n-1} 1 (1{n} 00)
        #总长度 <- [2*n+7..]
  ==>>
        #总长度 <- [n+4,2*n+6,2*n+7..]

[[编码的最小总长度
[总长度 <- [n+4,2*n+6,2*n+7..]]
[编码的最小总长度==n+4]
[编码的次小总长度==2*n+6]
]]
[[编码的负载率
[字长==W>=1]
[编码参数n >= 1]

最低负载率 出现于 没有 自由的首比特[01]，即:
  * (10 1{n} 00)
  * (10 1{n} 0) 1 (1{n} 00)
  * (10 1{n} 0) 11 (1{n} 00)
  * [n==1]:(101{n} 0) 111 (1{n} 00)
最高负载率的极限 出现于 无限总长度，即:
    * [k-->+oo][总长度-->2*n+6+k]

[最低负载率=(W-1)/W=(1-1/W)]
  #每字损失首比特
[最高负载率的极限=中部负载率=(n*W-1)/(n*W)==(1-1/W/n) if n>=2 else (1-2/3/W)]
]]
[[n取值的折衷考虑因素:
[字长==W>=1]
[编码参数n >= 1]
[编码的最小总长度==n+4 >=5]
[最高负载率的极限=中部负载率=(n*W-1)/(n*W)==(1-1/W/n) if n>=2 else (1-2/3/W)]

[[W==8][n==2] -> [最高负载率的极限=15/16]]
[[W==8][n==1] -> [最高负载率的极限=11/12]]
  看来还行
]]
[[负载比特数与字数的关系:
#see:负载比特数与字数的关系囗囗计算框架

[编码参数n >= 1]
[字长==W>=1]

[Lw:=字数]#总长度
[Lb:=负载比特数]
[Lhb:=负载首比特数]
[Lnhb:=非负载首比特数]
[Lb == Lhb + (W-1)*Lw == W*Lw - Lnhb]
[Lnhb + Lhb == Lw]
[(W-1)*Lw <= Lb <= W*Lw]
[Lw >= Lb/W]


[[Lw==n+4] -> [Lhb==0]]
[[n==1] -> [Lw>=8] -> [Lhb==(Lw-8)//3]]
[[n>=2] -> [Lw==2*n+6] -> [Lhb==0]]
[[n>=2] -> [Lw>=2*n+7] -> [Lnhb==(2*n+7) + (Lw-(2*n+7))//n]]

<==>
[[Lw==n+4] -> [Lb==(W-1)*Lw]]
[[n==1] -> [Lw>=8] -> [Lb==(W-1)*Lw + (Lw-8)//3]]
[[n>=2] -> [Lw==2*n+6] -> [Lb==(W-1)*Lw]]
[[n>=2] -> [Lw>=2*n+7] -> [Lb==W*Lw - (2*n+7) - (Lw-(2*n+7))//n==W*Lw - (Lw-7)//n - 2*n -5]]

==>>
[[n==1] -> [8<=Lw<=10] -> [Lb==(W-1)*Lw]]
[[n>=2] -> [Lw==2*n+7] -> [Lb==(W-1)*Lw]]
[[n>=2] -> [Lw==2*n+8] -> [Lb==1+(W-1)*Lw]]
==>>
[[Lw <- [n+4,2*n+6,2*n+7]] -> [Lb==(W-1)*Lw]]
[[n==1] -> [Lw>=2*n+8] -> [Lb==(W-1)*Lw + (Lw-8)//3]]
[[n>=2] -> [Lw>=2*n+8] -> [Lb==W*Lw - (Lw-7)//n - 2*n -5]]

==>>
#字数->负载比特数
[字数之负载比特数囗囗编码四囗(W,n;Lw) :=
  assert (W>=1 and n>=1 and (Lw==n+4 or Lw>=2*n+6)) $
  if Lw<=2*n+7 then (W-1)*Lw
  elif n==1 then (W-1)*Lw + (Lw-8)//3
  else W*Lw - (Lw-7)//n - 2*n -5
  ]

#负载比特数->字数
[负载比特数之字数囗囗编码四囗(W,n;Lb) := assert (W>=1 and n>=1 and Lb>=0) $
  #无需is_ok_ Lw
  let [ls_ Lw_ls := 负载比特数之字数过滤器囗<编码四>(W,n;Lb,Lw_ls)] in
  let [ls := ls_ [n+4,2*n+6,2*n+7,2*n+8]] in
  if ls then ls[0] else
  let [Lw0 := if n==1 then 1+ (3*Lb+7)//(3*W-2) else 1+ (Lb*n +2*n*n +4*n -7)//(W*n-1)] in
  (ls_ [Lw0..])[0]
  ]



#字数之位置之该字首比特类别囗:编码四
#字数->位置->首比特囗类别
[字数之位置之该字首比特类别囗囗编码四囗(W,n;Lw,idx) :=
  assert (W>=1 and n>=1 and (Lw==n+4 or Lw>=2*n+6)) $
  assert (0 <= idx < Lw) $
  if idx < n+3 then
      if (idx == 1 or idx == n+2)
      then 首比特囗类别.格式比特囗值零
      else 首比特囗类别.格式比特囗值一
  elif not idx+n+3 < Lw then
      # (idx+n+3) 代替 (idx+n+2)
      #     因为 除最短情形，其他一致为1
      if not idx+2 < Lw
      then 首比特囗类别.格式比特囗值零
      else 首比特囗类别.格式比特囗值一
  #now: [Lw > 2*n+6][(n+3) <= idx < Lw-(n+3)]
  elif n==1 then
      let [ir := (idx-(n+3))%3] in
      if ir==2
      then 首比特囗类别.负载比特囗值自由
      else 首比特囗类别.格式比特囗值一
  elif n>=2 then
      if idx==n+3 then 首比特囗类别.格式比特囗值一 else
      let [ir := (idx-(n+4))%n] in
      if (ir==n-2 and not idx+n+4==Lw)
      then 首比特囗类别.格式比特囗值零
      else 首比特囗类别.负载比特囗值自由
  else error 'logic-err'
  ]
  * (10 1{n} 00)
  * [n==1]:(1010) (11 [01])* 1{,2} 1 (100)
  * [n>=2]:(10 1{n} 0) 1 (1{n} 00)
  * [n>=2]:(10 1{n} 0) 1 ([01]{n-2} 0 [01])* [01]{,n-1} 1 (1{n} 00)





[使用囗计算框架囗实现囗负载比特数之字数囗囗编码四囗
#使用:计算框架<<==需要:字数之负载比特数囗囗编码四囗
#使用:计算框架<<==需要:字数之位置之该字首比特类别囗囗编码四囗

#override:抽象方法:
[编码参数是否合法囗<编码四>(W,n;) := (W>=1 and n>=1)]
[最高负载率的极限囗<编码四>(W,n;) := Fraction((1-1/W/n) if n>=2 else (1-2/3/W))]
[最小总长度囗<编码四>(W,n;) := n+4]
    #编码的最小总长度
[总长度是否合法囗<编码四>(W,n;Lw) := (W>=1 and n>=1 and (Lw==n+4 or Lw>=2*n+6))]
    !! [总长度 <- [n+4,2*n+6,2*n+7..]]
[字数之负载比特数囗<编码四>(W,n;Lw) := 字数之负载比特数囗囗编码四囗(W,n;Lw)]
[字数之位置之该字首比特类别囗<编码四>(W,n;Lw,idx) := 字数之位置之该字首比特类别囗囗编码四囗(W,n;Lw,idx)]

#override:可覆盖囗具象方法:
[枚举囗合法总长度囗囗大于等于囗<编码四>(W,n;Lw__lowbound) := if Lw__lowbound <= n+4 then [n+4,2*n+6,2*n+7..] else [max(Lw__lowbound,2*n+6)..]]


#调用 具象方法 实现
[负载比特数之字数囗囗编码四囗(W,n;Lb) := 负载比特数之字数囗<编码四>(W,n;Lb)]

]

]]

]]]












[[[编码五:[字长==W>=1][编码参数:u>=n>=2][D := u//n-1]
三版:旧版;更进;退化囗对称;
  但 其实 只有 最简单的 退化囗对称[u==n>=2][z:=u]最优

假设 字节首比特构成的定位符 分别为:
  * 首定位符:
    (1{n} 0)
  * 尾定位符:
    (1 0{u})
假设 合法的编码的字节首比特构成的比特块 为:
  # 首定位符    ............    尾定位符
  =============================旧版:
  * (1{n} 0{u})
        #交叠
        #总长度 <- [n+u]
  # (1{n} 0) [01]{,n-2} (1 0{u})
  * (1{n} 0) ([01]{n-2} 10)* [01]{,n-2} (1 0{u})
        #总长度 <- [n+u+2..] \\ [2*n+u+1,3*n+u+1..]
        #还缺: (n+1)+n*k+(n-1)+(1+u)==(k+2)*n+u+1

  * [u>n]:(1{n} 0) ([01]{n-2} 10)* [01]{n-2} 0 (1 0{u})
  * [u==n>=3]:(1{n} 0) ([01]{n-2} 10)* [01]{n-3} 10 (1 0{u})
        #[[u>n]or[u==n>=3]]
        #[[u>n]or[n>=3]]
        #[u=!=2]
        #[u=!=2]总长度 <- [2*n+u+1,3*n+u+1..]
  #还缺:[总长度==n+u+1]以及[u==2][总长度==(k+2)*n+u+1=2*k+7]
  ==>>
  * (1{n} 0{u})
  * (1{n} 0) ([01]{n-2} 10)* [01]{,n-2} (1 0{u})
  * [u>n]:(1{n} 0) ([01]{n-2} 10)* [01]{n-2} 0 (1 0{u})
  * [u==n>=3]:(1{n} 0) ([01]{n-2} 10)* [01]{n-3} 10 (1 0{u})
  ==>>
        #[u=!=2]总长度 <- [n+u..] \\ [n+u+1]
        #[u==2]总长度 <- [4,6..]
  =============================更进:
  #有一些1是不必要的
  * (1{n} 0{u})
        #总长度 <- [n+u]
  * (1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{,n-2} (1 0{u})
        [1+D*n+(n-2) <= u-1] #定义D
        [D <= u//n-1]
        [D := u//n-1] #计算D值
  * [D>=1]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{,n-2} (1 0{u})
  * [D>=1]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{n-2} 0 (1 0{u})
  * [u%n =!= 0]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-2} 0 (1 0{u})
        [1+D*n+(n-2)+1 <= u-1]
        [D*n+n <= u-1]
        [(D+1)*n < u]
        [u > u//n *n]
        [u%n =!= 0]
  * [[u%n == 0][n>=3]]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-3} (01 | 10) (1 0{u})
        #余部-([01]{n-3} (01 | 10)) 等效于 ([01]{n-2} F)
        !![u%n == 0]
        !![D := u//n-1]
        [u == (D+1)*n]
  #还缺:[总长度==n+u+1]以及[[[u%n == 0][n==2][k>=0]] -> [总长度==n+u+2+(k+1)*(D+1)*n-2+1==n+u+1+2*(k+1)*(D+1)==n+u+1+2*(k+1)*u/n==n+u+1+(k+1)*u]]
      [k >= 0]
      但 [k>=-1] 兼容 [总长度==n+u+1] 也行
  #还缺:[[[u%n =!= 0]or[n>=3]] -> [总长度==n+u+1]]以及[[[u%n == 0][n==2][t>=0]] -> [总长度==u+3+t*u]]
  ==>>
  [D := u//n-1]
  * (1{n} 0{u})
  * (1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{,n-2} (1 0{u})
  * [D>=1]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{,n-2} (1 0{u})
  * [D>=1]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{n-2} 0 (1 0{u})
  * [u%n =!= 0]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-2} 0 (1 0{u})
  * [[u%n == 0][n>=3]]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-3} (01 | 10) (1 0{u})
  ==>>
        #[[[u%n =!= 0]or[n>=3]] -> [总长度 <- [n+u..] \\ [n+u+1]]]
        #[[[u%n == 0][n==2]] -> [总长度 <- [u+2..] \\ [u+3,2*u+3..]]]
  =============================退化囗对称[u==n>=2][z:=u]:
  * (1{z} 0{z})
  * (1{z} 0) ([01]{z-2} 10)* [01]{,z-2} (1 0{z})
  * [z>=3]:(1{z} 0) ([01]{z-2} 10)* [01]{z-3} (01 | 10) (1 0{z})
        #余部-([01]{z-3} (01 | 10)) 等效于 ([01]{z-2} F)
  ==>>
        #[z>=3]总长度 <- [2*z..] \\ [2*z+1]
        #[z==2]总长度 <- [4,6..]

[[编码的最小总长度
=============================旧版:
[[u=!=2] -> [总长度 <- [n+u..] \\ [n+u+1]]]
[[u==2] -> [总长度 <- [4,6..]]]
[编码的最小总长度==n+u]
[编码的次小总长度==n+u+2]
=============================更进:
[[[u%n =!= 0]or[n>=3]] -> [总长度 <- [n+u..] \\ [n+u+1]]]
[[[u%n == 0][n==2]] -> [总长度 <- [u+2..] \\ [u+3,2*u+3..]]]
[编码的最小总长度==n+u]
[编码的次小总长度==n+u+2]
=============================退化囗对称[u==n>=2][z:=u]:
[[z>=3] -> [总长度 <- [2*z..] \\ [2*z+1]]]
[[z==2] -> [总长度 <- [4,6..]]]
[编码的最小总长度==2*z]
[编码的次小总长度==2*z+2]
]]
[[编码的负载率
[字长==W>=1]
[编码参数u >= n >= 2]
[D := u//n-1]

最低负载率 出现于 没有 自由的首比特[01]，即:
  =============================旧版:
  * (1{n} 0{u})
  * [n==2]or[总长度==n+u+2]:(1{n} 0) ([01]{n-2} 10)* [01]{,n-2} (1 0{u})
  * [u==n==3][总长度==n+u+4]:(1{n} 0) ([01]{n-2} 10)* [01]{n-3} 10 (1 0{u})
  * [u>n==2]:(1{n} 0) ([01]{n-2} 10)* [01]{n-2} 0 (1 0{u})
  =============================更进:
  [D := u//n-1]
  * (1{n} 0{u})
  * [D==0][n==2][2==n<=u<=3]or[总长度==n+u+2]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{,n-2} (1 0{u})
      * (11 0) (10)* (1 0{u})
      * (1{n} 0) (1 0{u})
  * [D>=1][总长度==n+u+2]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{,n-2} (1 0{u})
      * (1{n} 0) (1 0{u})
  * [D>=1][n==2][u>=4][总长度==n+u+3]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{n-2} 0 (1 0{u})
      * (1{n} 0) 0 (1 0{u})
      ==>> [n==2][u>=4][总长度==n+u+3]
      #++下面: ==>> [n==2][u>=3][总长度==n+u+3]
  * [u%n =!= 0][D==0][n==2][u==3]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-2} 0 (1 0{u})
      * (11 0) (10)* 0 (1 000)
      #==>> [[n==2][u==3][k>=0][总长度==n+u+3+2*k]]
  #xxx:必有一等效[01]: * [[u%n == 0][n>=3]]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-3} (01 | 10) (1 0{u})
  =============================退化囗对称[u==n>=2][z:=u]:
  * (1{z} 0{z})
  * [z==2]or[总长度==2*z+2]:(1{z} 0) ([01]{z-2} 10)* [01]{,z-2} (1 0{z})
  #xxx:必有一等效[01]: * [z==3][总长度==2*z+4]:(1{z} 0) ([01]{z-2} 10)* [01]{z-3} (01 | 10) (1 0{z})
最高负载率的极限 出现于 无限总长度，即:
    * [总长度-->+oo]

=============================旧版:
[最低负载率=(W-1)/W=(1-1/W)]
  #每字损失首比特
[最高负载率的极限=中部负载率=(n*W-2)/(n*W)==(1-2/W/n)]
=============================更进:
[最高负载率的极限=中部负载率=((D+1)*n*W-(D+2))/((D+1)*n*W)==(1-(D+2)/((D+1)*n*W))==(1 -1/W/n -1/W/(u-u%n))]
        !![D := u//n-1]

[最低负载率=(W-1)/W=(1-1/W)]
  #每字损失首比特
[最高负载率的极限=中部负载率=(1 -1/W/n -1/W/(u-u%n))]
=============================退化囗对称[u==n>=2][z:=u]:
[最低负载率=(W-1)/W=(1-1/W)]
  #每字损失首比特
[最高负载率的极限=中部负载率=(z*W-2)/(z*W)==(1-2/W/z)]
]]
[[n取值的折衷考虑因素:
[字长==W>=1]
[编码参数u >= n >= 2]
[D := u//n-1]
[编码的最小总长度==n+u >=4]

[[W==8][u==n==6] -> [最高负载率的极限=23/24]]
[[W==8][u==n==4] -> [最高负载率的极限=15/16]]
[[W==8][u==n==3] -> [最高负载率的极限=11/12]]
[[W==8][u==n==2] -> [最高负载率的极限=7/8]]
  看来还行

[[W==8][u==3][n==2] -> [最高负载率的极限=7/8]]
    不如[W==8][u==n==2]
    3+2 > 2+2
[[W==8][u==4][n==2] -> [最高负载率的极限=29/32]]
    不如[W==8][u==n==3]
    3/32 > 1/12
[[W==8][u==6][n==3] -> [最高负载率的极限=15/16]]
    不如[W==8][u==n==4]
    6+3 > 4+4
[[W==8][u==8][n==4] -> [最高负载率的极限=61/64]]
    不如[W==8][u==n==6]
    3/64 > 1/24

=============================退化囗对称[u==n>=2][z:=u]:
[退化囗对称:[u==n>=2][z:=u]:
  !! [最高负载率的极限=中部负载率=(z*W-2)/(z*W)==(1-2/W/z)]
  [[(W*z)保持不变]==>>[最高负载率的极限 也不变]]

  !! [最低负载率=(W-1)/W=(1-1/W)]
  [[[W减小,z增大][(W*z)保持不变]]==>>[[最高负载率的极限 保持不变][最低负载率 降低]]]

  [最高负载率的极限(W=8,z=2)
    == 最高负载率的极限(W=4,z=4)
    == 最高负载率的极限(W=2,z=8)
    == 最高负载率的极限(W=1,z=16)
    == 7/8
    ]
  [最低负载率(W=8,z=2)=7/8]
  [最低负载率(W=4,z=4)=3/4]
  [最低负载率(W=2,z=8)=1/2]
  [最低负载率(W=1,z=16)=0/1]
]
]]
[[负载比特数与字数的关系:
#see:负载比特数与字数的关系囗囗计算框架
=============================旧版:
=============================更进:
[编码参数u >= n >= 2]
[D := u//n-1]

[[Lw==n+u] -> [Lhb==0]]
[[Lw==n+u+2] -> [Lhb==0]]
[[[2==n<=u<=3][k>=0][Lw==n+u+2+2*k]] -> [Lhb==0]]
[[[n==2][u>=4][Lw==n+u+3]] -> [Lhb==0]]
[[[n==2][u==3][k>=0][Lw==n+u+3+2*k]] -> [Lhb==0]]


[[(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)] -> [(q1,r1) := r0/%n] -> [q1==D] -> [0 <= r1 <= n-2] -> [Lnhb==(n+u+2) +q0*(D+2) +q1]]
  # (1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{,n-2} (1 0{u})

[[(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)] -> [(q1,r1) := r0/%n] -> [D>=1] -> [0 <= q1 <= D-1] -> [0 <= r1 <= n-2] -> [Lnhb==(n+u+2) +q0*(D+2) +q1]]
  # [D>=1]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{,n-2} (1 0{u})

[[(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)] -> [(q1,r1) := r0/%n] -> [D>=1] -> [0 <= q1 <= D-1] -> [r1 == n-1] -> [Lnhb==(n+u+2) +q0*(D+2) +q1 +1]]
  # [D>=1]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){,D-1} [01]{n-2} 0 (1 0{u})

[[(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)] -> [(q1,r1) := r0/%n] -> [q1==D] -> [r1 == n-1] -> [u%n =!= 0] -> [Lnhb==(n+u+2) +q0*(D+2) +q1 +1]]
  # [u%n =!= 0]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-2} 0 (1 0{u})

[[(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)] -> [(q1,r1) := r0/%n] -> [q1==D] -> [r1 == n-1] -> [[u%n == 0][n>=3]] -> [Lnhb==(n+u+2) +q0*(D+2) +q1 +1]]
  # [[u%n == 0][n>=3]]:(1{n} 0) (([01]{n-1} 0){D} [01]{n-2} 10)* ([01]{n-1} 0){D} [01]{n-3} (01 | 10) (1 0{u})

<==>
[[Lw==n+u] -> [Lhb==0]]
[[Lw==n+u+2] -> [Lhb==0]]
[[[n==2][Lw==n+u+3]] -> [Lhb==0]]
[[[n==2][u<=3]] -> [Lhb==0]]


[[(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)] -> [(q1,r1) := r0/%n] -> [
  # [Lw == (n+u+2) +q0*((D+1)*n) +q1*n +r1]
  [[q1==D] -> [[r1<=n-2]or[u%n =!= 0]or[n>=3]] -> [Lnhb==(n+u+2) +q0*(D+2) +q1 + [r1==n-1]]]
  [[D>=1] -> [0 <= q1 <= D-1] -> [Lnhb==(n+u+2) +q0*(D+2) +q1 +1]]
  ]]

==>>

!! [[[u%n =!= 0]or[n>=3]] -> [总长度 <- [n+u..] \\ [n+u+1]]]
!! [[[u%n == 0][n==2]] -> [总长度 <- [u+2..] \\ [u+3,2*u+3..]]]
[[(n+u+3)非合法总长度] -> [
  [[u%n == 0][n==2]]
  [(n+u+3-(u+3))%u==0]
  !![u>=n>=2]
  [u==n==2]
  ]]
[[(n+u+3)非合法总长度] -> [u==n==2]]

==>>
#字数之负载比特数囗囗编码五:更进:
#字数->负载比特数
[字数之负载比特数囗囗编码五囗更进囗(W,u,n;Lw) :=
  assert (W>=1 and u>=n>=2 and Lw>=n+u and Lw =!= n+u+1 and (u%n =!= 0 or n>=3 or (Lw-3)%u =!= 0)) $
  if Lw <- [n+u,n+u+2] or (n==2 and (u<=3) or (Lw==n+u+3)) then (W-1)*Lw else
  #分支[[Lw>=n+u+4]or[n>=3][Lw==n+u+3]]
  let [[D := u//n-1][(q0,r0) := (Lw-(n+u+2))/%((D+1)*n)][(q1,r1) := r0/%n][Lnhb_ :=(n+u+2) +q0*(D+2) +q1]] in
  if [[q1==D][r1<=n-2]or[u%n =!= 0]or[n>=3]] then W*Lw -(Lnhb_+[r1==n-1])
  elif [[D>=1][0 <= q1 <= D-1]] then  W*Lw -(Lnhb_+1)
  else error 'logic-err'
  ]




[求Lw_(W,u,n;Lb)的 分支:[[Lw>=n+u+4]or[n>=3][Lw==n+u+3]]
    precondition:[[[Lw>=n+u+4]or[n>=3][Lw==n+u+3]][not [W==1][n==2][u<=3]]]
=============
D:=u//n-1
M:=(Lw-(n+u+2))
r1=M%n
q1=M//n%(D+1)
q0=M//n//(D+1)
M=(q0*(D+1)+q1)*n+r1
==>>
x :<- [0,1]
Lb <= W*Lw -(Lnhb_+x)
Lb +(Lnhb_+x) <= W*Lw
  降低Lw 是合理的，之后再搜索
    ==>> 去掉x
Lb +Lnhb_ <= W*Lw
Lb +(n+u+2) +q0*(D+2) +q1 <= W*Lw
Lb +(n+u+2) +q0 +q0*(D+1) +q1 <= W*Lw
Lb +(n+u+2) +q0 +M//n <= W*Lw
Lb +(n+u+2) +q0 +M//n <= W*(M+(n+u+2))
Lb -(W-1)*(n+u+2) +q0 +M//n <= W*M
Lb -(W-1)*(n+u+2) +M//n//(D+1) +M//n <= W*M
kkk:=Lb -(W-1)*(n+u+2)-1
kkk+1 +M//n//(D+1) +M//n <= W*M
1+ (kkk +M//n//(D+1) +M//n)//W <= M


计算过程:
#迭代:
#   发散==>> [W==1][n==2][D==0]
#   发散==>> [W==1][n==2][u<=3]
#   [not [W==1][n==2][u<=3]] ==>> 收敛
assert [not [W==1][n==2][u<=3]]
D:=u//n-1
kkk:=Lb -(W-1)*(n+u+2)-1
#M0 := 0
M0 := n+u+4
while 1:
  M1 := 1+ (kkk +M0//n//(D+1) +M0//n)//W
  if M1 == M0:break
  M0:=M1
M:=M0
Lw__lowbound:=(M+(n+u+2))
search [Lw__lowbound..] for min Lw
]


#负载比特数之字数囗囗编码五:更进:
#负载比特数->字数
[负载比特数之字数囗囗编码五囗更进囗(W,u,n;Lb) :=
  assert (W>=1 and u>=n>=2 and Lb>=0) $
  if Lb==0 then n+u else
  assert (not [[n==2][u<=3][W==1]]) $
    # otherwise ==>> [Lb==Lhb==0]
  if Lb <= (W-1)*(n+u) then n+u else
  if (n==2 and u<=3) then let Lw_ := max(n+u+2,1+ (Lb-1)//(W-1)) in (Lw_ +[[u%n == 0][n==2][(Lw_-3)%u==0]]) else
  # !! [[(n+u+3)非合法总长度] -> [u==n==2]]
  # now:[not (n==2 and u<=3)]
  # now:[(n+u+3)合法总长度]
  let [is_ok_ Lw := (Lw>=n+u and Lw =!= n+u+1 and (u%n =!= 0 or n>=3 or (Lw-3)%u =!= 0))] in
    #用于实现:总长度是否合法囗
  let [ls_ Lw_ls := 负载比特数之字数过滤器囗<编码五囗更进>(W,n,u;Lb,Lw_ls)] in
  let [ls := ls_ [n+u,n+u+2,n+u+3]] in
  if ls then ls[0] else
  # precondition:[[[Lw>=n+u+4]or[n>=3][Lw==n+u+3]][not [W==1][n==2][u<=3]]]
  # now:[Lw>=n+u+4]
  # now:[not [W==1][n==2][u<=3]] <<== assert()


  let [[D:=u//n-1][kkk:=Lb -(W-1)*(n+u+2)-1][f M0 := 1+ (kkk +M0//n//(D+1) +M0//n)//W]] in
  let [Lw0 := head $ filter (uncurry (==)) $ pairwise $ iterate f (n+u+4)] in
  (ls_ [Lw0..])[0]
  ]





=============================退化囗对称[u==n>=2][z:=u]:
[编码参数z >= 2]

[[Lw==2*z] -> [Lhb==0]]
[[Lw==2*z+2] -> [Lhb==0]]
[[z==2] -> [Lhb==0]]


[[Lw>=2*z+2] -> [(q,r):=(Lw-(2*z+2))/%z] -> [r=!=z-1] -> [Lnhb==(2*z+2) +q*2]]
  # (1{z} 0) ([01]{z-2} 10)* [01]{,z-2} (1 0{z})

[[Lw>=2*z+2] -> [(q,r):=(Lw-(2*z+2))/%z] -> [z>=3] -> [r==z-1] -> [Lnhb==(2*z+2) +q*2 +1]]
  # [z>=3]:(1{z} 0) ([01]{z-2} 10)* [01]{z-3} (01 | 10) (1 0{z})

==>>
[[Lw>=2*z+2] -> [(q,r):=(Lw-(2*z+2))/%z] -> [
  [[r=!=z-1] -> [Lnhb==(2*z+2) +q*2]]
  [[z>=3] -> [r==z-1] -> [Lnhb==(2*z+2) +q*2 +1]]
  ]]

<<==>>
[[Lw>=2*z+2] -> [(q,r):=(Lw-(2*z+2))/%z] -> [
  [[[r=!=z-1]or[z>=3]] -> [Lnhb==(2*z+2) +q*2 +[r==z-1]]]
  ]]

[[Lw==2*z] -> [Lhb==0]]
[[Lw==2*z+2] -> [Lhb==0]]
[[z==2] -> [Lhb==0]]


==>>

!! [[z>=3] -> [总长度 <- [2*z..] \\ [2*z+1]]]
!! [[z==2] -> [总长度 <- [4,6..]]]


==>>
#字数之负载比特数囗囗编码五:退化囗对称:
#字数->负载比特数
[字数之负载比特数囗囗编码五囗退化囗对称囗(W,z;Lw) :=
  assert (W>=1 and z>=2 and Lw>=2*z and Lw =!= 2*z+1 and (z>=3 or Lw%2 == 0)) $
  if Lw <- [2*z,2*z+2] or z==2 then (W-1)*Lw else
  #分支:[[z>=3][Lw>=2*z+3]]
  let [(q,r):=(Lw-(2*z+2))/%z] in
  assert [[r=!=z-1]or[z>=3]] $
  let [Lnhb:=(2*z+2) +q*2 +[r==z-1]] in
  W*Lw -Lnhb
  ]

[求Lw_(W,z;Lb)的分支:[[z>=3][Lw>=2*z+3]]
    precondition:[[[z>=3][Lw>=2*z+3]][not [W==1][z==2]]]
    <==>
    precondition:[[z>=3][Lw>=2*z+3]]
=============
M:=(Lw-(2*z+2))
[(q,r):=M/%z]
Lb <= W*Lw -Lnhb
Lb + Lnhb <= W*Lw
Lb + (2*z+2) +q*2 +[r==z-1] <= W*Lw
Lb + (2*z+2) +q*2 <= W*Lw
  降低Lw
Lb +(2*z+2) +M//z*2 <= W*Lw
Lb +(2*z+2) +M//z*2 <= W*(M+(2*z+2))
Lb -(W-1)*(2*z+2) +M//z*2 <= W*M

kkk := Lb -(W-1)*(2*z+2) -1
kkk+1 +M//z*2 <= W*M
(1+ (kkk +M//z*2)//W) <= M
  发散 ==>> [1 <= 2/z/W]
  发散 ==>> [z*W <= 2]
  发散 ==>> [[W==1][z==2]]
  [not [W==1][z==2]] ==>> 收敛
assert [not [W==1][z==2]]
迭代至稳定:
  M := (1+ (kkk +M//z*2)//W)
Lw__lowbound:=(M+(2*z+2))
search [Lw__lowbound..] for min Lw
]


#负载比特数之字数囗囗编码五:退化囗对称:
#   see:使用囗计算框架囗实现囗负载比特数之字数囗囗编码五囗退化囗对称囗
#负载比特数->字数
[负载比特数之字数囗囗编码五囗退化囗对称囗(W,z;Lb) :=
  assert (W>=1 and z>=2 and Lb>=0) $
  if Lb==0 then 2*z else
  assert (not [[z==2][W==1]]) $
    # otherwise ==>> [Lb==Lhb==0]
  if Lb <= (W-1)*(2*z) then 2*z else
  if z==2 then let Lw_ := max(2*z+2,1+ (Lb-1)//(W-1)) in (Lw_ +Lw_%2) else
  # !! [[(2*z+3)非合法总长度] -> [z==2]]
  # now:[not (z==2)]
  # now: [z>=3]
  # now:[(2*z+3)合法总长度]
  let [is_ok_ Lw := (Lw>=2*z and Lw =!= 2*z+1 and (z>=3 or Lw%2 == 0))] in
    #用于实现:总长度是否合法囗
  let [ls_ Lw_ls := 负载比特数之字数过滤器囗<编码五囗退化囗对称>(W,z;Lb,Lw_ls)] in
  let [ls := ls_ [2*z,2*z+2,2*z+3]] in
  if ls then ls[0] else
  # precondition:[[z>=3][Lw>=2*z+3]]
  # now: [z>=3]
  # now: [Lw>=2*z+4]


  let [[kkk:=Lb -(W-1)*(2*z+2) -1][f M0 := 1+ (kkk +M0//z*2)//W]] in
  let [Lw0 := head $ filter (uncurry (==)) $ pairwise $ iterate f (2*z+4)] in
  (ls_ [Lw0..])[0]
  ]



#字数之位置之该字首比特类别囗:编码五囗退化囗对称
#字数->位置->首比特囗类别
[字数之位置之该字首比特类别囗囗编码五囗退化囗对称囗(W,z;Lw,idx) :=
  assert (W>=1 and z>=2 and Lw>=2*z and Lw =!= 2*z+1 and (z>=3 or Lw%2 == 0)) $
  assert (0 <= idx < Lw) $
  if idx < z then 首比特囗类别.格式比特囗值一
  elif not idx+z < Lw then 首比特囗类别.格式比特囗值零
  #now: [Lw > 2*z][z <= idx < Lw-z]
  #bug:elif idx==z+1 then 首比特囗类别.格式比特囗值零
  elif idx==z then 首比特囗类别.格式比特囗值零
  elif idx+z+1 == Lw then 首比特囗类别.格式比特囗值一
  #now: [Lw > 2*z+2][(z+1) <= idx < Lw-(z+1)]
  else let
      [ir := (idx-(z+1))%z]
  in
  if ir < z-2 then 首比特囗类别.负载比特囗值自由
  elif (idx+z+2 == Lw and z>=3 and ir==z-2)
      then 首比特囗类别.格式比特囗值相反于前比特
  elif ir == z-2 then 首比特囗类别.格式比特囗值一
  elif ir == z-1 then 首比特囗类别.格式比特囗值零
  else error 'logic-err'
  ]
  * (1{z} 0{z})
  * (1{z} 0) ([01]{z-2} 10)* [01]{,z-2} (1 0{z})
  * [z>=3]:(1{z} 0) ([01]{z-2} 10)* [01]{z-3} (01 | 10) (1 0{z})
        #余部-([01]{z-3} (01 | 10)) 等效于 ([01]{z-2} F)







[使用囗计算框架囗实现囗负载比特数之字数囗囗编码五囗退化囗对称囗
#使用:计算框架<<==需要:字数之负载比特数囗囗编码五囗退化囗对称囗
#使用:计算框架<<==需要:字数之位置之该字首比特类别囗囗编码五囗退化囗对称囗

#override:抽象方法:
[编码参数是否合法囗<编码五囗退化囗对称>(W,z;) := (W>=1 and z>=2)]
[最高负载率的极限囗<编码五囗退化囗对称>(W,z;) := Fraction(1-2/W/z)]
[最小总长度囗<编码五囗退化囗对称>(W,z;) := 2*z]
    #编码的最小总长度
[总长度是否合法囗<编码五囗退化囗对称>(W,z;Lw) := (W>=1 and z>=2 and Lw>=2*z and Lw =!= 2*z+1 and (z>=3 or Lw%2 == 0))]
    !! [[z>=3] -> [总长度 <- [2*z..] \\ [2*z+1]]]
    !! [[z==2] -> [总长度 <- [4,6..]]]
[字数之负载比特数囗<编码五囗退化囗对称>(W,z;Lw) := 字数之负载比特数囗囗编码五囗退化囗对称囗(W,z;Lw)]
[字数之位置之该字首比特类别囗<编码五囗退化囗对称>(W,z;Lw,idx) := 字数之位置之该字首比特类别囗囗编码五囗退化囗对称囗(W,z;Lw,idx)]

#override:可覆盖囗具象方法:
[枚举囗合法总长度囗囗大于等于囗<编码五囗退化囗对称>(W,z;Lw__lowbound) :=
    let [step := 1+(z==2)] in
    if Lw__lowbound <= 2*z then [2*z]++count(2*z+2,step) else count(max(Lw__lowbound,2*z+2),step)
    ]


#调用 具象方法 实现
[负载比特数之字数囗囗编码五囗退化囗对称囗(W,z;Lb) := 负载比特数之字数囗<编码五囗退化囗对称>(W,z;Lb)]

]

]]

]]]







]]]]]]]]]
