CFG编译器

模块:本模块完全名
输入:终止符号*
输出:非终止符号*
默认:非终止符号?
噪声:非终止符号?

引用:外模块名(终止符号替换){非终止符号替换}

非终止符号::函数类型#(符号函数类型+数据函数类型)
	符号函数类型 = ((符号|整数|析合数据)->)* 符号
	数据函数类型
		| 串行式非终止符号 = 输出数据类型
		| 并行式非终止符号 = 输入数据类型 -> 输出数据类型



数据转换函数::数据函数类型
并行式非终止符号
	封闭式非终止符号
	开放式非终止符号
串行式非终止符号


模块终结


============================
系统数据 含 范围信息
	数据流 经过多次变换:字节 字符 终止符号 ...
	记录不同层次的数据流范围

符号=词=
	| 阳符 = 非终止符号 = 实词
	| 阴符 = 终止符号 = 虚词


(符号|整数|析合数据)
	太复杂
	如无意 包含 正则表达式，只用 符号 即可


行内注释？？？？
噪声？？？？
	除 默认主符号 外，噪声 只在 串行式非终止符号 的定义中自动插入，不在两端，不与“紧邻”相邻
	“相邻”也不在两端

保留字:
	非终止符号
		噪声、紧邻
		空、死
	数据转换函数
		并式分支标签

并行式非终止符号
	;a x:g$
		|b
		|c x
		|f$ d
	# g$ f$ 是 数据转换函数
串行式非终止符号
	多元组
	;a x = g$ ,b ,c x ,f$ d
	;a x = g$ ,+b ,-c x ,+f$ d
	别名
	;a x = *,b ,c x ,+f$ d
	;a x = f$ d
	# 注意：将右式放入括号作为表达式：(右式)
非终止符号函数实例化 的 命名
	用户可见命名=通用标准命名=文本命名 #如何加括号？？
	依赖于编程语言的实际数据命名


类型名、数据名 在同一命名空间
保留字、变量、常量 的 命名区分



=================
模块化函数化带数据转换函数的语法 =
	,模块头
	,重复零 阴符定义相关
	,模块尾

模块头 =
	,模块名声明
	,输入阳符声明
	,输出阴符声明
	,默认阴符声明
	,噪声阴符声明
	,引用阴符声明

阴符定义相关 :
	| 阴符定义
	| 阴符声明

阴符声明 =
	, 常量阴符名
	, '::'
	, 阴符类型
阴符定义 :
	| 并式阴符定义
	| 串式阴符定义

模块尾 =
	, ';模块终止'
并式阴符定义 =
	, ';'
	, 阴符定义头
	, ':'
	, 并式阴符定义体
并式阴符定义体 =
	重复一 (*, '|' , +阴符表达式)
串式阴符定义
	, ';'
	, 阴符定义头
	, '='
	, 串式阴符定义体
串式阴符定义体 :
	| 基本串式阴符定义体
	| 选择串式阴符定义体
	| 选择别名串式阴符定义体
	| 直接别名串式阴符定义体
基本串式阴符定义体 =
	, 重复零 转换式
	, 重复一 (*, ',' , +阴符表达式)
选择串式阴符定义体 =
	, 重复零 转换式
	, 重复一 (, -',' , +正负 ,+阴符表达式)
选择别名串式阴符定义体 =
	, -'*'
	, +重复零 (*, ',' , +阴符表达式)
	, -','
	, -'+'
	, +阴符表达式
	, +重复零 (*, ',' , +阴符表达式)
直接别名串式阴符定义体 =
	阴符表达式

正负 :
	, '-'
	, '+'

阴符表达式 =
	, 重复零 转换式
	, 重复一 原子阴符表达式
原子阴符表达式 :
	| 阴符名
	| 外括号阴符表达式
外括号阴符表达式 = *
	, '('
	, +括号内阴符表达式
	, ')'
括号内阴符表达式 :
	| 串式阴符定义体
	| 并式阴符定义体


阴符名 :
	| 常量阴符名 # '\w+' 字符串
	| 变量阴符名 # '\w+~' 字符串~

阴符定义头 =
	, 常量阴符名
	, 重复零 变量阴符名
阴符类型 :
	| 原子阴符类型
	| 箭头阴符类型

箭头阴符类型 =
	, 原子阴符类型
	, '->'
	, 阴符类型
原子阴符类型 :
	| '符号'
	| 外括号阴符类型
==========================================
# 去掉 “:”
# LL1
# 前向？？
# 优先？？？
阴符定义 =
	, ';'
	, 阴符定义头
	, '='
	, 阴符定义体

阴符定义体 =
	括号内阴符表达式

括号内阴符表达式 =
	| 选一阴符表达式
	| 非选一阴符表达式

选一阴符表达式 =
	, '*'
	, 重复零 (*, ',' , +阴符表达式)
	, ','
	, '+'
	, 阴符表达式
	, 重复零 (*, ',' , +阴符表达式)
非选一阴符表达式 =
	, 重复零 转换式
	, 非选一阴符表达式续

非选一阴符表达式续 =
	| 重复一 原子阴符表达式
	| 前向 !',[+-]': 重复一 x
	| 前向 '+,[+-]': (,'+' ,重复一 y)
	| 重复一 (,'|' ,阴符表达式)
	| 重复一 (,'^' ,阴符表达式)  #优先
	where
		x = (,',' ,阴符表达式)
		y = (,',' ,正负 ,阴符表达式)

========================================
# 识别系统
# 重复 贪婪否？？？xxx 不得回溯，只能贪婪
# 识别器+缓存器
缓存器
	=====数据
	当前地址
	缓存起始地址，缓存末尾地址
	可选 虚拟终结地址
	曾经的最大缓存量 #性能参考
	可选 最大缓存量 #设置上限
	=====约束
	缓存起始地址<=当前地址<=min(缓存末尾地址,虚拟终结地址)
	=====动作
	缩减缓存()
		缓存起始地址 := 当前地址
	读取不多于(n)->[阳符]

识别器
	启动()->(状态,是否保存当前地址,可选 (子识别器引用|识别结果))
	递增识别(状态,阳符)->(状态,是否缩减缓存是否回退当前地址,是否设置虚拟终结地址,可选 (子识别器|识别结果))
	处理子识别器结果(状态,识别结果)->...
	=======关联数据
	保存的地址
	当前状态
	是否是我 #最多只能发生一次变化，且只能是由“否”变“是”
	虚拟终结地址
	是否生成成功的数据
	是否锁死缓存起始地址，是否是我成功锁死(须由我解锁)
	=======识别结果
	消耗量,成功，数据
	消耗量,失败，原因，是否是我
	消耗量,继续，是否是我


# 由于存在递归，只能使用“识别器引用”或内建识别器，而非用户自定义的识别器本身
常量识别器([阳符])
缩减缓存识别器
非我失败识别器(非我失败原因)
是我失败识别器(是我失败原因)
	如已消耗输入，必是“是我”？？
		未必，假设本分支是最后分支，则头部检查时实无缓存的必要。
		各分支可随意消耗，通过“是我”消息使上层放弃缓存
	如不消耗输入，必是“非我”？？
		找不到反例，但不预先作此假设
		至少“是我失败识别器”本身就不消耗输入
限长成功识别器(最小长度,最大长度)
	必然成功识别器 #最短0，最长无限
前向识别器(识别器引用,成功变(成功|是我失败|非我失败))
	不含 失败保护识别器！！
	不论 成功失败，回退地址
失败保护识别器(识别器引用)
	“是我”失败 改为 “非我”失败
消耗是我串行识别器([识别器引用])
	由失败时是否产生消耗，判定是 是我失败 还是 非我失败
显式是我串行识别器([识别器引用],可选 识别器引用,[识别器引用])
	引用指定的“是我”消息
	======由于是我消息只在直接子辈发生作用，更换API
	串行识别器([识别器引用])
	是我消息转发识别器(识别器引用)
	是我消息发生识别器
	通过 是我消息转发识别器 及 是我消息发生识别器 产生 是我消息
优先识别器([识别器引用],可选 非我失败原因)
前缀识别器(识别器引用,[识别器引用],成功变)
等长识别器(识别器引用,[识别器引用],成功变)
	以第一个的识别结果来设置后者的 虚拟终结地址

定长重复#[定长..定长]
任意重复#[0..]
限长重复#[0..最长]
重复(最少重复数,识别器引用,可选 识别器引用,可选 是否贪婪)
	#==定长重复+任意重复
	#y 必须出现才能体现出“贪婪”与否
	if 最少重复数>0:
		x>>重复(最少重复数-1,...)
	if 贪婪:
		x>>重复(0,...) | 常量识别器([])>>y
	else:
		常量识别器([])>>y | x>>重复(0,...)




#优先
;a x =
	^ b x
	^ ,c x, d
	^ ,&?e, d #前向是，某前缀是
	^ ,&!e, d #前向否，所有前缀否
	#最好e有最大长度，否则要检查整个输入
	#限制输入长度
	^ ,&5?e, d #前向是，某前缀是
	^ ,&5!e, d #前向否，所有前缀否
	# 阻止本分支回溯???不允许回溯！！
	#^ ,c x ,. ,d
	# 阻止其他分支
	^ c x : ,e ,d


#且
;a x =
	& b x
	& b x
