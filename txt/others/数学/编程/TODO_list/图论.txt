

点:
  全部节点 静态存储
    遍历着色:
      静态并存
      动态增长
  邻接节点 动态生成
    遍历着色:
      知源森林无色
      知源有向无环图重复访问
        即 当作 压缩森林
      规避无向图动态栈但最坏爆炸不实用
        当存在极长的路径时，不实用
      深度逐遍递增重复访问
      深度逐遍递增重复访问同时规避无向图动态栈
        棋类游戏状态空间搜索，重在『搜索』『裁剪』，不在『遍历』
  超图 点边皆着色


端:
  #半边
  出端:半出边:点->边
    源端
  入端:半入边:点<-边
    终端
  ##xxx通端:半出入边:点<->边

边:
  边 按 端数 归类:
    两端边
      出端+入端==>>有向边
      ##xxx通端+通端==>>无向边
      出端+出端==>>无向边
      入端+入端==>>???不存在的断边？？？
    多端边#超图
      超图 是 无向图
      无向边，皆 出端
    零端边#孤环
    一端边#单端边#！非半边！

点、边、有向端 ==>> 有向二分简单图（无重复边，无孤环，无自环，无多端边）
  ##xxx有向端 是 三向，见上面:出端/入端/通端

图数据结构:
  点列表
  边列表
  ===端命名:
    端列表
    点到端列表
    边到端列表
    端到点
    端到边
    端到方向
    点边到可选端
  ===端不命名:
    点到出边列表
    边到点列表 #由 点着色，判断 是否 访问
    ##xxx边到出点列表 #邻接点 皆 出点
    点边到邻接类型#不邻接|出边|无向
  ===可选
    两点到边列表


命名:
  命名数据类型:
    紧凑自然数
      模n剩余类 [0..n-1]
      桶排序 O(n)
    全序可散列
      可散列:着色/记录数据/邻接表/邻接矩阵
      全序？
        集合:
          输出标准化 #必须！
          加速测试相等？无需！
          简化实现集合散列方法？无需！
  谁命名:
    #图命名
      可选
    点命名
      必须，因为默认一点多边
    边命名
      可选
      边不命名:
        无重复边:
          无向图 默认 边命名:
            {} 全图唯一的 孤环
            {x} 点x的唯一 自环
            {x,y} 点x 与 点y 之间唯一的 无向边
            ... 多端边 类似
          有向图 默认 边命名:
            () 全图唯一的 孤环
            (x,) 点x的唯一 自环
            (x,y) 点x 到 点y 唯一的 有向边
            ({x,...},{y,...}) 多端边
        有重复边:
          无单边数据，只有 重复边数据
          只记录 重复数
          <==> 无重复边+重复数
    端命名
      可选
      （点，边）1<-->0..1 端

遍历:
  点遍历
  边遍历
  点边遍历
    输入 起始的点边集合
    起始点 -> 邻接边
    起始边 -> 邻接点
    入边+点 -> 邻接边
    源点+边 -> 邻接点
      有向边 逆向时 跳过 邻接点


数据:
  图数据#整图约束
    有向？
    简单？
      重复边？
      自环？
      ===
      多端边？
        孤环？
        单端边？
    点端度范围#出/入
    边端度范围#出/入
  点数据#种类
    （复杂类型的图 转化为 简单无向图 时，一般会添加新点边，需着色区分）
  边数据#向性，重复数
  端数据#向性

