整数编码


不同需求：
	*概率分布
	*正负符号
		*无符号
		*有符号
			*正向符号探测
			*反向符号探测
	*大小端序
		*正向模2探测
		*反向模2探测
	*遍历方式
		*正向读取
			*尾指示
				最后N单元符合〖尾条件〗
				前面转义以回避〖尾条件〗
				〖尾条件〗：
					*单单元
						*单元前缀
						*单元常量
					*多单元
						*多单元常量
							带状态回避#类似子字符串搜索
						*复杂运算
			*正向跳过
				长度{正向读取编码}++负载
		*反向读取
			*头指示
			*反向跳过
				负载++长度{反向读取编码}
		*中间重定位 < 正向读取&反向读取
			*多单元(字节)联合前缀：
				*每单元单比特前缀
					#各单元前缀比特的正则表达式
					*11(01)*00
						长度=4+2*x
						效率=7/8
						落在中间时，读取当前单元的前缀比特：
							*0:
								#...[0]
								当前单元不是头单元
								读前一单元的前缀比特：
									*0:
										#...0[0]
										当前单元是尾单元
										*定位头单元：
											seek(.-3)
											while 当前单元的前缀比特==0:
												seek(.-2)
											DONE
										*定位尾单元：
											DONE
									*1:
										#...1[0]...
										当前单元不是尾单元
										双向搜索，同上
							*1:
								#[1]...
								当前单元不是尾单元
								读后一单元的前缀比特：
									*0:
										#...[1]0...
										当前单元不是头单元
										双向搜索，同上
									*1:
										#[1]1...
										当前单元是头单元
										单向搜索，同上
					*11{n}1(0[01]{n}1)*00{n}0
						长度=(2+n)*(2+x)
						效率<=1-2/8/(2+n)
							# == when n==0
						定位方法同上
						*0:
							反向读直到遇见1
							正向读直到0的个数为(2+n)或遇见1
							...双向移动
						*1:
							正向读直到遇见0
							反向读直到1的个数为(2+n)或遇见0
							...双向移动
			*每单元(字节)前缀：
				是否 单单元、头单元、尾单元、体单元
				#11      #各单元前缀的比特数
				#   {2}  #不同前缀的数量
				#expand 1->22
				#122,2222
				#   {3,4}
				#expand 2->33
				#1233,13333,22233,2233_33,233_3333,3333_3333
				#   {4,5,6,7,8}
				#4==>>2222,1233
				#3==>>122
				根据概率分布：
					*单单元 用 单比特前缀
						1233
						效率<6/8
						体单元 用 双比特前缀
						头单元、尾单元 用 三比特前缀
					*体单元 用 单比特前缀
						1233
						效率<7/8
						单单元、头单元、尾单元 用 双比特前缀*1、三比特前缀*2
					*均用 双比特前缀
						2222
						效率=6/8
					*不使用 单单元
						122
						效率<7/8
						体单元 用 单比特前缀
						头单元、尾单元 用 双比特前缀
				
		




