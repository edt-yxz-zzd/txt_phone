只增文档
	只记录修改动作，不保存最新版本的文档
	因为只增，故能：
		*避免一切误修改
		*随时保存，避免掉电丢失数据
	微动作：
		与文档格式版本息息相关，必须尽可能地稳定
		相对少以方便实现算法
		必须可逆
		如：
			删除 <哪里> <什么>
			插入 <哪里> <什么>
			==>>替换 <哪里> <什么> <什么>
		<什么> 是字符串，可考虑唯一化
	宏动作：
		库定义(同时替换多个匹配，从后往前)或用户自定义
		宏动作的实例展开为一系列微动作/宏动作
		在撤销时，一次撤销整个〖主动作〗
		其名在编辑过程中用于引用定义，文档中仅用于注释(为节省空间，只出现一次，引用其在文档中的编号)
	主动作：
		不嵌套在其他宏动作中的微动作或宏动作
	树状撤销
		赋予每个宏动作一个唯一的标识及父标识
		分支时刻vs线性时刻
			*线性时刻
				宏动作的保存顺序是隐含的实际绝对顺序(线性时刻)(可用作标识)
			*分支时刻
				父标识为宏动作的修改前分支时刻
				标识为宏动作的修改后分支时刻
	输入：插入模式
		类似VIM，否则单字符输入并即时保存开销太大
		移动光标或退出插入模式时自动保存
	只增文档格式：
		[[已存在的原文档]]
			初始化时已存在文档
			直接在原文档的基础上“只增”
		编码 <原文档及本行编码> <以下的编码>
		编码 <原文档编码> <本行及以下的编码>
			为何<本行及以下的编码>不用utf8？
				因为unicode并不能涵盖所有字符编码
					* unicode标准不能即时更新
					* unicode标准版本不清楚
					* unicode标准无意涵盖，如：无数汉字、自定义编码
					* unicode标准编码空间有限，不能涵盖未来可能出现的无穷多字符
			为避免歧义，两编码行只能出现一次，即最后一次有效出现(原文档可能多次有效出现)
			知道任一编码，即可解码
			由于使用双编码，所以本格式为二进制文档而非文本文档
		主语句*
	主语句：
		* 注释：注释 <谁> <什么>*
			主要是编辑程序自动注释
			用户注释最好通过编辑程序(主要是编码问题及只增保证)
				* TODO list
				* 注释主要的还原点(内部节点::分支时刻)，或多个前沿版本(叶节点::分支时刻)(不完整)
				* 注释多个稳定(完整定稿)及不稳定版本(完整但未定稿)
			主语句的注释可手动插入到前面而非以附加的方式，但这不“只增”
			注释不产生新的分支时刻，也不更改当前的分支时刻
		* 定义字符串常量：字符串 <ID> <什么>
			* 宏动作名
			* 动作/注释的实际字符串参数
		* 声明分支时刻：分支时刻 <ID>
			定义字符串常量、注释、声明分支时刻
				不产生新的分支时刻
				也不更改当前的分支时刻
		* 主动作
			* 微动作
			* 宏动作
				宏动作 开始 <宏动作名> <参数>...
				...宏动作展开...
				宏动作 结束 <宏动作名>
		* 复原 <分支时刻>
			复原不产生新的分支时刻，但更改当前的分支时刻
		
		
