
e others/数学/编程/并行并发/锁升级-混合锁.txt


锁升级
锁升级-或者说 混合锁-我的理解
  先尝试用轻量级的锁，如：非阻塞的锁（如：自旋锁）
  若成功，则得锁
  若失败，可多试几次（因为『非阻塞』）
      ，倘若还是失败，则需要引起注意
    。忙试 其实比单纯的挂起式阻塞 还要糟糕
      ，不仅阻塞，还浪费机器时间。
      #Regular locks employed in mutexes or semaphores are way more expensive, as the suspend/wakeup cycle requires a lot of work under the hood.
      #挂起/唤醒 也耗时，但毕竟有限
      #自旋锁 只能用在 锁独占时间 极少的情形
      #  也就是 争锁线程代码 完全可控，且 小心设计的情况
      #  需要 保证每次失败时，必有 同时竞争的线程成功
      #显然 这里的场景 并不符合这些要求：失败时 并没有成功者（获锁线程 并没有参与竞争），仅是 不断查询而已，毫无进步。
      #这也是不坚持自旋锁而进行升级锁的缘故
  升级一，每次失败后休眠一段时间
    ，避免过多浪费机器时间
      ，休眠间隔可逐次增大
      ，让别的线程多干活，特别是获锁线程
    。但失败一定次数后
      ，或 发现有别的线程开始参与竞争
      ，就知道问题严重了
    。由于有更多的线程参与竞争
      ，获锁的可能性不再乐观，情况越发糟糕
      ，与其随机获锁，不如先到先得。
  升级二，提升锁类型为阻塞锁，要求排队获锁
    。其他线程 进行非阻塞尝试时
      ，发现锁已升级
      ，可自行决定要不要排队挂起
    。排队又是一个技术活，毕竟多线程
        ，使用 无锁队列
      。无锁队列 成立的条件
        ，或者说 为何能同步成功的原因
        ，在于 关键操作是固定的，耗时非常少，
        ，每轮竞争至少一个线程成功排队并挂起
        ，竞争者越来越少
      ，相比之下
        ，线程在获锁后的操作则不可预测
        ，在这不可测的漫长时间里
        ，非阻塞式锁的竞争者 只增不减。
    。获锁线程 释放锁时
      ，若发现是阻塞锁
        ，则唤醒队列中的一员
        ，争锁线程需先将计数值加一
        ，升级锁时计数值便需非零
        ，释锁线程 等待 至少一个争锁线程 挂起后 再唤醒
      。无锁队列 可以是 单链表
      ，链头被对象直连
      ，链尾留给 获锁线程 唤醒
      ，争锁线程 竞争 链头位置
      ，试图将自己挂上去
      。


