
e others/数学/编程/设计/有限状态机-接口规范.txt

当作硬件组合时的接口规范

两种规范:
  *严格规范:降低组合后增加的新状态
  *随性规范:不对不透明子部件作太多要求

任一状态机{非确定性}:
  参数:状态总数
  假设:[总状态集==[0..<状态总数]]
  假设:[0<状态总数]
  假设:[入口/初始状态集是{0}]
  假设:[出口/接受状态集是{0}或{1}]
  假设:[外联状态 只能是 初始状态 与 接受状态，其余状态 封装不可见]
  假设:[父部件 的 插口状态 用于 插入任意数量子部件的出入口]
    # [引脚 == (出口|入口)]
    # 可能:[引脚 可能也是 插口:严格规范(不是)vs随性规范(是)]
    # 允许:同一子部件出口+入口 插入同一插口
    # 必须:子部件出口/入口 只能插入一插口(有且只有唯一一个插口)

子部件:
  *封装子部件#不透明子部件
  *直通子部件#短路子部件
  *断堑子部件#断路子部件
组合器:
  *串联器
  *并联器
  *循环器#复式/闭包

*严格规范:降低组合后增加的新状态
  假设:[出口/接受状态集是{1}] 即：[出口/接受状态 不同于 入口/初始状态]
  假设:[出口{1}没有出边]
  假设:[入口{0}没有入边]
    ==>> [插口 不含 出入口][状态总数>=2]
  以上三个假设的作用在于防止串并联后出现意外:
      *[出口==入口==0]导致并联意外:
        (A{0} | B{0--[z]->1})
        <==>
        C{0--[z]->0}
        <==>
        正则表达式:『z*』而非『z?』
      *[出口 有出边]导致并联意外:
        (A{0--[a]->1} | B{0--[z]->2--[y]->1--[]->2})
        <==>
        正则表达式:『(a|zy)y*』而非『(a|zyy*)』
      *[入口 有入边]导致并联意外:
        (A{0--[a]->1} | B{0--[z]->2--[y]->1; 2--[]->0})
        <==>
        正则表达式:『(a|zz*(a|y))』而非『(a|zz*y)』
      *[前件出口 有出边][后件入口 有入边]导致串联意外:
        (A{0--[a]->2--[b]->1--[]->2} ++ B{0--[z]->2--[y]->1; 2--[]->0})
        <==>
        正则表达式:『ab(b|z)*zy』而非『abb*zz*y』
      *[出口 有出边]导致循环意外:
        A{0--[z]->2--[y]->1--[]->2} *
        <==>
        正则表达式:『(zy|y)*』而非『(zyy*)*』
      *[入口 有入边]导致循环意外:
        A{0--[z]->2--[y]->1; 2--[]->0} *
        正则表达式:『(z|zy)*』而非『(zz*y)*』
  组合器:
    *串联器
      (A{0--[?A?]->1} ++ B{0--[?B?]->1})
      <==>
      C{0==A0--[?A?]->A1==2==B0--[?B?]->B1==1}
      [状态总数(A++B) == 状态总数(A)+状态总数(B)-1]
      [非出入口状态总数(A++B) == 非出入口状态总数(A)+非出入口状态总数(B)+1]
    *并联器
      (A{0--[?A?]->1} | B{0--[?B?]->1})
      <==>
      C{0==A0--[?A?]->A1==1;0==B0--[?B?]->B1==1}
      [状态总数(A|B) == 状态总数(A)+状态总数(B)-2]
      [非出入口状态总数(A|B) == 非出入口状态总数(A)+非出入口状态总数(B)]
    *循环器#复式/闭包
      (A{0--[?A?]->1} *)
      <==>
      C{0--[]->2--[]->1;2==A0--[?A?]->A1==2}
      [状态总数(A*) == 状态总数(A)+1]
      [非出入口状态总数(A*) == 非出入口状态总数(A)+1]


*随性规范:不对不透明子部件作太多要求
  并无假设:[出口/接受状态集是{1}] 即：[出口/接受状态 不同于 入口/初始状态]
  并无假设:[出口{1}没有出边]
  并无假设:[入口{0}没有入边]
    ==>> [插口 含 出入口][状态总数>=1]
  组合器:
    *串联器
      (A{0--[?A?]->01} ++ B{0--[?B?]->01})
      <==>
      C{0==A0--[?A?]->A01--[]->B0--[?B?]->B01==1}
          中间再串联一个『直通子部件』
      [状态总数(A++B) == 状态总数(A)+状态总数(B)]
    *并联器
      (A{0--[?A?]->01} | B{0--[?B?]->01})
      <==>
      C{0--[]->A0--[?A?]->A01--[]->1;0--[]->B0--[?B?]->B01--[]->1}
          两分支出入口各串联一个『直通子部件』#共四个
      [状态总数(A|B) == 状态总数(A)+状态总数(B)+2]
    *循环器#复式/闭包
      (A{0--[?A?]->01} *)
        * (A{0--[?A?]->0} *)
        * (A{0--[?A?]->1} *)
      <==>
      C{0--[]->1;01==A0--[?A?]->A01==0}
        * C{0==A0--[?A?]->A0==0}
        * C{0--[]->1;1==A0--[?A?]->A1==0}
      [状态总数(A*) == 状态总数(A)]


