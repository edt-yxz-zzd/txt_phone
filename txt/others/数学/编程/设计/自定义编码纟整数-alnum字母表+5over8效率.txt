
e others/数学/编程/设计/自定义编码纟整数-alnum字母表+5over8效率.txt
view others/数学/编程/设计/自定义编码纟整数-ASCII字母表+6over8效率.txt

#######
摘要:
  #扩增:指包含 正负无穷(编码扩增自然数 不包含 负无穷)
  编码扩增整数{3}
  编码扩增有理数{3}
    内部使用:编码扩增自然数{32}#头胞用符同于躯胞
    #可惜:编码扩增整数{3} 与 编码扩增有理数{3} 并不兼容，因为 后者 最后必是 正负无穷

  [支持词典序]
  [支持正负无穷]
  [极限效率5/8]
  [字母表 == regex"[0-9A-Y]"] # 大小写不敏感
    #35

#######

#######
[支持词典序]
[字母表 |<=| regex"[0-9A-Z]"] # 大小写不敏感
[极限效率5/8]
++补丁:无限保留区
  view ../../python3_src/seed/int_tools/digits/codecs4int.py

#######
[字母表 == '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ']
[字母表纟躯胞 == regex"[0-9A-V]"]
  32
[字母表纟头胞 == regex"[W-Z]"]
  4
######################
[[
编码自然数or编码整数
  考虑到 容易混淆，所以只 编码整数
  但是 考虑到 可能要编码 有理数，所以 也考虑 某些形式的自然数编码
编码有理数 如何 支持 词典序？
  采用 连分数 表达，并且以正负无穷结束，倒数第二个 非整数部的部分分母 不得为 1
  #严重错误:『=>部分分母 偏移1或2，并可能 取负』
  #@20250813:订正:部分分母统一偏移一
  #     具体见:view others/数学/编程/设计/自定义编码之要点.txt
  =>部分分母 统一偏移1，并可能 取负
  [int; -oo]
  [int; nint{<=-1}, +oo]
  [int; nint, uint{>=+1}, -oo]
  [int; (nint, uint)*, nint, uint{>=+1}, -oo]
  [int; (nint, uint)*, nint{<=-1}, +oo]
    正负无穷 用作 结束符(因为 没有前置长度)，并且 可保证 短连分数 是 长连分数 真前缀 情形之下 保持 次序 正确性
  中间的部分分母 头苞即是躯胞
  => 自然数编码 [头苞==躯胞] 需包含 正负无穷
  => 自然数编码 需包含 正负无穷
==>>:
编码有理数{4}
编码自然数{32}
编码整数{4}:
  头苞共4值 只使用其3:[WXY]，Z保留
  归结为:编码整数{3}
  孤胞码:X --> 整数0
  [W =[def]= 负号]
  [X =[def]= 零]
  [Y =[def]= 正号]
  表达{负数} --> 取反(表达{正数})
  归结为:编码自然数{32}
    但 考虑到 0已编码，所以 自然数编码方案中立即数偏移一下，留出最大值 表达 正无穷
==>>:
归结为:
编码扩增自然数{32}
编码扩增整数{3}
编码扩增有理数{3}

#######
编码扩增自然数{32}:
  直接进入 超凡层:
    超层==第零层==动态爻元
  0_bbbb => 1凡层:16:[0..<2**4]
    # regex"[A-F]"
  1_0bbb => 2凡层:[0..<8]:[0..<2**35]
    # regex"[G-N].*"
  1_10bb => 3凡层:[0..<4]:[0..<2**15]:[0..<2**((2**15-1)*5)==2**163835]
    # regex"[O-R].*"
  #1_111b => 保留区0
    1_1110 => 正无穷
      # 'U'
    1_1111 ... => 保留区0改
      # 'V'
  1_1100 => 4凡层
    # regex"[S].*"
  1_1101 1_bbbb => 保留区1
  1_1101 0_0bbb => 5凡层
  1_1101 0_11bb => 保留区2
  1_1101 0_100b => 6凡层
  1_1101 0_1011 => 保留区3
  1_1101 0_1010 0_bbbb => 7凡层
  1_1101 0_1010 1_1bbb => 保留区4
  <29>   ...
  1_1101 (0_1010 1_0101)*
  <29>   (<10> <21>)*
    # [<31> == 'V']
    # [<29> == 'T']
    # [<10> == 'A']
    # [<21> == 'L']
  regex"T(AL)*"
  ...


#######
编码扩增整数{3}:
[编码扩增整数{3}.表达{负无穷} =[def]= 取反(编码扩增整数{3}.表达{正无穷})]
[编码扩增整数{3}.表达{负整数} =[def]= 取反(编码扩增整数{3}.表达{取负(负整数)})]
[编码扩增整数{3}.表达{0} =[def]= "X"]
[编码扩增整数{3}.表达{正整数} =[def]= "Y"++头苞减一(编码扩增自然数{32}.表达{正整数})]
  #==>>头苞 最大值 被保留 (用作 正无穷)
[编码扩增整数{3}.表达{正无穷} =[def]= "YV"]


#######
编码扩增有理数{3}:
输入:正负无穷
过程:
  [编码扩增有理数{3}.表达(正负无穷) =[def]= 编码扩增整数{3}.表达(正负无穷)]
输入:有理数
过程:
  #发现 其实有两种不同但都很自然的编码方案{负有理数}:1.直接根据负数的连分数形式编码;2.先转化为 正有理数，编码后取反
  #     这里实现的是 第1种『直接根据负数的连分数形式编码』
  [规范连分数:=连分数表达牜最后部分分母大于等于二(有理数)]
  #bug:[偏置规范连分数:=部分分母减一并且最后一位再减一(规范连分数)]
  [偏置规范连分数:=部分分母统一减一(规范连分数)]
  [填充偏置规范连分数:=追附正无穷(偏置规范连分数)]
  [奇负填充偏置规范连分数:=奇位取负(填充偏置规范连分数)]
  [列表纟编码:=各自编码冫头丶躯奇位丶躯偶位(编码扩增整数{3},(取反<<<编码扩增自然数{32}<<<取负),编码扩增自然数{32};奇负填充偏置规范连分数)]
  [最终编码纟有理数:=串接(列表纟编码)]
  [编码扩增有理数{3}.表达(有理数) =[def]= 最终编码纟有理数]

#######
]]
######################


