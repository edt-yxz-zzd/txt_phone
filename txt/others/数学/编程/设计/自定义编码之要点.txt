
e others/数学/编程/设计/自定义编码之要点.txt
view ../../python3_src/seed/int_tools/digits/codecs4int.py
view ../../python3_src/seed/int_tools/StepDecoder.py

######################
分离式:各层解码后没有残留(即:st.rxdigit8remain.is_null)，后续各层无压缩
  首层不透明的分离式=>分离式是高层的大模样，混淆式只用于首层
  高层的配置 的 具象解码器 有:
    #可并用
    +无穷大+保留区？
    +分离式:首层不透明
      首层 输出 (Either 非终态 终态)
        终态 用于 标示 无穷大,保留区
      * 无符号整数:自然数
        首层 输出 (首层长度,(总后续层数,下一层的长度))
        非首层亦非末层 输出 (下一层的长度)
        非首层的末层 输出 (自然数)
        整体 输出 (各层长度/[uint]{len=1+总后续层数}, 自然数)
      * 带无穷大无符号整数:
        首层 输出 (首层长度,(无穷大|(总后续层数,下一层的长度)))
        整体 输出 (各层长度/[uint]{len=1+总后续层数}, (无穷大|自然数))
    +对称式:负数反转:基数纟宏头胞 折半
      自然数解码器->整数解码器
      非负有理数解码器->有理数解码器
      * 带符号整数:
        整体输出: (符号,输出{无符号整数})
          (0,([首层长度],0))
          (+,([uint],uint)) # 允许:不规范的正零
          (-,([uint],uint)) # 允许:不规范的负零
      * 带无穷大带符号整数:
        ...
######################
#后面是『双字母表假设』
@20250829
多字母表假设:
  #不过，由于 字母表 不相参杂，尾部必有多层完美分离，实际上可以归结为 第零层 双字母表(但输出复杂点而非整数)，后续各层再说
  数据模型:[胞值 == cased_digit :: (case, digit/uint%radix{case})]
  * 末层使用独立字母表:
    至少使用 三套字母表:
        #相当于 前置长度独立编码(头躯双字母表) 再追附末层(又一字母表)
        + 头符字母表
        + 躯符非末层字母表
        + 躯符末层字母表
  * 各层边界分明交错使用不同字母表:
    至少使用 三套字母表:
        + 头符字母表
        + 躯符奇层字母表
        + 躯符偶层字母表
    * 末层使用独立字母表丶各层边界分明交错使用不同字母表:
      至少使用 四套字母表:
        + 头符字母表
        + 躯符非末层奇层字母表
        + 躯符非末层偶层字母表
        + 躯符末层字母表
######################
主要数据存储模型假设:
  存储单元是啥？
      有可能是: [胞]
      有可能是: (头胞,[躯胞])
      有可能是: (不规整胞串冃头部,[躯胞])
      有可能是: (不规整胞串冃头部,[不规整胞串冃躯部周期性子串])
      有可能是: (不规整胞串冃头部,未必整周期[不规整胞串冃躯部周期性子串])
      有可能是: (不固定起始点不规整胞串冃头部,不固定结束点[不规整胞串冃躯部周期性子串])
      有可能是: (未必整胞不固定起始点不规整胞串冃头部,未必整胞不固定结束点[不规整胞串冃躯部周期性子串])
      还有可能更无理:未必整胞不固定起讫点[变胞{radix==f(idx)}]
  但是太麻烦，简化假定模型为:
      [数据存储模型=[def]=(头苞,[躯胞]){[radix{头苞}>=1][radix{躯苞}>=2]}]
          <==>(不规整胞串冃头部{固定起始点},整周期[不规整胞串冃躯部周期性子串])
          [不规整胞串冃头部 统统融入 宏头胞]
          [头苞=[def]=(头胞|宏头胞)]
          [苞=[def]=(头胞|宏头胞|躯胞)]
          [胞=[def]=(头胞|躯胞)]
          [胞 是 具象字母表 的 抽象化]
          [radix{胞{字母表}} == len(字母表)]
          [值{胞} :: uint%radix{胞}]
          [合法码元 是 单个合法值 的 编码结果]
          [合法码串 是 合法值串 的 编码结果]
######################
次级数据存储模型假设:
    [躯胞 是 非凡二幂]
        即 [log2_(radix{躯胞}) :: uint{>=1}]
          [radix{躯胞}==1]就无意义
    这一假设，使得某些编码方案变得更自然，但这里说一下，去掉此假设，如何逼近模拟这些编码方案？
        基础内用编码方案:goto

######################
支持码串词典序&&禁止码元错位交叠:
    #bug:支持词典序&&支持双刹内敛:
    类似utf8
    意图:使得 排序、搜索 可以直接在 符串 这一基层 进行，而非 解码后再行处理，大大简化ls{文件名排序},sort{字节行排序},grep{字节串搜索}这类基础程序的设计
    排序 需要 支持码串词典序
    搜索 需要 禁止码元错位交叠

    [支持码串词典序并禁止码元错位交叠{编码方案} =[简化假设为]= [[支持码元词典序{编码方案}][头躯符集不相交{编码方案}]]]
    <<==:

    [支持词典序，负载值的编码 必然采用 大端序/big_endian]
    [支持词典序，必然采用 长度前置的编码方案，无限长度 导致 长度的编码 本身就是 编码{自然数}，起始最初级的长度编码方案 必然是 类似动态爻元串的编码方案，必然 保证 起点后刹内敛]
        #类似动态爻元串的编码方案:goto

    [支持词典序{编码方案} =[def]= [支持码串词典序{编码方案}]]
    #串-->元:
    [支持词典序{编码方案} =[简化假设为]= [[支持码元词典序{编码方案}][支持起讫点双刹内敛{编码方案}]]]
    #双-->前
    [支持词典序{编码方案} =[简化假设为]= [[支持码元词典序{编码方案}][支持讫点前刹内敛{编码方案}]]]
        # !! 长度前置 => 起点后刹内敛


    [禁止码元错位交叠{编码方案} =[简化假设为]= 支持讫点前刹内敛{编码方案} =[简化假设为]= [头躯符集不相交{编码方案}]]
    [头躯符集不相交{编码方案} =[def]= [编码方案.头符集/-\编码方案.躯符集 == {}]]

    [支持码串词典序并禁止码元错位交叠{编码方案} =[def]= [[支持码串词典序{编码方案}][禁止码元错位交叠{编码方案}]]]
    [支持码串词典序并禁止码元错位交叠{编码方案} =[简化假设为]= [[支持码元词典序{编码方案}][头躯符集不相交{编码方案}]]]

    #起讫:
    [支持起讫点双刹内敛{编码方案} =[def]= [[支持讫点前刹内敛{编码方案}][支持起点后刹内敛{编码方案}]]]
    #间:
    [支持间点双刹内敛{编码方案} =[def]= [[支持间点前刹内敛{编码方案}][支持间点后刹内敛{编码方案}]]]

    #串:
    [支持码串词典序{编码方案} =[def]= [[@值串甲,值串乙:<-编码方案.合法值串集] -> [值串甲 < 值串乙] -> [编码方案.编码(值串甲) < 编码方案.编码(值串乙)]]]
    #元:
    [支持码元词典序{编码方案} =[def]= [[@值甲,值乙:<-编码方案.合法值集] -> [值甲 < 值乙] -> [编码方案.编码(值甲) < 编码方案.编码(值乙)]]]
        #=> 长度前置&&大端序
        #但不完美，因为 某一合法码元 可能是 另一合法码元 的 真前缀、内部真子串、真后缀。
        #依然 无法保证 合法码串 的 次序 同构于 值串 次序
        # 比如: [aA < aAA]但[aAbBB > aAAbBB]


    #讫:前:
    [支持间点前刹内敛{编码方案} =[def]= [定位于合法符串讫点，往前读取，定位于唯一的一个 涉及入口处的合法码元的 起点(假设存在的话)]]
    #起:后:
    [支持间点后刹内敛{编码方案} =[def]= [定位于合法符串起点，往后读取，定位于唯一的一个 涉及入口处的合法码元的 讫点(假设存在的话)]]
    #间:前:
    [支持间点前刹内敛{编码方案} =[def]= [随机定位于符串中间，往前读取，定位于唯一的一个 涉及入口处的合法码元的 起点(假设存在的话)]]
    #间:后:
    [支持间点后刹内敛{编码方案} =[def]= [随机定位于符串中间，往后读取，定位于唯一的一个 涉及入口处的合法码元的 讫点(假设存在的话)]]
        注意:『往前读取』=>『不能往后读』，『长度前置』不能蕴含『间点后刹内敛』，虽蕴含『起点后刹内敛』

######################
有限区、支持无限编码空间、自然数、整数、有理数、支持正负无穷、支持无限保留区、超层无限延展极限胞串:
    [统合码 的 最大毛病 是 编码空间有限]
      !! [人类专业领域不断增加，人类使用的字符 不断新增，不可能假设一个上限{考虑到 字符的废置/死字符，特定领域的活字符 总不会太多，但出于后顾性兼容 以及 包容兼并 各个领域专用字符 的 横向兼容 这两需求，不可能固定上限}]
    必需:支持无限编码空间
    =>必需:支持编码自然数
    =>考虑到完整性及兼容性:支持编码整数
    =>可选项:支持编码有理数
    #######
    如何编码有理数？
      !! 支持码元词典序
      => 采用 连分数 形式
        [int; uint{>=1}...]
        <->
        [int; (uint{>=1}..., uint{>=2})?]
        <->
        [int; (uint{>=1}..., uint{>=2})?, +oo]
        <->偏移:
        #严重错误:『[int; uint..., +oo]』
        #   !! {违反词典序}{没有前置长度的流水样式=>同位次的数的偏移量必须相同}
        #   比如: [3/2==cf[1;2,+oo] < cf[1;1,2,+oo]==5/3]
        #       尾偏移一=>[[1,-1,+oo] < [1,-0,+1,+oo]]
        #       尾偏移二=>[[1,-0,+oo] > [1,-0,+0,+oo]]
        #@20250813:订正:部分分母统一偏移一
        [int; (uint{>=0}..., uint{>=1})?, +oo]
        <->奇位取负:
        ([int; -oo]
        |[int; (nint,uint)*, nint,uint{>=+1}, -oo]
        |[int; (nint,uint)*, nint{<=-1}, +oo]
        )
        => 需要: 支持编码整数&&支持编码正负无穷，即 支持编码扩增整数
          => 顺手:支持编码扩增有理数
    => [编码有理数 归结为 编码扩增整数]
    => [编码扩增整数 可以在 支持编码有理数 的同时 兼容 支持编码扩增有理数]
    => [编码扩增有理数 归结为 编码扩增整数]
    #######
    发现:还有一种有理数的编码方案:无需 扩增 包含 正负无穷
      @20250906
      每个整数追附1爻元 表达是否小数部分非零，或者说 连分数部分分母追附1爻元 表达 是否还有下一个部分分母
        ([int; -oo]
        |[int; (nint,uint)*, nint,uint{>=+1}, -oo]
        |[int; (nint,uint)*, nint{<=-1}, +oo]
        )
        <->:
        ([int{==2*i+0};]
        |[int{==2*i+sgn(i)}; (nint{==2*n-1},uint{==2*u+1})*, nint{==2*n-1},uint{==2*u+0}{>=+2}]
        |[int{==2*i+sgn(i)}; (nint{==2*n-1},uint{==2*u+1})*, nint{==2*n+0}{<=-2}]
        )
          # 不是:int{==2*i+1} #因为不是 连分数 的 整数部分++小数部分，而是 绝对值的整数部分的取反++绝对值的小数部分的取反
        =>:只考虑绝对值(负数则只需将编码取反)
        [前提:[采取对称性编码方案][radix{头苞}%2==1][[radix{头苞}>=3]or[radix{躯胞}%2==1]]]
        ([uint{==2*u+0};]
        |[uint{==2*u+1}; (nint{==2*n-1},uint{==2*u+1})*, nint{==2*n-1},uint{==2*u+0}{>=+2}]
        |[uint{==2*u+1}; (nint{==2*n-1},uint{==2*u+1})*, nint{==2*n+0}{<=-2}]
        )
    #######
    发现 其实有两种不同但都很自然的编码方案{负有理数}:1.直接根据负数的连分数形式编码;2.先转化为 正有理数，编码后取反
        第一种实现简单，但是不具有『相反数的编码是相反的串』这一性质。
            #现代汉语词典:相反数:绝对值相等，正负号相反的两个数互为相反数。如＋5和－5，0的相反数是0。
        第二种有痛点『小于一的正有理数的连分数以无符号零开头』，为了识别负数，负有理数要么统一减一，要么使用『带负号的非规范零』。若是要求『相反数的编码是相反的串』，则 正有理数也要相应地统一加一或使用『带正号的非规范零』
          躯胞规模是二幂=>对称型编码方案{整数/有理数,欤扩增}的宏头胞规模是大于一的奇数,即总字母表规模是(3+2*k+2**e)(任意大于等于五的奇数)
          @20250908:注意:bug警惕:非规范零=>为了确保 词典序，需得确认『编码{规范零}<编码{带正号的非规范零}<编码{规范一}』
    #######
    如何编码扩增整数？
      [radix{头苞}==1]:则融合更多躯胞以令[radix{头苞}>=2]
      [radix{头苞}>=2]:偶则分为非正非负；奇则分为负零正
      [代表正整数的码元 取反，则 得到 代表其负数的码元；『取反』是指 该胞所用字母表的字符大小次序颠倒]
      => [编码扩增负整数 归结为 编码扩增正整数]
      => [编码扩增整数 归结为 编码扩增自然数]
        #注意:这里有一个小优化点:若是 零已被编码(头苞~负零正)，则 自然数.编码.头苞值 可减一，排斥出零值，留下最大值 给 正无穷
    => [编码扩增整数 归结为 编码扩增自然数]
    #######
    如何编码扩增自然数？
      考虑:支持无限保留区，将 首个保留区 划出 最低值 给 正无穷
      考虑:区分 不规整的有限区 与 规整的无限区
          无限区-超大自然数，无需为起步开销操心，所以『规整』
          有限区-小规模自然数，需为优化目标而进行设计规划，所以『不规整』
          ===
          无限区的固定前缀 取决于 有限区的安排
          无限区的固定前缀之后的编码方案固定为:超凡层{支持无限保留区;超层值偏移量,截断动态爻元串后继无限保留区{N}}
          [超凡层=[def]=(超层,多凡层{层数:=超层.值+超层值偏移量;第一层值 编码于b超层结束时产生的首个不完整苞{若是[radix{首个不完整苞}==1][radix{躯胞}>2]则 第一层值:=1}{若是[radix{首个不完整苞}<=2][radix{躯胞}==2]则 第一层值:=2}})]
          ===
          不规整的有限区:虽不规整，但可尝试如下安排:
              #头苞立即数区 只是 下述特例
              将 头苞空间 分成多个分区，对于各个子区:
                  [radix{子区}==1]:则 编码 立即数 或者 使用 特定深入型插件 跳过 旧头苞
                  [radix{子区}>=2]:则 分配一个固定凡层数，采用 多凡层插件{层数:=固定凡层数}
                    #[固定层数==1] => 头苞立即数区
                    #注意:各层可采用线性变换解压，末层只能使用无损压缩(即 仅限于偏移，即 步长固定为一)


    #######
    重要概念:超层无限延展极限胞串{编码方案纟扩增自然数}
    !! 超层 自身就是 自然数的编码方案(允许有损压缩,即 保存阶跃式总凡层数)
    => 超层 可以任意长
    => 总凡层数 趋向于 无穷大 时:整编码的极限胞串 == 超层的极限胞串
    将此胞串命名为『超层无限延展极限胞串』
      注意:此概念 并不依赖于 [躯胞 是 非凡二幂]
    任何合法编码的胞串 与『超层无限延展极限胞串』 比较:
      *小于则是常规编码空间#自然数(含正无穷)的编码
      *大于则是保留区
    若是没有保留区，则『超层无限延展极限胞串』的尾部是:regex"{<max_digit>}*"
    若是采用 内置无限保留区方案(即:截断动态爻元串后继无限保留区)，则『超层无限延展极限胞串』的尾部是:奇长二幂:regex"({<bit_10s>}{<bit_01s>})*";偶长二幂:regex"{<bit_10s>}*|{<bit_01s>}*";
        例如:[躯胞::uint%8]#奇长二幂
          则 『超层无限延展极限胞串』尾部为:regex"({0b101}{0b010})*" 即regex"(52)*"
        例如:[躯胞::uint%16]#偶长二幂
          则 『超层无限延展极限胞串』尾部为:regex"{0b1010}*|{0b0101}*" 即regex"{10}*|5*"
    [超层无限延展极限胞串{编码方案} =[简化假设为]= (不规整前缀纟极限胞串{编码方案} ++ cycle 尾部循环节纟极限胞串{编码方案})]
        #周期性简化假设
    #######
    不太重要概念:多凡层最小值胞串前缀树{编码方案纟扩增自然数}
    不太重要概念:多凡层最大值胞串前缀树{编码方案纟扩增自然数}
    将 有限区 的 编码空间 分为多个 规整有限子区，每个子区存在最小值、最大值
    [最小值胞串{编码方案;规整有限子区} =[def]= 编码方案.编码(最小值{编码方案;规整有限子区})]
    [最大值胞串{编码方案;规整有限子区} =[def]= 编码方案.编码(最大值{编码方案;规整有限子区})]
    #######
    [弃置]不太重要概念:多凡层上尾限胞串前缀树{编码方案纟扩增自然数}
    将 有限区 的 编码空间 分为多个 规整有限子区，每个子区存在最大值，最大值加一就是『上尾限』
        但是 上尾限胞串 并非 上尾限编码，因为它超出了该规整有限子区的定义域(虽然可以使用下一子区(或无限区)的最小值胞串替代，但耦合性弱)
    [上尾限胞串{编码方案;规整有限子区} =[def]= 大于 最大值胞串{编码方案;规整有限子区} 的 最小胞串{词典序}]
    内敛 => [1 <= len(上尾限胞串{编码方案;规整有限子区}) <= len(最大值胞串{编码方案;规整有限子区})]
        虽然 模拟了『超层无限延展极限胞串』，但『上尾限胞串』不是特别通用，比如 没有:无限区、正无穷、保留区 的 自然数.有限区 编码 的 最大值胞串 是 '{<max_digit>}{len}'，由此 得到的 上尾限胞串 不符合内敛要求
    #######
######################
理矩分区:
  * 占用区:
      * 保留区
        * 未来内用保留区
        * 用户自定义区
      * 已定义区
      * 未定义区/内用退化区
  * 禁用区:
<<==:
理矩分区:
  * 占用区:
      虽然上面隐含假设uint%radix是经过挤水压实后的占用区，但是若不如此，则其中可能出现空洞，占用区 需得 显示定义
      * 保留区
        当下占用vs未来使用
        用于未来扩增
        * 未来内用保留区
        * 用户自定义区
      * 已定义区
      * 未定义区/内用退化区
        已定义vs未定义
        有何用处？
          比如:在 退化前缀树 中，要 退化 某些 已定义区{如:特殊值的编码空间}:
              不能退化成 保留区，因为 外部 会观察到 保留区
              所以 只能 退化成 未定义区
  * 禁用区:
      显示占用vs显示禁用
      比如:utf8:头胞禁用0b10ii_iiii，躯胞禁用0b0iii_iiii&0b11ii_iiii，即 头胞 躯胞 互斥
      编码串 取反 时 只考虑 所有 占用区，跳过 禁用区
######################



######################
[[
基础内用编码方案:here
    [内用编码方案 未必 整胞起讫]
目录:
  编码方案{次级数据存储模型假设}:
  编码方案{无:次级数据存储模型假设}:
  阶跃式分阶层:逼近模拟:整除分阶层、稀疏二幂分阶层、稠密二幂分阶层、动态苞元分阶层、强除分阶层、强幂级取分阶层、强幂级进分阶层
    =>支持无限保留区以及正无穷等特殊值的一个比较自然的方案:稠密二幂分阶层{#先减去保留区与特殊值占用的空间，再稠密二幂分阶层#}
  透明数据化硬编码
===
编码方案{次级数据存储模型假设}:
    +定长爻元串{L;欤头苞另计}: regex"{<苞元>}{欤头苞另计}[01]{L}"
    +动态爻元串: regex"1*0"
    +截断动态爻元串{N}: regex"1{0,N-1}0|1{N}"
    +无限保留区甲型: regex"(01)*(00|1)"
    +无限保留区乙型: regex"(10)*(0|11)"
        泛化:完全覆盖型前缀树+自选前缀集冃结束串:view ../../python3_src/seed/int_tools/PrefixDecoder.py
    +[N>=1]截断动态爻元串后继无限保留区甲型{N}: regex"1{0,N-2}0|1{N-1}(01)*(00|1)"
        #相当于 在次大截断动态爻元串之后接上无限保留区甲型 但共享尾0 #次大 以0结尾 此0 共享于周期#周期格 前侵一位
        [N>=1] => 易得
        [N==0] => ???
        ...
        == regex"1{0,N-2}0|1{N-1}00|1{N-1}1|1{N-1}01(01)*(00|1)"
        == regex"1{0,N-2}0|1{N}|(1{N-1}0)0|(1{N-1}0)1(01)*(00|1)"
        == regex"1{0,N-2}0|1{N}|(1{N-1}0)0|(1{N-1}0)(10)*1(00|1)"
        == regex"1{0,N-2}0|1{N}|(1{N-1}0)0|(1{N-1}0)(10)*(100|11)"
        == regex"1{0,N-2}0|1{N}|(1{N-1}0)(10)*(0|11)"
          #相当于 在次大截断动态爻元串之后接上无限保留区乙型
        =>:
        [无限保留区乙型 == 截断动态爻元串后继无限保留区甲型{0}]
          xxx:[无限保留区甲型 == 截断动态爻元串后继无限保留区甲型{0}]
        =>:
        [无限保留区乙型 == 截断动态爻元串后继无限保留区甲型{0}]
        [无限保留区甲型 == 截断动态爻元串后继无限保留区甲型{1}]
        [无限保留区乙型 == 截断动态爻元串后继无限保留区甲型{2}]
    +[N>=0]截断动态爻元串后继无限保留区乙型{N}: regex"1{0,N-1}0|1{N}(10)*(0|11)"
        #相当于 在最大截断动态爻元串之后接上无限保留区乙型 #最大 以1结尾  但 假设最后一位是0
        # 拆出 1周期
        == regex"1{0,N-1}0|1{N}0|1{N}11|1{N}10(10)*(0|11)"
        == regex"1{0,N}0|1{N+1}1|1{N+1}0(10)*(0|11)"
        == regex"1{0,N}0|1{N+1}1|1{N+1}(01)*0(0|11)"
        == regex"1{0,N}0|1{N+1}1|1{N+1}(01)*(00|011)"
        == regex"1{0,N}0|1{N+1}1|1{N+1}(01)*00|1{N+1}(01)*011"
        == regex"1{0,N}0|1{N+1}(01)*00|1{N+1}1|1{N+1}(01)+1"
        == regex"1{0,N}0|1{N+1}(01)*00|1{N+1}(01)*1"
        == regex"1{0,N}0|1{N+1}(01)*(00|1)"
        == 截断动态爻元串后继无限保留区甲型{N+2}
        =>:
        [截断动态爻元串后继无限保留区乙型{N} == 截断动态爻元串后继无限保留区甲型{N+2}]
        =>:
        [无限保留区乙型 == 截断动态爻元串后继无限保留区乙型{0} == 截断动态爻元串后继无限保留区甲型{2}]
        => 甲型表达力更强
    +[N>=0]截断动态爻元串后继无限保留区{N} == 截断动态爻元串后继无限保留区甲型{N+1}: regex"1{0,N-1}0|1{N}(01)*(00|1)"
        #相当于 在最大截断动态爻元串之后接上无限保留区甲型 #最大 以1结尾  不论是否存在 假设最后一位是1
        ==(截断动态爻元串{N},[全一截断]=>无限保留区甲型)
===
编码方案{无:次级数据存储模型假设}:
    #类似动态爻元串的编码方案:here
    #注意:参考一下:『超层无限延展极限胞串』
    +定长苞元串{L;欤头苞另计,头苞偏移量}: regex"{<苞元>}{L+欤头苞另计}"
        #头苞偏移量:用于 大端序 求值时:比如:(+1) => ([0-8][0-9]*) --> ([1-9][0-9]*) #这样一来，头苞值『9』可保留或用作正无穷
    +内置动态苞元串: regex"{<苞.最大值>}*{<苞.非最大值>}"
        求值:=(sum(苞{idx}.最大值 for idx in range(last_idx)) + 苞{last_idx}.非最大值)
    +自定义动态苞元串:
      仔细考察 动态爻元串:每个爻元将编码空间 分割为 两部分，低值部 为 止步区，高值部 为 进步区
        但是:无限保留区甲型 周期性 反转 高低两部 的 行止性
      若是 自动化，可考虑:编码空间的规模 若偶则对半分，若为一则深入换头，若奇则分为相近的奇偶两部，以步进区偏好偶数以及高低两部行止性来判定高低两部奇偶性。
    ... ...
===
阶跃式分阶层:逼近模拟:整除分阶层、稀疏二幂分阶层、稠密二幂分阶层、动态苞元分阶层、强除分阶层、强幂级取分阶层、强幂级进分阶层
  =>支持无限保留区以及正无穷等特殊值的一个比较自然的方案:稠密二幂分阶层{#先减去保留区与特殊值占用的空间，再稠密二幂分阶层#}
#超层、凡层:是苞际分层
#阶层、级层:是苞内分层
#   阶层:阶跃式分阶层
#   级层:比如：二幂时数字共8爻元，取3爻元，则分解为 3爻元+5爻元，3是参数，即 多种阶跃式分阶层，每种称为一级。
#强除:不一定整除
#强幂:不一定完美幂方根
#
[深入指示用值纟苞元{苞元} :: uint{1..<radix}]
[结束指示用值纟苞元{深入指示用值纟苞元;苞元} :: uint{0..<深入指示用值纟苞元{苞元}}]

###
vs:
阶跃式分阶层
[阶层序号讠最大值{深入指示用值纟苞元;苞元} :: 严格递增[uint%radix]]
  #最后 是 (深入指示用值纟苞元{苞元}-1) 不一定是 (radix-1) => 允许 保留区
[阶跃式分阶层{阶层序号讠最大值{深入指示用值纟苞元;苞元}} :: digit/uint%radix -> Either 保留区 (阶层序号,阶层内偏移量)]
###
vs:
整除分阶层
[因子纟基数{深入指示用值纟苞元;苞元} :: uint{[this<-[1..=深入指示用值纟苞元{苞元}]][深入指示用值纟苞元{苞元}%this==0]}]
[整除分阶层{因子纟基数{深入指示用值纟苞元;苞元}} :: digit/uint%radix -> Either 保留区 (阶层序号,阶层内偏移量){==digit/%因子纟基数}]
[阶层序号讠最大值牜整除分阶层{因子纟基数{深入指示用值纟苞元;苞元}} =[def]= [-1+(1+j)*因子纟基数{深入指示用值纟苞元;苞元} for j in range(深入指示用值纟苞元{苞元}///因子纟基数{深入指示用值纟苞元;苞元})]]
###
vs:
稀疏二幂分阶层
[阶层序号讠最大值牜稀疏二幂分阶层{深入指示用值纟苞元;苞元} =[def]= let [bs:=bin(深入指示用值纟苞元{苞元}-1)[2:]][sz:=len(bs)][max_j:=bs.rindex("1")] in (f 0) where [f j := if j==sz then [深入指示用值纟苞元{苞元}-1] else [-1+int(bs[:j+1]+"0"*(sz-(j+1)),2)]++(f (if j==max_j then sz else bs.index("1",j+1)))]]
[稀疏二幂分阶层{深入指示用值纟苞元;苞元} =[def]= 阶跃式分阶层{阶层序号讠最大值牜稀疏二幂分阶层{深入指示用值纟苞元;苞元}}]
###
vs:
稠密二幂分阶层
[阶层序号讠最大值牜稠密二幂分阶层{深入指示用值纟苞元;苞元} =[def]= [*map((-1).__add__, accumulate(f(深入指示用值纟苞元{苞元})))] where [f radix := if radix==1 then [1] else let [half_zpow:=2**(-1+floor_log2(radix))] in ([half_zpow]++f (radix-half_zpow))]]
  # [1 <= half_zpow < 2*half_zpow <= radix]
  # [1 <= half_zpow <= radix-half_zpow < radix]
[稠密二幂分阶层{深入指示用值纟苞元;苞元} =[def]= 阶跃式分阶层{阶层序号讠最大值牜稠密二幂分阶层{深入指示用值纟苞元;苞元}}]
###
vs:
动态苞元分阶层
#甲版定义:动态苞元分阶层
[动态苞元串{深入指示用值纟苞元} =[def]= regex"{<深入指示用值纟苞元{苞元}>}{<结束指示用值纟苞元{深入指示用值纟苞元;苞元}>}"]
[阶层序号讠最大值牜动态苞元分阶层{深入指示用值纟苞元;苞元} =[def]= [深入指示用值纟苞元{苞元}-1]]
  #只有一阶层
[动态苞元分阶层{深入指示用值纟苞元;苞元} =[def]= 阶跃式分阶层{阶层序号讠最大值牜动态苞元分阶层{深入指示用值纟苞元;苞元}}]

#乙版定义:动态苞元分阶层
[因子纟基数牜动态苞元分阶层{深入指示用值纟苞元;苞元} =[def]= 深入指示用值纟苞元{苞元}]
[动态苞元分阶层{深入指示用值纟苞元;苞元} =[def]= 整除分阶层{因子纟基数牜动态苞元分阶层{深入指示用值纟苞元;苞元}}]
###
vs:
强除分阶层
[总阶层数纟基数{深入指示用值纟苞元;苞元} :: uint{[this<-[1..=深入指示用值纟苞元{苞元}]]}]
[最大厚度纟阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}} =[def]= ceil_div(深入指示用值纟苞元{苞元}, 总阶层数纟基数{深入指示用值纟苞元;苞元})]
[最小厚度纟阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}} =[def]= floor_div(深入指示用值纟苞元{苞元}, 总阶层数纟基数{深入指示用值纟苞元;苞元})]
[总厚层数纟基数{总阶层数纟基数{深入指示用值纟苞元;苞元}} =[def]= (深入指示用值纟苞元{苞元} % 总阶层数纟基数{深入指示用值纟苞元;苞元})]
[起点纟薄层{总阶层数纟基数{深入指示用值纟苞元;苞元}} =[def]= (总厚层数纟基数{总阶层数纟基数{深入指示用值纟苞元;苞元}} * 最大厚度纟阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}})]
[阶层序号讠最大值牜强除分阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}} =[def]= [(-1+min(1+j,总厚层数纟基数{总阶层数纟基数{深入指示用值纟苞元;苞元}}) + (1+j)*最小厚度纟阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}}) for j in range(总阶层数纟基数{深入指示用值纟苞元;苞元})]]
    #厚层 集中在 低序号
    #   若要均匀分布，则 (-1+(1+j)*深入指示用值//总阶层数)
[强除分阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}} =[def]= 阶跃式分阶层{阶层序号讠最大值牜强除分阶层{总阶层数纟基数{深入指示用值纟苞元;苞元}}}]
###
vs:
强幂级取分阶层
  #『取』
#级层:比如：二幂时数字共8爻元，取3爻元，则分解为 3爻元+5爻元，3是参数，即 多种阶跃式分阶层，每种称为一级。
#   [2**3 == (2**8)**(3/8)]
#   [总阶层数 == 深入指示用值**(头取级层数/总级层数)]
#   逼近:[总阶层数 ~= 深入指示用值**(头取级层数/总级层数)]
[最大总级层数纟基数{深入指示用值纟苞元;苞元} =[def]= floor_log2(深入指示用值纟苞元{苞元})]
  # >=0 !!
[总级层数纟基数{深入指示用值纟苞元;苞元} :: uint{[this<-[0..=最大总级层数纟基数{深入指示用值纟苞元;苞元}]]}]
  # >=0 !!
  #『级』
[头取级层数纟基数{总级层数纟基数{深入指示用值纟苞元;苞元}} :: uint{[this<-[0..=总级层数纟基数{深入指示用值纟苞元;苞元}]]}]
[总阶层数纟头取级层数{头取级层数纟基数{总级层数纟基数{深入指示用值纟苞元;苞元}}} =[def]= floor_kth_root_(总级层数纟基数{深入指示用值纟苞元;苞元};深入指示用值纟苞元{苞元}**头取级层数纟基数{总级层数纟基数{深入指示用值纟苞元;苞元}})]
  #『阶』
  # >=1
  # [总阶层数纟头取级层数==1] <==> [头取级层数纟基数==0]
  # [总阶层数纟头取级层数>=2] <==> [总级层数纟基数>=头取级层数纟基数>=1]
  #     !! floor_log2
[强幂级取分阶层{头取级层数纟基数{总级层数纟基数{深入指示用值纟苞元;苞元}}} =[def]= 强除分阶层{总阶层数纟头取级层数{头取级层数纟基数{总级层数纟基数{深入指示用值纟苞元;苞元}}}}]
###
vs:
强幂级进分阶层
  #『进』
#比如:二幂情形:起点:[0b0000,0b1000,0b1100,0b1110];末点:[0b0111,0b1011,0b1101,0b1110]
#   起点比较容易看出规律:[2**4-2**(1+j) for j in range(4)[::-1]]
#   =>末点公式:[-1+2**4-2**j for j in range(4)[::-1]]
#   =>逼近:末点公式:[-1+深入指示用值-floor(深入指示用值**(j/总级层数)) for j in range(总级层数)[::-1]]
[阶层序号讠最大值牜强幂级进分阶层{总级层数纟基数{深入指示用值纟苞元;苞元}} =[def]= [-1+深入指示用值纟苞元{苞元}-floor_kth_root_(总级层数纟基数{深入指示用值纟苞元;苞元};深入指示用值纟苞元{苞元}**j) for j in range(总级层数纟基数{深入指示用值纟苞元;苞元})[::-1]]]
[强幂级进分阶层{总级层数纟基数{深入指示用值纟苞元;苞元}} =[def]= 阶跃式分阶层{阶层序号讠最大值牜强幂级进分阶层{总级层数纟基数{深入指示用值纟苞元;苞元}}}]

###
===
透明数据化硬编码:
基数纟宏头胞+基数纟躯胞+区间前缀树+况态化解码器#参数{多凡层|超凡层}
  !! 一统{负数、保留区、未定义区} => 区间 替代 最大值、深入指示用值纟苞元
  !! 多况态 => 解码结果=(况态纟规整子区,负载值)
  !! 包含 未定义区 => 区间紧凑邻接,区间 可用 上尾限纟区间 来表达
[区间前缀树纟况态化解码器参数 =[def]= 非空[(非空区间纟苞元, 负载值纟区间前缀树纟况态化解码器参数)]]
[负载值纟区间前缀树纟况态化解码器参数 =[def]= (区间前缀树纟况态化解码器参数|况态化解码器参数)]
[况态化解码器参数 =[def]= (况态纟规整子区, 参数纟解码器)]
[参数纟解码器 =[def]= (参数纟解码器牜共同,(参数纟解码器牜多凡层|参数纟解码器牜超凡层))]
    #头苞值 根据输入苞串解码自动推导出来
[参数纟解码器牜头苞 =[def]= (带单位长度纟宏头胞,头苞另计,分阶层表纟苞元)]
  #单位=(苞元|苞内级层数)
  #分阶层表:阶跃式分阶层、强幂级进分阶层、...
[参数纟解码器牜多凡层 =[def]= (参数纟解码器牜头苞,总凡层数,凡层序号讠线性变换)]
  #线性变换纟末层 只能是 无损压缩/偏移
[参数纟解码器牜超凡层 =[def]= (颈部纟极限胞串,循环节纟尾部纟极限胞串,分阶层表巛苞元序号纟颈部,分阶层表巛苞元序号纟循环节,偏移量纟超层)]

===
]]

######################
