
e others/数学/编程/设计/自定义编码纟整数暨有理数-alnum字母表+5over8效率.txt
模板:
  view others/数学/编程/设计/自定义编码纟整数暨有理数-byte字母表+7over8效率.txt



[[
@20251104
与之前alnum编码主要不同点是:末爻提示，以使 有理数编码兼容整数编码
===
lexical_ordered_symmetric_encoded_int{alnum36}
lexical_ordered_symmetric_encoded_int{alnum62}
===
]]
[[
lexical_ordered_symmetric_encoded_int{alnum36}
  字母表 分为 36==3+33
    [XYZ] [0-9A-W]
  regex: [33..=35] [0..=32]+
  regex4positive: [34..=35] [0..=32] [0..=31]*
  regex4negative: [33..=34] [0..=32] [1..=32]*

使用 宏头胞: 3*33==99:
  宏头胞=>regex: [0..=98] [0..<32]*
只考虑非负=>regex: [49..=98] [0..<32]*
只考虑非负&&偏移后=>regex: [0..=49] [0..<32]*
  ##################
  1:y++[49] -> +reserved
  1:y++[48] -> +oo
  1:y++[47] -> continue
  ##################
  #47 = 20 + 16 + 2 + 4 + 4 + 1
  ##################
  #注意:宏头胞 2字节
  20:y++[0..<20]: 2byte:[0..<10]+b_fractional # decimal
  16:y++[20..<36]++B:3byte:(4+5-1)bit # byte
      [ceil(8/5) == 2]
      多耗费1字节
  2:y++[36..<38]++BB:4byte:(1+5+5-1)bit # 10bit
  4:y++[38..<42]++BBB:5byte:(2+5+5+5-1)bit # 16bit unicode_BMP
      [ceil(16/5) == 4]
      多耗费1字节
  4:y++[42..<46]++BBBB:6byte:(2+5*4-1)bit # 21bit unicode
      [ceil(21/5) == 5]
      多耗费1字节
  1:y++[46]++[0..<32]{后续字节数{offset:=+5}} ->:
      #注意:宏头胞 2字节
      y 46 {0->5} 5B : 8byte:(00+0+5*5-1)bit # 24bit
      y 46 {1->6} 6B : 9byte:(00+0+5*6-1)bit # 29bit
      y 46 {2->7} 7B : 10byte:(00+0+5*7-1)bit # 34bit
          10byte => 32bit/4byte
          [ceil(32/5) == 7]
          多耗费3字节
      ... ...
      y 46 {8->13} 13B : 16byte:(00+0+5*13-1)bit # 64bit
          16byte => 64bit/8byte
          [ceil(64/5) == 13]
          多耗费3字节
      ... ...
      y 46 {31->36} 36B : 39byte:(00+0+5*36-1)bit # 179bit
  ##################
  #此前:最多39byte，有效179bit
  ##################
  1:y++[47] -> continue
      超凡层:
      方案:y 47 {<凡层数>} 凡层序列/[凡层]{len=凡层数}{num_bytes_of(凡层序列[0])==1}
      ###
      ###
      凡层数 使用 动态胞元累计编码法:
        regex: 16* [0..<16]
        16{n} [0..<16] -> [n*16 ..< (n+1)*16]
        16* [17..=31] -> undefined(???)
          16{n} u@[17..=31] -> undefined(+,47,(16,n),u)
      ###
      ###
      y 47 0 -> non_std(+,0)#非标准,重复值
      y 47 1 B -> 非标准5bit
      y 47 2 sz1@[0..<32] B{sz1} -> 非标准154bit:[0..<2**(00+0+0+5*sz1-1)<=2**154]
        被前面完全涵盖
      y 47 3 sz1@[0..<32] sz2@[0..<32]{sz1} B{sz2} -> 部分非标准[0..<2**(00+0+0+0*sz1+5*(2**155-1)-1)]
        此致足敷实用
      ... ...
      ###
  ##################


]]

]]
[[
lexical_ordered_symmetric_encoded_int{alnum62}
  字母表 分为 62==29+33
    [XYZa-z] [0-9A-W]
  regex: [33..=61] [0..=32]*

只考虑非负=>regex: [47..=61] [0..=32]*
只考虑非负&&偏移后=>regex: [0..=14] [0..=32]*
只考虑非负&&偏移后=>regex: [0..=14] ([0..=32] [0..<32]*)?
{{弃置版:只使用了 [radixB:=32<33]
#:  ##################
#:  # 15 = 4*2 + 1*5 + 1 + 1{continue}
#:  ##################
#:  8:[0..<8]: 1byte:[0..<4]+b_fractional # 2bit => bool
#:  1:[8]++B: 2byte:(0+5-1)bit # 4bit hex
#:  1:[9]++BB: 3byte:(0+5*2-1)bit # 9bit => byte
#:  1:[10]++BBB: 4byte:(0+5*3-1)bit # 14bit
#:  1:[11]++BBBB: 5byte:(0+5*4-1)bit # 19bit => unicode_BMP
#:  1:[12]++BBBBB: 6byte:(0+5*5-1)bit # 24bit => unicode
#:  1:[13]++BBBBBB: 7byte:(0+5*6-1)bit # 29bit
#:  1:[14] -> continue
#:  对比 alnum36 没强到哪里去，只有 高频极小整数 得到优化
#:    alnum36 充分利用了 [radixB:=33]
}}

只考虑非负&&偏移后=>regex: [0..=14] ([0..=32] [0..<32]*)?
  ##################
  # 15 = 4*2 + 7
  ##################
  8:[0..<8]: 1byte:[0..<4]+b_fractional # 2bit => bool
      1byte => bool/1bit
      没有多耗字节      #  相比于alnum36，此处优化
  7:[8..=14]++[0..=32] 组成 子部件.宏头胞
      7*33 == 231
  ##################
  ==>>:
只考虑 子部件:regex: [0..=230] [0..<32]*
  ##################
  1:y++[230] -> +reserved
  1:y++[229] -> +oo
  1:y++[228] -> continue
  ##################
  #228 = 32+16 + 128 + 8 + 44
  ##################
  #注意:宏头胞 2字节
  32:y++[0..<32]: 2byte:[0..<16]+b_fractional # 4bit hex
      [ceil(4/5) == 1]
      多耗费1字节
  16:y++[32..<48]++B:3byte:(4+5-1)bit # byte
      [ceil(8/5) == 2]
      多耗费1字节
  128:y++[48..<176]++BB:4byte:(7+5+5-1)bit # 16bit unicode_BMP
      5byte => 16bit/2byte
      [ceil(16/5) == 4]
      没有多耗字节      #  相比于alnum36，此处优化
  8:y++[176..<184]++BBBB:6byte:(3+5*4-1)bit # 22bit => unicode
      6byte => unicode/21bit
      [ceil(21/5) == 5]
      多耗费1字节

  44:y++[184..<228]{后续字节数{offset:=-184+5}} ->:
      #注意:宏头胞 2字节
      y {184+0->5} 5B : 7byte:(00+5*5-1)bit # 24bit
      y {184+1->6} 6B : 8byte:(00+5*6-1)bit # 29bit
      y {184+2->7} 7B : 9byte:(00+5*7-1)bit # 34bit
          9byte => 32bit/4byte
          [ceil(32/5) == 7]
          多耗费2字节   #  相比于alnum36，此处优化
      ... ...
      y {184+8->13} 13B : 15byte:(00+5*13-1)bit # 64bit
          15byte => 64bit/8byte
          [ceil(64/5) == 13]
          多耗费2字节   #  相比于alnum36，此处优化
      ... ...
      y {227=184+43->48} 48B : 50byte:(00+5*50-1)bit # 249bit
  ##################
  #此前:最多50byte，有效249bit
  ##################
  #与alnum36完全雷同
  1:y++[228] -> continue
      超凡层:
      方案:y 228 {<凡层数>} 凡层序列/[凡层]{len=凡层数}{num_bytes_of(凡层序列[0])==1}
      ###
      ###
      凡层数 使用 动态胞元累计编码法:
        regex: 16* [0..<16]
        16{n} [0..<16] -> [n*16 ..< (n+1)*16]
        16* [17..=31] -> undefined(???)
          16{n} u@[17..=31] -> undefined(+,228,(16,n),u)
      ###
      ###
      y 228 0 -> non_std(+,0)#非标准,重复值
      y 228 1 B -> 非标准5bit
      y 228 2 sz1@[0..<32] B{sz1} -> 非标准154bit:[0..<2**(00+0+0+5*sz1-1)<=2**154]
        被前面完全涵盖
      y 228 3 sz1@[0..<32] sz2@[0..<32]{sz1} B{sz2} -> 部分非标准[0..<2**(00+0+0+0*sz1+5*(2**155-1)-1)]
        此致足敷实用
      ... ...
      ###
  ##################



]]



