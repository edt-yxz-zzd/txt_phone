e others/数学/编程/设计/料符串化框架.txt
view ../../python3_src/seed/recognize/regex/RegexLiteral.py

mv -iv others/数学/编程/设计/词符串化框架.txt others/数学/编程/设计/料符串化框架.txt

更名:忽略件:ignore --> omit 省略件/遗漏件

[[

[料符串化 :: 底本 -> [料符]]
[料符 == (种符,词料,段址)]
[段址 == (起址,讫址)]

LLoo(vivi:LL1:LL(1)--LL(+oo))
  先前瞻路由+再识别
  可考虑:限长后顾:即 保留固定数量的过往已阅数据 用于 后顾型锚件
但 类似 正则表达式 而非 语境无关语法
  禁止 深递归
  允许 尾递归
  不需要:引用式/惰性引用式
但 类似 确定型有限状态机 而非 不定型有限状态机
  禁止 多状态
  只能 单状态

左起识别==>>不论串并，都是右结合(左爆头)

]]

[[
重定义:识别器接口:
  源起:@接力件.传递变量的困难=>最后使用『透明传递』方案，即『共享内存』
  识别器:
    .鬽最大句长 # may_max_len <=> max_oolen
        <<== 限长识器式
    .识别扌(识别器, 全局变量区, 接力变量区, 底本语境, 欤忽略) -> 讫错果
    ===
    !! 欤忽略
    => 严格控制:名集纟输出接力变量/名集纟脱钩接力变量:只能 某些指定的内置必空式 使用:(保存式,注入式,另存式)
    => 依照 关联依赖 推断出 哪些变量 不能忽略，一般来说，但凡 名集纟输出接力变量 非空 的 识器式 不能忽略, 其他 只关注成败，可忽略 成果的求值辻存储
    => xxx ???严格控制:名集纟必需接力变量,只能由 接力式 初始触发
    => 关联依赖 指 『变量 被覆盖/被脱钩 前 是否 有 后续 识器式 必需 该变量』 依赖传递
    ===
    xxx.名集纟输入接力变量
    .名集纟必需接力变量#所有内部隐式依赖(含:显式输入)(用于静态检查)
    .名集纟输出接力变量
    ??? .名集纟脱钩接力变量 #似乎无用
      <==>伪代码:{; 输出=识别<输入>; del 脱钩;}
        修改:接力变量区
        调用时，使用同一个『接力变量区』对象
        返回时，凡是新增变量一律删除，被覆盖的旧变量一律重返，除非特别指明:输出+脱钩
  [欤忽略::bool]
    源起:忽略件(含:锚件)
    深入传递
    但是:优先并联式 等 可能 生成部分成果:况态
  [全局变量区::MapView]
  [接力变量区::DynamicStackedMapping<名,?oresult?>]
      [名::Symbol]
      view ../../python3_src/seed/types/Symbol.py
      view ../../python3_src/seed/types/mapping/DynamicStackedMapping.py
  [底本语境<=>(底本,段址)]
  [讫错果<=>(败况屮成果,讫址)]
  [败况屮成果 <=> (败况丷成果,败况丨成果)]
      [败况屮成果 :: Either 败况 成果]
  汉英对照:
      [识别器 == rgnr] #recognizer
      [讫错果 == rgnrpl]  #reply4recognizer #end_addr-eresult
      [败况 == errmsg] # error-message
      [成果 == oresult] #ok/output-result
      [败况屮成果 == eresult] # either-errmsg-oresult
      [全局变量区 == genv] #global-environment
      [接力变量区 == vctx] #relay-local-variable-context
      [底本语境 == ictx] # background-text-segment/context #input-stream
      [底本 == gtx] # background-text
]]



[[[
一览表:
===
优先并联式
前缀树并联式
贪婪复式
尾限复式
贪婪左递归复式
尾限左递归复式
贪婪右递归复式
尾限右递归复式

条件式
道岔式

取一式
串联式#输出定长
接力式
??? 新建接力变量对象式
    似乎可被取代为:接力式+保存式
保存式
注入式
另存式
??? 清理式/脱钩式
    似乎无用

#串部件:
员件
透明判我件
前瞻型驻件
  =>前瞻型锚件
后顾型驻件
  =>后顾型锚件
忽略件
步入件

??? 孤取件
  只是py表达式临时用
  非:串部件

标签载入式  # <: 必空式
匹配常量式
再贴标签式

更况式
更料式

]]]

<<==:

[[
路由:先前瞻判定+再识别
  #参见:条件式,道岔式
  优先并联式:优先识别前式:当作二元操作符时左操作数不能是优先并联式(右结合型二元操作符)
  前缀树并联式:见下面『前缀树』
  <>复式:
    贪婪复式:优先识别体式，所以没有尾限
      body*
    尾限复式:优先识别尾部
      body*? end
    左递归复式:vs复式:主要是后处理方式不同:
        源起:左结合二元操作符
        postprocess(oresult4base, oresult4body)
          vs: postprocess(oresult4base, ls4oresult4body)
        贪婪左递归复式:
          base body*
            atom_expr ("." "name")*
            atom_expr ("[" ... "]")*
            atom_expr ("(" ... ")")*
        尾限左递归复式:
          base body*? end
    右递归复式:vs复式:主要是后处理方式不同:
        源起:右结合二元操作符
        postprocess(oresult4body, oresult4base)
          vs: postprocess(ls4oresult4body, oresult4base)
        贪婪右递归复式:
          body* base
            (expr "**")* expr
            => 需要缓存 或者 直接:
              [假设:[右式<:左式]] => 右结合二元操作符式(左式, 中式, 右式)
                优先并联式([右式,左式])
                  *右式: 尝试匹配 中式+右式,成功则 原右式 当作 左式
                  *左式: 匹配 中式+右式
        尾限右递归复式:
          body* base
]]



[[
串联:用例:
  头颈体尾式:
    <==>取一式(忽略件(头式),前瞻型锚件(颈式),^判定是我^,孤取件(体式),忽略件(尾式))
    *头体尾式:头用于前瞻判定(但不一定是锚式)，掐头去尾，体果
      <==>取一式(忽略件(头式),^判定是我^,孤取件(体式),忽略件(尾式))
        #取一式(而非 幺元元组)
    *锚体式:锚判定(即头部)，与『头体尾式』区别在于:使用『锚式』
      <==>取一式(前瞻型锚件(头式),^判定是我^,孤取件(体式))
    *原子式:前瞻判定即识别
      取一式(孤取件(体式),^判定是我^)
  变量接力式:见下面:接力式
]]
==>>:
[[
串联:基础:
  取一式(取左丷取右,吾左丷吾右;左式,右式)
  串联式(吾左丷吾右;左件,右件)
  接力式(名序列纟输入接力变量,构造器纟识别器)
  ??? 新建接力变量对象式(名纟输出接力变量,构造器纟接力变量对象)
    似乎可被取代为:接力式+保存式
  保存式(名纟输出接力变量,识器式)
  注入式(名序列纟输出接力变量,名纟输入接力变量)
  另存式(长名纟输出接力变量,长名纟输入接力变量)
  ??? 清理式/脱钩式(名集纟脱钩接力变量)
    似乎无用
  <<==:
  *取一式:多个串联部分，只取一瓢
      取一式(取左丷取右,吾左丷吾右;左式,右式)
      <<==:
      *取一式(忽略件(头式),判我型锚件,体式,忽略件(尾式))
      *取一式(忽略件(头式),体式,判我型锚件,忽略件(尾式))
      *取一式(判我型锚件,忽略件(头式),体式,忽略件(尾式))
      *取一式(忽略件(头式),体式,忽略件(尾式),判我型锚件)
      *取一式(忽略件(头式),透明判我件(体式),忽略件(尾式))
      *取一式((透明判我件&忽略件)(头式),体式,忽略件(尾式))
      *取一式(忽略件(头式),体式,(透明判我件&忽略件)(尾式))
      ==>>:精简版:
      *取一式((透明判我件&忽略件)(头式),孤取件(体式))
      *取一式(孤取件(体式),(透明判我件&忽略件)(尾式))
      *取一式(忽略件(头式),(透明判我件&孤取件)(体式))
      ==>>:再精简版:
      取一式(取左丷取右,吾左丷吾右;左式,右式)
  *串联式:输出:输出定长:reiterable#Rope而非seq#但repr时简并为类似数组表达
      串联式+庸复式:输出定长
      诡复式:输出不定长
      串联式(吾左丷吾右;左件,右件)
      <<==:
      *串联式(吾左丷吾右;串部件(左式),串部件(右式))
        串部件:=
          *员件
          *透明判我件
          *驻件#(前瞻型驻件|后顾型驻件)
            => *锚件#(前瞻型锚件|后顾型锚件)
          *忽略件
          *步入件#[入式纟步入件==定长元组式]
          注意: 孤取件 导致 取一式 不是 串部件...
  xxx *接力式:
  xxx     接力式(吾左丷吾右;头式,接力件)
  xxx       接力件==(体式构造器)
  见:重定义:识别器接口
  接力式(名序列纟输入接力变量,构造器纟识别器)
  ??? 新建接力变量对象式(名纟输出接力变量,构造器纟接力变量对象)
    似乎可被取代为:接力式+保存式
  保存式(名纟输出接力变量,识器式)
  注入式(名序列纟输出接力变量,名纟输入接力变量)
  另存式(长名纟输出接力变量,长名纟输入接力变量)
    [长名==(名|长名.名|长名[址])]
      看来 左递归 是 常见且自然的
      难怪 多用 LR1
      右递归=>名(『.名』|『[址]』)*
      view others/数学/编程/设计/语法升级序列.txt
        爆头拟树
        证明:[语法变换:左递归讠右递归:必然可以实现]
  ??? 清理式/脱钩式(名集纟脱钩接力变量)
    似乎无用
    release
]]



xxx接力件:
  xxx [接力件==识器式构造器 :: 输入 -> 识器式]
  xxx 脱钩件(识器式)
  xxx *分配件:
  xxx     *分配件(吾左丷吾右,串联丷并联;接力左件,接力右件)
  xxx *配额件:
  xxx     *配额件(吾左丷吾右,串联丷并联;接力左件,接力右件)
  xxx       [输入<配额件> :: Pair]
  ...是个大坑...不太行...
  见:重定义:识别器接口

[[
接力式:特殊化:
  条件式(识器式@成败/保存式,识器式@成/接力式,识器式@败)
  道岔式(彧鬽名纟输出接力变量,识器式@况化值,况态讠接力式)
    道岔式/路由式
    #彧:emay:...|obj
    #鬽:may:None|obj
    鬽--> 不保存:况化值.负载值
    彧--> 仅有 况态 而非 况化值
    [况化值 :: Cased 况态 负载值]
    ###[况态讠接力式 :: {况态:接力式}]
    [况态讠接力式 :: {况态:识器式}]
]]
[[
串部件:
  *员件:只是简单封装 识器式
  *透明判我件:用于生成判定信号给串联式，是额外标志位，可与其余串部件叠加
    *[唯一]判我型锚件:无输入式，无果，驻留原地，用于生成判定信号给串联式
      <==>(透明判我件&忽略件)(必空式)
      [标签载入式 <: 必空式]
  #驻件
  *前瞻型驻件:有果，禁止反转成败，驻留原地
  *后顾型驻件:有果，禁止反转成败，驻留原地
      #锚件
      *前瞻型锚件:无果，允许反转成败，驻留原地
        <==>忽略件+前瞻型驻件
      *后顾型锚件:无果，允许反转成败，驻留原地#限长后顾#缓存长度<<==全局静态限长!
        <==>忽略件+后顾型驻件
  *忽略件:无果，前进
  xxx拆包件:就地拆包
  *步入件/遍历拆包件:[允许多重累叠]只在遍历元素时类同拆包:__iter__:禁用__getitem__但可提供它名访问方法:输入不能是任意表达式:
        [入式纟步入件==定长元组式==(串联式|庸复式|并联<各分支等长:定长元组式>|取一式<定长元组式>)]
]]
[[

更况式/更种式/更名式/冠名式:更改种符,更改况态
  更况式(况态,识器式)
更料式/求值式:更改词料,更改况化值的负载值
  更料式(料值,识器式)
  #更料式(料值/负载值纟况化值,识器式)
  #vs:变果式@oresult
  #vs:更况式@oresult.case@[oresult::Cased]
  #vs:更料式@oresult.payload@[oresult::Cased]


常量:
  标签载入式(标签/立即数)#必空式#立即数
  匹配常量式(种符串)
  再贴标签式(标签,识器式)
对象:
  ??? 新建接力变量对象式(名纟输出接力变量,构造器纟接力变量对象)
    似乎可被取代为:接力式+保存式


]]
[[

#前缀树:见:e ../../python3_src/seed/seq_tools/mk_prefix_tree.py

]]
[[
@py:
左起识别==>>不论串并，都是右结合(左爆头)
  py左结合二元操作符:只有『**』『-if-else-』
  py一元操作符:
    前缀操作符:只有『+』『-』『~』
    后缀操作符:只有『x[...]』『x(...)』『x.aaa』
  或许:
    ===
    并右件.__rpow__(识器式)
      『+识器式』-->并右件
      [优先并联式<:并右件]
      『识器式**+识器式』-->优先并联式
      『识器式**优先并联式』-->优先并联式
    ===
    xxx串部件.__pow__(串部件)
    串部件.__getitem__(tuple<(...|串部件)>)
      『...』代表self
      『左件[...,右件]』-->串联式(吾左丷吾右:=False;左件,右件)
      『右件[左件,...]』-->串联式(吾左丷吾右:=True;左件,右件)
      『识器式.I』-->串部件/员件
      『限长识器式.BI』-->串部件/后顾型驻件
      『识器式.FI』-->串部件/前瞻型驻件
      『限长识器式.BD』-->串部件/后顾型锚件
      『识器式.FD』-->串部件/前瞻型锚件
      『识器式.D』-->串部件/忽略件
      『识器式.G』-->串部件/步入件
      #只有:G,H特殊对待:
      # G:标志位:可自我累叠:
      # H:标志位:可尾附他件:
      『步入件.G』-->串部件/步入件
      『串部件.H』-->串部件/透明判我件
    ===
    孤取件.__getitem__(slice<(None|...|识器式)>)
      『...』代表self
      『识器式.O』-->孤取件
      『左式[...:右式]』-->取一式(取左丷取右:=False,吾左丷吾右:=False;左式,右式)
      『左式[...::右式]』-->取一式(取左丷取右:=False,吾左丷吾右:=True;左式,右式)
      『右式[左式:...]』-->取一式(取左丷取右:=True,吾左丷吾右:=False;左式,右式)
      『右式[左式::...]』-->取一式(取左丷取右:=True,吾左丷吾右:=True;左式,右式)
    ===
  <<==:
  view /sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-text/reference/expressions.txt
    6.17. Operator precedence
]]
