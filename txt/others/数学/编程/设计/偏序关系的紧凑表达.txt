
e others/数学/编程/设计/偏序关系的紧凑表达.txt
失败！
<<==:
  [失败根源:goto]
  [失败反例:goto]
    ##发散思考:特定偏序关系存在于最少几维空间？(以坐标代表元素)
    #       N元素 => [该维数<=N]


######################
唯一性标准表达纟偏序关系-感觉有点难，估计跟DAG标准表达一样难
  #DAG同构与简单无向图同构一样难
但是 紧凑表达纟偏序关系 还是很容易的
  失败！


######################
N节点简单有向图的数量: ==2**(N*N-N)
   !! N*N矩阵{[元素::爻元][对角元素全零]}
=> 简单有向图不可能有O(N)紧凑表达

######################
N节点简单无向图的数量: ==2**((N*N-N)/2)
   !! N*N对称矩阵{[元素::爻元][对角元素全零]}
=> 简单无向图不可能有O(N)紧凑表达

######################
N元素偏序关系的数量: > 2**(N/2)**2
  !! 平分成源墟两队
=> 偏序关系不可能有O(N)紧凑表达
  [失败根源:here]

# 偏序关系 相当于 使用 传递性 填充后的DAG
!! [偏序关系 <: DAG == 简单有向无环图]
=> DAG不可能有O(N)紧凑表达

######################




######################
失败:紧凑表达纟偏序关系:
  N元素偏序关系
  (~<~)代表偏序关系
  元素用(uint%N)再命名
  [紧凑表达{N元素偏序关系} =[def]= (重命名双射,新名串)]
  [重命名双射 :: [元素]{len==N}{排列{元素}}]
  [新名串 :: [uint%N]{len==N}{排列{uint%N}}]
  约束:
  #非必要:[@[i,j::uint%N] -> [重命名双射[i] ~<~ 重命名双射[j]] -> [i < j]]
  [@[i,j::uint%N] -> [[重命名双射[新名串[i]] ~<~ 重命名双射[新名串[j]]] <-> [[新名串[i] < 新名串[j]][i < j]]]]
  #注意:重命名双射 并非 任意 拓扑排序
  # 反例: 偏序关系{0~<~1~<~3,0~<~2},重命名双射:=恒等双射==>>新名串 不存在
  #     证明:
  #         新名串必含子串:[0,1,3],[0,2]
  #         共三个候选:
  #             * [0,2,1,3](多了[2~<~3])
  #             * [0,1,2,3](多了[1~<~2][2~<~3])
  #             * [0,1,3,2](多了[1~<~2])
  #注意:同理 新名串 并非 任意 拓扑排序
  #
######################
失败:存在性证明-构造性证明:
反例:
  [失败反例:here]
  发觉其实相当于:
    每个元素对应于平面坐标系第一象限中的一个点(x,y)
    这种简单结构，绝不可能表达复杂的偏序关系
    ##发散思考:特定偏序关系存在于最少几维空间？(以坐标代表元素)
    #       N元素 => [该维数<=N]
  构造反例如下:
    6元素:{a,b,c,AB,BC,CA}
    偏序关系:{a~<~AB,b~<~AB,a~<~CA,c~<~CA,b~<~BC,c~<~BC}
    不失一般性，可假设:
      a ~ (3,1)
      b ~ (2,2)
      c ~ (1,3)
    不失一般性，可进一步假设:
      AB ~ (3.5,2.5)
      BC ~ (2.5,3.5)
      CA ~ (3.1,3.1)
        CA 必然 涵盖 b
        即 多了[b~<~CA]

失败:
#.def 低效构造冫紧凑表达纟偏序关系扌(plt_, N, xs, /):
#.    '(x->x->bool){==(~<~)} -> N/uint -> {x}{len==N} -> 紧凑表达{N元素偏序关系}'
#.    ys = 构造冫任意拓扑排序扌(plt_, N, xs)
#.      #新名串 的 元素版
#.    y2j = {}
#.    j2y = []
#.      #重命名双射 的 初胚
#.    重命名双射 = 乸双射()
#.    新名串 = []
#.    for k in range(N):
#.      y = ys[k]
#.      xs = [x for x in ys[:k] if plt_(z,y)]
#.      zs = [z for z in ys[:k] if not plt_(z,y)]
#.      j = k-len(zs)+y2min_j[y]
#.      y2j[y] = j
#.      TODO...
#.      失败！
######################
