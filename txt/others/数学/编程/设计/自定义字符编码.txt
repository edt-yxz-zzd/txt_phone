
e others/数学/编程/设计/自定义字符编码.txt
  --> e others/数学/编程/永恒代码/自定义字符编码.txt
view others/数学/编程/永恒代码/反双缀符串.txt

TODO:goto

[[
目录:

摘要:goto

[:章节冫部分命名规范]:goto
[:章节冫使用情景纟编码]:goto

[:def__ui1323]:goto
  ui1323_vs_utf8:goto
  [:统合码变长编码]:goto
    [:编码字节串长度差异出现处的字符与中文无关]:goto

[:章节冫支持字符串词典序]:goto
  [:def__utf85pp]:goto
  [:def__utf86mm]:goto

  [:def__ui1229_szd24_86mm]:goto
  [:def__ui2219_szd24_87mm]:goto
  [:def__si2219_szd23_87mm]:goto

  [:def__ui1229_dybl_86mm]:goto
  [:def__ui2219_dybl_87mm]:goto
  [:def__si2219_dybl_87mm]:goto

  [:def__si_36alnum_dybl_85mm]:goto

  [:def__si_base89_nat_dybl_86mm]:goto
  [:def__si_base89_bbu_dybl_86mm]:goto
  [:def__ui_base89_nat_dybl_86mm]:goto
  [:def__ui_base89_bbu_dybl_86mm]:goto

===
]]
[[
摘要:
===
ui1323
  兼容ASCII但不兼容utf8的编码方案{不支持词典序}
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索}
  --字节串词典序

===
支持字符串词典序:即:字符串词典序 等价于 被编码的自然数的大小次序
  utf85pp
    兼容utf8的扩展方案{支持词典序}
    极限效率略高于5/8
    动态零结尾位串
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
  utf86mm
    兼容utf8的扩展方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  ui1229_szd24_86mm
    兼容ASCII但不兼容utf8的编码方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
  ui2219_szd24_87mm #类似于:ui1229_szd24_86mm
    不兼容ASCII的编码方案{支持词典序}
    极限效率略低于7/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
  si2219_szd23_87mm #类似于:ui2219_szd24_87mm
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于7/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  ui1229_dybl_86mm # 精简自ui1229_szd24_86mm
    兼容ASCII但不兼容utf8的编码方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
  ui2219_dybl_87mm # 精简自ui2219_szd24_87mm
    不兼容ASCII的编码方案{支持词典序}
    极限效率略低于7/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
  si2219_dybl_87mm # 精简自si2219_szd23_87mm,类同于『ui2219_dybl_87mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于7/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  si_36alnum_dybl_85mm # 类同于『si2219_dybl_87mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于5/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  si_base89_nat_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  si_base89_bbu_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  ui_base89_nat_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

  ui_base89_bbu_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

===
]]


[[
[:章节冫部分命名规范]:here
************
部分命名规范:
  ui:unsigned integer
  si:signed integer
  szd:sized
  dybl:number of dynamic bits be num_layers
  pp:plus-plus #C++
  mm:minus-minus #C--
  87:(7/8)
  86:(6/8)
  36alnum:明码表36字符:数字字母
  base89:明码表89字符
  nat:自然版/天然版
  bbu:特化版:bit,byte,unicode (2,256,0x11_00_00)

************
部分命名规范:
  [[
  regex"ui\d\d\d\d"
  胞串模式 = (孤胞 | 头胞 体胞* 尾胞)
  4个数字分别代表相应胞型的前冠位串长度:
      孤胞/孤立胞
      头胞
      体胞
      尾胞
      9 - 不存在
      [0-8] - 前冠位串长度
  为了 满足『支持词典序』的可能性需求(暂不考虑负载值为负整数的情景):
    最低要求:
        [:定义冫支持词典序的最宽松前缀模式乊自然数乊有头有尾]:here
          [孤胞值 < 头胞值][尾胞值 < 体胞值]
    最高要求:
        [孤胞值 < {头胞值,尾胞值} < 体胞值]
          # [:定义冫支持词典序的最严格前缀模式乊自然数]:here

    [:定义冫支持词典序的前缀模式乊自然数乊有头无尾]:here
        [孤胞值 < 头胞值 < 体胞值]
    注意: [:定义冫支持词典序的前缀模式乊整数乊有头无尾]:here
        非负整数:[孤胞值 < 头胞值 < 体胞值]
          100x < 101x < 11xx
        非正整数:[孤胞值 > 头胞值 > 体胞值]
          011x > 010x > 00xx
        [非正整数.孤胞值 < 非负整数.孤胞值]
          011x < 100x
        ===
        整数:[负.体胞值 < 负.头胞值 < 负.孤胞值 < 正.孤胞值 < 正.头胞值 < 正.体胞值]
          [00xx < 010x < 011x < 100x < 101x < 11xx]
          [通用情形=>绝对值相同的整数刚好互为反码(区分:同时含:+0,-0)]
          !!!体胞 前缀 2位，相当于 将 正负符号 硬编码 到 体胞!!!
        ===
        特殊情形:分级前置长度
          例如:si2219_szd23_87mm
          相同前缀 => 体胞 只能与体胞 比较
          因此 只需要比较:[孤胞值 <?> 头胞值]
          体胞:1xxx # 比 11xx/00xx 节省1位
            =>孤胞值,头胞值:0xxx:
          整数:[负.头胞值 < 负.孤胞值 < 正.孤胞值 < 正.头胞值]
          [000x < 001x < 010x < 011x]
          [特殊情形{分级前置长度}=>绝对值相同的整数除了各胞首位刚好互为反码(区分:同时含:+0,-0)]



    <<==:
    相同前缀 况态:
      * 相同前缀<...(头胞|体胞)> ++ (体胞|(尾胞? ++ (孤胞|(头胞? ++ 体胞))))
      * 相同前缀<...(尾胞|孤胞)> ++ (孤胞|(头胞? ++ 体胞? ++ 尾胞))

    有:头胞&有:尾胞=>:相同前缀 况态:
        * 相同前缀<...(头胞|体胞)> ++ (体胞|尾胞)
        * 相同前缀<...(尾胞|孤胞)> ++ (孤胞|头胞)
        ==>>:
        [尾胞值 < 体胞值]
        [孤胞值 < 头胞值]

    有:头胞&无:尾胞=>:相同前缀 况态:
        * 相同前缀<...(头胞|体胞)> ++ (体胞|孤胞|头胞)
        * 相同前缀<...(尾胞|孤胞)> ++ (孤胞|头胞)
        ==>>:
        [孤胞值 < 头胞值 < 体胞值]

    无:头胞&有:尾胞=>:相同前缀 况态:
        * 相同前缀<...(头胞|体胞)> ++ (体胞|尾胞)
        * 相同前缀<...(尾胞|孤胞)> ++ (孤胞|体胞|尾胞)
        ==>>:
        [孤胞值 < 尾胞值 < 体胞值]

    无:头胞&无:尾胞=>:相同前缀 况态:
        * 相同前缀<...(头胞|体胞)> ++ (体胞|孤胞)
        * 相同前缀<...(尾胞|孤胞)> ++ (孤胞|体胞)
        ==>>:
        [孤胞值 < 体胞值]


    最低要求:
        [尾胞值 < 体胞值]
        [孤胞值 < 头胞值]
    最高要求:
        [孤胞值 < {头胞值,尾胞值} < 体胞值]
        <<==:
        [头胞值 < 体胞值]
          <<== 9119 断尾型:
          [(相同前缀 ++ 头胞 ++ ...) < (相同前缀 ++ 体胞 ++ ...)]

        [孤胞值 < 尾胞值]
          <<== 9911 断头型:
          [(相同前缀 ++ 尾胞 ++ ...) < (相同前缀 ++ 孤胞 ++ ...)]

        [尾胞值 <?> 头胞值]
          这种比较，于 相同前缀 之后 是不可能存在的
          不可能有:[(相同前缀 ++ 尾胞 ++ ...) <?> (相同前缀 ++ 头胞 ++ ...)]

  !! [孤胞值 < {头胞值,尾胞值} < 体胞值]
  ==>>:
  例如:ui1999==ASCII:
    0xxx_xxxx
  例如:ui1323:
    * 0xxx_xxxx
    * (101x_xxxx 11xx_xxxx* 100x_xxxx)
  例如:ui9119:
    (0xxx_xxxx 1xxx_xxxx* <null>)
  例如:ui9911:
    (<null> 1xxx_xxxx* 0xxx_xxxx)
      动态字节
  ===
  但是:分级前置长度 由于 相同前缀 下 体胞 只能与 体胞 比较，所以 前缀模式 更自由，并非一定如上所示
  例如:ui1229_dybl_86mm
    * 0xxx_xxxx
    * (11xx_xxxx, 10xx_xxxx* <null>)
    而ui1229本该为:
      * 0xxx_xxxx
      * (10xx_xxxx, 11xx_xxxx* <null>)
  ]]

  ===
]]

[[
[:章节冫使用情景纟编码]:here
[动态字节=[def]= regex"a*b"]

===
使用情景纟编码
  * 受控范围内随机落点同步对齐到胞串边界
    ok:动态字节,utf8
  * 左起识别单整数，讫址不受限=>后刹/后端内敛
    ok:动态字节,utf8
  * 右起识别单整数，起址不受限=>前刹/前端内敛
    ok:utf8
    fail:动态字节
  * 受控范围内字节串搜索:
    ok:utf8
    fail:动态字节
    规避:
      * ?前符后缀与后符前缀交叠?
      * 内包含
      * 真前缀
      * 真后缀
          fail:动态字节 #仅败于此
            除非 使用正则表达式的锚式确认边界
  * 字节串排序(字节串词典序 体现 整数大小)
    ok:utf8
        <==> 赖前庸复式/(长度,庸复式/数组)
    fail:动态字节

==>> 需求:{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
]]





[[[
[:def__ui1323]:here
  兼容ASCII但不兼容utf8的编码方案{不支持词典序}
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索}
  --字节串词典序

ui1323_vs_utf8
  注意:ui1323不支持字符串词典序
谓之『自定义字符编码』实则『自定义自然数编码』
===

用于『永恒代码』
采用简单的字节串模式:
  自然数字节串编码方案{反双缀牜首尾特立牜字节高位标志位串区分}:
    :1_323:uint_codec__anti_bifix__msb_1_323:ui1323
    regex"[\x00-\x7F]|[\xA0-\xBF][\xC0-\xFF]*[\x80-\x9F]"
      0b0iii_iiii: [\x00-\x7F]
      0b100i_iiii: [\x80-\x9F]
      0b101i_iiii: [\xA0-\xBF]
      0b11ii_iiii: [\xC0-\xFF]
      [[
      设计方案决策缘起:
        1. 兼容ascii
            =>标志位『0』代表『结束』
            =>标志位『1』代表『待续』
        2. 侧重提高空间利用率
            =>〖体字节纟多字节编码〗使用更短标志位串，即2位
            =>〖起字节纟多字节编码〗使用更长标志位串，即3位
            =>〖讫字节纟多字节编码〗使用更长标志位串，即3位
            !!标志位『1』代表『待续』
            =>标志位串『11』代表『多字节编码继续』即〖体字节纟多字节编码〗
            !!标志位『0』代表『结束』
            =>标志位串『100』代表『多字节编码结束』即〖讫字节纟多字节编码〗
            =>标志位串『101』代表『多字节编码开始』即〖起字节纟多字节编码〗
        3. 错开utf8多字节编码
          utf8起字节: regex"[^\x80-\xBF]"
          上面的方案刚好满足
        4. 刚好满足:支持词典序的最严格前缀模式:
          [孤胞值 < {头胞值,尾胞值} < 体胞值]
            # [:定义冫支持词典序的最严格前缀模式乊自然数]:goto
        5. 但，还不够好，见下面:支持字符串词典序:goto
      ]]

===
ui1323_vs_utf8
  注意:ui1323不支持字符串词典序
  ===
  * utf8编码21位的整数(0x11_0000)需要4字节
      # [(8-3)*4+1==5*4+1==21]
      # [[num_bytes>=2] -> [num_bits4utf8(num_bytes) == num_bytes*5+1]]
  * ui1323编码21位的整数(0x11_0000)需要4字节
      # [((8-3)+(8-2)*(4-2)+(8-3))==(5+6*2+5)==22 > 21]
      # [[num_bytes>=2] -> [num_bits4ui1323(num_bytes) == num_bytes*6-2]]
  ===
  * 单字节:ui1323-7bit == utf8-7bit
  * 双字节:ui1323-10bit < utf8-11bit
  * 三字节:ui1323-16bit == utf8-16bit
  * 四字节:ui1323-22bit > utf8-21bit
  ===
  11bit:0b0000_01ii_iiii_iiii
    编码字节串长度差异出现在:[\u0400-\u07FF]:共4*256==1024个字符
  ===
  ui1323 vs utf8:半斤八两，都是空间利用率偏低{主要是兼容ascii造成的}
    对于编码中文相关字符而言，两者的空间需求应该是相同的。
    ascii之后，中文相关字符基本在u2000诸后，至少14bit，编码后至少三字节
    『　』u3000
    『一』u4E00
    见下面:编码字节串长度差异出现处的字符与中文无关:goto
===
]]]
==>>:
[[[
[:章节冫支持字符串词典序]:here
支持字符串词典序
===
utf8之所以前冠长度，是为了 支持字符串词典序
  上面的ui1323只 支持随机同步+支持字节串搜索，并不 支持字符串词典序
===
看起来:utf16并不 支持词典序
  Surrogates Area: U+D800..U+DFFF
  TODO:扩展utf8+utf16 突破21位
  *utf16 高位换码符 其他保留符 低位换码符
  *DONE:兼容utf8方案:utf85pp,utf86mm
  *DONE:类似utf8方案 但 首载长 为 2位:ui1229_szd24_86mm
===
bug:[[支持字符串词典序] -> [支持任意长度的编码后字节串] -> [必须采用前冠动态长度标志位方案{但该长度可自定立意，只需保持词典序}]]
[[支持字符串词典序] -> [支持任意长度的编码后字节串] -> [简洁假设:每次读取指定位数的片段数据，片段数据的保存也依位数] -> [可采用(序列纟等长长度信息,负载)形式:(欤本级为末级,位数纟本级)必须由前面的状态导出(不能于本级内动态确定，否则 要么 非词典序，要么 可以转化为 前述规范型)]]

==>>:逐步推进型编码方案:
[引领函数 :: 前置状态<n级> -> 参数<n级>]
[前置状态<0级> <==> ()]
[前置状态<n+1级> <==> (前置状态<n级>, 负载值<n级>) <==> (负载值<0级>, 负载值<1级>, ..., 负载值<n级>)]
[参数<n级> == (欤末级<n级>, 位数<n级>)]


!! 逐步推进型编码方案 必然 后刹
=> 双端内敛 还欠 前刹
!! [头符集/-\体符集=={}] ==>> 非后缀&前刹
[头符集/-\体符集=={}] ==>> 非后缀&双端内敛


逐步推进型编码方案 于小规模数据 可以人工微调，而于大整型则进入自动生成模式
逐步推进型编码方案-->逐步推进分级前置长度型编码方案
    『尾递归式逐层累计总层数』不太行，有点难保证 词典序，总层数 应该及早确定。
      可采用『中间递归式逐层累计总层数』
      ok:深入符{k:=.len} 负载{.len:=k} 负载纟自然数
      bad:(深入符 负载)* 负载纟自然数
      [重复常量计数法 =[def]= 诡复式<常量>]
      不是不可避免，但也差不多同理
      比如: 0级溢出值 1级溢出值 ...
        虽然 各级溢出值 逐级增大，但 它们都是常量 只是不同而已

    支持词典序=>:
      负载值较大的分支 应当 编码 比 较小分支 所能表达的最大整数 更大的整数。(如若不然，要么 报错，要么 当作 超符/带外数据/非目标整数)
      除了未定义的扩展分支(最大一部分 负载值)，只能允许一个无限编码空间的分支(次大负载值)，其余更小分支 只能编码有限空间，以防 违反词典序。
        #上述是 限定于 自然数 的推论
        #若是 整数，正负双向，可以有 两个无限空间的分支
        #若是 字符串，就更不必说，无限个无限空间的分支

  * 0级编码空间 是固定的
  * 首先，我们可以分配部分空间给 被编码的自然数:若不溢出，则直接硬编码在0级空间
  * 其次，假设 自然数溢出，我们可以分配部分空间给 总层数、1级负载长度:若不溢出，则 直接硬编码在0级空间
  * 最后，假设 总层数 溢出，假设此时 自然数 十分巨大，因此可以 采用动态枚举方式/重复常量计数法，显式列出 总层数，而 1级负载长度 采用 唯一指定值(硬编码)
自动生成模式:[假设 当前级别的负载区块已经出了首胞][假设 诸后所有级别的负载区块都占满尾胞]:
  bug:
  xxx:合理的设计方案是:
  xxx:  [[[自动生成模式:n][n级 末级]] -> [[负载位串<n级> == 负载值<n级> == 被编码的自然数]]]
  xxx:  [[[自动生成模式:n][n级 非末级]] -> [[负载位串<n级> == 欤非次末级++负载值<n级>][负载值<n级> == 胞数<n+1级>]]]
  xxx:    支持词典序=>:
  xxx:      欤非次末级 必须是 首位
  xxx:      [欤非次末级==0] 表示 下一级 是 末级
  xxx:      欤非次末级 而非是 欤次末级 #0,1 大小关系
===


===
[[支持字符串词典序] -> [兼容ascii] -> [不支持负整数编码]]
!! [[兼容ascii] -> [不兼容ascii的 允许不同位长储胞的 编码方案 可由 8位储胞方案 转为 7位储胞方案，即可兼容ASCII]]
=> [下面考虑 编码方案模板，因此不考虑兼容ASCII]


[[支持字符串词典序] -> [采用:大端序]]

xxx:!! [[支持字符串词典序] -> [支持负整数编码] -> [只需将 整个胞串的首位 当作 正负符号]]
!! [[支持字符串词典序] -> [支持负整数编码] -> [任何 负载值 之前 增加1位 正负符号，并且 负数情形下 任何 负载值 改为 反码存储]]
  正负号:负号必须是0，正号为1
  负数的绝对值以限长反码存储
    负数相关的所有前置负载长度以限长反码存储
=> [下面考虑 编码方案模板，因此不考虑 负整数编码]


===
自然数编码方案模板牜支持字符串词典序{况态前缀,储胞位长} ::= 况态前缀 + 自然数编码{储胞位长-bit_len(况态前缀)%储胞位长,储胞位长}
况态前缀 是 常量位串，用于 区别 其他编码分区空间
  要求:况态前缀集合 也 支持字符串词典序 并且 内敛/自束/自刹
  比如:兼容ASCII => [况态前缀[0]==1][储胞位长<=7]
  比如:支持负整数编码 => [况态前缀[-1]==0/负号|1/正号][储胞位长<=7]
  比如:无用{因为已自刹，只需ui1229前冠模式}:采用ui1323的起讫模式，则前冠更加复杂
    101xxx 11xxxx* 100xxx
    101     ==>> 胞内偏移量纟首胞==1
    11      ==>> 储胞位长==6
    100     ==>> 胞内偏移量纟尾胞==1
    考虑到: 区号位串纟子分区 长度至少1
      #因为兼容ASCII而无正负号
    首胞至少被消耗4位
    [首负载长度==首载长巛区号(区号)==2+区号 if 区号==0 else 区号]
      [区号==0]=>双字节:[0..<2**(8*2-4-3)==2**9==512]
      [区号==1]=>
        首负载值:1+[0..<8]==[1..=8]
        -->:人工微调:
        首负载值:2+[0..<8]==[2..=9]
        总共:3-10字节，
自然数编码{胞内偏移量纟首胞,储胞位长,胞内偏移量纟尾胞} := 区号位串纟子分区 负载位串纟子分区


[[
级别递降: 刚好与前述相反。为一致故，冠以『ddd:』以警醒
ddd:类似utf8的方案:
ddd:    区号位串纟子分区 是 零结尾位串
ddd:    区号位串纟子分区 := 1*{区号}0
ddd:      [0 <= 区号 == -1+bit_len(区号位串纟子分区)]
ddd:    [总负载长度:=总编码长度-bit_len(况态前缀+区号位串纟子分区-1)%储胞位长]
ddd:      即:含 区号位串纟子分区 的 尾胞，不论该尾胞是否已耗尽所有编码位
ddd:
ddd:    直接编码首负载长度:
ddd:      [首负载长度==首载长巛区号(区号)]
ddd:      * [首负载长度==区号+1]
ddd:      * [首负载长度==a*区号+b]
ddd:      * [首负载长度==f(区号)]
ddd:      => 首负载             # 位串 或 尾胞剩余位串+后续胞串
ddd:      => 首负载 的 负载值   # 大端序 <<== 词典序
ddd:    * 方案一:直接编码长度
ddd:      [总负载长度==首负载长度]
ddd:
ddd:    * 方案二:编码多级长度
ddd:      [被编码的自然数 == 0级负载长度]
ddd:      * [区号==0]:
ddd:        [0级负载长度 == 0 + 首负载 的 负载值]
ddd:          #若是正整数编码方案，则『1+』而非『0+』
ddd:      * [区号==1]:
ddd:        [1级负载长度 == 1 + 首负载 的 负载值]
ddd:          #『1+』避免零长度为
ddd:        [0级负载长度 == 0 + 1级负载 的 后继负载{长度==1级负载长度} 的 负载值]
ddd:      * [区号==2]:
ddd:        [2级负载长度 == 1 + 首负载 的 负载值]
ddd:        [1级负载长度 == 1 + 2级负载 的 后继负载{长度==2级负载长度} 的 负载值]
ddd:        [0级负载长度 == 0 + 1级负载 的 后继负载{长度==1级负载长度} 的 负载值]
ddd:      ...
ddd:      * [区号==...]:
ddd:        ...
ddd:#end-类似utf8的方案
]]



===
[[
兼容utf8的扩展方案{支持词典序}:
  * utf85pp #极限效率略高于5/8:动态零结尾位串
  * utf86mm #极限效率略低于6/8:分级前置长度#逐步推进分级前置长度型编码方案
===
[:def__utf85pp]:here
utf85pp
  兼容utf8的扩展方案{支持词典序}
  极限效率略高于5/8
  动态零结尾位串
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

;0xxx_xxxx;
  1字节
  num_bytes = 1
  num_payload_bits = 7bit
;11 1{len1=0..=5} 0 [01]{.len=5-len1}, 10xx_xxxx{.len=len1+1};
  2~7字节
  num_bytes = (len1+2)
  num_payload_bits = (5-len1)+(len1+1)*6 = len1*5+11 == num_bytes*5+1
  至此，已然兼容utf8
;1111_1111, 1011_1111{len6}, 10 1{len1=0..=5} 0 [01]{.len=5-len1}, 10xx_xxxx{.len=6+len6*6+len1+1-(1+len6)=(1+len6)*5+len1+1=(len6*5+len1+6)};
  >=8字节
  num_bytes = 1+len6+1+(len6*5+len1+6) = (len6*6+len1+8)
  num_payload_bits = (5-len1)+(len6*5+len1+6)*6 = len6*30+len1*5+41 == num_bytes*5+1

==>>:
utf85pp:[num_payload_bits == num_bytes*5+1 if num_bytes > 1 else 7]

===
[:def__utf86mm]:here
utf86mm
  兼容utf8的扩展方案{支持词典序}
  极限效率略低于6/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

;0xxx_xxxx;
  1字节
  num_bytes = 1
  num_payload_bits = 7bit
  硬编码:自然数 于 0级负载
;11 1{len1=0..=2} 0 [01]{.len=5-len1}, 10xx_xxxx{.len=len1+1};
  2~4字节
  num_bytes = (len1+2)
  num_payload_bits = (5-len1)+(len1+1)*6 = len1*5+11 == num_bytes*5+1
  至此，已然兼容utf8
  硬编码:总层数==2 # 1==末级序数
  硬编码:1级负载长度 于 0级负载
  硬编码:部分自然数 于 0级负载
  编码:部分自然数 于 1级负载
;1111 10yy, 10xx_xxxx{.len=1+yy}, 10xx_xxxx{.len=1+layer1_payload};
  ######################
  ######################
  ####?TODO:改为:5-8字节 <= (8-1)*6==42bit ~ 5B没啥卵用
  ####?????:改为:5-10字节 <= (10-1)*6==54bit ~ 6B没啥卵用
  ####?????:改为:5-11字节 <= (11-1)*6==60bit ~ 7B没啥卵用
  ####  64bit 至少占用 10胞+4bit==11胞-2bit
  ####      而utf8导致头5bit占用，额外消耗(5-2)=3bit，兼容utf8则 64bit整型 至少占用 67bit==11胞+1bit==12胞-5bit
  ####      6/8编码效率低下，多一字节关系不大
  ######################
  ######################
  # [胞数<0级> == 1]
  # [胞数<1级> <- [1..=4]]
  # [胞数<2级> <- [1..=2**24]]
  3~(2**24+5)字节 #16MB
  # yy = layer0_payload
  num_bytes = (3+yy+layer1_payload)
  num_payload_bits = 6*(1+layer1_payload)
  硬编码:总层数==3 # 2==末级序数
  硬编码:1级负载长度 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:自然数 于 2级负载
;1111 1100, 10xx_xxxx{1}, 10xx_xxxx{.len=1+layer1_payload}, 10xx_xxxx{.len=1+layer2_payload};
  # [胞数<0级> == 1]
  # [胞数<1级> == 1]
  # [胞数<2级> <- [1..=64]]
  # [胞数<3级> <- [1..=2**384]]
  4~(2**384+66)字节 #(2**344)TB
  num_bytes = (4+layer1_payload+layer2_payload)
  num_payload_bits = 6*(1+layer2_payload)
  硬编码:总层数==4 # 3==末级序数
  硬编码:1级负载长度(==1) 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  编码:自然数 于 3级负载
  ===
  末级序数.硬编码值=0,1,2,3
  末级序数.最大硬编码值=3
  总层数.最大硬编码值=4
;1111 1101, 1011_1111{m1}, 10 1{n1} 0 0{5-n1}, 10xx_xxxx{1}, 10xx_xxxx{.len=1+layer1_payload}, 10xx_xxxx{.len=1+layer2_payload}, ...10xx_xxxx{.len=1+layer<m1*6+n1+2(#ge1#)>_payload};
  软编码:总层数==(m1*6+n1+4) # (m1*6+n1+3)==末级序数>=3
  # [胞数<0级> == 1]
  # [胞数<0级.后附软编码层> == m1+1]
  # [胞数<1级> == 1]
  # [胞数<2级> <- [1..=64]]
  # [胞数<3级> <- [1..=2**384]]
  ...
  4~+oo字节
  num_bytes = (4+7*m1+n1+layer1_payload+layer2_payload+...)
  num_payload_bits = 6*(1+layer<m1*6+n1+2>_payload)
  软编码:总层数==(m1*6+n1+4) # (m1*6+n1+3)==末级序数>=3
  硬编码:1级负载长度(==1) 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (m1*6+n1+2)级负载
  ===
;1111 111x 未定义，保留作为扩展


==>>:
utf86mm:[limit num_payload_bits/(num_bytes*8) --> 6/8 -0.000...]

===
]]
[[
[:def__ui1229_szd24_86mm]:here
ui1229_szd24_86mm
  兼容ASCII但不兼容utf8的编码方案{支持词典序}
  极限效率略低于6/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

; 0xxx_xxxx
# 11xx_xxxx 10xx_xxxx*
; 11yy_zzzz 10xx_xxxx{1+zzzz} 10xx_xxxx*
  [yy =!= 3]

  [总层数 == 2+yy]
  [layer0_payload == zzzz]

  [yy =!= 3]
  [yy <- [0,1,2]]
  [总层数 <- [2,3,4]]
  # [胞数<0级> == 1]
  # [胞数<1级> == [1..=2**4=16]]
  # optional:[胞数<2级> <- [1..=2**96]]
  # optional:[胞数<3级> <- [1..=2**(6*2**96)]]
  2~(2**(6*2**96)+2**96+17)字节
  num_bytes = (2+layer0_payload+?(1+layer1_payload)+?(1+layer2_payload))
  * num_payload_bits = 6*(1+layer1_payload)
  * num_payload_bits = 6*(1+layer2_payload)
  * num_payload_bits = 6*(1+layer3_payload)
  硬编码:总层数 <- [2,3,4] # 3>=末级序数
  硬编码:1级负载长度 于 0级负载
  ?编码:2级负载长度 于 1级负载
  ?编码:3级负载长度 于 2级负载
  * 编码:自然数 于 1级负载
  * 编码:自然数 于 2级负载
  * 编码:自然数 于 3级负载
  ===
# 1111_0zzz ...
; (1111 0 1{k1} 0 0{2-k1} | 1111_0111, 1011_1111{m1}, 10 1{n1} 0 0{5-n1}), 10xx_xxxx{1}, 10xx_xxxx{.len=1+layer1_payload}, 10xx_xxxx{.len=1+layer2_payload}, ...10xx_xxxx{.len=1+layer<(k1+2 | m1*6+n1+5)(#ge1#)>_payload};
  软编码:总层数==(k1+4 | m1*6+n1+7) # (k1+3 | m1*6+n1+6)==末级序数>=3
  # [胞数<0级> == 1]
  # [胞数<0级.后附软编码层> == (0 | m1+1)]
  # [胞数<1级> == 1]
  # [胞数<2级> <- [1..=2**6=64]]
  # [胞数<3级> <- [1..=2**384]]
  ...
  4~+oo字节
  num_bytes = (4+(k1 | m1*7+n1+4)+layer1_payload+layer2_payload+...)
  num_payload_bits = 6*(1+layer<(k1+2 | m1*6+n1+5)>_payload)
  软编码:总层数==(k1+4 | m1*6+n1+7) # (k1+3 | m1*6+n1+6)==末级序数>=3
  硬编码:1级负载长度(==1) 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (k1+3 | m1*6+n1+6)级负载
  ===
; 1111_1xxx ... 未定义，保留作为扩展

==>>:
ui1229_szd24_86mm:[limit num_payload_bits/(num_bytes*8) --> 6/8 -0.000...]

===
]]
=>>:
[[
#ui9119_szd25_87mm --> ui2219_szd24_87mm
#   !! ++添加单字节支持:00xx_xxxx
[:def__ui2219_szd24_87mm]:here
  #『szd24』 <<== 『01yy_zzzz』

ui2219_szd24_87mm #类似于:ui1229_szd24_86mm
  不兼容ASCII的编码方案{支持词典序}
  极限效率略低于7/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

# 0xxx_xxxx 1xxx_xxxx*




===
; 00xx_xxxx
  1字节
  硬编码:总层数 = 1; 0==末级序数
  硬编码:自然数 于 0级负载
  自然数集:[0..=63]
# 01xx_xxxx 1xxx_xxxx*
; [yy =!= 3] => 01yy_zzzz 1xxx_xxxx{1+zzzz} 1xxx_xxxx*
  [总层数 == 2+yy]
  [layer0_payload == zzzz]

  [yy =!= 3]
  [yy <- [0,1,2]]
  [总层数 <- [2,3,4]]
  # [胞数<0级> == 1]
  # [胞数<1级> == [1..=2**4=16]]
  # optional:[胞数<2级> <- [1..=2**(16*7)=2**112]]
  # optional:[胞数<3级> <- [1..=2**(7*2**112)]]
  2~(2**(7*2**112)+2**112+17)字节
  num_bytes = (2+layer0_payload+?(1+layer1_payload)+?(1+layer2_payload))
  * num_payload_bits = 7*(1+layer1_payload)
  * num_payload_bits = 7*(1+layer2_payload)
  * num_payload_bits = 7*(1+layer3_payload)
  硬编码:总层数 <- [2,3,4] # 3>=末级序数
  硬编码:1级负载长度 于 0级负载
  ?编码:2级负载长度 于 1级负载
  ?编码:3级负载长度 于 2级负载
  * 编码:自然数 于 1级负载
  * 编码:自然数 于 2级负载
  * 编码:自然数 于 3级负载
  ===
# 0111_0zzz ... 1xxx_xxxx*
; (0111_0 1{k1} 0 0{2-k1} | 0111_0111, 1111_1111{m1}, 1 1{n1} 0 0{6-n1}), 1xxx_xxxx{1}, 1xxx_xxxx{.len=1+layer1_payload}, 1xxx_xxxx{.len=1+layer2_payload}, ...1xxx_xxxx{.len=1+layer<(k1+2 | m1*7+n1+5)(#ge1#)>_payload};
  软编码:总层数==(k1+4 | m1*7+n1+7) # (k1+3 | m1*7+n1+6)==末级序数>=3
  # [胞数<0级> == 1]
  # [胞数<0级.后附软编码层> == (0 | m1+1)]
  # [胞数<1级> == 1]
  # [胞数<2级> <- [1..=2**7=128]]
  # [胞数<3级> <- [1..=2**(128*7)=2**896]]
  ...
  4~+oo字节
  num_bytes
    = (1+(0 | m1+1)+1+(1+layer1_payload)+...+(1+layer<(k1+2 | m1*7+n1+5)>_payload))
    = (2++(0 | m1+1)+(k1+2 | m1*7+n1+5)+(layer1_payload+layer2_payload+...+layer<(k1+2 | m1*7+n1+5)>_payload))
    = (2+(k1+2 | m1*8+n1+6)+(layer1_payload+layer2_payload+...+layer<(k1+2 | m1*7+n1+5)>_payload))
    = (4+(k1 | m1*8+n1+4)+(layer1_payload+layer2_payload+...+layer<(k1+2 | m1*7+n1+5)>_payload))
  num_payload_bits = 7*(1+layer<(k1+2 | m1*7+n1+5)>_payload)
  软编码:总层数==(k1+4 | m1*7+n1+7) # (k1+3 | m1*7+n1+6)==末级序数>=3
  硬编码:1级负载长度(==1) 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (k1+3 | m1*7+n1+6)级负载
  ===
; 0111_1xxx  1xxx_xxxx* 未定义，保留作为扩展

==>>:
ui2219_szd24_87mm:[limit num_payload_bits/(num_bytes*8) --> 7/8 -0.000...]

===
]]

[[
[:def__si2219_szd23_87mm]:here
  #『szd23』 2y+3z<<== 『aaay_yzzz』011y_yzzz
  ######################
  # 注意:『si2219』不同于『ui2219』头胞次位前缀退1位，让位给正负符号:『01xx_xxxx』-->『0s1x_xxxx』[s:=欤非负]:先 编码 绝对值，[s:=1];接着，若负数，则各胞 除了首位 取反。(区分:同时含:+0,-0)
  ######################
  # 注意:『si2219』不同于『ui2219』:见上面: [:定义冫支持词典序的前缀模式乊整数乊有头无尾]:goto
      体胞:1xxx =>孤胞值,头胞值:0xxx:
        整数:[负.头胞值 < 负.孤胞值 < 正.孤胞值 < 正.头胞值]
        [000x < 001x < 010x < 011x]

        [特殊情形{分级前置长度}=>绝对值相同的整数除了各胞首位刚好互为反码(区分:同时含:+0,-0)]
  ######################
DONE:++si2219_szd23_87mm:负数支持 #不可能 [兼容ASCII 同时 支持词典序+支持负整数]#注意:长度也要取反
===
si2219_szd23_87mm #类似于:ui2219_szd24_87mm
  不兼容ASCII的编码方案{支持词典序}{支持负整数}
  极限效率略低于7/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
===
实现:『si2219』类同于『ui2219』:
  头胞次位前缀退1位，让位给正负符号:『01xx_xxxx』-->『0s1x_xxxx』[s:=欤非负]
  先 编码 绝对值，[s:=1]
  接着，若负数，则各胞 除了首位 取反。(区分:同时含:+0,-0)

!! [编码扌(非正整数) == 取反冫各胞首位扌(取反扌(编码扌(非负整数)))]
下面只考虑:非负整数的编码:
===
# 0xxx_xxxx 1xxx_xxxx*




===
; 010x_xxxx
  1字节
  硬编码:总层数 = 1; 0==末级序数
  硬编码:自然数 于 0级负载
  自然数集:[0..=31]
# 011x_xxxx 1xxx_xxxx*
; [yy =!= 3] => 011y_yzzz 1xxx_xxxx{1+zzz} 1xxx_xxxx*
  [总层数 == 2+yy]
  [layer0_payload == zzz]

  [yy =!= 3]
  [yy <- [0,1,2]]
  [总层数 <- [2,3,4]]
  # [胞数<0级> == 1]
  # [胞数<1级> == [1..=2**3=8]]
  # optional:[胞数<2级> <- [1..=2**(8*7)=2**56]]
  # optional:[胞数<3级> <- [1..=2**(7*2**56)]]
  2~(2**(7*2**56)+2**56+9)字节
  num_bytes = (2+layer0_payload+?(1+layer1_payload)+?(1+layer2_payload))
  * num_payload_bits = 7*(1+layer1_payload)
  * num_payload_bits = 7*(1+layer2_payload)
  * num_payload_bits = 7*(1+layer3_payload)
  硬编码:总层数 <- [2,3,4] # 3>=末级序数
  硬编码:1级负载长度 于 0级负载
  ?编码:2级负载长度 于 1级负载
  ?编码:3级负载长度 于 2级负载
  * 编码:自然数 于 1级负载
  * 编码:自然数 于 2级负载
  * 编码:自然数 于 3级负载
  ===
# 0111_10zz ... 1xxx_xxxx*
; (0111_10 1{k1} 0 0{1-k1} | 0111_1011, 1111_1111{m1}, 1 1{n1} 0 0{6-n1}), 1xxx_xxxx{1}, 1xxx_xxxx{.len=1+layer1_payload}, 1xxx_xxxx{.len=1+layer2_payload}, ...1xxx_xxxx{.len=1+layer<(k1+2 | m1*7+n1+4)(#ge1#)>_payload};
  软编码:总层数==(k1+4 | m1*7+n1+6) # (k1+3 | m1*7+n1+5)==末级序数>=3
  # [胞数<0级> == 1]
  # [胞数<0级.后附软编码层> == (0 | m1+1)]
  # [胞数<1级> == 1]
  # [胞数<2级> <- [1..=2**7=128]]
  # [胞数<3级> <- [1..=2**(128*7)=2**896]]
  ...
  4~+oo字节
  num_bytes
    = (1+(0 | m1+1)+1+(1+layer1_payload)+...+(1+layer<(k1+2 | m1*7+n1+4)>_payload))
    = (2++(0 | m1+1)+(k1+2 | m1*7+n1+4)+(layer1_payload+layer2_payload+...+layer<(k1+2 | m1*7+n1+4)>_payload))
    = (2+(k1+2 | m1*8+n1+5)+(layer1_payload+layer2_payload+...+layer<(k1+2 | m1*7+n1+4)>_payload))
    = (4+(k1 | m1*8+n1+3)+(layer1_payload+layer2_payload+...+layer<(k1+2 | m1*7+n1+4)>_payload))
  num_payload_bits = 7*(1+layer<(k1+2 | m1*7+n1+4)>_payload)
  软编码:总层数==(k1+4 | m1*7+n1+6) # (k1+3 | m1*7+n1+5)==末级序数>=3
  硬编码:1级负载长度(==1) 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (k1+3 | m1*7+n1+5)级负载
  ===
; 0111_11xx  1xxx_xxxx* 未定义，保留作为扩展
!! [编码扌(非正整数) == 取反冫各胞首位扌(取反扌(编码扌(非负整数)))]
; 0000_00xx  1xxx_xxxx* 未定义，保留作为扩展

==>>:
si2219_szd23_87mm:[limit num_payload_bits/(num_bytes*8) --> 7/8 -0.000...]

===
]]

szd24有点难看难记，应该精简之:
  [:def__ui1229_szd24_86mm]:goto
  [:def__ui2219_szd24_87mm]:goto
  [:def__si2219_szd23_87mm]:goto
  ui1229_szd24_86mm
  ui2219_szd24_87mm
  si2219_szd23_87mm
  -->:
  ui1229_dybl_86mm
  ui2219_dybl_87mm
  si2219_dybl_87mm
    szd:sized
    dybl:number of dynamic bits be num_layers

[[
[:def__ui1229_dybl_86mm]:here
ui1229_dybl_86mm # 精简自ui1229_szd24_86mm
  兼容ASCII但不兼容utf8的编码方案{支持词典序}
  极限效率略低于6/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

===
; 0xxx_xxxx;
  1字节
  [0..=127]

===
# 110x_xxxx, 10xx_xxxx*
; 110 1{p1} 0 z{.len=((-4-p1)%8)}, 10xx_xxxx{.len=1+z=1+layer0_payload}, 10xx_xxxx{.len=1+layer1_payload}, 10xx_xxxx{.len=1+layer2_payload}, ...10xx_xxxx{.len=1+layer<p1(#ge0#)>_payload};
  软编码:总层数==(p1+2) # (p1+1)==末级序数>=1
  # [胞数<前置软编码层++0级> == (p1+4+7)//8 = (1+(p1+3)//8)]
  #     [位数<0级> == ((-4-p1)%8)bit] #不完整字节:0~7bit
  # [胞数<1级> == 1+z <- [1..=2**7=128]]
  # optional:[胞数<2级> <- [1..=2**(128*6)=2**768]]
  ...
  2~+oo字节
  num_bytes
    = ((1+(p1+3)//8)+(1+layer0_payload)+(1+layer1_payload)+...+(1+layer<p1>_payload))
    = ((p1+2+(p1+3)//8)+(layer0_payload+layer1_payload+layer2_payload+...+layer<p1>_payload))
  num_payload_bits = 6*(1+layer<p1>_payload)
  软编码:总层数==(p1+2) # (p1+1)==末级序数>=1
  编码:1级负载长度 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (p1+1)级负载

===
; 111x_xxxx, 10xx_xxxx* : 未定义，保留作为扩展

===
]]
[[
[:def__ui2219_dybl_87mm]:here
ui2219_dybl_87mm # 精简自ui2219_szd24_87mm
  不兼容ASCII的编码方案{支持词典序}
  极限效率略低于7/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

===
; 00xx_xxxx;
  1字节
  [0..=63]

===
# 010x_xxxx, 1xxx_xxxx*
; 010 1{p1} 0 z{.len=((-4-p1)%8)}, 1xxx_xxxx{.len=1+z=1+layer0_payload}, 1xxx_xxxx{.len=1+layer1_payload}, 1xxx_xxxx{.len=1+layer2_payload}, ...1xxx_xxxx{.len=1+layer<p1(#ge0#)>_payload};
  软编码:总层数==(p1+2) # (p1+1)==末级序数>=1
  # [胞数<前置软编码层++0级> == (p1+4+7)//8 = (1+(p1+3)//8)]
  #     [位数<0级> == ((-4-p1)%8)bit] #不完整字节:0~7bit
  # [胞数<1级> == 1+z <- [1..=2**7=128]]
  # optional:[胞数<2级> <- [1..=2**(128*7)=2**896]]
  ...
  2~+oo字节
  num_bytes
    = ((1+(p1+3)//8)+(1+layer0_payload)+(1+layer1_payload)+...+(1+layer<p1>_payload))
    = ((p1+2+(p1+3)//8)+(layer0_payload+layer1_payload+layer2_payload+...+layer<p1>_payload))
  num_payload_bits = 7*(1+layer<p1>_payload)
  软编码:总层数==(p1+2) # (p1+1)==末级序数>=1
  编码:1级负载长度 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (p1+1)级负载

===
; 011x_xxxx, 1xxx_xxxx* : 未定义，保留作为扩展

===
]]
[[
[:def__si2219_dybl_87mm]:here
si2219_dybl_87mm # 精简自si2219_szd23_87mm,类同于『ui2219_dybl_87mm』
  不兼容ASCII的编码方案{支持词典序}{支持负整数}
  极限效率略低于7/8
  分级前置长度#逐步推进分级前置长度型编码方案
  ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
===
实现:『si2219』类同于『ui2219』:
  头胞次位前缀退1位，让位给正负符号:『01xx_xxxx』-->『0s1x_xxxx』[s:=欤非负]
  先 编码 绝对值，[s:=1]
  接着，若负数，则各胞 除了首位 取反。(区分:同时含:+0,-0)

!! [编码扌(非正整数) == 取反冫各胞首位扌(取反扌(编码扌(非负整数)))]
下面只考虑:非负整数的编码:
===
# 0xxx_xxxx 1xxx_xxxx*




===
; 010x_xxxx;
  1字节
  [0..=31]

===
# 0110_xxxx, 1xxx_xxxx*
; 0110 1{p1} 0 z{.len=((-5-p1)%8)}, 1xxx_xxxx{.len=1+z=1+layer0_payload}, 1xxx_xxxx{.len=1+layer1_payload}, 1xxx_xxxx{.len=1+layer2_payload}, ...1xxx_xxxx{.len=1+layer<p1(#ge0#)>_payload};
  软编码:总层数==(p1+2) # (p1+1)==末级序数>=1
  # [胞数<前置软编码层++0级> == (p1+5+7)//8 = (1+(p1+4)//8)]
  #     [位数<0级> == ((-5-p1)%8)bit] #不完整字节:0~7bit
  # [胞数<1级> == 1+z <- [1..=2**7=128]]
  # optional:[胞数<2级> <- [1..=2**(128*7)=2**896]]
  ...
  2~+oo字节
  num_bytes
    = ((1+(p1+4)//8)+(1+layer0_payload)+(1+layer1_payload)+...+(1+layer<p1>_payload))
    = ((p1+2+(p1+4)//8)+(layer0_payload+layer1_payload+layer2_payload+...+layer<p1>_payload))
  num_payload_bits = 7*(1+layer<p1>_payload)
  软编码:总层数==(p1+2) # (p1+1)==末级序数>=1
  编码:1级负载长度 于 0级负载
  编码:2级负载长度 于 1级负载
  编码:3级负载长度 于 2级负载
  ...
  编码:自然数 于 (p1+1)级负载

===
; 0111_xxxx, 1xxx_xxxx* : 未定义，保留作为扩展

!! [编码扌(非正整数) == 取反冫各胞首位扌(取反扌(编码扌(非负整数)))]
; 0000_xxxx, 1xxx_xxxx* : 未定义，保留作为扩展

===
]]




===
===
===
]]]






[[
[:统合码变长编码]:here
[统合码变长编码=[def]=utf8]
看看utf8都有啥:
view ../lots/NOTE/unicode/UTF-utf8.txt
utf8:
  0b 0xxx_xxxx
  0b 110x_xxxx 10xx_xxxx
  0b 1110_xxxx 10xx_xxxx 10xx_xxxx
  0b 1111_0xxx 10xx_xxxx 10xx_xxxx 10xx_xxxx
  起始字节不能是 0b 10xx_xxxx
    即不能是 0x8?, 0x9?, 0xA?, 0xB?
]]
[[
用C语言实现utf8<->ui1323
用C语言实现utf8<->uint32_t<->ui1323

enum Utf8_Decoding_Case__As_Ui1323 {utf8_decoding_ok, utf8_code_incomplete, utf8_code_error, ui1323_code_buffer_no_enough};
struct Utf8_Decoding_Info__As_Ui1323 {
    const byte* ihalt;
    byte* ohalt;
    size_t num_decoded_chars;
    enum Utf8_Decoding_Case__As_Ui1323 case;
};

bool utf8_to_ui1323(size_t max1_num_decoded_chars, const byte* ibegin, const byte* iend, byte* obegin, byte* oend, struct Utf8_Decoding_Info__As_Ui1323* output_info);
    -> ok
    [[max1_num_decoded_chars=!=0] -> [output_info.num_decoded_chars < max1_num_decoded_chars]]

]]





[[[
[:编码字节串长度差异出现处的字符与中文无关]:here
===
  ===
  中文相关字符:区块:
  view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__Blocks_txt.py.out.ver14_0.txt
  [[
  ,(0x2000, 0x2070)
  : 'General Punctuation'
  ,(0x2070, 0x20a0)
  : 'Superscripts and Subscripts'
  ,(0x20a0, 0x20d0)
  : 'Currency Symbols'
  ,(0x2e00, 0x2e80)
  : 'Supplemental Punctuation'
  ,(0x2e80, 0x2f00)
  : 'CJK Radicals Supplement'
  ,(0x2f00, 0x2fe0)
  : 'Kangxi Radicals'
  ,(0x2ff0, 0x3000)
  : 'Ideographic Description Characters'
  ,(0x3000, 0x3040)
  : 'CJK Symbols and Punctuation'
  ,(0x31c0, 0x31f0)
  : 'CJK Strokes'
  ,(0x31f0, 0x3200)
  : 'Katakana Phonetic Extensions'
  ,(0x3200, 0x3300)
  : 'Enclosed CJK Letters and Months'
  ,(0x3300, 0x3400)
  : 'CJK Compatibility'
  ,(0x3400, 0x4dc0)
  : 'CJK Unified Ideographs Extension A'
  ,(0x4dc0, 0x4e00)
  : 'Yijing Hexagram Symbols'
  ,(0x4e00, 0xa000)
  : 'CJK Unified Ideographs'
  ,(0xa000, 0xa490)
  : 'Yi Syllables'
  ,(0xa490, 0xa4d0)
  : 'Yi Radicals'
  ,(0xa4d0, 0xa500)
  : 'Lisu'
  ,(0xf900, 0xfb00)
  : 'CJK Compatibility Ideographs'
  ]]

  ===
  [\u0400-\u07FF]:差异部分的相关信息:不与中文相关
  view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__Blocks_txt.py.out.ver14_0.txt
  view /sdcard/0my_files/unzip/unicode14_0/UCD/Scripts.txt
  view /sdcard/0my_files/unzip/unicode14_0/UCD/ScriptExtensions.txt
  [[
  ==>>:
  view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__Blocks_txt.py.out.ver14_0.txt
  ,(0x400, 0x500)
  : 'Cyrillic'
  ,(0x500, 0x530)
  : 'Cyrillic Supplement'
  ,(0x530, 0x590)
  : 'Armenian'
  ,(0x590, 0x600)
  : 'Hebrew'
  ,(0x600, 0x700)
  : 'Arabic'
  ,(0x700, 0x750)
  : 'Syriac'
  ,(0x750, 0x780)
  : 'Arabic Supplement'
  ,(0x780, 0x7c0)
  : 'Thaana'
  ,(0x7c0, 0x800)
  : 'NKo'
  ==>>:
  grep -P '^0[4-7][[:xdigit:]][[:xdigit:]][^[:xdigit:]]' /sdcard/0my_files/unzip/unicode14_0/UCD/ScriptExtensions.txt
  06D4          ; Arab Rohg # Po       ARABIC FULL STOP
  064B..0655    ; Arab Syrc # Mn  [11] ARABIC FATHATAN..ARABIC HAMZA BELOW
  0670          ; Arab Syrc # Mn       ARABIC LETTER SUPERSCRIPT ALEF
  0484          ; Cyrl Glag # Mn       COMBINING CYRILLIC PALATALIZATION
  0487          ; Cyrl Glag # Mn       COMBINING CYRILLIC POKRYTIE
  0485..0486    ; Cyrl Latn # Mn   [2] COMBINING CYRILLIC DASIA PNEUMATA..COMBINING CYRILLIC PSILI PNEUMATA
  0483          ; Cyrl Perm # Mn       COMBINING CYRILLIC TITLO
  061C          ; Arab Syrc Thaa # Cf       ARABIC LETTER MARK
  0660..0669    ; Arab Thaa Yezi # Nd  [10] ARABIC-INDIC DIGIT ZERO..ARABIC-INDIC DIGIT NINE
  060C          ; Arab Nkoo Rohg Syrc Thaa Yezi # Po       ARABIC COMMA
  061B          ; Arab Nkoo Rohg Syrc Thaa Yezi # Po       ARABIC SEMICOLON
  061F          ; Adlm Arab Nkoo Rohg Syrc Thaa Yezi # Po       ARABIC QUESTION MARK
  0640          ; Adlm Arab Mand Mani Ougr Phlp Rohg Sogd Syrc # Lm       ARABIC TATWEEL
  ==>>:
  grep -P '^0[4-7][[:xdigit:]][[:xdigit:]][^[:xdigit:]].*(Common|Inherited)' /sdcard/0my_files/unzip/unicode14_0/UCD/Scripts.txt
  0605          ; Common # Cf       ARABIC NUMBER MARK ABOVE
  060C          ; Common # Po       ARABIC COMMA
  061B          ; Common # Po       ARABIC SEMICOLON
  061F          ; Common # Po       ARABIC QUESTION MARK
  0640          ; Common # Lm       ARABIC TATWEEL
  06DD          ; Common # Cf       ARABIC END OF AYAH
  0485..0486    ; Inherited # Mn   [2] COMBINING CYRILLIC DASIA PNEUMATA..COMBINING CYRILLIC PSILI PNEUMATA
  064B..0655    ; Inherited # Mn  [11] ARABIC FATHATAN..ARABIC HAMZA BELOW
  0670          ; Inherited # Mn       ARABIC LETTER SUPERSCRIPT ALEF
  ]]
===
view ../lots/NOTE/unicode/char_class/多语言共用耂可显示耂字符.txt
===
]]]
[[[
[:def__si_36alnum_dybl_85mm]:here
  vs:[:def__si2219_dybl_87mm]:goto
  『ui』版 无存在必要，只节省了字符『8』

si_36alnum_dybl_85mm # 类同于『si2219_dybl_87mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于5/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}


<<==:
[明码表==regex"[0-9A-Z]"]
  [数量纟胞值==36]
要求:{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}
要求:[头胞 <- [89]]代表[-+]
  0. 编码后的胞串必须非空以串联定位搜索
  1. 头胞必须是数字以避免被当成标识符
  2. 必须包含字母以避免被当成数字
  3. 头胞 避免:
    "0" - 可能有 "0x...", "0o...", "0b..."
    "6" - "69" 构成 括号"()"
    "7" - 注释
    "4" - 转义
    剩下:"13 25 89"
  4. 选择 "[89]" 作为 头胞 暨 正负符号 => [总码长 >= 2][编码 必含 颔胞]
  5. 词典序 => "8"是负号,"9"是正号
  6. 类似si2219_dybl_87mm，但也有一些需要规避的况态:
    * 只需考虑 非负整数 编码，即头胞为"9"，负数的编码 为 其绝对值的编码 的 反码
    ### 以下 只考虑 非负整数编码 ###
    * 颔胞支持0层长度编码 即 颔胞立即数
        # regex"9[A-P]"
    * [颔胞立即数.总码长==2][颔胞立即数.颔胞 为 字母]
    * [颔胞立即数.颔胞 为 字母][颔胞立即数 必是 最小部分自然数][词典序] => [标准编码.颔胞 为 字母]
    * [颔胞立即数 编码 范围 为 16 即 [0..=15]][颔胞立即数.颔胞 为 字母[A-P]]
    * [标准编码.颔胞 为 字母][颔胞立即数.颔胞 为 字母[A-P]] => [非颔胞立即数.颔胞 为 字母[Q-Z]]
        # QRSTUVWXYZ
    * [颔胞居后 为 字符[0-7A-Z] 共计34个 即 排除头胞[89]]
    * 颔胞支持1层长度编码 即 颔胞负载长度
        # QRSTUV
        # regex"9[Q-V][0-7A-Z]{1,6}"
        # or:regex"9[Q-V][0-7A-X]{1,6}"
        #   #排除 YZ => 32=2**5
    * 颔胞支持2层长度编码 即 颔胞负载长度长度
        # WX
        # regex"9[WX][0-7A-Z]{1,2}[0-7A-Z]{7,1196}"
        #   #使用bijective_numeration
        #   #不排除 YZ => 34
        # or:regex"9[WX][0-7A-X]{1,2}[0-7A-X]{0,1023}" # [1023 == (32**2-1)]
        #   #不使用bijective_numeration
        #   #排除 YZ => 32=2**5
    * 颔胞支持指示超2层长度编码 即 颔胞超负载长度长度指示
        # Y
        # regex"9Y{n}[0-7A-Z]{1}[0-7A-Z]{0,(34**1-1)}[0-7A-Z]{0,(34**(34**1-1)-1)...}" where [n >= 1][(n+2)'s "[0-7A-Z]{0,???}" layers]
        #   [n==1] => [3层] 首层的{1,2} 相当于 上面的WX
        # or:regex"9Y{n}[0-7A-X]{1}[0-7A-X]{0,(32**1-1)}[0-7A-X]{0,(32**(32**1-1)-1)...}" where [n >= 1][(n+2)'s "[0-7A-X]{0,???}" layers]
    * 颔胞保留支持指示无穷大编码 即 颔胞无穷大指示
        # Z
        # regex"9Z[0-7A-X]*Y"
        #   未定义:词典序？长度？结尾？
        #   另外:regex"9[0-7].*" 未定义
    * [颔胞负载长度长度.颔胞 为 字母[WX] 即 负载长度长度为[1..=2], 即 负载长度 为 ([6+1..=6+34]+[6+34+1..=6+34+34**2])or([0..<34]+[0..<1156])]
        # WX
        # [34+34**2==34*35==17*70==1190]
        # [6+34+34**2==1196]
        # 区别在于 是否 bijective_numeration
    * [颔胞负载长度.颔胞 为 字母[Q-V] 即 负载长度为[1..=6]][至少在"Q"时使用bijective_numeration]
        # QRSTUV
        view ../../python3_src/seed/int_tools/digits/uint25bijective_numeration.py
        假设都使用bijective_numeration:
        颔胞立即数[A-P]:16:[0..<16]
        颔胞"Q"+颈胞[0-7A-Z]:34:[16..<16+34]即[16..<50]
        #以下 增益不明显:30分之一
        颔胞"R"+[0-7A-Z]{2}:34**2==1156:[50..<50+1156]即[50..<1206]
        颔胞"S"+[0-7A-Z]{3}:34**3==39304:[1206..<1206+39304]即[1206..<40510]
        颔胞"T"+[0-7A-Z]{4}:34**4==1336336:[40510..<40510+1336336]即[40510..<1376846]
        ... ...
===
符号字符:4:[89YZ]
计数字符:
  计数字符@颔胞:16:[A-P]
  计数字符@颔胞居后:32:[0-7A-X]

===
非负整数编码:
regex"9[A-P]"
    [0..<16]
    2**4
regex"9[Q-V][0-7A-X]{1,6}"
  regex"9Q[0-7A-X]{1}"
    [0..<32]
    2**5
  regex"9R[0-7A-X]{2}"
    [0..<1024]
    2**10
  regex"9S[0-7A-X]{3}"
    [0..<32768]
    2**15
  regex"9T[0-7A-X]{4}"
    [0..<1048576]
    2**20
  regex"9U[0-7A-X]{5}"
    [0..<33554432]
    2**25
  regex"9V[0-7A-X]{6}"
    [0..<1073741824]
    2**30
regex"9[WX][0-7A-X]{1,2}[0-7A-X]{0,1023}" # [1023 == (32**2-1)]
  regex"9W[0-7A-X]{1}[0-7A-X]{0,31}"
  regex"9X[0-7A-X]{2}[0-7A-X]{0,1023}"
regex"9Y{n}[0-7A-X]{1}[0-7A-X]{0,(32**1-1)}[0-7A-X]{0,(32**(32**1-1)-1)...}" where [n >= 1][(n+2)'s "[0-7A-X]{0,???}" layers]
  [n==1] => [3层] 首层的{1,2} 相当于 上面的WX

===
负整数编码{负整数} := 取反扌(非负整数编码{绝对值(负整数)})
===
取反扌(整数编码)
  | regex"[89][A-Z][0-7A-Z]*" = regex"[98][Z-A][Z-A7-0]*"
      # 3况态:头胞,颔胞,颔胞居后
      #     # 注意:颔胞 只有字母，禁用数字
      #     # 注意:颔胞居后 数字字母合并取反
  ##########
  ###old:
  bug:颔胞取反后词典序不相反: | regex"[89][0-7A-Z][0-7A-Z]*" = regex"[98][7-0Z-A][Z-A7-0]*"
      # 3况态:头胞,颔胞,颔胞居后
      #     # 注意:颔胞 数字字母分离取反
      #     # 注意:颔胞居后 数字字母合并取反
      # 细分:
细分-取反扌(非负整数编码)
      | regex"9[A-Z][0-7A-Z]*" = regex"8[Z-A][Z-A7-0]*"
      bug:??? | regex"9[0-7][0-7A-Z]*" = regex"8[7-0][Z-A7-0]*"
          # | regex"9[A-P]" = regex"8[Z-K]"
          # | regex"9[Q-V][0-7A-X]*" = regex"8[J-E][X-A7-0]*"
          # | regex"9[WX][0-7A-X]*" = regex"8[DC][X-A7-0]*"
          # | regex"9Y+[0-7A-X]*" = regex"8B+[X-A7-0]*"
          # ??? | regex"9Z[0-7A-X]*Y" = regex"8A[X-A7-0]*B"
===
]]]
==>>:
[[[
vs:[:def__si_base89_nat_dybl_86mm]:goto
vs:[:def__si_base89_bbu_dybl_86mm]:goto

vs:[:def__ui_base89_nat_dybl_86mm]:goto
vs:[:def__ui_base89_bbu_dybl_86mm]:goto


[:def__si_36alnum_dybl_85mm]:goto
===
[:def__si_base89_nat_dybl_86mm]:here
  nat:自然版/天然版
vs:[:def__si_base89_bbu_dybl_86mm]:goto
  bbu:特化版:bit,byte,unicode (2,256,0x11_00_00)
===
si_base89_nat_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

<<==:
[明码表=='!#$%&()*+,-.0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_abcdefghijklmnopqrstuvwxyz{|}~']
  [数量纟胞值==89]
  除去: 『'"`\/』
  [89 == 94-5]
>>> import string as S
>>> S.printable.index(' ')
94

===
失败尝试二:
89
25==89-64 #体胞计数字符
24==25-1 #负号『-』#非负整数:无需 正号
  失败尝试一:bug:负号 作为 头胞
    !! 前刹 不成立！
  失败尝试二:bug:负号 只能 作为 颔胞 => 头胞立即数 必须包含 正负整数
    !! 词典序 不成立！
  词典序 => 正负号 必须 出现在 头胞
#以上 体胞
#头胞 体胞 不相交
#以下 头胞
7==24-17 #正负整数.头胞立即数#正负整数.0层#[-8..=+8]
4==7-3 #非负整数.1层#[0..<2**18]#64**3==2**18
2==4-2 #非负整数.2层
1==2-1 #非负整数.超2层 # (n+2)层
0==1-1 #非负整数.无穷大保留区



===
成功:天然版:
  fixed:失败尝试三:
89
25==89-64 #体胞计数字符
#以上 体胞
#头胞 体胞 不相交
#以下 头胞
# 词典序 => 正负号 必须 出现在 头胞
24==25-1 #零#无正负号
12==24/2 #对半分:正整数.头胞 或 负整数.头胞
#以下 只考虑 正整数:
4==12-8 #正负整数.头胞立即数#正负整数.0层#[-8..=+8]
2==4-2 #非负整数.1层#[0..<2**12]#64**2==2**12==4096
1==2-1 #非负整数.超1层 # (n+1)层
  fixed:失败尝试三:bug:dybl:导致 此字符 跨越 头胞 体胞 相交
  bug-fixed:不同于『si_36alnum_dybl_85mm』的『Y{n}』，体胞 采用 真前缀幺元计数
0==1-1 #非负整数.无穷大保留区

==>>:
#头胞 体胞 不相交 => 词典序 不跨越 比较 头胞 体胞
[体胞计数字符=='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz|~']
  64
[头胞字符=='!#$%&()*+,-.:;<=>?@[]^_{}']
  25
# 词典序+对半分 => 正中间是 零『:』, 前12个字符是负字符，后12个字符是正字符
[头胞.负字符=='!#$%&()*+,-.']
[头胞.零字符==':']
[头胞.正字符==';<=>?@[]^_{}']

===
vs:[:def__si_base89_nat_dybl_86mm]:goto
  nat:自然版/天然版
[:def__si_base89_bbu_dybl_86mm]:here
  bbu:特化版:bit,byte,unicode (2,256,0x11_00_00)

si_base89_bbu_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}{支持负整数}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

==>>:
unicode:17*2**16 < 5*2**18 == 5*64**3
    1.5层
    (1层:5头胞值*3体符)
byte:2**8 == 4*64**1
    1.5层
    (1层:4头胞值*1体符)
bit:2**1 == 2*64**0
    头胞立即数
    (0层:2头胞值*0体符)
补空:2体符
    (1层:1头胞值*2体符)
    2**12
以上 占用 头胞值 12个@非负整数
  即:
    + 占用 头胞值 11个@正整数
    + 占用 头胞值 1个@零
    + 占用 头胞值 11个@负整数
    对半分后的12个还剩下1个，用作 超1层 指示
==>>:
89
25==89-64 #体胞计数字符
#以上 体胞
#头胞 体胞 不相交
#以下 头胞
# 词典序 => 正负号 必须 出现在 头胞
24==25-1 #零#无正负号
12==24/2 #对半分:正整数.头胞 或 负整数.头胞
#以下 只考虑 正整数:
11==12-1 #bit#正负整数.头胞立即数#正负整数.0层#[-1..=+1]
7==11-4 #byte#非负整数.1层.1体符#[0..<2**8]#4*64**1==2**8==256
6==7-1 #补空#非负整数.1层.2体符#[0..<2**12]#64**2==2**12==4096
1==6-5 #unicode#非负整数.1层.3体符#[0..<5*2**18]#5*64**3==5*2**18==0x14_00_00 > 0x11_00_00
0==1-1 #非负整数.超1层 # (n+1)层
  不同于『si_36alnum_dybl_85mm』的『Y{n}』，体胞 采用 真前缀幺元计数
#无:-1==0-1 #非负整数.无穷大保留区
    #非得要的话，可以 将 超1层 归并 取代 [0x11_00_00..<0x14_00_00]区间




===
[:def__ui_base89_nat_dybl_86mm]:here
  自然数编码/非负整数编码:天然版
  vs:[:def__si_base89_nat_dybl_86mm]:goto

ui_base89_nat_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

==>>:
#自然数编码/非负整数编码:天然版
89
25==89-64 #体胞计数字符
#以上 体胞
#头胞 体胞 不相交
#以下 头胞
9==25-16 #bit#非负整数.头胞立即数#非负整数.0层#[0..<16]
3==9-6 #非负整数.1层#[0..<2**36]#64**6==2**36
2==3-1 #非负整数.2层#[0..<2**378]#64**63==2**378
1==2-1 #非负整数.超1层 # (n+1)层
  不同于『si_36alnum_dybl_85mm』的『Y{n}』，体胞 采用 真前缀幺元计数
0==1-1 #非负整数.无穷大保留区



===
[:def__ui_base89_bbu_dybl_86mm]:here
  自然数编码/非负整数编码:特化版
  vs:[:def__si_base89_bbu_dybl_86mm]:goto

ui_base89_bbu_dybl_86mm # 类同于『si_36alnum_dybl_85mm』
    不兼容ASCII的编码方案{支持词典序}
    极限效率略低于6/8
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

==>>:
#自然数编码/非负整数编码:特化版
89
25==89-64 #体胞计数字符
#以上 体胞
#头胞 体胞 不相交
#以下 头胞
17==25-8 #bit#非负整数.头胞立即数#非负整数.0层#[0..<8]
13==17-4 #byte#非负整数.1层.1体符#[0..<2**8]#4*64**1==2**8==256
9==13-4 #补空#非负整数.1层.2体符#[0..<2**14]#4*64**2==2**14==16384
1==9-8 #unicode#非负整数.1层.3体符#[0..<2**21]#8*64**3==2**21==0x20_00_00 > 0x11_00_00
0==1-1 #非负整数.超1层 # (n+1)层
  不同于『si_36alnum_dybl_85mm』的『Y{n}』，体胞 采用 真前缀幺元计数
#无:-1==0-1 #非负整数.无穷大保留区




]]]

