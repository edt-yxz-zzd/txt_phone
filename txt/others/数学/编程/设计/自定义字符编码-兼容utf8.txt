
e others/数学/编程/设计/自定义字符编码-兼容utf8.txt

[[
升级补丁:
@20250728
无限保留区方案:编码方案{超凡层插入无限个保留区}:
  view ../../python3_src/seed/int_tools/digits/codecs4int.py
]]

move from:
  view ../../python3_src/seed/int_tools/digits/codecs4int.py
[[[[[
@20250726
要是 支持词典序、同时重点优化:ASCII+统合码基位面+统合码 的 编码空间，则兼容utf8是个不错的起点
    由于utf8编码效率低，只有5/8，所以后续必须改变编码方案，以逼近极限效率6/8
    最优:{候选方案辛,候选方案壬{偏好},候选方案癸} <<==:
[[
7
11 # 5+6 # 7+4
16 # 4+6*2 # 11+5
21 # 3+6*3 # 16+5
>>> (0x1100_00-1).bit_length()
21
>>> bin(int.from_bytes(chr(0x80-1).encode('u8')))
'0b1111111'
>>> bin(int.from_bytes(chr(0x8_00-1).encode('u8')))
'0b1101111110111111'
>>> bin(int.from_bytes(chr(0x100_00-1).encode('u8')))
'0b111011111011111110111111'
>>> bin(int.from_bytes(chr(0x1100_00-1).encode('u8')))
'0b11110100100011111011111110111111'

21bit => 4byte
'0b11110100100011111011111110111111'
'0b1111_0100__1000_1111__1011_1111__1011_1111'
'11:11_0/100__10:00_1111__10:11_1111__10:11_1111'

16bit => 3byte
'0b111011111011111110111111'
'0b1110_1111__1011_1111__1011_1111'
'11:10/_1111__10:11_1111__10:11_1111'

11bit => 2byte
'0b1101111110111111'
'0b1101_1111__1011_1111'
'11:0/1_1111__10:11_1111'

7bit => 1byte
'0b111_1111'
'0b0111_1111'
'0:111_1111'

]]
[[
utf8_ext方案:
    多字节情形:(N)byte => (5*N+1)bit
    02byte => 11bit
    03byte => 16bit
    04byte => 21bit
    05byte => 26bit
    06byte => 31bit
    07byte => 36bit
    08byte => 41bit
    09byte => 46bit
    10byte => 51bit
    11byte => 56bit
    12byte => 61bit
    13byte => 66bit
    14byte => 71bit
    15byte => 76bit
    16byte => 81bit
    17byte => 86bit
    18byte => 91bit
    19byte => 96bit
    #注意:32bit,64bit:
        07byte => 36bit
        13byte => 66bit
]]
######################
######################
[[
失败:
候选方案甲:
兼容utf8_ext.4byte{负载21bit}
1111_0bbb ...{3byte} 依旧使用utf8_ext方案
    4==1+3
之后:1111_1bbb ...
    * 1111_10bb ... 超凡层
    * 1111_11bb ... 甲保留区{>=1byte{2bit}}
1111_10bb ... 超凡层
    1111_10bb:
        00 => (1+6)byte==7byte => 6*6==36bit
            # 同utf8_ext:36bit
        01 => (1+8)byte==9byte => 8*6==48bit
            # utf8_ext:46bit
        10 => (1+10)byte==11byte => 10*6==60bit
            # utf8_ext:56bit
        or:10 => (1+11)byte==12byte => 11*6==66bit
            # utf8_ext:61bit
            # utf8_ext:66bit 只多 1byte
        11 => 头部扩展到下一字节
    结论:候选方案甲:于32bit,64bit的效率比utf8_ext高不了多少，但是由于跳过许多中间bit数，导致实际编码效率更低。
        #回顾:发现其实是『2凡层.第一层』只保留2bit是不行的
        #   !! 见:候选方案丙:『2凡层.第一层』只保留3bit是不行的
        #=>重新考虑:候选方案壬:主要是 保留区 可能 起步 1byte
]]
######################
######################
[[
候选方案乙:begin:
『候选方案甲:失败』=>应当兼容utf8_ext至13byte(负载66bit)
1111_1111 1011_1110 ...{11byte} 依旧使用utf8_ext方案
    13==2+11
之后:1111_1111 1011_1111 ...
    * 1111_1111 1011_1111 100b_bbbb ... 超凡层
    * 1111_1111 1011_1111 101b_bbbb ... 乙保留区{>=3byte{5bit}}
1111_1111 1011_1111 100b_bbbb ... 超凡层
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载66bit，相当于11躯胞，所以下面一开始 偏移12
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==0]时，偏移量才非零
    * 1111_1111 1011_1111 1000_bbbb ... 共2凡层，第一层占4bit(偏移+12)
    * 1111_1111 1011_1111 1001_0bbb ... 共3凡层，第一层占3bit
    * 1111_1111 1011_1111 1001_10bb ... 共4凡层，第一层占2bit
    * 1111_1111 1011_1111 1001_110b ... 共5凡层，第一层占1bit
    * 1111_1111 1011_1111 1001_1110 ... 共6凡层，第一层占0bit(偏移+1)
    * 1111_1111 1011_1111 1001_1111 100b_bbbb ... 共7凡层，第一层占5bit
    * 1111_1111 1011_1111 1001_1111 1010_bbbb ... 共8凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1011_1111 1001_1111 1011_1110 ... 共12凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案乙:end
]]
[[
候选方案乙 vs utf8_ext:begin:
#######
1111_1111 1011_1111 1000_bbbb ... 共2凡层，第一层占4bit(偏移+12)
    最长:
        第二层/末层:
            2**4-1==15byte
            12+15==27byte
    末层 最长 27byte => 27*6==162bit
        开销3byte，共30byte
        #utf8_ext:30byte => 151bit
        #候选方案乙:30byte => 162bit
    末层 最短 12byte => 12*6==72bit
        开销3byte，共15byte # 跳过14byte{少字节则不及utf8_ext}
        #utf8_ext:15byte => 76bit
        #utf8_ext:14byte => 71bit
        #候选方案乙:13byte => 66bit
    [n:=总字节数]:
        [5*n+1==(n-3)*6]
            <==>[n==19]
    在19byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        19-3-12==4
        此时 第一层 负载值为4
        也就[0..<4]即15byte,16byte,17byte,18byte这4种情况(实际上还得包括14byte共5种情况)，效率不及utf8_ext
            #兼容区:13byte => 66bit == 66bit
            14byte => 71bit > 跳过！
            15byte => 76bit > 72bit
            16byte => 81bit > 78bit
            17byte => 86bit > 84bit
            18byte => 91bit > 90bit
            19byte => 96bit == 96bit
            #19-13==6==爻元数纟躯胞
            #19-13-1==5==1+4==比utf8_ext多用的爻元数==区别用爻元数纟保留区+爻元数纟第一层
            #   这是 配置所致，可缩减
            #   比如:保留区 后撤
            #   比如:缩减 第一层 爻元数 (1.增大兼容utf8_ext的兼容区 或者 2.留下部分躯胞融入第二层/末层)
            #但『3凡层』起始至少多开销1躯胞，要求『2凡层』最后超过utf8_ext至少4bit(因为开销+1,负载+1，6/8又追回5/8两爻元)
            #   第一层 至少3爻元
            #=>候选方案丙:1.后撤 保留区;2.第一层 只保留3爻元
#######
1111_1111 1011_1111 1001_0bbb ... 共3凡层，第一层占3bit
    最长:
        第二层:
            2**3-1==7byte
            7*6==42bit
        第三层/末层:
            2**42-1==4398046511103byte ~= 4.3980*10**12
    末层 最长 4398046511103byte => 4398046511103*6==26388279066618bit
        开销(3+7)=10byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:27+1==28byte
        第二层:需bit_length(28)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 28byte => 28*6==168bit
        开销(3+1)=4byte，共32byte # 跳过31byte{少字节仍优于utf8_ext}
        #utf8_ext:32byte => 161bit < 168bit
        #utf8_ext:31byte => 156bit
        #候选方案乙:30byte => 162bit
#######
『候选方案乙:[13byte~19byte]低谷期』
    在19byte时 才追平utf8_ext的效率，此后，一直『候选方案乙』更优
候选方案乙 vs utf8_ext:end
]]
######################
######################
[[
失败:
候选方案丙:begin:
『候选方案乙:[13byte~19byte]低谷期』=>候选方案丙:1.后撤 保留区;2.第一层 只保留3爻元
1111_1111 1011_1110 ...{11byte} 依旧使用utf8_ext方案
    13==2+11
之后:1111_1111 1011_1111 ...
    * 1111_1111 1011_1111 10cc_bbbb ... 超凡层
    * 1111_1111 1011_1111 1011_bbbb ... 丙保留区{>=3byte{4bit}}
1111_1111 1011_1111 10cc_bbbb ... 超凡层
    # [cc =!= 11]
    # [cc <- {0b, 10}]
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载66bit，相当于11躯胞，所以下面一开始 本应偏移12，但是由于多了2爻元，所以 偏移11
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==0]或者[魔改3凡层甲层]或[魔改3凡层乙层]时，偏移量才非零
    * 1111_1111 1011_1111 100b_bbqq ... 共2凡层，第一层占3bit(偏移+11)，第二层多占2爻元(除了:躯胞数)
    ######################
    ####此处 插入 保留区 1011_bbbb:导致 『3凡层』诸后 动态爻元中间多出一个0:
    ######################
    * [魔改3凡层]:1111_1111 1011_1111 1010_0bbb ... 共3凡层，第一层占3bit
        * [魔改3凡层甲层]:1111_1111 1011_1111 1010_00bb 10bb_bbqq ... 共3凡层，第一层占0bit(偏移+1)，第二层占6bit(跨2躯胞),第三层/末层多占2bit
        * [魔改3凡层乙层]:1111_1111 1011_1111 1010_01bb ... 共3凡层，第一层占2bit(偏移+2)
    * 1111_1111 1011_1111 1010_10bb ... 共4凡层，第一层占2bit
    * 1111_1111 1011_1111 1010_110b ... 共5凡层，第一层占1bit
    * 1111_1111 1011_1111 1010_1110 ... 共6凡层，第一层占0bit(偏移+1)
    * 1111_1111 1011_1111 1010_1111 100b_bbbb ... 共7凡层，第一层占5bit
    * 1111_1111 1011_1111 1010_1111 1010_bbbb ... 共8凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1011_1111 1010_1111 1011_1110 ... 共12凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案丙:end
]]
[[
候选方案丙 vs utf8_ext:begin:
#######
1111_1111 1011_1111 100b_bbqq ... 共2凡层，第一层占3bit(偏移+11)，第二层多占2爻元(除了:躯胞数)
    最长:
        第二层/末层:
            2**3-1==7byte
            11+7==18byte
    末层 最长 18byte => 2+18*6==110bit
        开销3byte，共21byte
        #utf8_ext:21byte => 106bit
        #候选方案丙:21byte => 110bit
    末层 最短 11byte => 2+11*6==68bit
        开销3byte，共14byte # 接力13byte
        #utf8_ext:14byte => 71bit > 68bit
    [n:=总字节数]:
        [5*n+1==2+(n-3)*6]
            <==>[n==17]
    在17byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        17-3-11==3
        此时 第一层 负载值为3
        也就[0..<3]即14byte,15byte,16byte这3种情况，效率不及utf8_ext
            #兼容区:13byte => 66bit == 66bit
            14byte => 71bit > 68bit
            15byte => 76bit > 74bit
            16byte => 81bit > 80bit
            17byte => 86bit == 86bit
            #17-13-1==3==比utf8_ext多用的爻元数==爻元数纟第一层
#######
######################
#.以下是:保留区 区别爻元 插在 『3凡层』之前的情形，导致 合理最短 时，不及utf8_ext:『23byte => 116bit > 114bit』
#.  但发现 就算 保留区 继续后撤也不济事，主要是 『2凡层』多出来的2爻元被取消(『3凡层』相当于 倒退 (2+6-2)=6bit)，而 『2凡层.末层.最长』超出utf8_ext部分(4bit) 不足弥补！
#.  =>『魔改3凡层』
#.〈〈
#.1111_1111 1011_1111 1010_0bbb ... 共3凡层，第一层占3bit
#.    #对比 与 候选方案乙 的 对比 几乎完全相同
#.    #   !! 后撤 保留区 只影响 『2凡层』与『保留区』
#.    #   !! 但 缩减 爻元数纟第一层 导致 合理最短{3凡层.末层} 也减小
#.    最长:
#.        第二层:
#.            2**3-1==7byte
#.            7*6==42bit
#.        第三层/末层:
#.            2**42-1==4398046511103byte ~= 4.3980*10**12
#.    末层 最长 4398046511103byte => 4398046511103*6==26388279066618bit
#.        开销(3+7)=10byte，共...byte
#.        #utf8_ext:不用比了，5/8 比 6/8
#.    合理最短:
#.        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
#.        第三层/末层:18+1==19byte
#.        第二层:需bit_length(19)=5bit < 6bit == 1躯胞 => 1byte
#.    末层 合理最短 19byte => 19*6==114bit
#.        开销(3+1)=4byte，共23byte # 跳过22byte{少字节则不及utf8_ext}
#.        #utf8_ext:23byte => 116bit > 114bit
#.        #utf8_ext:22byte => 111bit
#.        #候选方案丙:21byte => 110bit
#.〉〉
######################
#######
[魔改3凡层]:1111_1111 1011_1111 1010_0bbb ... 共3凡层，第一层占3bit
    #######
    * [魔改3凡层甲层]:1111_1111 1011_1111 1010_00bb 10bb_bbqq ... 共3凡层，第一层占0bit(偏移+1)，第二层占6bit(跨2躯胞),第三层/末层多占2bit
    最长:
        第二层:
            1+2**0-1==1byte
            2+(6-2)==6bit
        第三层/末层:
            2**6-1==63byte
    末层 最长 63byte => 2+63*6==380bit
        开销(3+1)=4byte，共67byte
        #utf8_ext:67byte => 336bit
        #候选方案丙:67byte => 380bit
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:18+1==19byte
        第二层:需bit_length(19)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 19byte => 2+19*6==116bit
        开销(3+1)=4byte，共23byte # 跳过22byte{少字节则不及utf8_ext}
        #utf8_ext:23byte => 116bit 同效率
        #utf8_ext:22byte => 111bit
        #候选方案丙:21byte => 110bit
    #######
    * [魔改3凡层乙层]:1111_1111 1011_1111 1010_01bb ... 共3凡层，第一层占2bit(偏移+2)
    最长:
        第二层:
            2+2**2-1==5byte
            5*6==30bit
        第三层/末层:
            2**30-1==1073741823byte ~= 1.0737*10**9
    末层 最长 1073741823byte => 1073741823*6==6442450938bit
        开销(3+5)=8byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        #末层 比『魔改3凡层甲层.末层』多1byte:
        第三层/末层:63+1==64byte
        第二层:需bit_length(64)=7bit < 2*6bit == 2躯胞 => 2byte
    末层 合理最短 64byte => 64*6==384bit
        开销(3+2)=5byte，共69byte # 跳过68byte{少字节仍优于utf8_ext}
        #utf8_ext:69byte => 346bit < 384bit
        #utf8_ext:68byte => 341bit
        #候选方案丙:67byte => 380bit
    #######
#######
『候选方案丙:[13byte~17byte,22byte~23byte]低谷期』
    分别在17byte/23byte时 才追平utf8_ext的效率，此后，一直『候选方案丙』更优
    => 『2凡层.第一层』只保留3bit是不好的
    => 候选方案丁:1.后撤 保留区;2.第一层 仍保留4爻元
候选方案丙 vs utf8_ext:end
]]
######################
######################
[[
候选方案丁:begin:
『候选方案丙:[13byte~17byte,22byte~23byte]低谷期』 => 『2凡层.第一层』只保留3bit是不好的
    =>候选方案丁:1.后撤 保留区;2.第一层 仍保留4爻元
1111_1111 1011_1110 ...{11byte} 依旧使用utf8_ext方案
    13==2+11
之后:1111_1111 1011_1111 ...
    * 1111_1111 1011_1111 10cc_bbbb ... 超凡层
    * 1111_1111 1011_1111 1011_bbbb ... 丁保留区{>=3byte{4bit}}
1111_1111 1011_1111 10cc_bbbb ... 超凡层
    # [cc =!= 11]
    # [cc <- {0b, 10}]
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载66bit，相当于11躯胞，所以下面一开始 本应偏移12，但是由于多了1爻元，所以 偏移11
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==0]时，偏移量才非零
    * 1111_1111 1011_1111 100b_bbbq ... 共2凡层，第一层占4bit(偏移+11)，第二层多占1爻元(除了:躯胞数)
    ######################
    ####此处 插入 保留区 1011_bbbb:导致 『3凡层』诸后 动态爻元中间多出一个0:
    ######################
    * 1111_1111 1011_1111 1010_0bbb ... 共3凡层，第一层占3bit
    * 1111_1111 1011_1111 1010_10bb ... 共4凡层，第一层占2bit
    * 1111_1111 1011_1111 1010_110b ... 共5凡层，第一层占1bit
    * 1111_1111 1011_1111 1010_1110 ... 共6凡层，第一层占0bit(偏移+1)
    * 1111_1111 1011_1111 1010_1111 100b_bbbb ... 共7凡层，第一层占5bit
    * 1111_1111 1011_1111 1010_1111 1010_bbbb ... 共8凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1011_1111 1010_1111 1011_1110 ... 共12凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案丁:end
]]
[[
候选方案丁 vs utf8_ext:begin:
#######
1111_1111 1011_1111 100b_bbbq ... 共2凡层，第一层占4bit(偏移+11)，第二层多占1爻元(除了:躯胞数)
    最长:
        第二层/末层:
            2**4-1==15byte
            11+15==26byte
    末层 最长 26byte => 1+26*6==157bit
        开销3byte，共29byte
        #utf8_ext:29byte => 146bit
        #候选方案丁:29byte => 157bit
    末层 最短 11byte => 1+11*6==67bit
        开销3byte，共14byte # 接力13byte
        #utf8_ext:14byte => 71bit > 67bit
    [n:=总字节数]:
        [5*n+1==1+(n-3)*6]
            <==>[n==18]
    在18byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        18-3-11==4
        此时 第一层 负载值为4
        也就[0..<4]即14byte,15byte,16byte,17byte这4种情况，效率不及utf8_ext
            #兼容区:13byte => 66bit == 66bit
            14byte => 71bit > 67bit
            15byte => 76bit > 73bit
            16byte => 81bit > 79bit
            17byte => 86bit > 85bit
            18byte => 91bit == 91bit
            #18-13-1==4==比utf8_ext多用的爻元数==爻元数纟第一层
#######
1111_1111 1011_1111 1010_0bbb ... 共3凡层，第一层占3bit
    #对比 与 候选方案乙 的 对比 几乎完全相同
    #   !! 后撤 保留区 只影响 『2凡层』与『保留区』
    #   !! 虽未 缩减 爻元数纟第一层 但 减少 偏移(+12-->+11) 导致 合理最短{3凡层.末层} 也减小
    最长:
        第二层:
            2**3-1==7byte
            7*6==42bit
        第三层/末层:
            2**42-1==4398046511103byte ~= 4.3980*10**12
    末层 最长 4398046511103byte => 4398046511103*6==26388279066618bit
        开销(3+7)=10byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:26+1==27byte
        第二层:需bit_length(27)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 27byte => 27*6==162bit
        开销(3+1)=4byte，共31byte # 跳过30byte{少字节仍优于utf8_ext}
        #utf8_ext:31byte => 156bit < 162bit
        #utf8_ext:30byte => 151bit
        #候选方案丁:29byte => 157bit
#######
『候选方案丁:[13byte~18byte]低谷期』
    在18byte时 才追平utf8_ext的效率，此后，一直『候选方案丁』更优
候选方案丁 vs utf8_ext:end
]]
######################
######################
[[
对比:各候选方案:
    候选方案甲:失败
    候选方案乙
    候选方案丙:失败
    候选方案丁

候选方案乙vs候选方案丁:
    『候选方案乙:[13byte~19byte]低谷期』
        在19byte时 才追平utf8_ext的效率，此后，一直『候选方案乙』更优
    『候选方案丁:[13byte~18byte]低谷期』
        在18byte时 才追平utf8_ext的效率，此后，一直『候选方案丁』更优
    #######
    乙-缺点:
        候选方案乙 不仅 低谷期 更长，而且由于 跳过14byte 导致严重断层。
            #但 这些都发生在[66bit..91bit~96bit]之间，也就是 不影响 64bit,128bit
            #=> 候选方案戊:移至[36bit..61bit~66bit]，不影响 32bit,64bit,128bit
            #=> 候选方案壬:移至[21bit..46bit~51bit]，影响32bit
            #=> 候选方案己:移至[96bit..121bit~126bit]，不影响 32bit,64bit,128bit
    #######
    丁-缺点:
        + 后撤 保留区，导致 编码方案 复杂
        + 『2凡层』遗留1bit给 末层，导致 编码方案 复杂
            # =>『2凡层.第一层』的4bit尾部对齐躯胞边界
            #   => 候选方案庚:13+1 兼容utf8_ext.14byte(负载71bit)
            #   => 候选方案辛:13-5 兼容utf8_ext.8byte(负载41bit)
            #   xxx:=> 13-11 兼容utf8_ext.2byte(负载11bit) 但 不能优化支持 基位面+统合码
    #######
若顾虑算法实现难度，则 乙 更佳
若顾虑数据存储效率，则 丁 更佳
]]
######################
######################
[[
候选方案戊:begin:
候选方案戊:改版{候选方案乙}:低谷期 移至[36bit..61bit~66bit]，不影响 32bit,64bit,128bit => 兼容utf8_ext.7byte(负载36bit) #保持对齐:『2凡层.第一层』自然为4bit
1111_1110 ...{6byte} 依旧使用utf8_ext方案
    7==1+6
之后:1111_1111 10bb_bbbb ...
    * 1111_1111 100b_bbbb ... 超凡层
    * 1111_1111 101b_bbbb ... 戊保留区{>=2byte{5bit}}
1111_1111 100b_bbbb ... 超凡层
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载36bit，相当于6躯胞，所以下面一开始 偏移7
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==0]时，偏移量才非零
    * 1111_1111 1000_bbbb ... 共2凡层，第一层占4bit(偏移+7)
    * 1111_1111 1001_0bbb ... 共3凡层，第一层占3bit
    * 1111_1111 1001_10bb ... 共4凡层，第一层占2bit
    * 1111_1111 1001_110b ... 共5凡层，第一层占1bit
    * 1111_1111 1001_1110 ... 共6凡层，第一层占0bit(偏移+1)
    * 1111_1111 1001_1111 100b_bbbb ... 共7凡层，第一层占5bit
    * 1111_1111 1001_1111 1010_bbbb ... 共8凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1001_1111 1011_1110 ... 共12凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案戊:end
]]
[[
候选方案戊 vs utf8_ext:begin:
#######
1111_1111 1000_bbbb ... 共2凡层，第一层占4bit(偏移+7)
    最长:
        第二层/末层:
            2**4-1==15byte
            7+15==22byte
    末层 最长 22byte => 22*6==132bit
        开销2byte，共24byte
        #utf8_ext:24byte => 121bit
        #候选方案戊:24byte => 132bit
    末层 最短 7byte => 7*6==42bit
        开销2byte，共9byte # 跳过8byte{少字节则不及utf8_ext}
        #utf8_ext:9byte => 46bit
        #utf8_ext:8byte => 41bit
        #候选方案戊:7byte => 36bit
    [n:=总字节数]:
        [5*n+1==(n-2)*6]
            <==>[n==13]
    在13byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        13-2-7==4
        此时 第一层 负载值为4
        也就[0..<4]即9byte,10byte,11byte,12byte这4种情况(实际上还得包括8byte共5种情况)，效率不及utf8_ext
            #兼容区:7byte => 36bit == 36bit
            08byte => 41bit > 跳过！
            09byte => 46bit > 42bit
            10byte => 51bit > 48bit
            11byte => 56bit > 54bit
            12byte => 61bit > 60bit
            13byte => 66bit == 66bit
            #13-7==6==爻元数纟躯胞
            #13-7-1==5==1+4==比utf8_ext多用的爻元数==区别用爻元数纟保留区+爻元数纟第一层
            #   这是 配置所致，可缩减
            #   比如:保留区 后撤
            #   比如:缩减 第一层 爻元数 (1.增大兼容utf8_ext的兼容区 或者 2.留下部分躯胞融入第二层/末层)
#######
1111_1111 1001_0bbb ... 共3凡层，第一层占3bit
    最长:
        第二层:
            2**3-1==7byte
            7*6==42bit
        第三层/末层:
            2**42-1==4398046511103byte ~= 4.3980*10**12
    末层 最长 4398046511103byte => 4398046511103*6==26388279066618bit
        开销(2+7)=9byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:22+1==23byte
        第二层:需bit_length(23)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 23byte => 23*6==138bit
        开销(2+1)=3byte，共26byte # 跳过25byte{少字节仍优于utf8_ext}
        #utf8_ext:26byte => 131bit < 138bit
        #utf8_ext:25byte => 126bit
        #候选方案戊:24byte => 132bit
#######
『候选方案戊:[7byte~13byte]低谷期』
    在13byte时 才追平utf8_ext的效率，此后，一直『候选方案戊』更优
候选方案戊 vs utf8_ext:end
]]
######################
######################
[[
候选方案己:begin:
候选方案己:改版{候选方案乙}:低谷期 移至[96bit..121bit~126bit]，不影响 32bit,64bit,128bit => 兼容utf8_ext.19byte(负载96bit) #保持对齐:『2凡层.第一层』自然为4bit
1111_1111 1011_1111 1011_1110 ...{16byte} 依旧使用utf8_ext方案
    19==3+16
之后:1111_1111 1011_1111 1011_1110 10bb_bbbb ...
    * 1111_1111 1011_1111 1011_1110 100b_bbbb ... 超凡层
    * 1111_1111 1011_1111 1011_1110 101b_bbbb ... 己保留区{>=4byte{5bit}}
1111_1111 1011_1111 1011_1110 100b_bbbb ... 超凡层
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载96bit，相当于16躯胞，所以下面一开始 偏移17
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==0]时，偏移量才非零
    * 1111_1111 1011_1111 1011_1110 1000_bbbb ... 共2凡层，第一层占4bit(偏移+17)
    * 1111_1111 1011_1111 1011_1110 1001_0bbb ... 共3凡层，第一层占3bit
    * 1111_1111 1011_1111 1011_1110 1001_10bb ... 共4凡层，第一层占2bit
    * 1111_1111 1011_1111 1011_1110 1001_110b ... 共5凡层，第一层占1bit
    * 1111_1111 1011_1111 1011_1110 1001_1110 ... 共6凡层，第一层占0bit(偏移+1)
    * 1111_1111 1011_1111 1011_1110 1001_1111 100b_bbbb ... 共7凡层，第一层占5bit
    * 1111_1111 1011_1111 1011_1110 1001_1111 1010_bbbb ... 共8凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1011_1111 1011_1110 1001_1111 1011_1110 ... 共12凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案己:end
]]
[[
候选方案己 vs utf8_ext:begin:
#######
1111_1111 1011_1111 1011_1110 1000_bbbb ... 共2凡层，第一层占4bit(偏移+17)
    最长:
        第二层/末层:
            2**4-1==15byte
            17+15==32byte
    末层 最长 32byte => 32*6==192bit
        开销4byte，共36byte
        #utf8_ext:36byte => 181bit
        #候选方案己:36byte => 192bit
    末层 最短 17byte => 17*6==102bit
        开销4byte，共21byte # 跳过20byte{少字节则不及utf8_ext}
        #utf8_ext:21byte => 106bit
        #utf8_ext:20byte => 101bit
        #候选方案己:19byte => 96bit
    [n:=总字节数]:
        [5*n+1==(n-4)*6]
            <==>[n==25]
    在25byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        25-4-17==4
        此时 第一层 负载值为4
        也就[0..<4]即21byte,22byte,23byte,24byte这4种情况(实际上还得包括20byte共5种情况)，效率不及utf8_ext
            #兼容区:19byte => 96bit == 96bit
            20byte => 101bit > 跳过！
            21byte => 106bit > 102bit
            22byte => 111bit > 108bit
            23byte => 116bit > 114bit
            24byte => 121bit > 120bit
            25byte => 126bit == 126bit
            #25-19==6==爻元数纟躯胞
            #25-19-1==5==1+4==比utf8_ext多用的爻元数==区别用爻元数纟保留区+爻元数纟第一层
            #   这是 配置所致，可缩减
            #   比如:保留区 后撤
            #   比如:缩减 第一层 爻元数 (1.增大兼容utf8_ext的兼容区 或者 2.留下部分躯胞融入第二层/末层)
#######
1111_1111 1011_1111 1011_1110 1001_0bbb ... 共3凡层，第一层占3bit
    最长:
        第二层:
            2**3-1==7byte
            7*6==42bit
        第三层/末层:
            2**42-1==4398046511103byte ~= 4.3980*10**12
    末层 最长 4398046511103byte => 4398046511103*6==26388279066618bit
        开销(4+7)=11byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:32+1==33byte
        第二层:需bit_length(33)=6bit = 1躯胞 => 1byte
    末层 合理最短 33byte => 33*6==198bit
        开销(4+1)=5byte，共38byte # 跳过37byte{少字节仍优于utf8_ext}
        #utf8_ext:38byte => 191bit < 198bit
        #utf8_ext:37byte => 186bit
        #候选方案己:36byte => 192bit
#######
『候选方案己:[19byte~25byte]低谷期』
    在25byte时 才追平utf8_ext的效率，此后，一直『候选方案己』更优
候选方案己 vs utf8_ext:end
]]
######################
######################
[[
候选方案壬:begin:
候选方案壬:改版{候选方案乙}:低谷期 移至[21bit..46bit~51bit]，影响32bit(发现都得7byte，等效于没影响) => 兼容utf8_ext.4byte(负载21bit) #不能保持对齐:『2凡层.第一层』人为4bit，其实更像 候选方案丁，同时 是 改版{候选方案甲}{2bit-->4bit}
    原本太复杂，不考虑
        但由于 甲保留区{>=1byte{2bit}} 是 最短的，导致 重启...
兼容utf8_ext.4byte{负载21bit}
1111_0bbb ...{3byte} 依旧使用utf8_ext方案
    4==1+3
之后:1111_1bbb ...
    * 1111_10bb 10bb_bbbb ... 超凡层
    * 1111_11bb ... 壬保留区{>=1byte{2bit}}
1111_10bb 10bb_bbbb ... 超凡层
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载21bit，相当于3躯胞，所以下面一开始 偏移4 (虽多了3bit，但 偏移3 仍只21bit，不行)
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==3][凡层数>3]时，偏移量才非零
    * 1111_100b 10bb_bqqq ... 共2凡层，第一层占4bit(偏移+4)，第二层多占3爻元(除了:躯胞数)
    * 1111_1010 10bb_bbbb ... 共3凡层，第一层占6bit(特设)
    * 1111_1011 100b_bbbb ... 共4凡层，第一层占5bit
    * 1111_1011 1010_bbbb ... 共5凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1011 1011_1110 ... 共9凡层，第一层占0bit(偏移+1)
    * 1111_1011 1011_1111 100b_bbbb ... 共10凡层，第一层占5bit
    ... ...
    ... ...
    * 1111_1011 1011_1111 1011_1110 ... 共15凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案壬:end
]]
[[
候选方案壬 vs utf8_ext:begin:
#######
1111_100b 10bb_bqqq ... 共2凡层，第一层占4bit(偏移+4)，第二层多占3爻元(除了:躯胞数)
    最长:
        第二层/末层:
            2**4-1==15byte
            4+15==19byte
    末层 最长 19byte => 3+19*6==117bit
        开销2byte，共21byte
        #utf8_ext:21byte => 106bit
        #候选方案壬:21byte => 117bit
    末层 最短 4byte => 3+4*6==27bit
        开销2byte，共6byte # 跳过5byte{少字节则不及utf8_ext}
        #utf8_ext:6byte => 31bit
        #utf8_ext:5byte => 26bit
        #候选方案壬:4byte => 21bit
    [n:=总字节数]:
        [5*n+1==3+(n-2)*6]
            <==>[n==10]
    在10byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        10-2-4==4
        此时 第一层 负载值为4
        也就[0..<4]即6byte,7byte,8byte,9byte这4种情况(实际上还得包括5byte共5种情况)，效率不及utf8_ext
            #兼容区:4byte => 21bit == 21bit
            5byte => 26bit > 跳过！
            6byte => 31bit > 27bit
            7byte => 36bit > 33bit
            8byte => 41bit > 39bit
            9byte => 46bit > 45bit
            10byte => 51bit == 51bit
            #10-4==6==爻元数纟躯胞
            #10-4-1==5==1+4==比utf8_ext多用的爻元数==区别用爻元数纟保留区+爻元数纟第一层
            #   这是 配置所致，可缩减
            #   比如:保留区 后撤
            #   比如:缩减 第一层 爻元数 (1.增大兼容utf8_ext的兼容区 或者 2.留下部分躯胞融入第二层/末层)
#######
1111_1010 10bb_bbbb ... 共3凡层，第一层占6bit(特设)
    最长:
        第二层:
            2**6-1==63byte
            63*6==378bit
        第三层/末层:
            2**378-1==非常大byte
    末层 最长 非常大byte => 非常大*6==非常大bit
        开销(2+63)=65byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:19+1==20byte
        第二层:需bit_length(20)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 20byte => 20*6==120bit
        开销(2+1)=3byte，共23byte # 跳过22byte{少字节仍优于utf8_ext}
        #utf8_ext:23byte => 116bit < 120bit
        #utf8_ext:22byte => 111bit
        #候选方案壬:21byte => 117bit
#######
『候选方案壬:[4byte~10byte]低谷期』
    在10byte时 才追平utf8_ext的效率，此后，一直『候选方案壬』更优
    [21bit..46bit~51bit]，影响32bit(发现都得7byte，等效于没影响)
        #utf8_ext:7byte => 36bit > 33bit
    [21bit..46bit~51bit]，不影响32bit,64bit,128bit
候选方案壬 vs utf8_ext:end
]]
######################
######################
[[
候选方案癸:begin:
候选方案癸:改版{候选方案壬}:后撤 保留区
兼容utf8_ext.4byte{负载21bit}
1111_0bbb ...{3byte} 依旧使用utf8_ext方案
    4==1+3
之后:1111_1bbb ...
    * 1111_1ccb 10bb_bbbb ... 超凡层
    * 1111_111b ... 癸保留区{>=1byte{1bit}}
1111_1ccb 10bb_bbbb ... 超凡层
    # [cc =!= 11]
    # [cc <- {0b, 10}]
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载21bit，相当于3躯胞，所以下面一开始 本应偏移4，但是由于多了4爻元，所以 偏移3
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==3][凡层数>3]时，偏移量才非零
    * 1111_10bb 10bb_qqqq ... 共2凡层，第一层占4bit(偏移+3)，第二层多占4爻元(除了:躯胞数)
    ######################
    ####此处 插入 保留区 1111_111b:导致 『3凡层』诸后 动态爻元中间多出一个0:
    ######################
    * 1111_1100 10bb_bbbb ... 共3凡层，第一层占6bit(特设)
    * 1111_1101 100b_bbbb ... 共4凡层，第一层占5bit
    * 1111_1101 1010_bbbb ... 共5凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1101 1011_1110 ... 共9凡层，第一层占0bit(偏移+1)
    * 1111_1101 1011_1111 100b_bbbb ... 共10凡层，第一层占5bit
    ... ...
    ... ...
    * 1111_1101 1011_1111 1011_1110 ... 共15凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案癸:end
]]
[[
候选方案癸 vs utf8_ext:begin:
#######
1111_10bb 10bb_qqqq ... 共2凡层，第一层占4bit(偏移+3)，第二层多占4爻元(除了:躯胞数)
    最长:
        第二层/末层:
            2**4-1==15byte
            3+15==18byte
    末层 最长 18byte => 4+18*6==112bit
        开销2byte，共20byte
        #utf8_ext:20byte => 101bit
        #候选方案癸:20byte => 112bit
    末层 最短 3byte => 4+3*6==22bit
        开销2byte，共5byte # 接力4byte
        #utf8_ext:5byte => 26bit
    [n:=总字节数]:
        [5*n+1==4+(n-2)*6]
            <==>[n==9]
    在9byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        9-2-3==4
        此时 第一层 负载值为4
        也就[0..<4]即5byte,6byte,7byte,8byte这4种情况，效率不及utf8_ext
            #兼容区:4byte => 21bit == 21bit
            5byte => 26bit > 22bit
            6byte => 31bit > 28bit
            7byte => 36bit > 34bit
            8byte => 41bit > 40bit
            9byte => 46bit == 46bit
            #9-4-1==4==比utf8_ext多用的爻元数==爻元数纟第一层
#######
1111_1100 10bb_bbbb ... 共3凡层，第一层占6bit(特设)
    最长:
        第二层:
            2**6-1==63byte
            63*6==378bit
        第三层/末层:
            2**378-1==非常大byte
    末层 最长 非常大byte => 非常大*6==非常大bit
        开销(2+63)=65byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:18+1==19byte
        第二层:需bit_length(19)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 19byte => 19*6==114bit
        开销(2+1)=3byte，共22byte # 跳过21byte{少字节仍优于utf8_ext}
        #utf8_ext:22byte => 111bit < 114bit
        #utf8_ext:21byte => 106bit
        #候选方案癸:20byte => 112bit
#######
『候选方案癸:[4byte~9byte]低谷期』
    在9byte时 才追平utf8_ext的效率，此后，一直『候选方案癸』更优
    [21bit..41bit~46bit]，影响32bit(发现都得7byte，等效于没影响)
        #utf8_ext:7byte => 36bit > 34bit
    [21bit..41bit~46bit]，不影响32bit,64bit,128bit
候选方案癸 vs utf8_ext:end
]]
######################
######################
[[
候选方案庚:begin:
『候选方案丁:2凡层.第一层 未对齐』 => 候选方案庚:改版{候选方案丁}:后撤 保留区 && 『2凡层.第一层』的4bit尾部对齐躯胞边界:13+1 兼容utf8_ext.14byte(负载71bit)
1111_1111 1011_1111 100b_bbbb ...{11byte} 依旧使用utf8_ext方案
    14==3+11
之后:1111_1111 1011_1111 101b_bbbb ...
    * 1111_1111 1011_1111 101c_cbbb ... 超凡层
    * 1111_1111 1011_1111 1011_1bbb ... 庚保留区{>=3byte{3bit}}
1111_1111 1011_1111 101c_cbbb ... 超凡层
    # [cc =!= 11]
    # [cc <- {0b, 10}]
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载71bit，相当于11.x躯胞，所以下面一开始 偏移12
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==5]时，偏移量才非零
    * 1111_1111 1011_1111 1010_bbbb ... 共2凡层，第一层占4bit(偏移+12)
    ######################
    ####此处 插入 保留区 1011_1bbb:导致 『3凡层』诸后 动态爻元中间多出一个0:
    ######################
    * 1111_1111 1011_1111 1011_00bb ... 共3凡层，第一层占2bit
    * 1111_1111 1011_1111 1011_010b ... 共4凡层，第一层占1bit
    * 1111_1111 1011_1111 1011_0110 ... 共5凡层，第一层占0bit(偏移+1)
    * 1111_1111 1011_1111 1011_0111 100b_bbbb ... 共6凡层，第一层占5bit
    * 1111_1111 1011_1111 1011_0111 1010_bbbb ... 共7凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1011_1111 1011_0111 1011_1110 ... 共11凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案庚:end
]]
[[
候选方案庚 vs utf8_ext:begin:
#######
1111_1111 1011_1111 1010_bbbb ... 共2凡层，第一层占4bit(偏移+12)
    最长:
        第二层/末层:
            2**4-1==15byte
            12+15==27byte
    末层 最长 27byte => 27*6==162bit
        开销3byte，共30byte
        #utf8_ext:30byte => 151bit
        #候选方案庚:30byte => 162bit
    末层 最短 12byte => 12*6==72bit
        开销3byte，共15byte # 接力14byte
        #utf8_ext:15byte => 76bit > 72bit
    [n:=总字节数]:
        [5*n+1==(n-3)*6]
            <==>[n==19]
    在19byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        19-3-12==4
        此时 第一层 负载值为4
        也就[0..<4]即15byte,16byte,17byte,18byte这4种情况，效率不及utf8_ext
            #兼容区:14byte => 71bit == 71bit
            15byte => 76bit > 72bit
            16byte => 81bit > 78bit
            17byte => 86bit > 84bit
            18byte => 91bit > 90bit
            19byte => 96bit == 96bit
            #19-14-1==4==比utf8_ext多用的爻元数==爻元数纟第一层
#######
1111_1111 1011_1111 1011_00bb ... 共3凡层，第一层占2bit
    最长:
        第二层:
            2**2-1==3byte
            3*6==18bit
        第三层/末层:
            2**18-1==262143byte ~= 2.6*10**5
    末层 最长 262143byte => 262143*6==1572858bit
        开销(2+3)=6byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:27+1==28byte
        第二层:需bit_length(28)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 28byte => 28*6==168bit
        开销(3+1)=4byte，共32byte # 跳过31byte{少字节仍优于utf8_ext}
        #utf8_ext:32byte => 161bit < 168bit
        #utf8_ext:31byte => 156bit
        #候选方案庚:30byte => 162bit
#######
『候选方案庚:[14byte~19byte]低谷期』
    在19byte时 才追平utf8_ext的效率，此后，一直『候选方案庚』更优
候选方案庚 vs utf8_ext:end
]]


######################
######################
[[
候选方案辛:begin:
『候选方案丁:2凡层.第一层 未对齐』 => 候选方案辛:改版{候选方案丁}:后撤 保留区 && 『2凡层.第一层』的4bit尾部对齐躯胞边界:13-5 兼容utf8_ext.8byte(负载41bit)
1111_1111 100b_bbbb ...{6byte} 依旧使用utf8_ext方案
    13==2+6
之后:1111_1111 101b_bbbb ...
    * 1111_1111 101c_cbbb ... 超凡层
    * 1111_1111 1011_1bbb ... 辛保留区{>=2byte{3bit}}
1111_1111 101c_cbbb ... 超凡层
    # [cc =!= 11]
    # [cc <- {0b, 10}]
    首层/第零层/动态爻元 是 超层，表达 凡层数
    非末层的凡层 单位为 躯胞(6bit)
    由于之前已编码负载41bit，相当于6.x躯胞，所以下面一开始 偏移7
        偏移量一般为0
        只有[凡层数==2]或者[凡层数%6==5]时，偏移量才非零
    * 1111_1111 1010_bbbb ... 共2凡层，第一层占4bit(偏移+7)
    ######################
    ####此处 插入 保留区 1011_1bbb:导致 『3凡层』诸后 动态爻元中间多出一个0:
    ######################
    * 1111_1111 1011_00bb ... 共3凡层，第一层占2bit
    * 1111_1111 1011_010b ... 共4凡层，第一层占1bit
    * 1111_1111 1011_0110 ... 共5凡层，第一层占0bit(偏移+1)
    * 1111_1111 1011_0111 100b_bbbb ... 共6凡层，第一层占5bit
    * 1111_1111 1011_0111 1010_bbbb ... 共7凡层，第一层占4bit
    ... ...
    ... ...
    * 1111_1111 1011_0111 1011_1110 ... 共11凡层，第一层占0bit(偏移+1)
    ... ...
    ... ...
候选方案辛:end
]]
[[
候选方案辛 vs utf8_ext:begin:
#######
1111_1111 1010_bbbb ... 共2凡层，第一层占4bit(偏移+7)
    最长:
        第二层/末层:
            2**4-1==15byte
            7+15==22byte
    末层 最长 22byte => 22*6==132bit
        开销2byte，共24byte
        #utf8_ext:24byte => 121bit
        #候选方案辛:24byte => 132bit
    末层 最短 7byte => 7*6==42bit
        开销2byte，共9byte # 接力8byte
        #utf8_ext:9byte => 46bit > 42bit
    [n:=总字节数]:
        [5*n+1==(n-2)*6]
            <==>[n==13]
    在13byte时 才追平utf8_ext的效率
        #总字节数-头部开销字节数-末层.最短
        13-2-7==4
        此时 第一层 负载值为4
        也就[0..<4]即9byte,10byte,11byte,12byte这4种情况，效率不及utf8_ext
            #兼容区:8byte => 41bit == 41bit
            09byte => 46bit > 42bit
            10byte => 51bit > 48bit
            11byte => 56bit > 54bit
            12byte => 61bit > 60bit
            13byte => 66bit == 66bit
            #13-8-1==4==比utf8_ext多用的爻元数==爻元数纟第一层
#######
1111_1111 1011_00bb ... 共3凡层，第一层占2bit
    最长:
        第二层:
            2**2-1==3byte
            3*6==18bit
        第三层/末层:
            2**18-1==262143byte ~= 2.6*10**5
    末层 最长 262143byte => 262143*6==1572858bit
        开销(2+3)=5byte，共...byte
        #utf8_ext:不用比了，5/8 比 6/8
    合理最短:
        # !! 『3凡层.末层.合理最短』 比『2凡层.末层.最长』多1byte
        第三层/末层:22+1==23byte
        第二层:需bit_length(23)=5bit < 6bit == 1躯胞 => 1byte
    末层 合理最短 23byte => 23*6==138bit
        开销(2+1)=3byte，共26byte # 跳过25byte{少字节仍优于utf8_ext}
        #utf8_ext:26byte => 131bit < 138bit
        #utf8_ext:25byte => 126bit
        #候选方案辛:24byte => 132bit
#######
『候选方案辛:[8byte~13byte]低谷期』
    在13byte时 才追平utf8_ext的效率，此后，一直『候选方案辛』更优
候选方案辛 vs utf8_ext:end
]]

######################
######################
[[
对比:各候选方案:
    候选方案甲:失败
        甲保留区{>=1byte{2bit}}
    候选方案乙
        乙保留区{>=3byte{5bit}}
    候选方案丙:失败
        丙保留区{>=3byte{4bit}}
    候选方案丁
        丁保留区{>=3byte{4bit}}
    候选方案戊
        戊保留区{>=2byte{5bit}}
    候选方案己
        己保留区{>=4byte{5bit}}
    候选方案庚
        庚保留区{>=3byte{3bit}}
    候选方案辛
        辛保留区{>=2byte{3bit}}
    候选方案壬
        壬保留区{>=1byte{2bit}}
    候选方案癸
        癸保留区{>=1byte{1bit}}
]]
[[
候选方案辛&候选方案庚 优于 候选方案丁
    不复杂
    同样不影响32bit,64bit,128bit
        『候选方案辛:[8byte~13byte]低谷期』[41bit..61bit~66bit];辛保留区{>=2byte{3bit}}
        『候选方案丁:[13byte~18byte]低谷期』[66bit..86bit~91bit];丁保留区{>=3byte{4bit}}
        『候选方案庚:[14byte~19byte]低谷期』[71bit..91bit~96bit];庚保留区{>=3byte{3bit}}
    但感觉 辛 更优:越早，后期效率越高;保留区 起步更短

++癸:
候选方案辛 vs 候选方案癸
    癸 更复杂 #雷同于 丁
    同样不影响32bit,64bit,128bit
        『候选方案癸:[4byte~9byte]低谷期』[21bit..41bit~46bit](但不影响32bit);癸保留区{>=1byte{1bit}}
        『候选方案辛:[8byte~13byte]低谷期』[41bit..61bit~66bit];辛保留区{>=2byte{3bit}}
    但感觉 癸 更优:越早，后期效率越高;保留区 起步更短
]]
[[
候选方案戊&候选方案己&候选方案壬 雷同于 候选方案乙
    等同复杂
    都不影响 32bit,64bit,128bit
        『候选方案壬:[4byte~10byte]低谷期』[21bit..46bit~51bit](但不影响32bit);壬保留区{>=1byte{2bit}}
        『候选方案戊:[7byte~13byte]低谷期』[36bit..61bit~66bit];戊保留区{>=2byte{5bit}}
        『候选方案乙:[13byte~19byte]低谷期』[66bit..91bit~96bit];乙保留区{>=3byte{5bit}}
        『候选方案己:[19byte~25byte]低谷期』[96bit..121bit~126bit];己保留区{>=4byte{5bit}}
    #但感觉 戊 更优:越早，后期效率越高;保留区 起步更短
    ++壬:
    但感觉 壬 更优:越早，后期效率越高;保留区 起步更短

]]
[[
候选方案戊vs候选方案辛:
    『候选方案辛:[8byte~13byte]低谷期』[41bit..61bit~66bit];辛保留区{>=2byte{3bit}}
    『候选方案戊:[7byte~13byte]低谷期』[36bit..61bit~66bit];戊保留区{>=2byte{5bit}}
    初感 戊 更优:无需 后撤 保留区，算法更显自然
    后来感觉 辛 更优:无断层，更平滑
]]
[[
++壬:
候选方案壬vs候选方案辛:
    『候选方案壬:[4byte~10byte]低谷期』[21bit..46bit~51bit](但不影响32bit);壬保留区{>=1byte{2bit}}
    『候选方案辛:[8byte~13byte]低谷期』[41bit..61bit~66bit];辛保留区{>=2byte{3bit}}
    辛:无断层，更平滑
    壬:越早，后期效率越高;保留区 起步更短
    算法实现难度:辛 更简单
    #######
若顾虑保留区，则 壬 更佳
若顾虑算法实现难度&数据存储效率，则 辛 更佳
]]
[[
++壬:
++癸:
候选方案壬vs候选方案辛vs候选方案癸:
    『候选方案壬:[4byte~10byte]低谷期』[21bit..46bit~51bit](但不影响32bit);壬保留区{>=1byte{2bit}}
    『候选方案癸:[4byte~9byte]低谷期』[21bit..41bit~46bit](但不影响32bit);癸保留区{>=1byte{1bit}}
    『候选方案辛:[8byte~13byte]低谷期』[41bit..61bit~66bit];辛保留区{>=2byte{3bit}}
    辛:无断层，更平滑
    癸:无断层，但极小数据效率比不上 辛;保留区 起步 比 辛 更短
    壬:有断层，极小数据效率比不上 辛&癸(但 癸 也只强1bit);越早，后期效率越高;保留区 起步 比 辛 更短
    算法实现难度:辛 更简单；壬 癸 差不多
    #######
若顾虑算法实现难度&数据存储效率，则 辛 更佳
若折衷，则 癸
若顾虑保留区，则 壬 更佳
  考虑到 癸 只比 壬 强1bit
  辛保留区 起步 多了1byte
  我更偏好 壬
<<==:
极小数据效率:utf8_ext (>=) 辛 (>=而后<=) 癸 (>=) 壬
<<==:
#######
辛:
    #兼容区:8byte => 41bit == 41bit
    09byte => 46bit > 42bit
    10byte => 51bit > 48bit
    11byte => 56bit > 54bit
    12byte => 61bit > 60bit
    13byte => 66bit == 66bit
#######
壬:
    #兼容区:4byte => 21bit == 21bit
    5byte => 26bit > 跳过！
    6byte => 31bit > 27bit
    7byte => 36bit > 33bit
    8byte => 41bit > 39bit
    9byte => 46bit > 45bit
    10byte => 51bit == 51bit
#######
癸:
    #兼容区:4byte => 21bit == 21bit
    5byte => 26bit > 22bit
    6byte => 31bit > 28bit
    7byte => 36bit > 34bit
    8byte => 41bit > 40bit
    9byte => 46bit == 46bit
#######
极小数据效率:utf8_ext (>=) 辛 (>=而后<=) 癸 (>=) 壬
04byte=>21bit ==21bit ==21bit ==21bit
05byte=>26bit ==26bit > 22bit > 跳过
06byte=>31bit ==31bit > 28bit > 27bit
07byte=>36bit ==36bit > 34bit > 33bit
08byte=>41bit ==41bit > 40bit > 39bit
09byte=>46bit > 42bit < 46bit > 45bit ==46bit

10byte=>51bit > 48bit < 51bit ==51bit
11byte=>56bit > 54bit < 56bit ==56bit
12byte=>61bit > 60bit < 61bit ==61bit
13byte=>66bit ==66bit ==66bit ==66bit
#######
]]
######################
######################
==>>:最优:{候选方案辛,候选方案壬{偏好},候选方案癸}
]]]]]
