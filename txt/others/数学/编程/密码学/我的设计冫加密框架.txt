
e others/数学/编程/密码学/我的设计冫加密框架.txt
我的:
  工作模式纟块型加密器冫半掩模式:goto
  工作模式纟块型加密器冫多遍循环半掩模式:goto
  部分工作模式纟块型加密器冫预填充模式:goto

[[
confusion+diffusion
  confusion:混淆/模糊
  diffusion:扩散/散布/铺散/弥漫
==>>:
diffusion:循环对抗赛配对
  #view script/循环对抗赛配对方案20240313.py
  view ../../python3_src/seed/algo/round_robin_schedule.py
  见下面:最快扩散方式冫车轮战:goto

confusion:非线性置换
  三爻元密钥纟二爻元置换:goto
  四爻元密钥纟二爻元置换:goto
  十五爻元密钥纟三爻元置换:goto
]]
[[[[[
循环对抗赛配对
view ../../python3_src/seed/algo/round_robin_schedule.py
单层扩散:O(N**2)
太大的话，就拆分成:组内循环+组间循环
  小组循环赛:group round robin
  intragroup:adj. 社会团体内部的,社会团体成员之间的
  intergroup:adj. 社会团体间的,种族团体间的

摘要:
  + 单轮调度牜先组间再组内纟幂方完全扩散:goto
  + 用归纳法证明冫配对计数公式:goto
  + 最快扩散方式冫车轮战:goto
    + 最快扩散方式冫循环半掩:goto
  + 密钥充分利用牜方案一冫细嚼慢咽:goto
  + 密钥充分利用牜方案二冫囫囵鲸吞:goto
[[
单轮扩散: 单层扩散-->两层扩散-->多层扩散
  [g1(k) =[def]= k*(k-1)/2]
  [g2(k0,k1) =[def]= k0*k1*(k0+k1-2)/2]
  [g3(k0,k1,k2) =[def]= (k012*(k0+k1+k2-3)/2)]

  #单层扩散
  [N%2==0]:
    (N*(N-1)/2)
    == g1(N)
  -->
  #两层扩散
  [N==N0*N1==N01][gcd(N0,N1)%2==0]:
      (g1(N0)*N01/N0+N0*g1(N1))
      == (N0*(N0-1)/2*N01/N0+N0*N1*(N1-1)/2)
      == (N01*(N0-2+N1)/2)
      == g2(N0,N1)
  -->
  #多层扩散
  #三层扩散
  [N==N0*N1*N2==N012][gcd(N0,N1,N2)%2==0]:
      (g1(N0)*N012/N0+N0*g2(N1,N2))
      == (N0*(N0-1)/2*N012/N0+N0*(N12*(N1-2+N2))/2)
      == (N012*(N0+N1+N2-3)/2)
      == g3(N0,N1,N2)
  ==>>:
      II*(SUM-NUM_LAYERS)/2
      == N*(SUM-L)/2
      [个人每轮总对抗次数==(sum(Ns)-len(Ns))]
      [每轮总对抗次数==II(Ns)*(sum(Ns)-len(Ns))/2]
      见下面:用归纳法证明冫配对计数公式:goto
  -->
  #多层扩散
  #二幂完全扩散
  [N==2**L]:
      N*(2*L-L)
      ==N*L
      ==N*log2(N)
  #幂方完全扩散
  单轮调度牜先组间再组内纟幂方完全扩散:here
  [单轮调度(f,L;ls) :: @[Z>=1] -> ([a]{len==Z} -> [a]{len==Z}) -> @[L>=1] -> ([a]{len==Z**L} -> [a]{len==Z**L})]
  [Z>=1][f :: [a]{len==Z} -> [a]{len==Z}][L>=1][ls :: [a]{len==Z**L}]:
    [单轮调度(Z,f,L;ls) =[def]= f(ls) if L==1 else let [H:=Z**(L-1)] in (chain . map (\_ls->单轮调度(f,H;_ls)) . transpose H Z . map f . transpose Z H $ cut H ls)]
      #先组间再组内
]]



用归纳法证明冫配对计数公式:here
[[
[j>=1][ks :: [pint]{len=j}][K:=II(ks)]:
  [g[1](k0) =[def]= k0*(k0-1)/2]
  [j>=2]:
      [g[j](*ks) =[def]= (g1(ks[0])*K/ks[0]+k0*g[j-1](*ks[1:]))]
        即:[域内配对:=分区循环配对*区际串行对抗+并行分区*区内配对]

[[j>=1][ks :: [pint]{len=j}] -> [g[j](*ks) == II(ks)*(sum(ks)-j)/2]]
    配对计数公式:here
    证明:
    *[j==1]:
        [g[1](k0) == k0*(k0-1)/2 == II([k0])*(sum([k0])-j)/2]

    *[j>=2][g[j-1](*ks[1:]) == II(ks[1:])*(sum(ks[1:])-(j-1))/2]:
        [g[j](*ks)
        == (g1(ks[0])*II(ks)/ks[0]+ks[0]*g[j-1](*ks[1:]))
        == (ks[0]*(ks[0]-1)/2*II(ks)/ks[0]+ks[0]*II(ks[1:])*(sum(ks[1:])-(j-1))/2)
        == (II(ks)*(ks[0]-1)/2+II(ks)*(sum(ks[1:])-(j-1))/2)
        == II(ks)*((ks[0]-1)+(sum(ks[1:])-(j-1)))/2
        == II(ks)*(sum(ks)-j)/2
        ]
]]

[[
上述使用:[域内配对:=分区循环配对*区际串行对抗+并行分区*区内配对]
  但这样一来，意味着 某人乊某分区 只与他区某人 对抗一次
      [个人每轮总对抗次数==(sum(Ns)-len(Ns))]
  究竟得几轮才能将自身的影响扩散到整域？
      根深蒂固，盘根错节
  这么说吧:有限无向连通图如何同时减少边数辻最长点距并保持连通性？
    # [不连通=>最长点击无限大]
    [最小边数{多点连通图}==(N-1)]
      =>树
    [最小最长点距{多点连通图}==1]
      =>完全图
    [最长点距{完全图}==1] 但 [边数{完全图}==N*(N-1)/2]
    [最长点距{星形树}==2][边数{星形树}==(N-1)]
    =>星形树 最优化
  =>最快扩散方式冫车轮战:它节点流水配对首节点，只需两轮便完成单向扩散(或者 首末交替作为中心乊各轮)，只需四轮便完成反馈扩散
      最快扩散方式冫车轮战:here
        见:最快扩散方式冫循环半掩:goto
      但是:需得缓存整个灰文
      nonstreamable cipher
  可能存在的毛病:单点联系相当脆弱，因为单点状态空间小，容易被暴力枚举...
  密钥如何有效利用？
    仅作用于首节点，有效密钥长度就变成log2(节点空间规模)
    [灰文 =[def]= 明文变换至密文的任意中间态]
    [灰文 :: [uint%M]{len=T}]
    [密钥 :: [uint%M]{len=Y}]
    [总批数 := S]
    [轮数每批 := R]
    [R >= 4]
    [总轮数==S*R]
    [总配对数==S*R*(T-1)]
  方案一:细嚼慢咽
    密钥充分利用牜方案一冫细嚼慢咽:here
    1.一点点充分消化吸收=>每批次只使用一个密钥胞加密灰文首胞，然后使用『最快扩散方式冫车轮战』多轮轰炸灰文首胞
    2.多批次直到密钥耗尽
    for 密胞 in 密钥:
        灰文[0] +%= 密胞
        for _ in [0..<轮数每批]:
            单轮轰炸首胞(灰文)
        灰文[0] +%= ~密胞
        #颠倒折返
        灰文.reverse()
    [S:=Y]
    [总批数==Y]
    [总轮数==Y*R]
    [总配对数==Y*R*(T-1)]
    ==>>:
    [总耗时:=(Y*R*(T-1)*配对加密耗时)]
    O(Y*R*T*配对加密耗时)
  方案二:囫囵鲸吞
    密钥充分利用牜方案二冫囫囵鲸吞:here
    『方案一:细嚼慢咽』有点久，考虑到所需只是将密钥充分融入到灰文中，可以一次性将密钥加到灰文中(假设灰文更长)
    为了避免密钥泄露，总批数必须足够大。
        但是多少算大呢？log2(Y)? log2(T)? 或许 应该使用 伪随机数生成器 产生任意长密钥，然后截取片段
    #[Y <= T]:
    [1 <= _Y_ <= T][f :: uint%S -> [uint%M]{len=Y} -> [uint%M]{len=_Y_}]:
        for i in [0..<总批数]:
          灰文 +%= f(i;密钥)
          for j in [0..<轮数每批]:
            单轮轰炸首胞(灰文)
          灰文 +%= ~f(i;密钥)
          #颠倒折返
          灰文.reverse()
        灰文 +%= f(总批数;密钥)
        ==>>:
        [总耗时==(S*R*(T-1)*配对加密耗时+S*密钥变换耗时)]
        O(S*T*R*配对加密耗时*(1+密钥变换耗时/T/R/配对加密耗时))
        比如:
        [f(i;j) =[def]= i+j]:
            [密钥变换耗时==O(Y*log2(M))]
        比如:
        [f(i;j) =[def]= (-1+M*i)*j%M**Y]
            [密钥变换耗时==O((Y*log2(M))**2)]
        [密钥变换耗时 <= Y*R*配对加密耗时]:
            !! [Y <= T]
            O(S*R*T*配对加密耗时)
]]
]]]]]


密钥即是算法，算法即是密钥
密钥即是置换，置换即是密钥
  置换的数量即是密钥的数量
  但是某些置换看起来更随机更安全
  如何有效地将置换用密钥表达出来？
    <==>如何从密钥中解读出有效的置换？
[[
Nonce = number only used once

Nonce怎么翻译？
  ？一次性辅助码？
  ？一次性噪声码？
  ？一次性增熵码？
  ？增熵码？
  ？熵数？
  ？临时码？
entropy熵
<<==:
21世纪英汉汉英双向词典
nonce
<<名词>>
◆常用于下列成语
for the nonce ((文语))目前,暂时,临时地
<<形容词>>
‘文法’ <字、句等> 临时的,限于当时的
a ~ noun [verb]
临时名词
a ~ word
临时字
在线英汉－汉英词典
n. 目前；特定场合；[俚]强奸犯 adj. 临时的；特定场合的
===
]]

[[[
另类Nonce
===
Nonce另类用法:用于声明前后加密算法
  目的在于:阻止了 核心加密算法 的 (明文,密文) 泄露
  泄露的只能是 (后加密算法<<<核心加密算法<<<前加密算法) 的 (明文,密文)
===
固化:核心加密算法
输入:
  Nonce := 随机选择:(前加密算法,后加密算法)
  明文
  密钥
输出:
  Nonce
  密文 := 后加密算法(密钥;核心加密算法(密钥;前加密算法(密钥;明文)))
===
]]]
[[[
更新Nonce以防重用:
  原:加密扌(密钥;Nonce,明文) -> (Nonce,密文)
  改:[Nonce2:=摘要扌(密钥;Nonce,?明文?)] => 加密扌(密钥;Nonce2,明文) -> (Nonce2,密文)
===
]]]



[[[
工作模式纟块型加密器冫半掩模式:here
工作模式纟块型加密器冫多遍循环半掩模式:here
考虑改名:半掩-->鳞叠
===
半掩模式:
  象形:『/////』
  就像揉面蒸馒头，每次留下些酵头
  这样一来就造成了回溯性影响
    但也导致解密时必须从后往前解密#缓存=>空间占用
    弊端冫不能流水作业
===
(明文半块组[0],明文半块组[1]) --[块型加密]-> (密文半块组[0],灰文半块组[1])
(灰文半块组[1],明文半块组[2]) --[块型加密]-> (密文半块组[1],灰文半块组[2])
...
(灰文半块组[T-2],明文半块组[T-1]) --[块型加密]-> (密文半块组[T-2],灰文半块组[T-1])
密文半块组[T-1] := 灰文半块组[T-1]
===
多遍循环半掩模式
  即 上一遍 灰文半块组[T-1] 置于 下一遍 灰文半块组[0] 之前
前面的『最快扩散方式冫车轮战』也可以改为『最快扩散方式冫循环半掩』
  最快扩散方式冫循环半掩:here
===
发酵曲子
leaven
《源自拉丁文“举起者”的意思》
<<名词>>
1 (U)
a. (留下来作下一炉面包酦酵用的) 酦酵的面团
b. 酦酵素,酵母
c. 酦粉
2 具有感化[影响]作用之物,潜力
===
===
]]]
[[[
部分工作模式纟块型加密器冫预填充模式:here
预填充模式
要求:明文全长在开始加密前已知
最少填充需求:至多填充一块，至少填充一胞(不太行:必须得是大胞，1爻元的话递推开就变成动态爻元计数，没有空闲安插随机爻元)
  若依安全计，该填充更多
  与『「1000」尾填充』 不同，不使用雷同的『「0001」预填充』，而是使用『整数的后刹变长爻元编码』来编码『无效爻元串长度』
  空闲爻元串 填充 随机爻元
    在头部填充随机数，避免被发现相同头块
===
]]]



























uint%N 双射:类陪集最短非空路径
[M, N :: uint][0 < N < 2*N <= M][i, o :: uint%N][(K,R) := M/%N][ki, ko :: uint%K][fs :: [(uint%M -> uint%M)]]:
  [M == R+K*N]
  def vs:
    [vs[0] := i+ki*N]
    [vs[j+1] := fs[j](vs[j])]
  [t := min {j | [[j :<- [1..]][ko == vs[j] //N ]]}]
    # [t:不确定大小]
  [o := vs[t] -ko*N]



(uint%2)**L 双射:选择性部分就地变换+使用输入密钥与未选中部分作为总密钥
[L :: uint][L >= 2][eL := floor_log2(L)][I,O :: (uint%2)**L == [(0|1)]{len==L}][encrypt{H,L-H} :: (key{encrypt},(uint%2)**(L-H)) -> ((uint%2)**H -> (uint%2)**H)][permute{L} :: key{permute} -> permutation{L}/((uint%2)**L -> (uint%2)**L)][kf :: [key{encrypt}]][kp :: [key{permute}]]:
    [eL >= 1]
    [2**eL <= L < 2**(eL+1)]
    [2**(eL-1) <= L/2 < 2**eL]
    [H := 2**(eL-1)]
    [H <= L/2 < 2*H]
    [2*H <= L < 4*H]
    [0 <= L-2*H < 2*H]
    [T := L-2*H]
    [0 <= T < 2*H]
    [Xs[0] := I]
    [Ys[j] := permute{fwd}(kp[j]; Xs[j])]
    [Zs[j][:H] := encrypt{fwd}(kf[j],Ys[j][H:L]; Ys[j][:H])]
    [Zs[j][H:L] := Ys[j][H:L](kf[j],; Ys[j][:H])]
    [Xs[j+1] := permute{bwd}(kp[j]; Zs[j])]
    [O := Xs[J]]



单密钥->多密钥
internal_key[k] = hash((external_key, k))
data_key[k] = hash((internal_key[k], unselected_data[k]))
encrypt(data_key[k]; selected_data[k])


块型加密器:
  构造冫超长块型加密器巛小型块型加密器
    #
    bug:循环CBC:尾交换+多轮+变密钥
      #或者 简单地 超长块*N 周期性延展
      !! bug <<== 隐性状态必须出现在灰文中否则不可逆#灰文=明文至密文的任意中间态
      由于 多余的隐性状态 不存在，所以 同向多轮 没有意义 因为 头块 只是简单的被多加密几次
      => 顺向+逆向 或者 顺向+乱序+顺向
    第一轮:CBC尾交换{固定初始值,变密钥}=>同长块牜第一轮密文
    第二轮:固定乱序置换>>>CBC尾交换{固定初始值,变密钥}=>同长块牜第二轮密文
    ...
    一轮=>广度
    多轮=>深度
    为何CBC不如此？
      *尾交换:
          早有，但少用的原因大概是代码不优雅，需得缓存『前一块密文』直到确认『下一块 是否 末块』。
      *多轮:
          双方需得 缓存 整份明文/整份密文，空间时间开销大
          不太匹配 流作业模式
          但是 一轮的迭代 相当不安全，不论对于 块型加密器 还是 散列摘要器 而言
            #只靠一个中间状态 单向联系，容易被糊弄
      *变密钥:
          密钥 可变否？未必所有密钥都可变
          等价于 一个 不同于 前一块密文 的 隐性状态

  注意:最小的块型加密器纟爻元串
    [置换数量巛爻元串长扌(L) == factorial(2**L)]
    view others/数学/编程/密码学/xor泛化版异或.txt
    1爻元=>2加密算法    #(2**1)!
    2爻元=>24加密算法   #(2**2)!
    3爻元=>40320加密算法   #(2**3)!
三爻元密钥纟二爻元置换
  +2:(8, (3, 1))
四爻元密钥纟二爻元置换
  #对立互补
  +1:(6, (4,))
  +3:(3, (2, 2))
  +4:(6, (2, 1, 1))
  +5:(1, (1, 1, 1, 1))

十二爻元密钥纟三爻元置换
  +9:(3360, ((4, 1), (3, 1), (1, 1)))
  +12:(420, ((4, 1), (1, 4)))
  +18:(105, ((2, 4),))
  +20:(210, ((2, 2), (1, 4)))
  +22:(1, ((1, 8),))
十五爻元密钥纟三爻元置换
  -2:(5760, ((7, 1), (1, 1)))
  -15:(1680, ((3, 1), (2, 2), (1, 1)))
  -17:(112, ((3, 1), (1, 5)))
<<==:
view ../../python3_src/seed/math/uint_partition.py
>>> factorial(8) -2**15   -sum([5760, 1344, 420, 28])
0
>>> factorial(8) -2**15   -sum([5760, 1260, 112, 420])
0
>>> factorial(8) -2**15   -sum([5760, 1680, 112])
0

###>>> show2(8, to_expand=False)
#1:(5040, ((8, 1),))
2:(5760, ((7, 1), (1, 1)))
7:(1344, ((5, 1), (1, 3)))
8:(1260, ((4, 2),))
10:(1260, ((4, 1), (2, 2)))
12:(420, ((4, 1), (1, 4)))
15:(1680, ((3, 1), (2, 2), (1, 1)))
17:(112, ((3, 1), (1, 5)))
19:(420, ((2, 3), (1, 2)))
21:(28, ((2, 1), (1, 6)))


>>> 2**12   -sum([3360, 420, 105, 210, 1])
0

###>>> show2(8, to_expand=False)
#1:(5040, ((8, 1),))
3:(3360, ((6, 1), (2, 1)))
4:(3360, ((6, 1), (1, 2)))
9:(3360, ((4, 1), (3, 1), (1, 1)))
12:(420, ((4, 1), (1, 4)))
18:(105, ((2, 4),))
19:(420, ((2, 3), (1, 2)))
20:(210, ((2, 2), (1, 4)))
22:(1, ((1, 8),))


