呜呼哀哉尚飨加密.py

<pre>
"""
呜呼哀哉尚飨
whazsx.py



==============
简单版
明文：他妈的
加密方选择：
	协议：呜呼哀哉尚飨
	密码提示：一蓑/烟雨/任平生
密码：哀烟雨哉
假设：$X$=呜呼哀哉尚飨.加密&lt;哀烟雨哉&gt;(他妈的)
密文：呜呼一蓑$X$任平生尚飨
解密方识别：
	#此处需人工识别或自动引用搜索结果
	呜呼，一蓑，任平生，尚飨
	=&gt;协议：呜呼哀哉尚飨
	=&gt;密码提示：一蓑/烟雨/任平生
	他妈的=呜呼哀哉尚飨.解密&lt;哀烟雨哉&gt;($X$)



def 呜呼哀哉尚飨.gen_byte_mask(key::bytes, L):
	global _hash_, _n_, _k0_
	k = _k0_
	for i in range(_n_):
		k = _hash_(k+key)
	ks = []; sz = 0
	for i in range(L):
		i = str(i).encode('utf8')
		k = _hash_(k+key+i)
		ks.append(k)
		sz += len(k)
		if sz &gt;= L:
			kk = b''.join(ks)
			kk = kk[:L]
			break
	else:
		raise logic-error
	return kk
def 呜呼哀哉尚飨.read_prefix_ex(it):
	global _random_bytes_arg_
	read till (prefix[-2]-prefix[-1])%256 &lt; _random_bytes_arg_
def 呜呼哀哉尚飨.mk_random_prefix():
def 呜呼哀哉尚飨.加密&lt;key&gt;(txt):
	global _zh_char256_
	bs = 呜呼哀哉尚飨.mk_random_prefix()
	key = key.encode('utf8')
	txt = txt.encode('utf8')
	L1 = len(txt)
	L2 = len(bs)+len(txt)
	kk1 = 呜呼哀哉尚飨.gen_byte_mask(bs, L1)
	kk2 = 呜呼哀哉尚飨.gen_byte_mask(key, L2)
	txt = kk1 xor txt
	mmm = kk2 xor (bs+txt)
	mmm = ''.join(_zh_char256_[b] for b in mmm)
	return mmm
def 呜呼哀哉尚飨.解密&lt;key&gt;(mmm):
	global _zh_char2idx_
	mmm = bytes(_zh_char2idx_[ch] for ch in mmm)
	L2 = len(mmm)
	key = key.encode('utf8')
	kk2 = 呜呼哀哉尚飨.gen_byte_mask(key, L2)
	bs = kk2 xor mmm
	bs,txt = 呜呼哀哉尚飨.read_prefix_ex(bs)
	txt = bytes(txt)
	L1 = len(txt)
	kk1 = 呜呼哀哉尚飨.gen_byte_mask(bs, L1)
	txt = kk1 xor txt
	txt = txt.decode('utf8')
	return txt


"""


import hashlib
import random

def sha256(bs):
	m = hashlib.sha256()
	m.update(bs)
	return m.digest()

def without_spaces(s):
	s = s.strip()
	if has_space(s):raise eee
	return s
def has_space(s):
	ls = s.split()
	return len(ls) &gt; 1
def 呜呼哀哉尚飨加解密(要解密, 密码提示, 文):
	f = 呜呼哀哉尚飨解密 if 要解密 else 呜呼哀哉尚飨加密
	return f(密码提示, 文)
def 呜呼哀哉尚飨加密(密码提示, 明文):
	'密码提示 eg "一蓑/烟雨/任平生"'
	密码提示 = without_spaces(密码提示)
	init, mid, tail = 密码提示.split('/')
	密码 = f'哀{mid}哉'
	载荷 = 呜呼哀哉尚飨.加密(密码, 明文)
	密文 = f'呜呼{init}{载荷}{tail}尚飨'
	if 明文 != 呜呼哀哉尚飨解密(密码提示, 密文): raise eee
	return 密文
def 呜呼哀哉尚飨解密(密码提示, 密文):
	'密码提示 eg "一蓑/烟雨/任平生"'
	密码提示 = without_spaces(密码提示)
	密文 = without_spaces(密文)
	init, mid, tail = 密码提示.split('/')
	密码 = f'哀{mid}哉'
	hh,tt = f'呜呼{init}', f'{tail}尚飨'
	if len(密文) &lt; len(hh)+len(tt): raise eee
	if not 密文.startswith(hh): raise eee
	if not 密文.endswith(tt): raise eee
	载荷 = 密文[len(hh):-len(tt)]
	明文 = 呜呼哀哉尚飨.解密(密码, 载荷)
	return 明文

def xor_bytes(lhs, rhs):
	if len(lhs) != len(rhs): raise eee
	return bytes(a^b for a,b in zip(lhs,rhs))


class 呜呼哀哉尚飨:
	_hash = sha256
	_random_bytes_arg = 8
	_n = 2**16
	_k0 = bytes(range(2**8))
	_zh_char256 = "竺笙翊釉宸潼徇礁僖臾泗瑾羲渥拷壕脯壑瑛孺熄瑚琶斡渤爰甄恁苔芍嗔偈褥痰裨舷磐勺簪蟠橡嫦逋珀佃夙濠肪枷剔薇椿蹙茄涓溥衢茸翌窒穹蛾卞衾陟琵菁雉猝曙酵邯懋眸曷瀑焙悸蛭珂揆瑁喙陂淙舫斫麝燮桔愆庠跛黍佚癖蹇曦湍蒜磬珥橙娑怏暹瓢逡嵋跏燧昴疵爻麒橄寤幄胛淞滓狎窈湫帑芹拌荻嬖盂碇燔倨皿瘠蚌祉淅洵楹秧咫筮蚣瞑攫悌跣趺褶灸樟魃倬翡傀殄岬菽俳槁蒿羸侏裟暝袈痘俑稔畛粕翕濂甑蜈葺柑楔椽匐樗嵬溟噫蔗琥匍碣嗾纛禳醵艮戡萸瓠雎槿侑枋肄暾慝梏楮檎汐豌蕨逑桎枳楸慊螟佶畦稗酊圄菖揄孱疥蓍蹉痍枸枇茯廛猊酩荏擘苒眄茱痂篁腱膈筌埴醍柝酎莪疝茴堀檗疳蒡嚆"
	assert len(_zh_char256) == 2**8
	_zh_char2idx = {ch:i for i,ch in enumerate(_zh_char256)}
	assert len(_zh_char2idx) == 2**8
	#######
	@classmethod
	def read_prefix_ex(呜呼哀哉尚飨, it):
		#Iter int -&gt; (bs, Iter int)
		#global _random_bytes_arg_
		it = iter(it)
		bbb = 呜呼哀哉尚飨._random_bytes_arg_()
		b = 256
		def is_bad(x,y):
			return (x-y)%b &lt; bbb
		for r0 in it:break
		ls = [r0]
		for r1 in it:
			ls.append(r1)
			if is_bad(r0,r1):break
			r0 = r1
		return bytes(ls), it
	@classmethod
	def mk_random_prefix(呜呼哀哉尚飨):
		#-&gt;bs
		f = random.randrange
		b = 256
		def mk():
			while 1:
				yield f(b)
		it = mk()
		prefix, _ = 呜呼哀哉尚飨.read_prefix_ex(it)
		return prefix
	@classmethod
	def _random_bytes_arg_(呜呼哀哉尚飨):
		return 呜呼哀哉尚飨._random_bytes_arg
	@classmethod
	def _hash_(呜呼哀哉尚飨, bs):
		return 呜呼哀哉尚飨._hash(bs)
	@classmethod
	def _zh_char256_(呜呼哀哉尚飨):
		return 呜呼哀哉尚飨._zh_char256
	@classmethod
	def _zh_char2idx_(呜呼哀哉尚飨):
		return 呜呼哀哉尚飨._zh_char2idx
	@classmethod
	def _n_(呜呼哀哉尚飨):
		return 呜呼哀哉尚飨._n
	@classmethod
	def _k0_(呜呼哀哉尚飨):
		return 呜呼哀哉尚飨._k0
	@classmethod
	def gen_byte_mask(呜呼哀哉尚飨, key:bytes, L):
		#bs-&gt;uint-&gt;bs{len}
		#global _hash_, _n_, _k0_
		_hash_ = 呜呼哀哉尚飨._hash_
		_n_ = 呜呼哀哉尚飨._n_()
		_k0_ = 呜呼哀哉尚飨._k0_()
		#key = key.encode('utf8')
		k = _k0_
		for i in range(_n_):
			k = _hash_(k+key)
		ks = []; sz = 0
		for i in range(L):
			i = str(i).encode('utf8')
			k = _hash_(k+key+i)
			ks.append(k)
			sz += len(k)
			if sz &gt;= L:
				kk = b''.join(ks)
				kk = kk[:L]
				break
		else:
			raise logic-error
		return kk
	@classmethod
	def salt_encrypt(呜呼哀哉尚飨, encrypt, key, txt):
		#(bs -&gt; bs -&gt; bs) -&gt; bs -&gt; bs -&gt; bs
		bs = 呜呼哀哉尚飨.mk_random_prefix()
		txt = encrypt(bs, txt)
		mmm = encrypt(key, bs+txt)
		return mmm
	@classmethod
	def salt_decrypt(呜呼哀哉尚飨, decrypt, key, mmm):
		#(bs -&gt; bs -&gt; bs) -&gt; bs -&gt; bs -&gt; bs
		bs_txt = decrypt(key, mmm)
		bs,txt = 呜呼哀哉尚飨.read_prefix_ex(bs_txt)
		txt = bytes(txt)
		txt = decrypt(bs, txt)
		return txt
	@classmethod
	def symmetry_cipher(呜呼哀哉尚飨, key, txt):
		#bs -&gt; bs -&gt; bs
		L1 = len(txt)
		kk1 = 呜呼哀哉尚飨.gen_byte_mask(key, L1)
		txt = xor_bytes(kk1, txt)
		return txt
	@classmethod
	def 加密(呜呼哀哉尚飨, key, txt):
		#global _zh_char256_
		_zh_char256_ = 呜呼哀哉尚飨._zh_char256_()
		key = key.encode('utf8')
		txt = txt.encode('utf8')
		mmm = 呜呼哀哉尚飨.salt_encrypt(
				呜呼哀哉尚飨.symmetry_cipher
				,key, txt)
		mmm = ''.join(_zh_char256_[b] for b in mmm)
		return mmm
	@classmethod
	def 解密(呜呼哀哉尚飨, key, mmm):
		#global _zh_char2idx_
		_zh_char2idx_ = 呜呼哀哉尚飨._zh_char2idx_()
		key = key.encode('utf8')
		mmm = bytes(_zh_char2idx_[ch] for ch in mmm)
		txt = 呜呼哀哉尚飨.salt_decrypt(
				呜呼哀哉尚飨.symmetry_cipher
				,key, mmm)
		txt = txt.decode('utf8')
		return txt







def main(args=None):
	import common_short_hand
	import argparse
	from seed.io.may_open import may_open_stdin, may_open_stdout

	parser = argparse.ArgumentParser(
		description="呜呼哀哉尚飨加密协议"
		, epilog=""
		, formatter_class=argparse.RawDescriptionHelpFormatter
		)
	parser.add_argument('-u', '--undo_encrypt', action='store_true'
						, default = False
						, help='decrypt')
	parser.add_argument('-d', '--direct_input', action='store_true'
						, default = False
						, help='"--input" is data not path')
	parser.add_argument('key_hint', type=str
						#, required=True
						, help='f"{word}/{word}/{word}"')
	parser.add_argument('-i', '--input', type=str, default=None
						, help='input file path')
	parser.add_argument('-o', '--output', type=str, default=None
						, help='output file path')
	parser.add_argument('-e', '--encoding', type=str
						, default='utf8'
						, help='input/output file encoding')
	parser.add_argument('-f', '--force', action='store_true'
						, default = False
						, help='open mode for output file')
	def read(fin):
		return fin.read()

	args = parser.parse_args(args)
	encoding = args.encoding
	omode = 'wt' if args.force else 'xt'

	may_ifname = args.input
	if args.direct_input and may_ifname is not None:
		txt = may_ifname
	else:
		with may_open_stdin(may_ifname, 'rt', encoding=encoding) as fin:
			txt = read(fin)

	mmm = 呜呼哀哉尚飨加解密(
				要解密=args.undo_encrypt
				, 密码提示=args.key_hint
				, 文=txt
				)
	may_ofname = args.output
	with may_open_stdout(may_ofname, omode, encoding=encoding) as fout:
		#bug: fout.write(mmm)
		print(mmm, file=fout)

def main2(args=None):
	import argparse
	import sys

	parser = argparse.ArgumentParser(
		description="呜呼哀哉尚飨加密协议"
		, epilog=""
		, formatter_class=argparse.RawDescriptionHelpFormatter
		)
	parser.add_argument('-u', '--undo_encrypt', action='store_true'
						, default = False
						, help='decrypt')
	parser.add_argument('-d', '--direct_input', action='store_true'
						, default = False
						, help='"--input" is data not path')
	parser.add_argument('key_hint', type=str
						#, required=True
						, help='f"{word}/{word}/{word}"')
	parser.add_argument('-i', '--input', type=str, default=None
						, help='input file path')
	parser.add_argument('-o', '--output', type=str, default=None
						, help='output file path')
	parser.add_argument('-e', '--encoding', type=str
						, default='utf8'
						, help='input/output file encoding')
	parser.add_argument('-f', '--force', action='store_true'
						, default = False
						, help='open mode for output file')
	def read(fin):
		return fin.read()
	def output(fout, txt):
		#bug: fout.write(mmm)
		print(txt, file=fout)

	args = parser.parse_args(args)
	encoding = args.encoding
	omode = 'wt' if args.force else 'xt'

	may_ifname = args.input
	if args.direct_input and may_ifname is not None:
		txt = may_ifname
	elif may_ifname is None:
		txt = read(sys.stdin)
	else:
		with open(may_ifname, 'rt', encoding=encoding) as fin:
			txt = read(fin)

	mmm = 呜呼哀哉尚飨加解密(
				要解密=args.undo_encrypt
				, 密码提示=args.key_hint
				, 文=txt
				)
	may_ofname = args.output
	if may_ofname is None:
		output(sys.stdout, mmm)
	else:
		with open(may_ofname, omode, encoding=encoding) as fout:
			output(fout, mmm)


if __name__ == "__main__":
	main2()

</pre>

