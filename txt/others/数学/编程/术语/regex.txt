
e others/数学/编程/术语/regex.txt

A regular expression denotes a regular set of strings.

notation:
metasymbol:
  dot .
  bar |
  star *
  parentheses ()
  ==>>:
  positive closure symbol +
    [x+ =[def]= (x . x*)]
  question mark ? #optional
    [x? =[def]= (x | )]
  brackets [] hyphen -

Concatenation
  x . y
Alternation
  x | y
Repetition
  x *
Grouping
  ( x )

FSM (Finite State Machine)
DFA (deterministic finite automaton)
NFA (nondeterministic finite automaton)
  nondeterminisitc Turing machine



BNF
  The formal study of syntax as applied to programming languages took a great step forward in about 1960, with the publication of the Algol 60 report by Naur (1960, 1963), which used an elegant, yet simple, notation known as Backus-Naur-Form (sometimes called Backus-Normal-Form).
formal language theory
  symbol == token
  alphabet :: {symbol}
    A
  phrase == word == string :: alphabet => [symbol<alphabet>]
  null_string == empty_word :: string{len==0}
  closure == Kleene_closure :: alphabet -> {string<alphabet>}
    A*
    [string_set_of_len_ sz alphabet =[def]= {s :: string<alphabet> | [len(s) == sz]}]
    [Kleene_closure alphabet =[def]= \-/~ string_set_of_len_ sz alphabet {sz :<- [0..]}]
  positive_closure :: alphabet -> {string<alphabet>}
    A+
    [positive_closure alphabet =[def]= \-/~ string_set_of_len_ sz alphabet {sz :<- [1..]}]


  language<alphabet> :: {string<alphabet>}
  language<alphabet> |<=| Kleene_closure<alphabet>



algebraic properties of regex:
  A | B = B | A (commutativity for alternation)
  A | ( B | C ) = ( A | B ) | C (associativity for alternation)
  A | A = A (absorption for alternation)
  A · ( B · C ) = ( A · B ) · C (associativity for concatenation)
  A ( B | C ) = A B | A C (left distributivity)
  ( A | B ) C = A C | B C (right distributivity)
  A = A = A (identity for concatenation)
  A * A * = A * (absorption for closure)
      A * * = A *

毛病:
  回溯vs FSM最糟指数级状态空间
    回溯:重复解析前缀
    not LL1

??LL1_regex
