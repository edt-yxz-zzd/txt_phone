
我的术语.txt

e others/数学/编程/术语/我的术语.txt
view ../../python3_src/useful__cjk_naming.txt

######################
txt edit state
  ?TODO
  .DONE
  !WORKING

lambda:
  @All
  ?Some
  &Recur
  \Abstract
  $Let
  [proposition]
  input -> output
  term :: type
  subtype <: type

doc mask:
  『醒目文本』
      普通文本的醒目强调形式
  〖特义词条〗
      被赋予特殊语义的词条
      一般都是已定义/将定义的技术性词条
  【醒目特义词条】
      特义词条的醒目强调形式

file section:
==================================[ZZZ
==================================]ZZZ




包
  互斥并串数据类型
  打包O/拆包O - 串联
  涂装I/卸装O - 并联
  装成O/卸装O - 并联
    装成=涂装+

号/码
  #用于 压缩/解压 运行期 数据
  编号/解号
    #封号/解号？
    #索引？
    编号区 :: {x : 号}
    解号区 :: [x]
    ====
    后置保证：
      号 = 紧致自然数
    前置要求：
      数据 可散列
    空间开销：
      两个容器
  编码/解码
    编码 :: x -> 字节串
    解码 :: 字节串 -> x
    ====
    前置要求：
      数据 特定类型 设计一套编码方案











并行
  拟并行
    并发（concurrency）
  齐并行
    并行（parallellism）

互斥并串数据类型
  inductive data type
    收敛数据类型
  coinductive data type
    发散数据类型


finite state automata FSM
  regex
    并联union
    串联concatation
    闭包closure




编译相关 见：
  e others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt

元语言vs句语言
语法 是 元语言 的 句
句法=句语法=语法
句析器=句法分析器=语法分析器
词析器=词法分析器
降噪


句析器 相关：
  重符 -> 阳符
  轻符 = 阳符 | 阴符

  阴义 = 阴符+轻符串
  句法 = 阴义集
  启动阴符

  重符流
  具象语法树
  抽象语法树

  孤语法=CFG
  端语法=FS

  ######
  有歧义:阳符/阴符
    动静: 展开/叉/动/阳，终止/叶/静/阴
    表里: 引入/叶/表/阳，导出/叉/里/阴
    ??改为??:叶符/右符/引入符/基符，父符/叉符/左符/导出符/展符 # 重符/码元











=====
  view others/数学/编程/tree/2_3_4_tree.txt
树节点 往上:
  根节点:无父节点
  非根节点:有父节点
树节点 往下:
  叉节点:
    子节点为叉节点或拳节点
    子节点为丫节点或末节点
    ===
    芽节点=根叉节点
    丫节点=非根叉节点
    ===
  拳节点:
    子节点为叶节点
    子节点为鳞节点
    ===
    独节点=根拳节点
    末节点=非根拳节点
    ===
  叶节点:
    无子节点
    ===
    卵节点=根叶节点
    鳞节点=非根叶节点
      ==父节点为拳节点
    ===
根节点=整树根节点=卵节点|独节点|芽节点
==>>:
#B-tree:两个子节点之间夹份数据
树节点:按有无父节点分类:欤根
  根节点:无父节点
  子节点:非根节点:有父节点
树节点:按有无子节点分类:欤叶
  叶节点:无子节点
  父节点:非叶节点:有子节点
树节点:按有无数据分类:欤胖
  瘦节点:叶节点|链节点:无数据
  胖节点:叉节点|拳节点:有数据
    #若允许独子:则存在无数据而有子节点的节点:非叉暨非拳暨非叶==>>链节点
[欤叉+欤叶+欤拳+欤链==1]
[欤叉+欤拳==欤胖=!=欤瘦==欤叶+欤链]
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,0,0,0,1)]:肘节点=子链节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,0,0,1,0)]:末节点=子拳节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,0,1,0,0)]:鳞节点=子叶节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(0,1,0,0,0)]:丫节点=子叉节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,0,0,0,1)]:臂节点=根链节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,0,0,1,0)]:独节点=根拳节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,0,1,0,0)]:卵节点=根叶节点
[(欤根,欤叉,欤叶,欤拳,欤链)==(1,1,0,0,0)]:芽节点=根叉节点




=====

[[
剪切移动:源自:e ../../python3_src/useful__cjk_naming.txt
  [:非汉字部件环境冫标识命名规范]:goto
[固实数据 <: 无环数据]
[数据乊类型构造器无环 <: 无环数据]
[固实数据 无关 数据乊类型构造器无环]
[(固实数据++数据乊类型构造器无环) <: 无环数据]#两者同在，配合
[[作任何修改:确保 对象.所属循环组 不发生改变] -> [方案有效:『(计数强引用<循环组>,裸引用<内部对象>)』]]
<<==:
now:场景==工厂/匴一揽子构造器+固化变量/匞参数配置包+只增变量/注册处纟变量
  所谓 固化/只增 指 类似tuple，特定位置 对象不变，但对象本身 可改变
  固实vs固化vs只读
    固实:data_immutable+hashable
      所有接口 不修改数据
      本身数据 不允许变更
          ==>>构造时 子对象 已存在
      子对象 固实
          !! 构造时 子对象 已存在
          ==>>不存在 循环引用
      固实 具备 递归性
    固化:data_immutable+hashable依赖于 子对象
      所有接口 不修改数据
      本身数据 不允许变更
          ==>>构造时 子对象 已存在
      子对象数据 允许变更
          ==>>可能存在 循环引用
      固化 不具备 递归性
    只读:view:ops_immutable,但 本身数据 允许变更
      所有接口 不修改数据
      本身数据 允许变更
      子对象数据 允许变更
  Haskell类型 与 循环引用
    也许 我们该 输出 类型构造器循环引用信息
    惰性求值
    ==>> 先保存 表达式，模式匹配 时 求值 并保存 终值(whnf/固化)
    ==>> 存在 表达式 到 终值 这一变更
    ==>> 非 固化
    ==>> 非 固实
    ==>> 数据可能出现 循环引用
    * 若 类型构造器 本身 允许 自引用... 则 数据可能出现 循环引用
      \sf -> ...
      [a]:
        [] :: [a]
        (:) :: a -> [a] -> [a]
    [[类型构造器 之间 循环引用] =[def]= 所有 前提中的类型的 数据构造器 的 类型 不含 某一 前提中的类型的 类型构造器]
    [[类型构造器 之间 没有循环引用] =[def]= 所有 前提中的类型的 数据构造器 的 类型 不含 任何 前提中的类型的 类型构造器]
    [[[类型构造器 之间 没有循环引用]] -> [数据不可能循环引用]]
    ===数据 分类 排序:
    [固实数据 <: 无环数据]
    [数据乊类型构造器无环 <: 无环数据]
    [固实数据 无关 数据乊类型构造器无环]
      * [固实数据][非 数据乊类型构造器无环]:
        例如:[a]: 类型构造器有环，但 在 固实构造环境下，数据无环
      * [非 固实数据][数据乊类型构造器无环]:
        例如:所有 类型构造器:{(,), (,,)}:不论怎么修改，类型 各不相同，[子对象类型 严格 小于 父对象类型]，必 数据无环
    [(固实数据++数据乊类型构造器无环) <: 无环数据]#两者同在，配合
        !! [固实数据 是 叶节点]
    惰性求值环境下 如何避免 数据循环引用？
        一存皆存，共用一个强引用
        具现方案:
          [循环组 =[def]= (计数值纟强引用, 数组<裸指针<(元素值|惰性表达式)> >)]
          元素变量:封装冫元素变量,动态冫元素变量
          [对外:封装冫元素变量 =[def]= (强引用<循环组>,索引号)]
          [对内:动态冫元素变量 =[def]= (强引用<循环组> -> 索引号 -> 封装冫元素变量)] #(其实就是函数！)
          [元素值 =[def]= (静态指针<虚函数表>, 数据)]
          [惰性表达式 =[def]= (筐表达式况型, 数据)]
          [{强引用<循环组>,静态指针<虚函数表>,筐表达式况型} 互斥]
        例如:
          『x := f g a b 』
          若 出现 可能有 [x -*-> x]
          则 源代码 必有 [{f,g,a,b}其中至少一个能访问到x，即其定义 (隐式)引用了x]
        源代码 静态识别出 循环组
    上述只适用于 惰性表达式
        对于 动态生成的循环引用(双向链表)，显然 不能静态识别出循环组
            双向链表 切片, 切片插入
              ==>>所属循环组 发生改变
        [[作任何修改:确保 对象.所属循环组 不发生改变] -> [方案有效:『(计数强引用<循环组>,裸引用<内部对象>)』]]
    函数调用死循环？
        ??欤已暂时移除:标志位:临时占用？
          不行！
        局域临时假性移除:
          [原变量.裸指针:=空]
             已 禁止重复访问同一数据
             退出时，复原 <<== 后续语句流 continu?a???
          用 原裸指针 构造新的变量 往下调用传递==>>数据独占性冫不可重入
]]
view others/数学/编程/rust/note--Hands-On-Data-Structures-and-Algorithms-with-Rust.txt
view others/数学/编程/rust/rust内存管理.txt
[[
转移vs借出
区别在于: 数据传递方式: 『move』 vs 『&』
    move 毕竟还得 浅复制 本身数据
    这是由 转入的函数的接口类型 决定的
一经 转移，不许 借出
一经 借出，不许 转移
而 任何使用 不是 借出 就是 转移！
    除非开后门给复制
    复制构造函数 使用了 借用&
    移动构造函数 使用了 转移&&
    赋值运算符 使用了 借用& 或 复制+移动 (借用+转移)
==>>数据结构体中的成员 只能有 只读性观察权
==>>数据结构体中的成员 的修改 只能通过 赋值整个替换
==>>数据结构体中只有当前函数栈上变量 的成员 能被修改 且 只能通过赋值来整个替换
shadowing 复用同一变量名
  let s = ...
  let s = ...
interior mutability
  深入修改 大对象 的 叶对象
  rust 通过 Rc<RefCell<T> > 实现这一目标
  Rc引用计数 ==>> 多个拥有者
  RefCell 提供 .borrow_mut()->(&mut xxx) ==>> 多个读写借用？运行期检查不超过2个？
  但感觉会出现 循环引用:这还怎么自动管理内存？？
    #doubly linked list:
    old.borrow_mut().next = Some(new.clone());
    new.borrow_mut().prev = Some(old.clone());
    ???赋值时:Copy trait 浅复制
    ???.clone() 深复制
借用/裸引用:存活期有要求
计数强引用:整体要求无环
]]
[[
对象冫权限丶责任丶约束:
  ::::::::::::::::::::::
  #简略:
  ::::::::::::::::::::::
  * 负责析构权
    #具有唯一独占性
  * 转移权
    #具有允空独占性
    #转移后数据失效
        #转移后所有权限丢失
  * 借出权
    #借出后必须确保数据有效
        #借出后转移权丢失
    * 只读性观察权
      * 更改观察权
        + 借出权冫更改观察权
      * 快照观察权<方面指定>
        + 借出权冫快照观察权
        + 借出权冫更改观察权
    * 读写性操作权
        #具有允空独占性
        + 借出权冫读写性操作权
          #借出后读写性操作权丢失
          #借出后仅更改观察权保留
        + 借出权冫快照观察权
          #借出后读写性操作权丢失
          #借出后仅快照观察权保留
        + 借出权冫更改观察权
  ::::::::::::::::::::::
  #详细:
  ::::::::::::::::::::::
  * 负责析构权
    #具有唯一独占性
    #此权限可转移，但必须唯一
    #存活期结束时，负责析构
      + 转移权冫负责析构权
  * 转移权
    #具有允空独占性
    #此权限可转移，允许无人拥有
    #转移后数据失效
        #转移后所有权限丢失
            #转移后负责析构权丢失
            #转移后转移权丢失
            #转移后借出权丢失
  * 借出权
    #借出后必须确保数据有效
        #借出后转移权丢失
        #借出后负责析构权保留
    * 只读性观察权
      * 更改观察权
        #只读性观察，允许观察期间对象变更
        + 借出权冫更改观察权
          #借出后权限未变更
      * 快照观察权<方面指定>
        #指定方面结果不变性
        # <<==:
        #只读性观察，但要求观察期间对象不变更，保证逻辑性结果不变
        #   也许，更重要的是，允许某些无关方面的变更:引用计数，惰性表达式
        #
        + 借出权冫快照观察权
        + 借出权冫更改观察权
          #借出后权限未变更
    * 读写性操作权
        #具有允空独占性
        #此权限可转移，允许无人拥有
        + 借出权冫读写性操作权
          #借出后读写性操作权丢失
          #借出后仅更改观察权保留
        + 借出权冫快照观察权
          #借出后读写性操作权丢失
          #借出后仅快照观察权保留
        + 借出权冫更改观察权
          #借出后权限未变更
]]
函数输入参数的类型约束:禁止引用泄露、存活期限制/比较


自然语言 很好，自然语言 很糟
替代 自然语言:
  使用 数字语言
  使用 符号语言
  使用 形象语言
  比如:
    fst pair
      --> pair.0
      --> 0 pair
      --> pair[0]
      --> pair[0]
    add(a,b)
      --> (a + b)
    sum(a,b,c)
      --> (+, a,b,c)
    None
      --> ()


