[[[[[[

e others/book/matrix_chain_product/Computation of matrix chain products I,II(1984)(Hu)(Shing)[polygon partitioning].pdf.txt

e script/matrix_chain_product.py


[[[前面部分发现有误，后面继续改进
[[摘要:重大更进:
论文定义的概念:[潜在的潜在的横对角线]
自定义的概念:[除零的类横对角线囗第二版]

[one_sweep_algorithm 输出所有 潜在的潜在的横对角线]
[第二版的除零的类横对角线是无印版的潜在的潜在的横对角线]
[若某词典序最先的最优三角化方案不含第二版的除零的类横对角线则该方案为聚焦于最小处的扇形方案]
]]


===
bug:不止两种情况！:注意:基本多边形的fan扇形三角化方案/聚焦型三角化方案 有 两种可能！！！
  聚焦于i0或i1
  [[ls[i0] == ls[i1]] -> [聚焦于i1]]
  [[ls[i0] < ls[i1]] -> [聚焦于i0]]
===

  ???论文bug???仔细看看，前面似乎提到只用『monotone basic polygon』单调基本多边形
  论文part II,page3[31/128]:
    证明中 只提到 [聚焦于i0]
    我原以为 [[
      论文证明了: [MNO__fan(ls;i0) <= MNO__non_fan(ls)]
      但并未证明: [[i :<- [0..<L]] -> [MNO__fan(ls;i0) <= MNO__fan(ls;i)]]
        事实是不可能的
        存在反例: [11,11,33,22]
          #这是『monotone basic polygon』？
          # [11,11,33,22]是！即使严格按照fw排序
          # 但 [11,33,22,22] 严格来说不是
        但由于 基本多边形 最优解 必含 (i0,i3)或(i1,i2)
      ]]
    原来不是！
    作者竟然直接认为 竖对角线 打横后 mno不增，可怕的错误！
      实际上 打横后 mno不减
===
bug:我来证明 只有 两种情况
  反例: ls=[11,22,11,22,11,22,11,22] 的 词典序最先的最优三角化方案 内边 为 [(0,2),(0,4),(0,6),(2,4),(4,6)]
[多边形 词典序最先的最优三角化方案 不含 潜在的横对角线]
<==>[多边形 词典序最先的最优三角化方案 不含 横对角线]
        !! [横对角线是潜在的横对角线]
<==>[多边形 词典序最先的最优三角化方案 内边 都是 竖对角线]
        !! [对角线局部稳定必要条件囗非横则竖]
==>>[该方案 必是 扇形]
==>>[该方案 必是 聚焦于i0或i1的扇形]
  失败:存在反例:[[proof:
    [L >= 3]
    * [该方案 含 某个四边形(i0,a,b,c)以及 竖对角线(a,c)][is_rotated_asc_seq([i0,a,b,c])]
      [该方案 不是 聚焦于i0的扇形]
      [L >= 4]
      [是竖对角线(ls;i0,b;a,c)]
      !! [是竖对角线(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) < min(ls[b],ls[d])]or[[min(ls[a],ls[c]) == min(ls[b],ls[d])][max(ls[a],ls[c]) <= max(ls[b],ls[d])]]]]
      [[min(ls[a],ls[c]) < min(ls[b],ls[i0])]or[[min(ls[a],ls[c]) == min(ls[b],ls[i0])][max(ls[a],ls[c]) <= max(ls[b],ls[i0])]]]
      !! [ls[i0] == min(ls)]
      [[min(ls[a],ls[c]) == ls[i0]][max(ls[a],ls[c]) <= ls[b]]]
      [(x,y) := sorted([a,c],key=fw)]
      [{x,y} == {a,c}]
      [ls[x] <= ls[y]]

      [[ls[x] == ls[i0]][ls[y] <= ls[b]]]
      [ls[i0] == ls[x] <= ls[y] <= ls[b]]
      !! [词典序最先的最优三角化方案]
      [ls[i0] == ls[x] <= ls[y] < ls[b]]
        ！！！无法继续！！！
          反例: ls=[11,22,11,22,11,22,11,22] 的 词典序最先的最优三角化方案 内边 为 [(0,2),(0,4),(0,6),(2,4),(4,6)]
          ====
          增加条件[ls.count(ls[i0]) == 1]可证明
          新增条件[ls.count(ls[i0]) == 1]:
            !![ls[i0] == ls[x]]
            !![x =!= i0]
            !![ls.count(ls[i0]) == 1]
            _L

    * [not [该方案 含 某个四边形(i0,a,b,c)以及 竖对角线(a,c)][is_rotated_asc_seq([i0,a,b,c])]]:
      [L >= 3]
      [该方案 是 聚焦于i0的扇形]
  ]]


=======
[多边形 词典序最先的最优三角化方案 不含 潜在的横对角线]
<==>[多边形 词典序最先的最优三角化方案 不含 横对角线]
        !! [横对角线是潜在的横对角线]
<==>[多边形 词典序最先的最优三角化方案 内边 都是 竖对角线]
        !! [对角线局部稳定必要条件囗非横则竖]
#----->
[第四型多边形词典序最先的最优三角化方案不含潜在的横对角线则必是聚焦于最小处的扇形] =[def]=:
[多边形顶点最小权重唯一][多边形 词典序最先的最优三角化方案 不含 潜在的横对角线] ==>>[该方案 必是 聚焦于i0的扇形]
  # 证明:见上面『新增条件』打补丁后的证明


如何得到:[多边形顶点最小权重唯一]的多边形？
  参考:见下面:『识别可分解的多边形:降解』

[[第二型多边形] -> [{(i0,i) | [[i :<- [0..<L]][ls[i] == ls[i0]]]} |<=| {i0,i0+1,i0-1}%L]]
  # 定义:第二型多边形
[[第三型多边形] -> [{(i0,i) | [[i :<- [0..<L]][ls[i] == ls[i0]]]} |<| {i0,i0+1,i0-1}%L]]
  # 定义:第三型多边形
[[第三型多边形] <-> [[第二型多边形][多边形的最小权重顶点最多两个]]]
[[第三型基本多边形] <-> [[第三型多边形][基本多边形]]]
  # 定义:第三型基本多边形
[[第三型强基本多边形] <-> [[第三型多边形][基本多边形][ls[i0] < ls[i2] < ls[i3]]]]
  # 定义:第三型强基本多边形
[[第四型多边形] <-> [多边形顶点最小权重唯一]]
  # 定义:第四型多边形 #即:目标型号

[任意多边形降解为多个第二型多边形] =[def]=:
[{(i0,i) | [[i :<- [i0+2..=i0+L-2]%L][ls[i] == ls[i0]]]} 将 任意多边形 切成多个 第二型多边形，这些边 属于 该任意多边形的 词典序最先的最优三角化方案(ls;i0)，这些 第二型多边形 的 词典序最先的最优三角化方案(lsX;i0) 的 三角边 同样也属于它[#i0未改变#]]
    !![最低两边为某最优解的三角边]


[i0_p1:=(i0+1)%L]
[i0_n1:=(i0-1)%L]

[第二型多边形降解为第三型多边形] =[def]=:
[[第二型多边形][i0_p1:=(i0+1)%L][i0_n1:=(i0-1)%L][ls[i0_p1] == ls[i0] == ls[i0_n1]] -> [(i0_p1,i0_n1) <- 词典序最先的最优三角化方案(ls;i0)]] #而且是 最小边 除非 该多边形是三角形
  [[proof:
  [该方案 存在 一个 聚焦于i0的扇形 子结构]
  [该扇形子结构 不是 三角形]:
    [该扇形子结构 若改为 聚焦于i0_p1,i0_n1，结果均更优]
    _L
  [该扇形子结构 是 三角形]
  [(i0_p1,i0_n1)是 该方案 的 三角边]
  ]]


bug:[[第二型多边形][i0_p1:=(i0+1)%L][i0_p2:=(i0+2)%L][ls[i0_p1] == ls[i0]] -> [(i0_p1,i0_p2) <- 词典序最先的最优三角化方案(ls;i0)]] #而且是 最小边
  xxx !![聚焦型多边形三角化方案的优化囗推论三]


[第三型多边形降解为第三型基本多边形] =[def]=: [最低两边为某最优解的三角边]
[第三型基本多边形降解为第三型强基本多边形] =[def]=: [最低两边为某最优解的三角边]
  [[proof:
    [ls[i0] < ls[i2] == ls[i3] == ... == ls[iX] < ...]
    [fw(i2) < fw(i3) < ... < fw(iX)]
    镜像:
      [fw(i2_) > fw(i3_) > ... > fw(iX_)]
      [(i0_,iX_) 为 低一之三边 属于 某最优解]
      !![(i0_,iX_)切分 多边形]...
      [(i0_,i3_) 属于 某最优解]
    [(i0,i3) 属于 某最优解]
    !![(i0,i3) 为 第一 内边]
    [(i0,i3) 属于 词典序最优解]
  ]]


[第三型强基本多边形降解为第四型多边形] =[def]=:
[[第三型强基本多边形][ls[i0] == ls[i0] < ls[i2] < ls[i3]] -> [(i1,i2) <- 词典序最先的最优三角化方案(ls;i0)]] #而且是 最小边 除非 该多边形是三角形
  #证明 与 [第二型多边形降解为第三型多边形]的证明 雷同

综上:
  [任意多边形降解为多个第二型多边形]
  [第二型多边形降解为第三型多边形]
    #任意多边形挖出全最小权重顶点的极大子多边形 剩下的就是 第三型多边形
  [第三型多边形降解为第三型基本多边形]
  [第三型基本多边形降解为第三型强基本多边形]
  [第三型强基本多边形降解为第四型多边形]
  [第四型多边形词典序最先的最优三角化方案不含潜在的横对角线则必是聚焦于最小处的扇形]
  ！！但这并没有用！！因为算法过程中 出现 许多 子多边形，它们是 基本多边形 但不是 第四型多边形！！

xxx [四边以上多边形的所有扇形解中的最优解的聚焦点的权重 是否 为最小权重？]
  反例:横对角线:[22,33,88,33]

重定义 横对角线:哪些边会阻止 i0的扇形射线？
横对角线 无印版-->第二版
竖对角线 无印版-->第二版
  [是横对角线(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) > min(ls[b],ls[d])][max(ls[a],ls[c]) < max(ls[b],ls[d])]]]
  --> [是横对角线囗第二版(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) >= min(ls[b],ls[d])][max(ls[a],ls[c]) < max(ls[b],ls[d])]]]
    # min『>』-->『>=』
    # max『<』不变
  [横对角线 必是 横对角线囗第二版]
  !![所有竖对角线囗第二版 == 所有竖对角线\-\所有横对角线囗第二版]
  [竖对角线囗第二版 必是 竖对角线]


  [是竖对角线(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) < min(ls[b],ls[d])]or[[min(ls[a],ls[c]) == min(ls[b],ls[d])][max(ls[a],ls[c]) <= max(ls[b],ls[d])]]]]
  --> [是竖对角线囗第二版(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) < min(ls[b],ls[d])]or[[min(ls[a],ls[c]) == min(ls[b],ls[d])][max(ls[a],ls[c]) == max(ls[b],ls[d])]]]]
    # 竖对角线 移除 横对角线囗第二版 部分

  #无需 [ls[a] <= ls[c]][ls[b] <= ls[d]]:
      [not [[是竖对角线囗第二版(ls;b,d;a,c)][是横对角线囗第二版(ls;b,d;a,c)]]]
        #同对角线囗横竖互斥囗第二版
      [not [[是横对角线囗第二版(ls;b,d;a,c)][是横对角线囗第二版(ls;a,c;b,d)]]]
        #异对角线囗横横互斥囗第二版
      [[[是竖对角线囗第二版(ls;b,d;a,c)][是竖对角线囗第二版(ls;a,c;b,d)]] == [{ls[a],ls[c]} == {ls[b],ls[d]}]]
        #异对角线囗竖竖交集为权重相等囗第二版
      [not [[是横对角线囗第二版(ls;b,d;a,c)] -> [是竖对角线囗第二版(ls;a,c;b,d)]]]
        #异对角线囗横为竖的子集囗第二版不成立
        <==>[not [[[min(ls[a],ls[c]) >= min(ls[b],ls[d])][max(ls[a],ls[c]) < max(ls[b],ls[d])]] -> [[min(ls[a],ls[c]) > min(ls[b],ls[d])]or[[min(ls[a],ls[c]) == min(ls[b],ls[d])][max(ls[a],ls[c]) == max(ls[b],ls[d])]]]]]
      [[[是横对角线囗第二版(ls;b,d;a,c)][是竖对角线囗第二版(ls;a,c;b,d)]] == [min(ls[a],ls[c]) > min(ls[b],ls[d])][max(ls[a],ls[c]) < max(ls[b],ls[d])] == 是横对角线(ls;b,d;a,c)]
        #异对角线囗横竖交集囗第二版囗降版为横对角线


    [not [[是竖对角线囗第二版(ls;b,d;a,c)][是横对角线囗第二版(ls;b,d;a,c)]]]


  [[[是竖对角线囗第二版(ls;b,d;a,c)]or[是横对角线囗第二版(ls;b,d;a,c)]] == [[是竖对角线(ls;b,d;a,c)]or[是横对角线(ls;b,d;a,c)]]]
    # 第二版与无印版囗横竖并集相同

  [对角线局部稳定必要条件囗非横则竖囗囗第二版] =[def]=: [[是四边形最优对角线(ls;b,d;a,c)] -> [[是竖对角线囗第二版(ls;b,d;a,c)]or[是横对角线囗第二版(ls;b,d;a,c)]]]
    !![对角线局部稳定必要条件囗非横则竖] #无印版
    !![第二版与无印版囗横竖并集相同]

  [所有横对角线不相交囗第二版]
    !!仍然是同样原因:[max<max]不可交换
one_sweep_algorithm相关定理无印版->第二版:
无印版:
  [无用囗词典序最先的最优三角化方案囗横对角线的必要条件]
  [词典序最先的最优三角化方案囗潜在的横对角线的必要条件]
第二版:
[[[ls :: [pint]][L := len(ls)][L >= 4][imin :<- [0..<L]][ls[imin] == min(ls)]] -> [ltpg := 词典序最先的最优三角化方案囗(imin;ls)] -> [a,b,c,d :<- [0..<L]] -> [len{a,b,c,d} == 4] -> [{{a,c},{a,b},{b,c},{c,d},{d,a}} |<=| ltpg] -> [is_rotated_asc_seq([a,b,c,d])] -> [_ac_ := range_mod_(L;a+1,c)] -> [_ca_ := range_mod_(L;c+1,a)] -> [是横对角线囗第二版(ls;b,d;a,c)] -> [
  [len(_ac_) > 0]
  [len(_ca_) > 0]
  [fw := \i->fweight(ls;imin;i))]
  [i := min(_ac_, key=fw)]
  [j := min(_ca_, key=fw)]
  [(u,v) := sorted([i,j], key=fw)]

  #xxx [ls[u] < ls[a] < ls[v]]
  #xxx [ls[u] < ls[c] < ls[v]]
  [ls[u] <= ls[a] < ls[v]]
  [ls[u] <= ls[c] < ls[v]]
    # :=[def]= [无用囗词典序最先的最优三角化方案囗横对角线的必要条件囗第二版]
    # 这俩条件不能简化为: <=!=>[ls[a] < ls[v]][ls[c] < ls[v]]
  [ls[u] == min(ls)] #但 u不一定是imin
    # 可以简化为: <==>[ls[u] == min(ls)][ls[a] < ls[v]][ls[c] < ls[v]]
    #               :=[def]= [类横对角线囗第二版]
    #   用于one_sweep_algorithm后续修正
    #   还有一个条件:[a =!= imin =!= c]
    #       它不能用在『横对角线囗第二版』的定义中，因为 递归性证明中，不存在 全局性的imin，子多边形的imin会造成必要的『横对角线囗第二版』丢失
    #       真的吗？真的会丢失有用边？其实还可更进:[所有以i为端点的『横对角线囗第二版』，保留唯一边；否则 保留 次低边；最低边 被保留 只可能是因为 该边是其另一端点的次低边；保留 次低边 的目的是阻止将最低边另一端点当作聚焦点；于是有:当i为imin，所有射线可删]
    #       #次低边 之于 最低边 的 角色 就是 论文中所说的『children』
    #           #真的吗？虽然 最低边存在 必然 引入 次低边，但 没有最低边 时 次低边 有无 独立存在的可能？感觉不太对
    #       :=[def]= [有用囗词典序最先的最优三角化方案囗横对角线的必要条件囗第二版]
    #           原始:即: [a =!= imin =!= c][ls[a] < ls[v]][ls[c] < ls[v]]
    #               :=[def]= [除零的类横对角线囗第二版]
    #           xxx 很大可能是错的:更进:即: [a =!= imin =!= c][ls[a] < ls[v]][ls[c] < ls[v]][所有以i为端点的『横对角线囗第二版』，保留唯一边；否则 保留 次低边；最低边 被保留 只可能是因为 该边是其另一端点的次低边；保留 次低边 的目的是阻止将最低边另一端点当作聚焦点；于是有:当i为imin，所有射线可删]
    #               :=[def]= xxx [有效的类横对角线囗第二版]
    #
  [imin <- {u,a,c}]
    # 因为u的定义使用了fw

  #xxx [fw(u) < fw(a) < fw(v)]
  #xxx [fw(u) < fw(c) < fw(v)]
  [fw(u) <= fw(a) < fw(v)]
  [fw(u) <= fw(c) < fw(v)]
    # :=[def]= [词典序最先的最优三角化方案囗潜在的横对角线的必要条件囗第二版]
    # 这俩条件<=!=>[fw(a) < fw(v)][fw(c) < fw(v)]
    # 这俩条件<==>[ls[u] == min(ls)][fw(a) < fw(v)][fw(c) < fw(v)]
  ]]

上面定义了:
  『类横对角线囗第二版』
    |>=|『除零的类横对角线囗第二版』
    |>=|xxx『有效的类横对角线囗第二版』
xxx [有效的类横对角线是除零的类横对角线囗第二版]
[除零的类横对角线是类横对角线囗第二版]

# 『类横对角线囗第二版』与『潜在的横对角线』的关系
[第二版的类横对角线是无印版的潜在的横对角线]
  !![无印版的潜在的横对角线] <-> [fw(u) < {fw(a),fw(b)} < fw(v)]
  !![类横对角线囗第二版] <-> [a =!= imin =!= c][ls[a] < ls[v]][ls[c] < ls[v]]

##由于one_sweep_algorithm生成的是『潜在的潜在的横对角线』
# 考虑『有效的类横对角线囗第二版』与『潜在的潜在的横对角线』的关系
xxx [第二版的有效的类横对角线是无印版的潜在的潜在的横对角线]
  !![有效的类横对角线是除零的类横对角线囗第二版]
  !![除零的类横对角线是类横对角线囗第二版]
  !![第二版的类横对角线是无印版的潜在的横对角线]
  !![潜在的横对角线是潜在的潜在的横对角线]

# 由于『有效的类横对角线囗第二版』有毛病，回退:
# 考虑『除零的类横对角线囗第二版』与『潜在的潜在的横对角线』的关系
[第二版的除零的类横对角线是无印版的潜在的潜在的横对角线]
  !![除零的类横对角线是类横对角线囗第二版]
  !![第二版的类横对角线是无印版的潜在的横对角线]
  !![潜在的横对角线是潜在的潜在的横对角线]

=======
xxx [若某词典序最先的最优三角化方案不含第二版的有效的类横对角线则该方案为聚焦于最小处的扇形方案]
  !![若某词典序最先的最优三角化方案不含第二版的有效的类横对角线则该方案不含第二版的除零的类横对角线]
  !![若某词典序最先的最优三角化方案不含第二版的除零的类横对角线则该方案为聚焦于最小处的扇形方案]

xxx [若某词典序最先的最优三角化方案不含第二版的有效的类横对角线则该方案不含第二版的除零的类横对角线]
  [[proof:???不太行
  ]]
[若某词典序最先的最优三角化方案不含第二版的除零的类横对角线则该方案为聚焦于最小处的扇形方案]
  [[proof:
    [L >= 3]
    * [该方案 含 某个四边形(i0,a,b,c)以及 对角线(a,c)][is_rotated_asc_seq([i0,a,b,c])]
      [该方案 不是 聚焦于i0的扇形]
      [L >= 4]
      !![不含第二版的除零的类横对角线]
      [(a,c)不是 除零的类横对角线囗第二版]
      !! 除零的类横对角线囗第二版 定义自 [a =!= imin =!= c][ls[a] < ls[v]][ls[c] < ls[v]]
      !! [a =!= imin =!= c]
      [not [[ls[a] < ls[b]][ls[c] < ls[b]]]]
      * [ls[a] >= ls[b]]:
        !![ls[c] >= ls[i0]]
        [原方案 不优于 用(i0,b)替代(a,c)后的方案]
        [按词典序，原方案 在 用(i0,b)替代(a,c)后的方案 之后]
        [原方案 不是 词典序最先的最优三角化方案]
        _L
      * [ls[c] >= ls[b]]:
        同理于:[ls[a] >= ls[b]]

    * [not [该方案 含 某个四边形(i0,a,b,c)以及 对角线(a,c)][is_rotated_asc_seq([i0,a,b,c])]]:
      [L >= 3]
      [该方案 是 聚焦于i0的扇形]
  ]]
]]]
[[[
xxx 一个用于『script/matrix_chain_product.py::词典序最先的最优三角化方案囗立方算法囗』的定理:
xxx [[[ls :: [pint]][L := len(ls)][L >= 3]] -> [i,j,k :<- [0..<L]] -> [?[tpg0 :: 最优多边形三角化方案<ls>] -> [(i,j)是tpg0中三角形的边]] -> [?[tpg1 :: 最优多边形三角化方案<ls>] -> [(i,k)是tpg1中三角形的边]] -> [?[tpg2 :: 最优多边形三角化方案<ls>] -> [(i,j),(i,k)是tpg2中三角形的边]]]
    见下面『找反例的过程』
    存在反例:[ls=[70, 111, 185, 148, 74]]
  xxx [[proof:
  * [j==k]:ok
  * [(i,j)是 外边)]:ok
  * [(i,k)是 外边)]:ok
  * [(i,j),(i,k) 都不是 外边)][j=!=k]:
    [L >= 5]
    * [L == 5]:ok
    * [L > 5][归纳法-假设]:
      [?:[tpg0 :<- 最优多边形三角化方案<ls>] -> [(i,j)是tpg0中三角形的边]]
      [vs := tpg0中度为2的顶点]
      [len(vs) >= 2]
      [vs /-\ {i,j}=={}]
      [us := vs \-\ {i,j,k}]
      [len(us) >= 1]
      [u :<- us]
      [tpg0删去u]????无法继续
  ]]
试试更强版:xxx [[[ls :: [pint]][L := len(ls)][L >= 3]] -> [i,j,a,b :<- [0..<L]] -> [(i,j),(a,b)相容] -> [?[tpg0 :: 最优多边形三角化方案<ls>] -> [(i,j)是tpg0中三角形的边]] -> [?[tpg1 :: 最优多边形三角化方案<ls>] -> [(a,b)是tpg1中三角形的边]] -> [?[tpg2 :: 最优多边形三角化方案<ls>] -> [(i,j),(a,b)是tpg2中三角形的边]]]
    见下面『找反例的过程』
    存在反例:[ls=[70, 111, 185, 148, 74]]
  xxx [[proof:
  # 还不够 [低一之二边及低一之三边同时是某最优解的三角边]
  # 还不够 [低一之二边及低一之三边是高度相容的最优解的三角边]
  #还得靠 [不与低一之三边相容的最优解的三角边只能是另外的低一之三边且低一低二的权重相同][不与低一之三边相容的最优解的三角边若非聚焦型则低一低二低三的权重相同]
  #还得靠[不与低一之二边相容的最优解的三角边只能是另外的低一之二边且低一低二低三的权重相同]
  [ij := (i,j)]
  [ab := (a,b)]
  * [L==3]:ok
  * [L>3][归纳法-假设]:
    * [?:[arc :<- 所有可能的内边<L>] -> [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]:
      * [arc 分隔开ij,ab]:
          两更小半合并 ok
      * [arc 不分隔开ij,ab]:
          递降归纳 ok
    * [not [?[arc :<- 所有可能的内边<L>] -> [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]]:
      [@[arc :<- 所有可能的内边<L>] -> [not [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]]
      !! [不与低一之三边相容的最优解的三角边只能是另外的低一之三边且低一低二的权重相同][不与低一之三边相容的最优解的三角边若非聚焦型则低一低二低三的权重相同]
      !! [不与低一之二边相容的最优解的三角边只能是另外的低一之二边且低一低二低三的权重相同]
      * [{ij或ab} 是 (某 低一之二边 或 某 低一之三边 或 外边)]:
        ok
      * [{ij,ab} 都不是 (某 低一之二边 或 某 低一之三边 或 外边)]:
        !! [@[arc :<- 所有可能的内边<L>] -> [not [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]]
        [所有 低一之二边 是外边]
        [所有 低一之三边 是外边]
        [低一点唯一]
        [低三低四点的权重不同]
        let [(i0,i1,i2,i3) := 低一低二低三低四点]
        [ls[i0] < ls[i1] <= ls[i2] < ls[i3B]==...==ls[i3E] < min(ls[*others])]
        [低二点集 := {i1,i2} if ls[i1] == ls[i2] else {i1}]
        [低四点集 := {i3B,...,i3E}]
        [(i0,i1),(i0,i2) 是外边]
        [是 基本多边形]
        !! [基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
        ?:[tpg <- 最优多边形三角化方案<ls>] -> [[(i1,i2) <- tpg]or[(i0,i3) <- tpg]]
        * [(i1,i2)存在于某最优解][(i1,i2) <- tpg]:
          !! [{ij,ab} 都不是 外边]
          * [{ij,ab} 都与(i1,i2)相容]
            !! [@[arc :<- 所有可能的内边<L>] -> [not [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]]
            _L
          * [{ij,ab} 都与(i1,i2)不相容]
            !! [(i0,i1),(i0,i2) 是外边]
            [{ij,ab} 都以i0为端点]
            [{ij,ab,(i0,i3)} 都以i0为端点]
            [{ij,ab,(i0,i3)} 都相容]
            ?:[i3m <- 低四点集]-> ?:[tpg_03m <- 最优多边形三角化方案<ls>] -> [(i0,i3m) <- tpg_03m]
            [i03m := (i0,i3m)]
            !![ij分隔开来的两半中至少有一含原低四点i3m点作为 新低三点]
            ?:[tpg_03m_ij <- 最优多边形三角化方案<ls>] -> [[i03m <- tpg_03m_ij][ij <- tpg_03m_ij]]
            ?:[tpg_03m__ab <- 最优多边形三角化方案<ls>] -> [[i03m <- tpg_03m_ab][ab <- tpg_03m_ab]]
            !! [@[arc :<- 所有可能的内边<L>] -> [not [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]]
            _L
          * [{ij,ab} 有且只有一条与(i1,i2)不相容]
            ?:[{pq} <- {ij,ab}]->[xy与(i1,i2)相容]
            ?:[{xy} <- {ij,ab}]->[xy与(i1,i2)不相容]
            [xy与 任一 低一之四边 相容] # i03m
            !! [@[arc :<- 所有可能的内边<L>] -> [not [[arc与ij,ab相容][arc与ij可拓展为 最优解][arc与ab可拓展为 最优解]]]]
            [pq不与 任一 低一之四边 相容] # i03m
            ##
            [(i1,i2)存在于某最优解]
            [{ij,ab} 有且只有一条与(i1,i2)不相容，另一条不与 任一 低一之四边 相容]
            [{ij,ab} 有且只有一条与(i1,i2)相容，且与任一 低一之四边 不相容]
          !![{ij,ab} 有一条与(i1,i2)不相容]
            [某 低一之四边 存在于某最优解]
            [所有 低一之四边 同时存在于某最优解]
            [xy <- {ij,ab}]
            [xy 与(i1,i2)不相容]
            [xy与 任一 低一之四边 相容]
            [pq <- {ij,ab}]
            [pq 与(i1,i2)相容]
            [pq与任一 低一之四边 不相容]
            !![pq 与(i1,i2)相容]
            [tpg_i0 := tpg删去i0]
            [原tpg中低四点 变为 新tpg_i0的低三点]
            !![pq 与任一 原tpg低一之四边 不相容]
            !![pq =!={i1,i2}]
            [pq是tpg_i0的 内边]
            * [pq与tpg_i0中的 某 低一之三点 不相容]:
              !![tpg_i0 的 唯一 低一之二点 是 外边]
              [pq也是tpg_i0中的 低一之三点]
              [pq含tpg_i0的低三点]
              [pq含tpg的低四点]
              [pq与tpg的某 低一之四边 相容]
              _L

            * [pq与tpg_i0中的 任一 低一之三点 相容]
              [pq 含i1点][tpg低二点唯一]
              [ls[i0] < ls[i1] < ls[i2] < ls[i3B]==...==ls[i3E] < min(ls[*others])]
              [{i1,iq} := pq]
              !![pq 与任一 原tpg低一之四边 不相容]
              [iq !<- 低四点集]
              [ls[iq] =!= ls[i3B]]
              [ls[iq] > ls[i3B]]
              [@[i3m<-低四点集] -> [(i1,i0,i2,iq,i3m)成环]]
              !![ab与 tpg 低二之三边 不相容]
              !![xy 与(i1,i2)不相容]
              [xy含i0点]
              [{i0,iy} := xy]
              [i2=!=iy]
              !![xy 与pq相容]
              [@[i3m<-低四点集] -> [(i1,i0,i2,iy,iq,i3m)成环]]
              [ls[iy] > ls[i3B]]
              [@[i3m<-低四点集] -> [(i1,i0,i2,iy,iq,i3m)中只有iy,iq可能是同一点]]
              [i3m_q := 不经i0与iq最近的 低四点]
              [(i0,iy),(i0,i3m_q)共存于某最优解]
              [(i1,i2),(i1,iq)共存于某最优解]
              [(i1,i2),(i1,iq),(i1,i3m_q)共存于某最优解]
              [[(i0,iy),(i0,i3m_q),(i1,i3m_q)共存于某最优解] -> [低四点唯一]]
              [below_i1_i3mq := 整个原多边形被(i1,,i3m_q)分隔开的带{i0,i2,iy,iq}的子多边形]
              [(i1,i2),(i1,iq)共存于below_i1_i3mq某最优解]
              [[(i0,iy),(i0,i3m_q)共存于below_i1_i3mq某最优解] -> [低四点唯一]]
              [below_i1_i3mq__del_i0 := 多边形below_i1_i3mq删i0]
              [(i1,iq)存于below_i1_i3mq__del_i0某最优解]
                # vs:???[(i2,i3m_q)存于below_i1_i3mq__del_i0某最优解]???
              #xxx [(i1,iq)是below_i1_i3mq__del_i0的 低一之三边] 该说 沾 below_i1_i3mq__del_i0的 低一之三边 的 光
              #『找反例的过程』
              #尝试找反例:
              #[iy==iq][L==5]:[(i0,i2,iq=iy=i4,i3,i1) := [0..=4]][ls没有重复值][ls=[w0,w2,w4,w3,w1]]
              # [(i1,i2),(i1,i4)共存于某最优解]
              # [(i0,i2,i4,i1),(i1,i2,i4,i3)俩 局部四边形]
              # ???[1/w4+1/w0 <= 1/w2+1/w3]
              # [1/w4+1/w0 <= 1/w2+1/w1]
              # [1/w2+1/w3 <= 1/w1+1/w4]
              # [(w021+w124+w143) <= w0*(w24+w43+w31)]
              # [(w124+w143) <= w0*(w24+w43+w31-w21)]
              # [(w124+w143)/(w24+w43+w31-w21) <= w0]
              # [w14*(w2+w3)/(w24+w43+w31-w21) <= w0]
              # !![1/w4+1/w0 <= 1/w2+1/w1]
              # [1/w0 <= (1/w2+1/w1)-1/w4]
              # [w0 >= 1/(1/w2+1/w1-1/w4)]
              # [w0 >= w124/(w14+w24-w12)]
              # !! [1/w2+1/w3 <= 1/w1+1/w4]
              # [1/w2+1/w3-1/w4 <= 1/w1]
              # [w234/(w34+w24-w23) >= w1]
              ########
              # [w0 >= w14*(w2+w3)/(w24+w43+w31-w21)]
              # [w0 >= w124/(w14+w24-w12)]
              # [w1 <= w234/(w34+w24-w23)]
              # [w0 >= (ws[1]*ws[4]*(ws[2]+ws[3])/(ws[2]*ws[4]+ws[4]*ws[3]+ws[3]*ws[1]-ws[2]*ws[1]))]
              # [w0 >= (ws[1]*ws[2]*ws[4]/(ws[1]*ws[4]+ws[2]*ws[4]-ws[1]*ws[2]))]
              # [w1 <= (ws[2]*ws[3]*ws[4]/(ws[3]*ws[4]+ws[2]*ws[4]-ws[2]*ws[3]))]
              #
              # w02431
              # ls=ws[::2]+[ws[3],ws[1]]
              # ws=[1900, 2000, 3000, 4000, 5000]
              # ls=[1900, 3000, 5000, 4000, 2000]
              # w0 >=70/37 *1000
              # ls=[70, 3*37, 5*37, 4*37, 2*37]
              # ws=[70, 74, 111, 148, 185]
              # ls=[70, 111, 185, 148, 74]


              # py script/matrix_chain_product.py ,matrix_chain_product__dynamic_programming__O_NNN ='[1900, 3000, 5000, 4000, 2000]'
              # []
              # []
              # [(40000000000, 2, [3], 5)]
              # [(70000000000, 1, [2], 5)]
              # [(81400000000, 0, [1], 5)]
              # 24,14
              # i4i1,i2i1 ok!
              # py script/matrix_chain_product.py ,matrix_chain_product__dynamic_programming__O_NNN ='[70, 111, 185, 148, 74]'
              # []
              # []
              # [(1437450, 0, [1], 3), (2026120, 2, [3], 5)]
              # [(3354050, 0, [2], 4), (3545710, 1, [2], 5)]
              # [(4120690, 0, [1, 3], 5)]
              # 14,24 ok
              # 03,02 ok

              ##重点是如何利用:
              #     [所有 低一之四边 同时存在于某最优解]
              #     [(i1,i2)存在于某最优解]
              ...这条分支见下面『综上』继续，无法继续...
              存在反例:[ls=[70, 111, 185, 148, 74]]
        * [(i1,i2)不存在于某最优解][?:[i3m <- 低四点集]->[(i0,i3m) <- tpg]]:
          [任一 低一之四边 与{ij,ab} 其中至少一条 不相容]
          !![{ij,ab}相容][低一点唯一]
          [任一 低一之四边 只与{ij,ab} 一条 不相容]or[{ij,ab}至少一条与 任一 低一之四边 不相容]
          [{ij,ab}至少一条与 任一 低一之四边 不相容]:
            [(i1,i2)存在于某最优解]
            _L
          [任一 低一之四边 只与{ij,ab} 一条 不相容][{ij,ab}没有一条与 任一 低一之四边 不相容]
          [任一 低一之四边 只与{ij,ab} 一条 不相容]
          [{ij,ab} 都与 某一 低一之四边 相容]
          [{ij,ab} 都与 某一 低一之四边 不相容]
          [len(低四点集)>=2]
          [i03m_ij := 某一 与 ij 相容的  低一之四边]
          [i03m_ab := 某一 与 ab 相容的  低一之四边]
          [i03m_ij与ab不相容]
          [i03m_ab与ij不相容]
          [half_ij := i03m_ij分隔开来的两半的 含 ij 的一半]
          [half_ij 含 ij,i03m_ab的顶点]
          !![i03m_ab与ij不相容]
          !![i03m_ab是half_ij中的 某 新的 低一之三边]
          [ij是half_ij中的 某 新的 (低一之二边 或 )低一之三边)]
          !! [低一点唯一]
          _L

        #综上:继续分支:
        ...
        ???无法继续
        见上面『找反例的过程』
        存在反例:[ls=[70, 111, 185, 148, 74]]
          两个最优解的所有内边分别是:
            [(4,1),(4,2)] #聚焦于4 即i1
            [(0,2),(0,3)] #聚焦于0 即i0
            其中{(4,2), (0,2)}相容，甚至 共享一端点，但 并无 最优解 包含它们
  ]]

===
]]]


[[顺时针++升序标记顶点:
多边形顶点标记:
  (L-1)个矩阵相乘，L个维数
  [ls :<- 矩阵乘法链维数序列]
  [ls :: [pint]{len>=2}]
  [L := len(ls)]
  [L >= 2]
  矩阵乘法链从左到右的(L-1)个矩阵的行列维数是:[(ls[i], ls[i+1]) | [i :<- [0..=L-2]]]
  ###
  * [L==2]: 多边形退化成一条边(0,1)
  * [L>=3]:
    以从左到右的有向边(0,L-1)为地基
    以从右到左的有向边(L-1,0)为地基，，顺时针方向依次标记多边形的所有顶点
    顺时针方向外边弧(0~L-1)代表整个表达式
    假设矩阵乘法链最外层拆分成L-1==(k)+(L-k-1)个矩阵
      即 最外层乘号的左操作数含(k)个矩阵，右操作数含(L-k-1)个矩阵
    则:ls[k]共享:(ls[:k+1], ls[k:])
    顺时针方向外边弧(0~k)代表整个表达式的左操作数
    顺时针方向外边弧(k~L-1)代表整个表达式的右操作数
    三角形(0,k,L-1)代表最外层乘号
]]

三角化方案partition

内边/对角线diagonal/arc
外边side
三角边=[def]=内边\-/外边

[[
去歧义多边形顶点的权重比较<imin>:tie-breaking-rule:tie_breaking_rule
  全局性前提设置:选择任意最小权重的顶点imin
  # 论文中的符号:从1开始的数组:
  #     [_imin = 1]
  #     [_i :<- [1..=L]]:
  #         [V[_i] = fweight[(imin+_i-1)%L]]
  #         [w[_i] = ls[(imin+_i-1)%L]]
[[ls :: [pint]][L := len(ls)][L >= 3][imin :<- [0..<L]][ls[imin] == min(ls)][i,j :<- [0..<L]]]:
    [fweight(ls;imin;i) =[def]= (ls[i],(i-imin)%L)]
    [[fweight(i)==fweight(j)] <-> [i==j]]
    # [lt__fw(ls;imin;i,j) =[def]= ((ls[i],(i-imin)%L) < (ls[j],(j-imin)%L))]
    [lt__fw(ls;imin;i,j) =[def]= (fweight(ls;imin;i) < fweight(ls;imin;j))]

]]
[[
对角线比较: 与权重无关，但与imin相关
  用在定义:lexicographically-optimum partition
      [partition :: sorted[arc]{len=L-3}]
      词典序最先的最优三角化方案lexicographically_optimum_partition
[[L :: uint][L >= 3][imin :<- [0..<L]][i,i_ :<- [0..<L]]]:
    [offset_(L;imin;i) =[def]= (i-imin)%L]
    [unoffset_(L;imin;i_) =[def]= (i_+imin)%L]
[[L :: uint][L >= 3][imin :<- [0..<L]][i,j,u,v :<- [0..<L]]]:
    [lt__arc(imin; (i,j), (u,v)) =[def]= (sorted((offset_(L;imin;i),offset_(L;imin;j))) < sorted((offset_(L;imin;u),offset_(L;imin;v))))]
]]







[矩阵乘法链:存在 O(N) 次优解 操作数 小于等于 最优解 的 1.25倍]

[@[N>=3] -> [N边-多边形 被不相交的对角线 完全三角化 的 分割方式的总数 为 Catalan_number(N-2)]]
  Catalan_number
  view ../../python3_src/nn_ns/math_nn/numbers/ballot_number.py
  view ../../python3_src/nn_ns/RMQ/LeftBiasedRMQ/ballot_number/Catalan_number.py
    [Catalan_number(n) == C(2n, n)/(n+1) == xballot_number(n,n)]

[@[N>=3] -> [N边-多边形 任选一边 作为 地面，剩下(N-1)边 每边代表一个矩阵[#共N-1#]，每个顶点代表矩阵维数[#共N#]，每一个 三角化方案 代表 一个 矩阵链打括号方案<N>，每一个 三角形 代表 一次矩阵乘法-其顶点对应的矩阵维数之积即是操作数]]


[[ls0 :: [pint]] -> [ls1 := 循环左移(ls0)] -> [L := len(ls)] -> [L >= 2] -> [cps <- 所有矩阵链打括号方案(L)] -> @[cp0 <- cps] -> ?[cp1 <- cps] -> [操作数囗(cp1,ls1) == 操作数囗(cp0,ls0)]] # :=[def]= [矩阵乘法链维数序列循环移动操作数集合不变]
  证明:多边形相同，三角化方案 也相同
  另:证明:见:view others/book/matrix_chain_product/On-instances-of-the-matrix-chain-product-problem-solved-in-linear-time (2009)(Sana).pdf.txt



[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [ls[0] <= ls[1]] -> [ls[2] <= ls[L-1]] -> [操作数囗多边形三角化囗(多边形三角化方案:={对角线(1,i) | [i :<- [3..=L-1]]};多边形囗顶点权重:=ls) >= 操作数囗多边形三角化囗(多边形三角化方案:={对角线(0,i) | [i :<- [2..=L-2]]};多边形囗顶点权重:=ls)]] # :=[def]= [聚焦型多边形三角化方案的优化]
  [[proof:
  [lhs - rhs
  = ls[1]*(ls[0]*ls[L-1] + sum{ls[i-1]*ls[i] | [i :<- [3..=L-1]]})
  - ls[0]*(sum{ls[i-1]*ls[i] | [i :<- [2..=L-1]]})
  = ls[1]*ls[0]*ls[L-1] + ls[1]*(sum{ls[i-1]*ls[i] | [i :<- [3..=L-1]]})
  - ls[0]*ls[1]*ls[2] - ls[0]*(sum{ls[i-1]*ls[i] | [i :<- [3..=L-1]]})
  = ls[1]*ls[0]*(ls[L-1]-ls[2]) + (ls[1] -ls[0])*(sum{ls[i-1]*ls[i] | [i :<- [3..=L-1]]})
  !![ls[2] <= ls[L-1]]
  !![ls[0] <= ls[1]]
  >= 0
  ]
  DONE
  ]]

[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [ls_del1 := (ls[:1]++ls[2:])] -> [ls[0] <= {ls[1],ls[2]} <= min([+oo]++ls[3:])] -> [操作数囗多边形三角化囗(多边形三角化方案:={对角线(1,i) | [i :<- [3..=L-1]]};多边形囗顶点权重:=ls) >= 操作数囗多边形三角化囗(多边形三角化方案:={对角线(0,i) | [i :<- [2..=L-2]]};多边形囗顶点权重:=ls) >= MNO(ls[:3]) + MNO(ls_del1)]]



bug:[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [ls_del1 := (ls[:1]++ls[2:])] -> [ls[1] <= {ls[0],ls[2]} <= min([+oo]++ls[3:])] -> [MNO(ls) == MNO(ls[:3]) + MNO(ls_del1)]]
  反例:[ls == [3,2,4,6]]
    [3*2 *6 + 2*4*6 == 36+48 == 84 < 96 == 24+72 == 3*2*4 + 3* 4*6]


[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [ls[0] <= ls[1]] -> [ls[2] == min(ls)] -> [操作数囗多边形三角化囗(多边形三角化方案:={对角线(1,i) | [i :<- [3..=L-1]]};多边形囗顶点权重:=ls) >= 操作数囗多边形三角化囗(多边形三角化方案:={对角线(0,i) | [i :<- [2..=L-2]]};多边形囗顶点权重:=ls)]] # :=[def]= [聚焦型多边形三角化方案的优化囗推论一]
  <<== [聚焦型多边形三角化方案的优化]

[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [ls[1] == max(ls)] -> [ls[2] == min(ls)] -> [操作数囗多边形三角化囗(多边形三角化方案:={对角线(1,i) | [i :<- [3..=L-1]]};多边形囗顶点权重:=ls) >= 操作数囗多边形三角化囗(多边形三角化方案:={对角线(0,i) | [i :<- [2..=L-2]]};多边形囗顶点权重:=ls)]]

[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [ls[0] <= ls[1]] -> [ls[2] == min(ls)] -> [?[tpg :: 最优多边形三角化方案<ls>] -> [(0,2)是tpg中三角形的边]]] # :=[def]= [聚焦型多边形三角化方案的优化囗推论二]
  [[proof:
  * [L==3]: ok!
  * [L>3][归纳法-假设]:
      [tpg :<- 最优多边形三角化方案<ls>]
      [tpg_ := {对角线(0,i) | [i :<- [2..=L-2]]}]
      * [tpg == {对角线(1,i) | [i :<- [3..=L-1]]}]:
        !![聚焦型多边形三角化方案的优化]
        [MNO(ls) <= 操作数囗多边形三角化囗(tpg_;多边形囗顶点权重:=ls) <= 操作数囗多边形三角化囗(tpg;多边形囗顶点权重:=ls) == MNO(ls)]
        [MNO(ls) == 操作数囗多边形三角化囗(tpg_;多边形囗顶点权重:=ls)]
        [tpg_ <- 最优多边形三角化方案<ls>]
        [(0,2) 是 tpg_中的三角边]
      * [tpg =!= {对角线(1,i) | [i :<- [3..=L-1]]}]:
        ?:[(i,j)是 tpg中的内边/对角线] -> [i =!= 1 =!= j]
        [对角线(i,j)将 多边形 切成更小的两半，其一包含顶点:{0,1,2}，将这一半的参数记为ls_half]
        !![ls[2] == min(ls)]
        [ls_half[2] == min(ls_half)]
        !![ls[0] <= ls[1]]
        [ls_half[0] <= ls_half[1]]
        !![归纳法-假设]
        [?[tpg_half :: 最优多边形三角化方案<ls_half>] -> [(0,2)是tpg_half中三角形的边]]
        [tpg_half_update := tpg_half 结合 tpg 另一半]
        [tpg_half_update <- 最优多边形三角化方案<ls>]
        [(0,2) 是 tpg_half_update中的三角边]

  DONE
  ]]
[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [i,j,k :<- [0..<L]] -> [{i,k} == {(j-1)%L,(j+1)%L}] -> [ls[i] <= ls[j]] -> [ls[k] == min(ls)] -> [?[tpg :: 最优多边形三角化方案<ls>] -> [(i,k)是tpg中三角形的边]]] # :=[def]= [聚焦型多边形三角化方案的优化囗推论三]
  #也就是说：最小处往外 只能是 上升，连续2个？




[ls :: [pint]][L := len(ls)][idc :: strict_sorted[int%L]]:
  [del_(ls; *idc) =[def]= for i in reversed(idc): del ls[i]]

[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [i,j,k :: int%L] -> [len{i,j,k} == 3] -> [ls[i] == min(ls)] -> [ls[j] == min(del_(ls;i))] -> [ls[k] == min(del_(ls;i,j))] -> [
    [i =!= j]
    [i =!= k]
    [j =!= k]
    [0 <= {i,j,k} < L]
    [min(ls) == ls[i] <= ls[j] <= ls[k] == min(del_(ls;i,j))]
    [?[tpg :: 多边形三角化方案<L>] -> [[操作数囗多边形三角化囗(tpg;多边形囗顶点权重:=ls) == MNO(ls)][(i,j),(i,k)皆是tpg中三角形的边]]]
      #可能 为tpg的 内边、外边
    [?[tpg :: 最优多边形三角化方案<ls>] -> [(i,j),(i,k)皆是tpg中三角形的边]] # :=[def]= [低一之二边及低一之三边同时是某最优解的三角边]
        #--->[定义基本多边形][降解至基本多边形]
  ]]
  #两份证明:直接法 是为了 最后 新出的结论！
  [[proof:直接法
  [tpg :<- 最优多边形三角化方案<ls>]
  [(i,k)不是tpg三角边]:
    [(i,k)不是 外边]
    [arcs := tpg中与(i,k)不相容的内边]
    [small_polygon_ge4 := tpg删去arcs后，内部出现的非三角形的多边形]
    [i,k是small_polygon_ge4的顶点]
    #   [j可能是small_polygon_ge4的顶点]
    [no_j_half_vs := small_polygon_ge4被{i,k}分隔开来的两半中任一不含j的半面顶点 \-\{i,k}]
    [another_half_vs := small_polygon_ge4\-\no_j_half_vs \-\{i,k}]
    [tpg_ := tpg删去arcs，添加(i,k)，no_j_half_vs中所有顶点连向i，another_half_vs中所有顶点连向k]
    [@[v<-another_half_vs顶点] -> [ls[v] >= ls[j] >= ls[i]]]
    [min(ls[*another_half_vs]) >= ls[j] >= ls[i]]
    [no_j_half_vs上相应三角形 的 另一点 在 another_half_vs上，tpg变为tpg_时 移为 i，操作数变小]
    [@[v<-no_j_half_vs顶点] -> [ls[v] >= ls[k]]]
    [min(ls[*no_j_half_vs]) >= ls[k]]
    [another_half_vs上相应三角形 的 另一点 在 no_j_half_vs上，tpg变为tpg_时 移为 k，操作数变小]
    [操作数<tpg_> <= 操作数<tpg>]
    !![tpg :<- 最优多边形三角化方案<ls>]
    [操作数<tpg> <= 操作数<tpg_>]
    [操作数<tpg_> == 操作数<tpg>]
    [tpg_ <- 最优多边形三角化方案<ls>]
    ###扩展:
    [max(ls[*another_half_vs]) == min(ls[*another_half_vs]) == ls[j] == ls[i]]
    [max(ls[*no_j_half_vs]) == min(ls[*no_j_half_vs]) == ls[k]]
    [[{*another_half_vs}=={j}]or[ls[k]==ls[j]==ls[i]]]
      # :=[def]= [不与低一之三边相容的最优解的三角边只能是另外的低一之三边且低一低二的权重相同][不与低一之三边相容的最优解的三角边若非聚焦型则低一低二低三的权重相同]
  [@[arcs :: 任意数量的三角边] -> [(i,k)与arcs相容] -> ?[tpg :<- 最优多边形三角化方案<ls>] -> [arcs |<=| tpg] -> [?[tpg_ :<- 最优多边形三角化方案<ls>] -> [[arcs |<=| tpg_][(i,k) <- tpg_]]]]
  !!let[arcs := {}]
  [?[tpg_ :<- 最优多边形三角化方案<ls>] -> [(i,k) <- tpg_]]

  [(i,j)不是tpg三角边]:
    同理于[(i,k)不是tpg三角边]
    ###扩展:
    [max(ls[*another_half_vs]) == min(ls[*another_half_vs]) == ls[k] == ls[i]]
    [max(ls[*no_k_half_vs]) == min(ls[*no_k_half_vs]) == ls[k] == ls[j]]
      # :=[def]= [不与低一之二边相容的最优解的三角边只能是另外的低一之二边且低一低二低三的权重相同]
  [@[arcs :: 任意数量的三角边] -> [(i,j)与arcs相容] -> ?[tpg :<- 最优多边形三角化方案<ls>] -> [arcs |<=| tpg] -> [?[tpg_ :<- 最优多边形三角化方案<ls>] -> [[arcs |<=| tpg_][(i,j) <- tpg_]]]]
  !!let[arcs := {}]
  [?[tpg_ :<- 最优多边形三角化方案<ls>] -> [(i,j) <- tpg_]]
  !!let[arcs := {(i,k)}]
  [?[tpg_ :<- 最优多边形三角化方案<ls>] -> [{(i,j),(i,k)} |<=| tpg_]]
  DONE
  ===ps:
  # 比 [低一之二边及低一之三边同时是某最优解的三角边] 更强的结论:
  [@[arcs :: 任意数量的三角边] -> @[arcs_ :<- 2**{(i,j),(i,k)}] -> [arcs_与arcs相容] -> ?[tpg :<- 最优多边形三角化方案<ls>] -> [arcs |<=| tpg] -> [?[tpg_ :<- 最优多边形三角化方案<ls>] -> [(arcs/-\arcs_) |<=| tpg_]]]
    # :=[def]= [低一之二边及低一之三边是高度相容的最优解的三角边]

    #见上面:证明过程中的定义:
    [不与低一之三边相容的最优解的三角边只能是另外的低一之三边且低一低二的权重相同][不与低一之三边相容的最优解的三角边若非聚焦型则低一低二低三的权重相同]
    [不与低一之二边相容的最优解的三角边只能是另外的低一之二边且低一低二低三的权重相同]
  ]]
  [[proof:归纳法
  * [L==3]: ok!
  * [L>3][归纳法-假设]:
    ?:[u <- [0..<L]] -> [[u !<- {i,j,k}][ls[u] == min(del_(ls;i,j,k))]]
    * ?[tpg :<- 最优多边形三角化方案<ls>] -> [tpg中i的度>2]:
        [含i的内边 将tpg3切成更小的两半]
        归纳ok!
    * @[tpg :<- 最优多边形三角化方案<ls>] -> [tpg中i的度==2]:
      [tpg :<- 最优多边形三角化方案<ls>]
      [tpg中i的度==2]
      [vs2 := {tpg中所有度为2的顶点}]
      [i <- vs2]
      [len(vs2) >= 2]
      [vs2_not_min := vs2 \-\ {i,j,k}]
      * [len(vs2_not_min) > 0]:
        [v :<- vs2_not_min]
        [tpg_ := tpg移除顶点v]
        [ls_ := del_(ls;v)]
        [tpg_是ls_的 最优解]
        !![归纳法-假设]
        ?:[tpg_2是ls_的 最优解] -> [(i,j),(i,k)皆是tpg_2中三角形的边]
        [tpg2 := tpg_2添加顶点v]
        [MNO(ls)
        == 操作数<tpg_> + ls[v]*ls[(v+1)%L]*ls[(v-1)%L]
        = MNO(ls_) + ls[v]*ls[(v+1)%L]*ls[(v-1)%L]
        = 操作数<tpg_2> + ls[v]*ls[(v+1)%L]*ls[(v-1)%L]
        = 操作数<tpg2>
        ]
        [tpg2是ls的 最优解][(i,j),(i,k)皆是tpg2中三角形的边]

      * [len(vs2_not_min) == 0]:
        [vs2 |<=| {i,j,k}]
        !![i <- vs2]
        [{i} |<=| vs2 |<=| {i,j,k}]
        !![len(vs2) >= 2]
        [[{i,j} |<=| vs2]or[{i,k} |<=| vs2]]
        [[{i,j} == vs2]or[{i,k} == vs2][{i,j,k} == vs2]]

        * [{i,j} == vs2]:
          !![L > 3][{i,j} == vs2]
          [i,j不相邻]
          [(i,j)不是tpg的外边]
          [(i,j)不是tpg的三角边]
          !![归纳法-假设]
          移除顶点j再补回，得:[tpg3:<-最优解<L>][tpg3中j的度为2][(i,k),(i,u)为tpg3的三角边]
          !!分支条件[@[tpg :<- 最优多边形三角化方案<ls>] -> [tpg中i的度==2]]
          [tpg3中i的度==2]
          [(i,k),(i,u)为tpg3的外边]
          [(k,u)为tpg3的内边]
          [i,k相邻][i,u相邻]

          !![归纳法-假设]
          移除顶点i再补回，得:[tpg4:<-最优解<L>][tpg4中i的度为2][(j,k),(j,u)为tpg4的三角边]
          !![tpg4中i的度为2]
          !![i,k相邻][i,u相邻]
          [(k,u)为tpg4的三角边]
          [(j,k),(j,u),(k,u)为tpg4的三角边]
          !![i,k相邻][i,u相邻]
          [(i,k),(i,u)为tpg4的三角边]
          [(i,k),(i,u),(j,k),(j,u),(k,u)为tpg4的三角边]
          [{(i,k),(i,u),(j,k),(j,u),(k,u)} <- 最优多边形三角化方案<ls[i,k,j,u]>]
          !!镜像对称等价
          !!循环移动等价
          !![聚焦型多边形三角化方案的优化]
          [作为多边形三角化方案:{(i,k),(i,u),(j,k),(j,u),(i,j)} 不劣于 {(i,k),(i,u),(j,k),(j,u),(k,u)}]
          [{(i,k),(i,u),(j,k),(j,u),(i,j)} <- 最优多边形三角化方案<ls[i,k,j,u]>]
          !![最优解中i的度数只能是2]
          _L

        * [{i,k} == vs2]:
          同理于:[{i,j} == vs2]
          _L
        * [{i,j,k} == vs2]:
          同理于:[{i,j} == vs2]
          _L
        _L
  DONE
  ]]


[词典序最先的最优三角化方案必含低一之二边及低一之三边作为三角边] #可能是外边
  !![低一之二边及低一之三边同时是某最优解的三角边]
  !!词典序最先的最优三角化方案 定义

[所有索引序列囗升像囗 :: Ord a => [a]{len==L} -> {all_permutations_([0..<L])/unique[int%L]{len==L}}]
[所有索引序列囗升像囗(ls) =[def]= let L := len(ls) in {idc | [[idc :: all_permutations_([0..<L])][len(idc)==L][@[i::int] -> [0 <= i < L] -> [0 <= idc[i] < L]][@[i,j::int] -> [0 <= i <= j < L] -> [ls[idc[i]] <= ls[idc[j]]]][@[i,j::int] -> [0 <= i < j < L] -> [idc[i] =!= idc[j]]]]}]

[[ls :: [pint]] -> [L := len(ls)] -> [L >= 3] -> [idc :<- 所有索引序列囗升像囗(ls)] -> [i,j,k := idc[:3]] -> [
    [?[tpg :: 最优多边形三角化方案<ls>] -> [(i,j),(i,k)皆是tpg中三角形的边]] # :=[def]= [最低两边为某最优解的三角边]
  ]]

[[ls :: [pint]] -> [L := len(ls)] -> [L >= 4] -> [idc :<- 所有索引序列囗升像囗(ls)] -> [i,j,k,u := idc[:4]] -> [(i,j),(i,k)皆是 多边形囗(ls)的外边] -> [
    [?[tpg :: 最优多边形三角化方案<ls>] -> [
      [[not [(j,k)是tpg中的 内边]] -> [(i,u)是tpg中的 内边]]
      [[(j,k)是tpg中的 内边] -> [[(j,u)是tpg中的 三角边][1/ls[i]+1/ls[u] <= 1/ls[j]+1/ls[k]]]]
      # 外边{(i,j),(i,k)} 即 基本多边形 ==>> {(j,k),(j,u)}or{(i,u)}
      ]] # :=[def]= [基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
        # 旧命名有毛病:[基本多边形的任意最优解的内边必含有低二之三边或低一之四边]
        # 证明有毛病，或者说缺少条件:[ls[i] < ls[j] <= ls[k] < ls[u]] :=[def]= [强基本多边形] ==>>??? [强基本多边形的任意最优解的内边必含有低二之三边或某低一之四边]
        #==>>???[基本多边形的任意最优解的内边必含有某低二之三边或某低一之四边]

  ]]
  [[proof:
  [tpg :<- 最优多边形三角化方案<ls>]

  * [not [(j,k)是tpg中的 内边]]:
    !![L >= 4][(i,j),(i,k)皆是 多边形囗(ls)的外边]
    [tpg中i的度>2]
    ?:[v <- [0..<L]] -> [(i,t)是tpg中的 内边]
    [(i,t)将tpg分割成更小的两半:j,k被分开；至少一半含u]
    !![最低两边为某最优解的三角边]
    [?[tpg5 :: 最优多边形三角化方案<ls>] -> [(i,u)是tpg5中的 内边]]

  * [(j,k)是tpg中的 内边]:
    !![(i,j),(i,k)皆是 多边形囗(ls)的外边]
    [tpg中i的度==2]
    !![最低两边为某最优解的三角边]
    移除顶点i再补回，得:[tpg6:<-最优解<L>][tpg6中i的度为2][(j,k),(j,u)为tpg6的三角边]
    [(j,u)为tpg6的三角边]

    # (j,u)切掉tpg6的一半，以成为外边
    * [(i+1)%L == j]:
      [(i-1)%L == k]
      [(ls_;i_,j_,k_,u_;tpg6_) := ls删去 j,u 之间不含{i,k}的外环上的顶点 并 相应变量的更新值]
      [ls[k,i,j,u] == ls_[k_,i_,j_,u_]]
      [(k_+1)%L == i_]
      [(i_+1)%L == j_]
      [(j_+1)%L == u_]
      [(k_,i_)是tpg6_中的 外边]
      [(i_,j_)是tpg6_中的 外边]
      [(j_,u_)是tpg6_中的 外边]
      [tpg6_ <- 最优多边形三角化方案<ls_>]
      [tpg6_中i_的度为2]
      [(j_,k_)是tpg6_中的 内边]
      [ls[k]*ls[i]*ls[j]+MNO(del_(ls_;i_)) == MNO(ls_) <= ls[i]*ls[j]*ls[u]+MNO(del_(ls_;j_))]

      [+ls[i]*ls[j]*ls[u]-ls[k]*ls[i]*ls[j]
      >=+MNO(del_(ls_;i_))-MNO(del_(ls_;j_))
      let[ls_2 := (循环左移**(j_+1))(ls_)[:-2]]
      ==+MNO(ls_2++[ls[j]])-MNO(ls_2++[ls[i]])
      let[tpg_n1 :<- 最优多边形三角化方案<(ls_2++[ls[j]])>]
      ==+操作数囗多边形三角化囗(tpg_n1;多边形囗顶点权重:=(ls_2++[ls[j]]))-MNO(ls_2++[ls[i]])
      >=+操作数囗多边形三角化囗(tpg_n1;多边形囗顶点权重:=(ls_2++[ls[j]]))-操作数囗多边形三角化囗(tpg_n1;多边形囗顶点权重:=(ls_2++[ls[i]]))
      == (ls[j]-ls[i])*sum{ls_2[a1]*ls_2[a2] | [{(L-2),a1,a2} :<- tpg_n1中所有含顶点(L-2)的三角]}
      >= (ls[j]-ls[i])*sum{ls[k]*ls[u] | [{(L-2),a1,a2} :<- tpg_n1中所有含顶点(L-2)的三角]}
      >= (ls[j]-ls[i])*(ls[k]*ls[u]*1)
      ]
      [+ls[i]*ls[j]*ls[u]-ls[k]*ls[i]*ls[j]
      >= (ls[j]-ls[i])*(ls[k]*ls[u]*1)
      ]
      [1/ls[k]-1/ls[u] >= 1/ls[i]-1/ls[j]]
      [1/ls[k]+1/ls[j] >= 1/ls[i]+1/ls[u]]
      [1/ls[i]+1/ls[u] <= 1/ls[j]+1/ls[k]]

      # [tpg7_ := tpg6_删去内边(j_,k_)，新增内边(i_,u_)]
        #bug:没有[tpg6_中j_的度为2]，不能添加(i_,u_)
      #[tpg7_ <- 多边形三角化方案<len(ls_)>] #不一定最优

    * [(i-1)%L == j]:
      !!镜像对称等价
      同理于:[(i+1)%L == j]
      [1/ls[i]+1/ls[u] <= 1/ls[j]+1/ls[k]]
    [1/ls[i]+1/ls[u] <= 1/ls[j]+1/ls[k]]

  DONE
  ]]


[四稳定多边形三角化方案 =[def]= 任意相邻两个三角构成的四边形最优的多边形三角化方案]#对角线局部稳定
[最优多边形三角化方案 必是 四稳定多边形三角化方案]
[四稳定多边形三角化方案 不必是 最优多边形三角化方案]
  例:
    [ls := [10,11,25,40,12]]
    [左结合优先方案<5> = 聚焦于ls[0]的方案 <- 四稳定多边形三角化方案<ls>]
    [右结合优先方案<5> = 聚焦于ls[-1]的方案 <- 最优多边形三角化方案<ls>]



竖对角线vertical arc
横对角线horizontal arc
潜在的横对角线potential horizontal arc
  [三角化方案]:
    [对角线 两侧 必是 三角形]
    [对角线 在 四边形 中]
    [四边形(a,b,c,d)][对角线(a,c)]:
      [是四边形最优对角线(ls;b,d;a,c) =[def]= [(ls[a]*ls[c])*(ls[b]+ls[d]) <= (ls[b]*ls[d])*(ls[a]+ls[c])]]
      [是四边形最优对角线(ls;b,d;a,c) == [(1/ls[b]+1/ls[d]) <= (1/ls[a]+1/ls[c])]]

      [ls[a] <= ls[c]][ls[b] <= ls[d]]:
        !![是四边形最优对角线(ls;b,d;a,c) == [(1/ls[b]+1/ls[d]) <= (1/ls[a]+1/ls[c])]]
        [[是四边形最优对角线(ls;b,d;a,c)] -> [ls[b] == ls[a]] -> [ls[c] <= ls[d]]]
        [[是四边形最优对角线(ls;b,d;a,c)] -> [ls[b] < ls[a]] -> [ls[c] < ls[d]]]

        [[是四边形最优对角线(ls;b,d;a,c)] -> [
        [ls[b] > ls[a]]
        or[[ls[b] == ls[a]][ls[c] <= ls[d]]]
          #前两种情况合为 竖对角线
        or[[ls[b] < ls[a]][ls[c] < ls[d]]]
          #最后一种情况为 横对角线
        ]]
      [[是四边形最优对角线(ls;b,d;a,c)] -> [[是竖对角线(ls;b,d;a,c)]or[是横对角线(ls;b,d;a,c)]]]
          # :=[def]= [对角线局部稳定必要条件囗非横则竖]


      [是竖对角线(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) < min(ls[b],ls[d])]or[[min(ls[a],ls[c]) == min(ls[b],ls[d])][max(ls[a],ls[c]) <= max(ls[b],ls[d])]]]]
      [是横对角线(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) > min(ls[b],ls[d])][max(ls[a],ls[c]) < max(ls[b],ls[d])]]]
      [ls[a] <= ls[c]][ls[b] <= ls[d]]:
        [是竖对角线(ls;b,d;a,c) == [[ls[a] < ls[b]]or[ls[a] == ls[b] <= ls[c] <= ls[d]]]]
        [是竖对角线(ls;b,d;a,c) == [(ls[a],ls[c]) <= (ls[b],ls[d])]]
        [是横对角线(ls;b,d;a,c) == [ls[b] < ls[a] <= ls[c] < ls[d]]]

        [[not [[是竖对角线(ls;b,d;a,c)]or[是横对角线(ls;b,d;a,c)]]]
        == [[ls[a] == ls[b] <= ls[d] < ls[c]]or[[ls[b] < ls[a]][ls[d] <= ls[c]]]]
        == [[ls[b] <= ls[a]][ls[d] <= ls[c]][(ls[b],ls[d]) =!= (ls[a],ls[c])]]
        == [[ls[b] <= ls[a]][ls[d] <= ls[c]][(ls[b],ls[d]) < (ls[a],ls[c])]]
        ]
      #无需 [ls[a] <= ls[c]][ls[b] <= ls[d]]:
      #补集
      [[not [[是竖对角线(ls;b,d;a,c)]or[是横对角线(ls;b,d;a,c)]]] -> [是竖对角线(ls;a,c;b,d)]]

      #交集
      [not [[是竖对角线(ls;b,d;a,c)][是横对角线(ls;b,d;a,c)]]]
      [[是横对角线(ls;b,d;a,c)] -> [not [是竖对角线(ls;b,d;a,c)]]]
      [[是竖对角线(ls;b,d;a,c)] -> [not [是横对角线(ls;b,d;a,c)]]]

      !![[是四边形最优对角线(ls;b,d;a,c)] -> [[是竖对角线(ls;b,d;a,c)]or[是横对角线(ls;b,d;a,c)]]]
      [[not [[是竖对角线(ls;b,d;a,c)]or[是横对角线(ls;b,d;a,c)]]] -> [not [是四边形最优对角线(ls;b,d;a,c)]]]


      # 四者关系:C(4;2)=6份关系
      #   [是竖对角线(ls;b,d;a,c)]
      #   [是竖对角线(ls;a,c;b,d)]
      #   [是横对角线(ls;b,d;a,c)]
      #   [是横对角线(ls;a,c;b,d)]
      [[ls[a] <= ls[c]][ls[b] <= ls[d]]]:
        !![是竖对角线(ls;b,d;a,c) == [(ls[a],ls[c]) <= (ls[b],ls[d])]]
        !![是竖对角线(ls;a,c;b,d) == [(ls[a],ls[c]) >= (ls[b],ls[d])]]
        [[[是竖对角线(ls;b,d;a,c)][是竖对角线(ls;a,c;b,d)]] == [{ls[a],ls[c]} == {ls[b],ls[d]}]]

        !![是横对角线(ls;b,d;a,c) == [ls[b] < ls[a] <= ls[c] < ls[d]]]
        [not [[是横对角线(ls;b,d;a,c)][是横对角线(ls;a,c;b,d)]]]

        !![是竖对角线(ls;b,d;a,c) == [(ls[a],ls[c]) <= (ls[b],ls[d])]]
        !![是横对角线(ls;b,d;a,c) == [ls[b] < ls[a] <= ls[c] < ls[d]]]
        [not [[是竖对角线(ls;b,d;a,c)][是横对角线(ls;b,d;a,c)]]]
          #同一对角线的横竖交集#2份关系

        !![是横对角线(ls;b,d;a,c) == [ls[b] < ls[a] <= ls[c] < ls[d]]]
        !![是竖对角线(ls;a,c;b,d) == [(ls[a],ls[c]) >= (ls[b],ls[d])]]
        [[是横对角线(ls;b,d;a,c)] -> [是竖对角线(ls;a,c;b,d)]]
          #不同一对角线的横竖交集#2份关系


      #无需 [ls[a] <= ls[c]][ls[b] <= ls[d]]:
      [not [[是竖对角线(ls;b,d;a,c)][是横对角线(ls;b,d;a,c)]]]
        #同对角线囗横竖互斥
      [not [[是横对角线(ls;b,d;a,c)][是横对角线(ls;a,c;b,d)]]]
        #异对角线囗横横互斥
      [[[是竖对角线(ls;b,d;a,c)][是竖对角线(ls;a,c;b,d)]] == [{ls[a],ls[c]} == {ls[b],ls[d]}]]
        #异对角线囗竖竖交集为权重相等
      [[是横对角线(ls;b,d;a,c)] -> [是竖对角线(ls;a,c;b,d)]]
        #异对角线囗横为竖的子集

[边数大于三的基本多边形的词典序最先的最优三角化方案的内边含有低二之三边的必要条件囗低一二三四顶点关系 是 [[1/ls[i0]+1/ls[i3] < 1/ls[i1]+1/ls[i2]][ls[i2] < ls[i3]]]]
  [[proof:
  #等号被去掉 是因为 词典序
  假设 (i1,i2)所在 四边形 为{i0,i1,i3,ik}
    !!基本多边形 定义
  !![低一二三四顶点]
  [ls[i0] <= ls[i1] <= ls[i2] <= ls[i3] <= ls[ik]]

  !![基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
  [1/ls[i0]+1/ls[i3] <= 1/ls[i1]+1/ls[i2]]
  [1/ls[i0]+1/ls[i3] == 1/ls[i1]+1/ls[i2]]:
    [1/ls[i0]+1/ls[ik] <= 1/ls[i1]+1/ls[i2]]
    !![词典序最先的最优三角化方案]
    [(i0,ik)优于(i1,i2)]
    _L
  [1/ls[i0]+1/ls[i3] < 1/ls[i1]+1/ls[i2]]

  [ls[i2] == ls[i3]]:
    [1/ls[i0] < 1/ls[i1]]
    [ls[i0] > ls[i1]]
    _L
  [ls[i2] =!= ls[i3]]
  [ls[i2] < ls[i3]]
  ]]

[ls :: Ord a => [a]]:
  [is_rotated_asc_seq(ls) =[def]= if not ls then True else let [[_imax := ls.index(max(ls))][ls_ := ls[_imax:]++ls[:_imax]][imin := ls_.index(min(ls_))][ls__ := ls[imin:]++ls[:imin]]] in is_sorted(ls__)]
[[L :: pint][i,j :<- [0..<L]]]:
  [range_mod_(L; i,j) =[def]= if i <= j then [i..<j]%L else [i-L..<j]%L]
[[L :: pint][i,j :: int]]:
  [range_mod_ex_(L; i,j) =[def]= range_mod_(L; i%L,j%L)]



[[[ls :: [pint]][L := len(ls)][L >= 4][imin :<- [0..<L]][ls[imin] == min(ls)]] -> [ltpg := 词典序最先的最优三角化方案囗(imin;ls)] -> [a,b,c,d :<- [0..<L]] -> [len{a,b,c,d} == 4] -> [{{a,c},{a,b},{b,c},{c,d},{d,a}} |<=| ltpg] -> [is_rotated_asc_seq([a,b,c,d])] -> [_ac_ := range_mod_(L;a+1,c)] -> [_ca_ := range_mod_(L;c+1,a)] -> [是横对角线(ls;b,d;a,c)] -> [
  [len(_ac_) > 0]
  [len(_ca_) > 0]
  [fw := \i->fweight(ls;imin;i))]
  [i := min(_ac_, key=fw)]
  [j := min(_ca_, key=fw)]
  [(u,v) := sorted([i,j], key=fw)]
  [ls[u] < ls[a] < ls[v]]
  [ls[u] < ls[c] < ls[v]]
    # :=[def]= [无用囗词典序最先的最优三角化方案囗横对角线的必要条件]
    #   无用是因为 [ls := [11,11,33,22]][imin:=0][one_sweep_algorithm(ls)==[(1,2)]][(1,2)不是 横对角线][(1,3)是 潜在的横对角线][(1,3) <- ltpg<ls;imin>]
  #[ls[u] == min(ls)]
  [u==imin] #fw(u)全局最小
  [fw(u) < fw(a) < fw(v)]
  [fw(u) < fw(c) < fw(v)]
    # :=[def]= [词典序最先的最优三角化方案囗潜在的横对角线的必要条件]
    #   one_sweep_algorithm 输出所有 潜在的潜在的横对角线，而非 潜在的横对角线，所以其后续需要修正
    #   用于one_sweep_algorithm之后，移除 非『潜在的横对角线』，这是于整个算法而言是必要的
    #   #并不需要 u在半链最小(这时条件更严格)(反正最小的比u更小，肯定也满足)，但仍要求v在半链上最小
  ]]
  [[proof:
  !!b,d的存在
  [len(_ac_) > 0]
  [len(_ca_) > 0]
  [i,j良定义]


  !!b,d的存在
  [(b_,d_) := sorted([b,d], key=fw)]
  !![是横对角线(ls;b,d;a,c) =[def]= [[min(ls[a],ls[c]) > min(ls[b],ls[d])][max(ls[a],ls[c]) < max(ls[b],ls[d])]]]
  !![是横对角线(ls;b,d;a,c)]
  [ls[b_] < ls[a] < ls[d_]]
  [ls[b_] < ls[c] < ls[d_]]

  #得用ls证明，fw无用

  [{u,v} == {i,j}]
  [i =!= j]
  [u =!= v]
  [fw(u) < fw(v)]
  [ls[u] <= ls[v]]

  [((p,q,r,s),(_pr_,_rp_)) := if [u == i] then ((a,b,c,d),(_ac_,_ca_)) else ((c,d,a,b),(_ca_,_ac_))]
  [u <- _pr_]
  [v <- _rp_]
  [{p,r} == {a,c}]
  [{q,s} == {b,d}]

  !![i := min(_ac_, key=fw)]
  !![j := min(_ca_, key=fw)]
  [u == min(_pr_, key=fw)]
  [v == min(_rp_, key=fw)]

  !![len{a,b,c,d} == 4][{{a,c},{a,b},{b,c},{c,d},{d,a}} |<=| ltpg][is_rotated_asc_seq([a,b,c,d])][_ac_ := range_mod_(L;a+1,c)][_ca_ := range_mod_(L;c+1,a)][是横对角线(ls;b,d;a,c)]
  [len{p,q,r,s} == 4][{{p,r},{p,q},{q,r},{r,s},{s,p}} |<=| ltpg][is_rotated_asc_seq([p,q,r,s])][_pr_ == range_mod_(L;p+1,r)][_rp_ == range_mod_(L;r+1,p)][是横对角线(ls;q,s;p,r)]
  [q <- _pr_]
  [s <- _rp_]

  !![{q,s} == {b,d}]
  [ls[b_] < ls[p] < ls[d_]]
  [ls[b_] < ls[r] < ls[d_]]
  [(q_,s_) := sorted([q,s], key=fw)]
  [{q_,s_} == {q,s} == {b,d} == {b_,d_}]
  !![(b_,d_) := sorted([b,d], key=fw)]
  [(q_,s_) == (b_,d_)]
  [ls[q_] < ls[p] < ls[s_]]
  [ls[q_] < ls[r] < ls[s_]]

  [(p_,r_) := sorted([p,r], key=fw)]
  [fw(p_) < fw(r_)]
  [{p_,r_} == {p,r}]
  [ls[q_] < ls[p_] < ls[s_]]
  [ls[q_] < ls[r_] < ls[s_]]
  [ls[q_] < ls[p_] <= ls[r_] < ls[s_]]

  !![_pr_ == range_mod_(L;p+1,r)]
  !![_rp_ == range_mod_(L;r+1,p)]
  !![u == min(_pr_, key=fw)]
  !![v == min(_rp_, key=fw)]
  !![fw(u) < fw(v)]
  !![{p_,r_} == {p,r}]
  !![fw(p_) < fw(r_)]
  [ls[p_] <= ls[u]]:
    [ls[p_] == min(ls)]
      #四部分:p,r,_pr_,_rp_
    !![ls[q_] < ls[p_] < ls[s_]]
    [ls[p_] > ls[q_] >= min(ls)]
    _L
  [ls[u] < ls[p_]]
  [fw(u) < fw(p_)]
  !![fw(p_) < fw(r_)]
  !![fw(u) < fw(v)]
  [u == imin]
      #四部分:p,r,_pr_,_rp_

  [?无用?发现反例！不对，还有条件没用到:词典序+低一二三四顶点『边数大于三的基本多边形的词典序最先的最优三角化方案的内边含有低二之三边的必要条件囗低一二三四顶点关系』]:
    !![is_rotated_asc_seq([p,q,r,s])]
    !![q <- _pr_]
    !![u <- _pr_]
    !![s <- _rp_]
    !![v <- _rp_]
    [is_rotated_asc_seq([p,u,r,v])]
    [is_rotated_asc_seq([u,r,v,p])]
    !![u == imin]
    [[fw(p) < fw(r)] <-> [ls[p] < ls[r]]]
      ######『<』
    [[fw(p) < fw(v)] <-> [ls[p] < ls[v]]]
      ######『<』
    [[fw(r) < fw(v)] <-> [ls[r] <= ls[v]]]
      ######『<=』
    !![{p_,r_} == {p,r}]
    [[fw(r_) < fw(v)] -> [ls[r_] <= ls[v]]]
      ######『<=』没用！！
    [[fw(p_) < fw(v)] -> [ls[p_] < ls[v]]]
      ######『<』有用！！

    [fw(r_) < fw(v)]:
      [ls[p] < ls[v]]
      [ls[r] <= ls[v]]
      发现反例: [ls[u,r,v,p] == [1,4,4,3]]
      bug:不能证明:
        [ls[u] < ls[a] < ls[v]]
        [ls[u] < ls[c] < ls[v]]
      只能证明:
        [ls[u] < ls[a] <= ls[v]]
        [ls[u] < ls[c] <= ls[v]]
        [not [ls[a] == ls[c] == ls[v]]]
        [fw(a) < fw(v)]:
        [fw(c) < fw(v)]:

  [?无用?]:
    !![是横对角线(ls;q,s;p,r)]
    !![{p_,r_} == {p,r}]
    [是横对角线(ls;q,s;p_,r_)]
    [max(ls[p_], ls[r_]) < max(ls[q], ls[s])]
    #bug:[ls[r_] < ls[s]]
    [ls[r_] < max(ls[q], ls[s])]
    !![v == min(_rp_, key=fw)]
    !![s <- _rp_]
    [ls[v] <= ls[s]]


  !![u <- _pr_]
  [len(_pr_) >= 1]:
  #归纳法:
  * [len(_pr_) == 1]:
    !![len(_pr_) == 1]
    !![u <- _pr_]
    !![q <- _pr_]
    [q == u]
    [(u,p_)是 三角边]
    [(u,r_)是 三角边]

    !![len(_pr_) == 1]
    [degree(u) == 2]
    !![u == imin]
    [degree(imin) == degree(u) == 2]
    !![词典序最先的最优三角化方案必含低一之二边及低一之三边作为三角边]
    !![fw(p_) < fw(r_)]
    [(u,p_)是 低一之二边]
    [(u,r_)是 低一之三边]

    !![基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
    !![ltpg不含 低一之四边]
    [ltpg含 低二之三边]
    [(p_,r_)是 ltpg中的 低二之三边]
    !![v == min(_rp_, key=fw)]
    [v是 低四顶点]
    [fw(u) < fw(p_) < fw(r_) < fw(v)]
    [ls[u] <= ls[p_] <= ls[r_] <= ls[v]]
    !![ls[u] < ls[p_]]
    [ls[u] < ls[p_] <= ls[r_] <= ls[v]]
    !![边数大于三的基本多边形的词典序最先的最优三角化方案的内边含有低二之三边的必要条件囗低一二三四顶点关系]
    [ls[r_] < ls[v]]
    [ls[u] < ls[p_] <= ls[r_] < ls[v]]

  * [len(_pr_) > 1][归纳法-假设]:
    !![u <- _pr_]
    !![u == imin]
    * [degree(u) > 2]:
      [{u,z} :<- ltpg的对角线]
      [{z,u,v,p,q,r,s} 在 {u,z}分割ltpg的某一半ltpg_half上]
      !![imin == u <- ltpg_half的顶点]
      [fw{z,u,v,p,q,r,s}次序不变]
      [ltpg_half <- 词典序最先的最优三角化方案囗(imin;ls[ltpg_half顶点])]
      [len(ltpg_half顶点) < L]
      !![归纳法-假设]
      [ls[u] < ls[p_] <= ls[r_] < ls[v]]
    * [degree(u)==2]:
      !![词典序最先的最优三角化方案必含低一之二边及低一之三边作为三角边]
      !![u == imin]
      假设 [(u,i1)是 低一之二边]
      假设 [(u,i2)是 低一之三边]
      [ltpg_u := ltpg切去u]
      * [is_rotated_asc_seq([u,i1,i2])]:
        #不论是否[ls.count(ls[i1]) == 1]
        [ltpg_u 以i1为起点，顶点的fw次序不变]
      * [is_rotated_asc_seq([u,i2,i1])]:
        [ls_ := ls[u:] ++ ls[:u]]
        [ls[i1] < min(ls_[1:-1])]
        [ls.count(ls[i1]) == 1]
        [ltpg_u 以i1为起点，顶点的fw次序不变]
      [ltpg_u 以i1为起点，顶点的fw次序不变]
      [ltpg_u <- 词典序最先的最优三角化方案囗(i1;ls[ltpg_u顶点])]
      !![归纳法-假设]
      [ls[i0] < ls[p_] <= ls[r_] < ls[v]]
      !![ls[u] <= ls[i0]]
      [ls[u] < ls[p_] <= ls[r_] < ls[v]]
    [ls[u] < ls[p_] <= ls[r_] < ls[v]]
  [ls[u] < ls[p_] <= ls[r_] < ls[v]]


  !![ls[u] < ls[p_] <= ls[r_] < ls[v]]
  !![{p_,r_} == {p,r}]
  !![{p,r} == {a,c}]
  [ls[u] < ls[a] < ls[v]]
  [ls[u] < ls[c] < ls[v]]

  [fw(u) < fw(a) < fw(v)]
  [fw(u) < fw(c) < fw(v)]
  [fw(u) == fw(imin)]
  [u == imin]

  DONE
  ]]

#潜在的横对角线 定义
[[ls :: [pint]][L := len(ls)][L >= 4][imin :<- [0..<L]][ls[imin] == min(ls)][fw := \i->fweight(ls;imin;i))][a,c :<- [0..<L]]]:
  [是潜在的横对角线(ls;imin;a,c) =[def]= [[a=!=c]
    [_ac_ := range_mod_(L;a+1,c)]
    [_ca_ := range_mod_(L;c+1,a)]
    [len(_ac_) > 0][len(_ca_) > 0]

    [?[(_xy_,_yx_) :<- all_permutations_([_ac_,_ca_])] -> [
      [@[j <- _xy_] -> [fw(j) > max{fw(a),fw(c)}]]
      [?[i <- _yx_] -> [fw(i) < min{fw(a),fw(c)}]]
      ]]
    ]]
  [是潜在的横对角线(ls;imin;a,c) == [
    [len{imin,a,c} ==3]
    [(x,y) := if a < c then (a,c) else (c,a)]
    [y-x >= 2]
    [_xy_ := range_mod_(L;x+1,y)]
    [@[j <- _xy_] -> [fw(j) > max{fw(a),fw(c)}]]
    ]]
  [[是潜在的横对角线(ls;imin;a,c)] -> [imax := max([0..<L],key=fw)] -> [imin < min(fw(b), fw(d)) < max(fw(b), fw(d)) < imax]]
      # :=[def]= [潜在的横对角线不含权重最大的顶点]
      # :=[def]= [潜在的横对角线不含权重最小的顶点]


[[[ls :: [pint]][L := len(ls)][L >= 4][imin :<- [0..<L]][ls[imin] == min(ls)][fw := \i->fweight(ls;imin;i))]] -> [a,b,c,d :<- [0..<L]] -> [len{a,b,c,d} == 4] -> [is_rotated_asc_seq([a,b,c,d])] -> [是潜在的横对角线(ls;imin;a,c)] -> [max(fw(a), fw(c)) < max(fw(b), fw(d))]]

[[[ls :: [pint]][L := len(ls)][L >= 4][imin :<- [0..<L]][ls[imin] == min(ls)][fw := \i->fweight(ls;imin;i))]] -> [a,b,c,d :<- [0..<L]] -> [len{a,b,c,d} == 4] -> [is_rotated_asc_seq([a,b,c,d])] -> [是潜在的横对角线(ls;imin;a,c)] -> [not [是潜在的横对角线(ls;imin;b,d)]]]
  # [所有潜在的横对角线不相交]
  [[proof:
  !![是潜在的横对角线(ls;imin;a,c)]:
  [max(fw(a), fw(c)) < max(fw(b), fw(d))]

  [是潜在的横对角线(ls;imin;b,d)]:
    [max(fw(b), fw(d)) < max(fw(a), fw(c))]
    _L
  [not [是潜在的横对角线(ls;imin;b,d)]]
  ]]

#潜在的潜在的横对角线 递归定义:
[所有潜在的潜在的横对角线囗(ls;imin) =[def]= if L==3 then {} else {权重最大的顶点的最近对角线}\-/囗索引回归囗(所有潜在的潜在的横对角线囗(ls移除最大顶点;imin))]
  #one_sweep_algorithm算法依据
[权重最大的顶点的最近对角线是潜在的潜在的横对角线]
[所有潜在的潜在的横对角线不相交]
  #<<==定义

[横对角线是潜在的横对角线]
[潜在的横对角线是潜在的潜在的横对角线]
  !![潜在的横对角线不含权重最大的顶点]
  !![所有潜在的横对角线不相交]
[所有潜在的潜在的横对角线不相交]
[所有潜在的横对角线不相交]
[所有横对角线不相交]

潜在的横对角线上方的多边形upper subpolygon of potential horizontal arc
  其中除原潜在的横对角线(a,c)以外的其他顶点j有:[ls[j] >= max(ls[a,c])]
    !![@[j <- _xy_] -> [fw(j) > max{fw(a),fw(c)}]]


识别可分解的多边形:降解
  [聚焦型多边形三角化方案的优化囗推论三]
  [最低两边为某最优解的三角边]
  [基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
  ===
  [[ls :: [pint]][L := len(ls)][L >= 4][idc :<- 所有索引序列囗升像囗(ls)][i,j,k,u := idc[:4]]]:
      [ls[(i+1)%L] >= ls[(i+2)%L]]:
        !![聚焦型多边形三角化方案的优化囗推论三]
        [(i,(i+2)%L)必是 多边形囗(ls)的内边，可用于切分]

      [ls[(i-1)%L] >= ls[(i-2)%L]]:
        !![聚焦型多边形三角化方案的优化囗推论三]
        [(i,(i-2)%L)必是 多边形囗(ls)的内边，可用于切分]
        # 不可降解的多边形最小处相邻点的外向边必须严格递增

      [ls[i] == ls[j]]:
        !![最低两边为某最优解的三角边]
        [(i,j),(i,k),(j,k)必有 多边形囗(ls)的内边，可用于切分]
        # 不可降解的多边形只有一个最小处

      [ls[k] == ls[u]]:
        !![最低两边为某最优解的三角边]
        [(i,j),(i,k),(i,u)必有 多边形囗(ls)的内边，可用于切分]
        # 不可降解的多边形第三第四最小值不同

      [{j,k} =!= {(i-1)%L,(i+1)%L}]:
        !![最低两边为某最优解的三角边]
        [(i,j),(i,k)必有 多边形囗(ls)的内边，可用于切分]
        # 不可降解的多边形第二第三最小处在最小处两侧

      [{j,k} == {(i-1)%L,(i+1)%L}][1/ls[i]+1/ls[u] > 1/ls[j]+1/ls[k]]:
        !![基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
        [(i,u)必是 多边形囗(ls)的内边，可用于切分]
        # 不可降解的多边形必有[1/ls[i]+1/ls[u] <= 1/ls[j]+1/ls[k]]

至此，得到 不可降解的多边形
  !![L>=4]的不可降解的多边形
  [ls[i] < ls[j] <= ls[k] < ls[u]] # ==>> {i,j,k} 唯一 # ==>> i,{j,k} 唯一
  [{j,k} == {(i-1)%L,(i+1)%L}]
  [1/ls[i]+1/ls[u] <= 1/ls[j]+1/ls[k]]
  [ls[(i-1)%L] < ls[(i-2)%L]]
  [ls[(i+1)%L] < ls[(i+2)%L]]

  进一步，可能非最优的『局部极大处 移除』贪婪算法:
    需要标识出:最终保留的3顶点，即{i,j,k}
    其余 局部极大处 可无序移除，不影响最终收集到的 切分用到的 对角线集合



??? @论文Part I pg22[24/128]:one_sweep_algorithm有bug!
  [ls == [11,44,33,22]]
  one_sweep_algorithm(&ph_arcs,&stack;ls);
    ==>> [ph_arcs=={(0,2),(0,3)}][stack==[11,22]]
      [2 == len(ph_arcs) =!= L-3 == 1]
      提前 标识出 {i,j,k} 是有必要的！
  事实上，最终必然有[len(stack)==2][len(ph_arcs)==L-2]
  也不一定:第一阶段只处理(L-1)个，最后一个只参加第二阶段？？
    第一阶段:pop前要求:[len(stack)>=2]
    第二阶段:pop前要求:[len(stack)>=3]
# 关于one_sweep_algorithm后续修正:见: [词典序最先的最优三角化方案囗潜在的横对角线的必要条件] #not:[无用囗词典序最先的最优三角化方案囗横对角线的必要条件]







# O(N)特例:单调的矩阵乘法链维数序列
[[ls :: [pint]] -> [L := len(ls)] -> [L >= 2] -> [?[k,i :<- [0..<L]] -> [[ls_ := (循环左移**k)(ls)][ls_[:i] 非严格单调递增][ls_[i:] 非严格单调递减]]] -> [计算MNO(ls)存在O(L)算法]]

[所有单调的矩阵乘法链维数序列 =[def]= {ls | [[ls :: [pint]][L := len(ls)][L >= 2][?[k,i :<- [0..<L]] -> [[ls_ := (循环左移**k)(ls)][ls_[:i] 非严格单调递增][ls_[i:] 非严格单调递减]]]]}]
[[ls :<- 所有单调的矩阵乘法链维数序列] -> [计算MNO(ls)存在O(L)算法]]



[[[ls :: [pint]][L := len(ls)][L >= 2][idc :<- 所有索引序列囗升像囗(ls)]] -> [inv_idc := inv_permutation_(idc)] -> [@[i,j <- [0..<L]] -> [inv_idc[i] < inv_idc[j]] -> [ls[i] <= ls[j]]]] #inv_idc 与ls有近似的升降周期，是ls的某个升降严格版
[ls = idx2real_value = i2rv]
[idc = order2idx = virtual_value2idx = ord2idx = vv2i]
[inv_idc = idx2order = idx2virtual_value = idx2ord = i2vv]

[[ls :: [pint]][L := len(ls)][L >= 3]]:
  #tpg==arcs4idc
  #三角边=内边\-/外边
  [所有多边形三角化方案(L) :: {{{int%L, int%L}{.len==2}}{.len==L-3+L}}]
  [所有多边形三角化方案(L) =[def]= let js:=[0..<L] in if L == 3 then {{0,1},{0,2},{1,2}} else 所有多边形三角化方案(L-1) \-/ 囗索引回归囗(所有多边形三角化方案(L-1), (js[:-2]++js[-1])) \-/ unions{囗索引回归囗(所有多边形三角化方案(i+2), (js[:i+1]++js[-1])) \-/ 囗索引回归囗(所有多边形三角化方案(L-i-1), (js[i:-1])) \-/ {{L-2,L-1}} | [i :<- [1..=L-4]]}]

  [所有最优多边形三角化方案(ls) =[def]= {arcs4idc | [[arcs4idc :<- 所有多边形三角化方案(L)][操作数囗多边形三角化囗(多边形三角化方案:=arcs4idc;多边形囗顶点权重:=ls) == MNO(ls)]]}]

[[ls :: [pint]][L := len(ls)][L >= 3][idc :<- 所有索引序列囗升像囗(ls)]]:
  [最优多边形三角化方案囗升像索引序列的索引最小版囗(ls;idc) =[def]= min{arcs4idc4idc | [[arcs4idc4idc :: sorted[(int%L, int%L)]][len(arcs4idc4idc)==L-3+L][tpg := {{idc[i],idc[j]} | [(i,j) :<- arcs4idc4idc]}][tpg <- 所有最优多边形三角化方案(ls)]]}]



[[[ls :: [pint]][L := len(ls)][L >= 3][idc :<- 所有索引序列囗升像囗(ls)]] -> [ltpg := 最优多边形三角化方案囗升像索引序列的索引最小版囗(ls;idc)] -> [
  !![最低两边为某最优解的三角边]
  [(0,1) <- ltpg]
  [(0,2) <- ltpg]

  !![基本多边形的某最优解的内边含有低二之三边或任一低一之四边]
  [[[L>=4][{idc[1],idc[2]} == {(idc[0]-1)%L,(idc[0]+1)%L}]] -> [[(0,3) <- ltpg]or[(1,2) <- ltpg]]]

  [[L>=4] -> [[(0,3) <- ltpg]or[(1,2) <- ltpg]]]
    #对比 上面:
    #无需 是 基本多边形
    #不论0,3是否被1,2隔开
    #(0,3)不一定是 内边
    #(1,2)不一定是 内边
    # :=[def]= [任意多边形的最优多边形三角化方案囗升像索引序列的索引最小版的三角边必含有低二之三边或低一之四边]
  ]]

[[[L::int][L >= 3][ls :<- all_permutations_([0..<L])][idc :<- 所有索引序列囗升像囗(ls)][inv_idc := inv_permutation_(idc)]] -> [
  [inv_idc == ls]
  ]]

[[[ls :: [pint]][L := len(ls)][L >= 3][idc :<- 所有索引序列囗升像囗(ls)][inv_idc := inv_permutation_(idc)]] -> [
  [idc <- 所有索引序列囗升像囗(inv_idc)]
  [{idc} == 所有索引序列囗升像囗(inv_idc)]
    # 良定义:[strict_ltpg := 最优多边形三角化方案囗升像索引序列的索引最小版囗(inv_idc;idc)]
  ]]

[[[ls :: [pint]][L := len(ls)][L >= 3][idc :<- 所有索引序列囗升像囗(ls)][inv_idc := inv_permutation_(idc)][i2rv := ls][i2vv := inv_idc][vv2i := idc]] -> [ltpg := 最优多边形三角化方案囗升像索引序列的索引最小版囗(ls;idc)] -> [strict_ltpg := 最优多边形三角化方案囗升像索引序列的索引最小版囗(inv_idc;idc)] -> [
    #(ls,idc),inv_idc 或者说ltpg,strict_ltpg 这俩 潜在的横对角线ph_arcs 相同
    #基本多边形的ltpg中:横对角线(2,3) vs 竖对角线(0,4)，等MNO情形下，竖对角线 更优
    #以下顶点 使用 ltpg的表达 即 idx4idc 即 inv_idc的元素值 即 order 即 virtual_value
    #横对角线(x,y) ==>> [[?[b] -> [idx[0,x,y,b]成环]][@[b] -> [idx[0,x,y,b]成环] -> [0 < x < y < b]]]
    #[所有潜在的横对角线 =[def]= {{x,y} | [?[a,b] -> [[a < x < y < b][idx[a,x,y,b]成环]]]}]
    #[所有潜在的横对角线不相交]
    #   !![[[{x,y},{a,b} <- 所有潜在的横对角线][len{0,x,y,a,b}==5][x<y][a<b][vv2i{x,y},vv2i{a,b} 相交]] -> [[0<x<y<max(a,b)==b][0<a<b<max(x,y)==y][b<y<b][矛盾]]]
    #[切除最大处的对角线 == {i2vv[vv2i[-1]-1)%L], i2vv[vv2i[-1]+1)%L]}]
    #[含0的 切除最大处的对角线 <- ltpg] #潜在的竖对角线
    #   !![聚焦型多边形三角化方案的优化囗推论三]
    #   [ltpg判定中等MNO下含0对角线 优于 不含0的] #需要 归纳法 证明
    #[不含0的 切除最大处的对角线 <- 所有潜在的横对角线]
    #   依此有one_sweep_algorithm:并不需要 单调的矩阵乘法链维数序列#得到的是 所有潜在的横对角线\-/部分潜在的竖对角线
  ]]


[[L :: int][L >= 3][i :<- [0..<L]]]:
  [聚焦型多边形三角化方案的内边囗(L; i) =[def]= {对角线{i,k_%L} | [k_ :<- [i+2..=i+L-2]]}]
[[L :: int][L >= 3][i,j :<- [0..<L]][i=!=j]]:
  #[circle_path_(L; i, j) =[def]= [k | [[i_ := if i < j then i else i-L][k_ :<- [i_..=j]][k := k_%L]]]]
  [circle_path_(L; i, j) =[def]= [k | [[i_ := j - (j-i)%L][k_ :<- [i_..=j]][k := k_%L]]]]

[[ls :: [pint]][L := len(ls)][L >= 3][i,j :<- [0..<L]][i=!=j]]:
  [side_product(ls; i, j) =[def]= sum{ls[k]*ls[(k+1)%L] | [k_ <- circle_path_(L;i,j)][k=!=j]}]
  [base_product(ls; i, j) =[def]= ls[i]*ls[j]]
[[ls :: [pint]][L := len(ls)][L >= 3][i :<- [0..<L]]]:
  [操作数囗聚焦型多边形三角化囗(ls;i) =[def]= 操作数囗多边形三角化囗(多边形三角化方案:=聚焦型多边形三角化方案的内边囗(L; i);多边形囗顶点权重:=ls)]
[[ls :: [pint]][L := len(ls)][L >= 3][i,j,k :<- [0..<L]][len{i,j,k}==3]]:
  [操作数囗一半最优一半聚焦型多边形三角化囗(ls;i;j,k) =[def]= let [[xs := circle_path_(L;j,k)][ys := circle_path_(L;k,j)][(us,vs,j_,k_) := if i <- xs then (xs,ys,j,k) else (ys,xs,k,j)]] in (操作数囗聚焦型多边形三角化囗(ls[*us,];(i-j_)%L) + MNO(ls[*vs,]))]

[[[ls :: [pint]][L := len(ls)][L >= 3][i :<- [0..<L]]] -> [操作数囗聚焦型多边形三角化囗(ls;i) == (ls[i]*side_product(ls; (i+1)%L,(i-1)%L))]]
  # H0 := 操作数囗聚焦型多边形三角化囗

[[[ls :: [pint]][L := len(ls)][L >= 3][i,j,k :<- [0..<L]][len{i,j,k}==3]] -> [[操作数囗一半最优一半聚焦型多边形三角化囗(ls;i;j,k) < 操作数囗聚焦型多边形三角化囗(ls;i)] <-> [
  [[xs := circle_path_(L;j,k)][ys := circle_path_(L;k,j)][(us,vs,j_,k_) := if i <- xs then (xs,ys,j,k) else (ys,xs,k,j)][D<vs> := (side_product(vs; 0,len(vs)-1) -base_product(vs; 0,len(vs)-1))][D<vs> > 0][MNO(ls[*vs,])//D<vs> < ls[i]]]
    #vs 不含i ==>> 最终判别式(vs,ls[i])，与us中除i,j,k外的其余点无关！
    #us 含i
    #us := [j_..=k_]%L
    #vs := [k_..=j_]%L
    #[i:=imin]:[横对角线判定式(ls;j,k) =[def]= [[D<vs> > 0][MNO(ls[*vs,])//D<vs> < ls[imin]]]]
    #[i:=imin][D<vs> > 0]:[supporting_weight(ls;j,k) =[def]= MNO(ls[*vs,])//D<vs>]
    #   #[i:=imin] 即 取j,k剖分不含imin的那一半作vs
  ]]]
  [[proof:
  [[xs := circle_path_(L;j,k)][ys := circle_path_(L;k,j)][(us,vs,j_,k_) := if i <- xs then (xs,ys,j,k) else (ys,xs,k,j)]]
  [操作数囗一半最优一半聚焦型多边形三角化囗(ls;i;j,k) - 操作数囗聚焦型多边形三角化囗(ls;i)
  = (操作数囗聚焦型多边形三角化囗(ls[*us,];(i-j_)%L) + MNO(ls[*vs,]))
  - 操作数囗聚焦型多边形三角化囗(ls;i)
  = MNO(ls[*vs,])
  + (ls[i]*base_product(ls; k_%L,j_%L))
  - (ls[i]*side_product(ls; k_%L,j_%L))
  = MNO(ls[*vs,])
  + (ls[i]*base_product(vs; 0,len(vs)-1))
  - (ls[i]*side_product(vs; 0,len(vs)-1))
  ]
  let [diff := ...above expr...]
  [diff < 0]
    <==> [MNO(ls[*vs,]) < (ls[i]*side_product(vs; 0,len(vs)-1)) -(ls[i]*base_product(vs; 0,len(vs)-1))]
    <==> [MNO(ls[*vs,]) < ls[i]*(side_product(vs; 0,len(vs)-1) -base_product(vs; 0,len(vs)-1))]
    <==> [D := (side_product(vs; 0,len(vs)-1) -base_product(vs; 0,len(vs)-1))][D > 0][MNO(ls[*vs,])//D < ls[i]]
  ]]


[[[ls :: [pint]][L := len(ls)][L >= 3][idc :<- 所有索引序列囗升像囗(ls)][inv_idc := inv_permutation_(idc)][i2rv := ls][i2vv := inv_idc][vv2i := idc]] -> [imin := vv2i[0]] -> [
  ???
  ]]
]]]]]]
