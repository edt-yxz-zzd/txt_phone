
e others/book/factor_papers__primality_test.txt

[[第二批:20220901之前:
'A Beginner_s Guide To The General Number Field Sieve(after2002)(Michael).pdf'
'An Introduction to the General Number Field Sieve(1998)(Matthew).pdf'
'An Introduction to the Theory of Elliptic Curves(2006)(Silverman).pdf'
'Detecting perfect powers in essentially linear time(1998)(Berstein).pdf'
'Double-Speed Safe Prime Generation(2003)(Naccache).pdf'
'ELLIPTIC CURVES AND LENSTRA’S FACTORIZATION ALGORITHM(2014)(PARKER).pdf'
'Edouard Lucas and primality testing(1998)(Williams).pdf'
'Elliptic curves-- what they are, why they are called elliptic, and why topologists like them(2007)(Doug Ravenel)[ppt].pdf'
'Factoring Algorithms--Pollard p-1 Method,Quadratic Sieve Method,Index Calculus(2009)(Purdue University).pdf'
'Factoring integers with elliptic curves(1987)(LENSTRA).pdf'
'Lenstra Elliptic Curve Factorization(2016)(Thomas Browning).pdf'
'Math component--Elliptic curves and Lenstra_s Algorithm(简要大纲).pdf'
'New primality criteria and factorizations of 2^m ± 1(1975)(Brillhart).pdf'
'On distinguishing prime numbers from composite numbers(1983)(Adleman).pdf'
'Pollard_s p-1 and Lenstra_s factoring algorithms(2005)(Charest).pdf'
'Primality testing on a computer(1978)(Williams).pdf'
'Recent developments in primality proving(1999)(Mihailescu).pdf'
'The Number Field Sieve(2005)(Byrnes).pdf'
'The new book of prime number records(3ed)(1996)(Ribenboim).djvu'
'elliptic-integrals[Why are They Called Elliptic Curves].pdf'
]]

[
来源？
  'Double-Speed Safe Prime Generation(2003)(Naccache).pdf'
]
[
mkdir ~/my_home/book/math/factorint/snd/
cd ~/download/wget_
mv 'A Beginner_s Guide To The General Number Field Sieve(after2002)(Michael).pdf' 'An Introduction to the General Number Field Sieve(1998)(Matthew).pdf' 'An Introduction to the Theory of Elliptic Curves(2006)(Silverman).pdf' 'Detecting perfect powers in essentially linear time(1998)(Berstein).pdf' 'Double-Speed Safe Prime Generation(2003)(Naccache).pdf' 'ELLIPTIC CURVES AND LENSTRA’S FACTORIZATION ALGORITHM(2014)(PARKER).pdf' 'Edouard Lucas and primality testing(1998)(Williams).pdf' 'Elliptic curves-- what they are, why they are called elliptic, and why topologists like them(2007)(Doug Ravenel)[ppt].pdf' 'Factoring Algorithms--Pollard p-1 Method,Quadratic Sieve Method,Index Calculus(2009)(Purdue University).pdf' 'Factoring integers with elliptic curves(1987)(LENSTRA).pdf' 'Lenstra Elliptic Curve Factorization(2016)(Thomas Browning).pdf' 'Math component--Elliptic curves and Lenstra_s Algorithm(简要大纲).pdf' 'New primality criteria and factorizations of 2^m ± 1(1975)(Brillhart).pdf' 'On distinguishing prime numbers from composite numbers(1983)(Adleman).pdf' 'Pollard_s p-1 and Lenstra_s factoring algorithms(2005)(Charest).pdf' 'Primality testing on a computer(1978)(Williams).pdf' 'Recent developments in primality proving(1999)(Mihailescu).pdf' 'The Number Field Sieve(2005)(Byrnes).pdf' 'The new book of prime number records(3ed)(1996)(Ribenboim).djvu' 'elliptic-integrals[Why are They Called Elliptic Curves].pdf' ~/my_home/book/math/factorint/snd/
view /sdcard/0my_files/book/math/factorint/snd/
]



[[[from:
https://primes.utm.edu/prove/merged.html
view others/数学/整数分解/素数/primes.utm.edu..prove..merged.html

https://primes.utm.edu/external/references/refs.cgi/Williams78
Williams78
H. C. Williams, "Primality testing on a computer," Ars Combin., 5 (1978) 127--185.  MR 80d:10002 [A survey of the classical primality tests.]
wget 'https://www.ams.org/mcom/1978-32-143/S0025-5718-1978-0476625-0/S0025-5718-1978-0476625-0.pdf' -O 'Primality testing on a computer(1978)(Williams).pdf'
已下载

https://primes.utm.edu/external/references/refs.cgi/Williams98
Williams98
H. C. Williams, Édouard Lucas and primality testing, Canadian Math. Soc. Series of Monographs and Adv. Texts Vol, 22, John Wiley \& Sons, 1998.  New York, NY, pp. x+525, ISBN 0-471-14852-0. MR 2000b:11139 (Annotation available)
https://libgen.ee/book_86581965
wget 'https://libgen.rocks/get.php?md5=cf1442d3f874b61b880ee88101f9e213&key=VQE1PWKA9CCQO0MU' -O 'Edouard Lucas and primality testing(1998)(Williams).pdf'
已下载


https://primes.utm.edu/references/refs.cgi/APR83
APR83
L. M. Adleman, C. Pomerance and R. S. Rumely, "On distinguishing prime numbers from composite numbers," Ann. Math., 117:1 (1983) 173--206.  MR 84e:10008 [The first of the modern primality tests.]
已下载

https://primes.utm.edu/references/refs.cgi/CL84
CL84
H. Cohen and Lenstra, Jr., H. W., "Primality testing and Jacobi sums," Math. Comp., 42 (1984) 297--330.  MR 86g:11078 [APRT-CL test introduced.]
已下载

https://primes.utm.edu/references/refs.cgi/CL87
CL87
H. Cohen and A. K. Lenstra, "Implementation of a new primality test," Math. Comp., 48 (1987) 103--121.  MR 88c:11080 [APRT-CL test implemented.]
已下载

https://primes.utm.edu/references/refs.cgi/Mihailescu98
Mihailescu98
P. Mihailescu, Cyclotomy primality proving -- recent developments.  In "Proceedings of the III Applied Number Theory Seminar, ANTS III, Portland, Oregon 1998," Lecture Notes in Computer Science Vol, 1423, 1998.  pp. 95--110, MR 2000j:11195
Cyclotomy primality proving -- recent developments(1998)(Mihailescu).pdf
搜索:Mihailescu。查看1998前后
https://libgen.ee/book_15227248
wget 'https://libgen.rocks/get.php?md5=8ed816eb441785423dfac4cc489539ea&key=JAASW4PFQH9ZLKF4' -O 'Recent developments in primality proving(1999)(Mihailescu).pdf'
已下载

https://primes.utm.edu/references/refs.cgi/BH90
BH90
W. Bosma and M. P. van der Hulst, Faster primality testing.  In "Advances in Cryptology--EUROCRYPT '89 Proceedings," J. J. Quisquater and J. Vandewalle editors, Springer-Verlag, 1990.  pp. 652--656,
Faster primality testing(1990)(Bosma).pdf
已下载

https://primes.utm.edu/references/refs.cgi/BLS75
  J. Brillhart, D. H. Lehmer and J. L. Selfridge, "New primality criteria and factorizations of 2m ± 1," Math. Comp., 29 (1975) 620--647.  MR 52:5546 [The article for the classical (n2 -1) primality tests. Table errata in [Brillhart1982]]
wget -c 'https://www.ams.org/journals/mcom/1975-29-130/S0025-5718-1975-0384673-1/S0025-5718-1975-0384673-1.pdf' -O 'New primality criteria and factorizations of 2^m ± 1(1975)(Brillhart).pdf'
已下载

https://primes.utm.edu/references/refs.cgi/Ribenboim95
  # 数据列表:[n<?][n is {???}-SPRP] -> [is_prime n]
  #     Strong probable-primality
  #
  P. Ribenboim, The new book of prime number records, 3rd edition, Springer-Verlag, 1995.  New York, NY, pp. xxiv+541, ISBN 0-387-94457-5. MR 96k:11112 [An excellent resource for those with some college mathematics. Basically a Guinness Book of World Records for primes with much of the relevant mathematics. The extensive bibliography is seventy-five pages.]
https://libgen.lc/edition.php?id=135789101
wget 'http://62.182.86.140/main/11000/d46c0428209914a6acfaede707854241/Paulo%20Ribenboim%20-%20The%20new%20book%20of%20prime%20number%20records-Springer%20%281996%29.djvu' -O 'The new book of prime number records(3ed)(1996)(Ribenboim).djvu'



https://primes.utm.edu/references/refs.cgi/Bernstein1998b
  #determining if the number is a perfect power, can be done in essentially linear time [Bernstein1998b].
  D. Berstein, "Detecting perfect powers in essentially linear time," Math. Comp., 67:223 (1998) 1253--1283.  Available from http://cr.yp.to/papers.html.  MR 98j:11121 (Abstract available)
wget 'http://cr.yp.to/papers/powers-19971106-retypeset20220326.pdf' -O 'Detecting perfect powers in essentially linear time(1998)(Berstein).pdf'


]]]
[[[[[[[from:
Pollard p-1 method and Lenstra elliptic curve factorization algorithm
  ???[N = p**2 * q**3]??? 这些分解法 还有用吗？

The sum of any three colinear points in E is zero.
  椭圆曲线上的 共线的 三点 相加(交换群加法) 为零(无穷远点)。
  同点/重根:
    A+B+C==O
    2*B+C==O
    3*C==O
    #要求:域特征 不为 2或3
为何 是 椭圆曲线？
  群乘法涉及3个值，通过3个根联系起来，==>>三次多项式
  https://blog.csdn.net/mmphhh/article/details/123296805
  wget 'https://blog.csdn.net/mmphhh/article/details/123296805' -O '椭圆曲线：椭圆曲线是怎么来的？_Lytain2022.html'
why is Elliptic curve?
  https://wiki.openssl.org/index.php/Elliptic_Curve_Cryptography

  https://math.stackexchange.com/questions/853089/why-is-it-called-elliptic-curve
    https://www.unf.edu/~ddreibel/mas4932/elliptic-integrals.pdf
      Why are They Called “Elliptic” Curves?
    wget 'https://www.unf.edu/~ddreibel/mas4932/elliptic-integrals.pdf' -O 'elliptic-integrals[Why are They Called Elliptic Curves].pdf'
    http://www.math.rochester.edu/people/faculty/doug/mypapers/wayne1.pdf
      https://people.math.rochester.edu/faculty/doug/mypapers/wayne1.pdf
      wget 'https://people.math.rochester.edu/faculty/doug/mypapers/wayne1.pdf' -O 'Elliptic curves-- what they are, why they are called elliptic, and why topologists like them(2007)(Doug Ravenel)[ppt].pdf'

  https://www.math.brown.edu/johsilve/Presentations/WyomingEllipticCurve.pdf
  wget 'https://www.math.brown.edu/johsilve/Presentations/WyomingEllipticCurve.pdf' -O 'An Introduction to the Theory of Elliptic Curves(2006)(Silverman).pdf'
    非常好！
    [[
  椭圆曲线分解 不要求 (p-1)  是 B-smooth
  而是 要求 |Elliptic_Curve(%GF(p))|  是 B-smooth:
    Suppose that there is a prime p dividing N for which the number of points in E(GF[p]) is B-smooth.
    The advantage of Lenstra’s Elliptic Curve Algorithm over Pollard’s p − 1 Algorithm is the introduction of many finite groups E(GF[p]) with many different orders.
    The fact that the running time depends on the smallest prime divisor of N makes Lenstra’s algorithm especially good for factoring “random” numbers, but it is slower than sieve methods for “RSA-type” numbers N = pq.
    ===
    More precisely, choose an elliptic curve modulo N and a point on the curve[#反过来，先有点S与系数a 再求 系数b#]: [E : y**2= x**3+ a*x + b,a,b ∈ Z/NZ,S ∈ E(Z/NZ)].
    Suppose that there is a prime p dividing N for which the number of points in E(GF[p]) is B-smooth.
    Then there is a good chance that during the computation of (LCM(1,2,...,B)S mod N)[#LCM(1,2,...,B)?我觉得应该改成II p**2**ceil_log2(floor_log<p>(N)){p<-primes_lt(B+1)} 确保p的指数足够大#], some inverse ((x2−x1)**−1 mod N)[#两点的加法-计算过两点直线斜率-inv_mod-失败即分解#] will not exist, yielding [gcd(x2− x1,N) = p].
    ]]

搜索:p-1 与 椭圆曲线 整数分解法Lenstra factoring algorithm
  Pollard's p-1 method
  Lenstra's elliptic curve factorization algorithm
    The Lenstra's elliptic curve factorization (LEF) algorithm is a problem to factor a composite number N that is a modulus to define an elliptic curve over it, namely E mod N. The LEF method considered as the third fastest algorithm comparing to multiple polynomial quadratic and general number field sieves algorithms


  view others/数学/整数分解/factorint.txt

  https://www.cs.purdue.edu/homes/ssw/cs355/2009f.pdf
  https://www.cs.purdue.edu/homes/ssw/cs655/2009f.pdf
  Factoring Algorithms Pollard’s p-1 Method
  wget 'https://www.cs.purdue.edu/homes/ssw/cs655/2009f.pdf' -O 'Factoring Algorithms--Pollard p-1 Method,Quadratic Sieve Method,Index Calculus(2009)(Purdue University).pdf'
    61KB
    Factoring Algorithms:
      * Pollard’s p − 1 Method
      * Quadratic Sieve Method
      * Discrete Logarithms via Index Calculus
    ===
    quadratic sieve algorithm O(e**sqrt(ln(N) * ln(ln(N))))
      [@[C1,C2 :: PositiveReal] -> ?[N0 :: uint] -> @[N <- [N0..]] -> [ln(N)**C1 < e**sqrt(ln(N) * ln(ln(N))) < N**C2]]

  https://www.math.uchicago.edu/~may/REU2014/REUPapers/Parker.pdf
  ELLIPTIC CURVES AND LENSTRA’S FACTORIZATION ALGORITHM
  wget 'https://www.math.uchicago.edu/~may/REU2014/REUPapers/Parker.pdf' -O 'ELLIPTIC CURVES AND LENSTRA_S FACTORIZATION ALGORITHM(2014)(PARKER).pdf' --no-check-certificate
    215KB
    好！
    前提:[N%2=!=0][N%3=!=0][@[i <-[2..=floor_log2(N)]] -> [not$ pow_nth_root(N,i) <- uint]][@a,P.x,P.y<-[2..<N]][b:=P.y**2-P.x**3-a*P.x][gcd(N,4*a**3+27*b**2)==1][E(ZZ%N,a,b)==[y**2=x**3+a*x+b]]
      #nonsingular curve:[gcd(N,4*a**3+27*b**2)==1]
      #Elliptic_Curve over ZZ%N: E(ZZ%N,a,b)
    终止条件:求f(B)*P==>>求(P+Q)时，[P=!=-Q]==>>求 直线PQ斜率==>>求inv_mod<N>([P=!=-Q][P=!=Q](P.x-Q.x) + [P=!=-Q][P==Q](2*P.y))，inv_mod不存在 即 分解(若gcd为N，则减小f(B)再尝试，否则 成功分解)
      f(B) =? lcm(1..=B)
      f(B) =? II p**floor_log<p>(N) {p<-primes_lt(B+1)}
    Hasse-Weil Bound: [p + 1 − 2√p ≤ len(E(GF[P])) ≤ p + 1 + 2√p]
      失败，则更换 椭圆曲线 E，期待 len(E(GF[P])) 是 B-smooth

  https://sites.math.washington.edu/~morrow/336_16/2016papers/thomas.pdf
  Lenstra Elliptic Curve Factorization
  wget 'https://sites.math.washington.edu/~morrow/336_16/2016papers/thomas.pdf' -O 'Lenstra Elliptic Curve Factorization(2016)(Thomas Browning).pdf'
    172KB
    Asymptotically it is only the third fastest integer factorization algorithm known (beaten by the Quadratic Sieve and the General Number Field Sieve).
    [O(General Number Field Sieve) < O(Quadratic Sieve) < O(Lenstra Elliptic Curve Factorization)]
    待搜索:
      Williams’ p + 1 algorithm
      General Number Field Sieve
      [[
General Number Field Sieve
In number theory, the general number field sieve (GNFS) is the most efficient classical algorithm known for factoring integers larger than 10¹⁰⁰. Heuristically, its complexity for factoring an integer n (consisting of ⌊log₂ n⌋ + 1 bits) is of the form exp((∛(64/9)+o(1))(lnn)¹/³(lnlnn)²/³)=Lₙ[1/3,∛(64/9)] (in L-notation), where ln is the natural logarithm. It is a generalization of the special number field sieve: while the latter can only factor numbers of a certain special form, the general number field sieve can factor any number apart from prime powers (which are trivial to factor by taking roots).


https://vtechworks.lib.vt.edu/bitstream/handle/10919/36618/etd.pdf
An Introduction to the General Number Field Sieve
wget 'https://vtechworks.lib.vt.edu/bitstream/handle/10919/36618/etd.pdf' -O 'An Introduction to the General Number Field Sieve(1998)(Matthew).pdf'

https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf
A Beginner’s Guide To The General Number Field Sieve
wget 'https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf' -O 'A Beginner_s Guide To The General Number Field Sieve(after2002)(Michael).pdf'

http://sjbyrnes.com/math129-finalpaper.pdf
The Number Field Sieve
wget 'http://sjbyrnes.com/math129-finalpaper.pdf' -O 'The Number Field Sieve(2005)(Byrnes).pdf'

https://github.com/MathSquared/general-number-field-sieve
  This project depends on Victor Shoup's NTL and CMake, and is written in C++11.

      ]]


  https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/Lenstra87.pdf
  Factoring integers with elliptic curves
  wget 'https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/Lenstra87.pdf' -O 'Factoring integers with elliptic curves(1987)(LENSTRA).pdf'
    1.35MB 原论文

  https://hernandez.ku.edu/601/CP4-elliptic-curves.pdf
  Math component: Elliptic curves and Lenstra’s Algorithm
  wget 'https://hernandez.ku.edu/601/CP4-elliptic-curves.pdf' -O 'Math component--Elliptic curves and Lenstra_s Algorithm(简要大纲).pdf'
    148KB

  https://github.com/delta003/lenstra_algorithm
    https://github.com/delta003/lenstra_algorithm/blob/master/lenstra.py
    wget 'https://github.com/delta003/lenstra_algorithm/blob/master/lenstra.py' -O 'github.com-delta003-lenstra.py.html'
    view /storage/emulated/0/Download/wget_/github.com-delta003-lenstra.py

  https://www.math.mcgill.ca/darmon/courses/05-06/usra/charest.pdf
  Pollard’s p-1 and Lenstra’s factoring algorithms
  wget 'https://www.math.mcgill.ca/darmon/courses/05-06/usra/charest.pdf' -O 'Pollard_s p-1 and Lenstra_s factoring algorithms(2005)(Charest).pdf'
    188KB 非常详细
    [[
Contents 
1 Pollard’s p-1 algorithm..........................3 
1.1 General idea of the algorithm..................3 
1.2 The steps of the algorithm....................4 
1.3 Conditions of success of the algorithm..............5 
1.4 Efficiency of the algorithm....................5 
1.5 Possible improvements of the algorithm.............10 
2 Lenstra’s algorithm using elliptic curves..........................11
2.1 Elliptic curves...........................11 
2.2 General idea of the algorithm..................14 
2.3 The steps of the algorithm....................15 
2.4 Conditions of success of the algorithm..............15 
2.5 Efficiency of the algorithm....................16 
2.6 Possible improvements of the algorithm.............19
    ]]
Natual Logarithm Base e 自然对数底
natural base e
2.71828182845904523536...
>>> e=2.71828182845904523536
>>> e**e
15.154262241479259

[[[
https://math.stackexchange.com/questions/3527401/why-is-the-pollards-p-1-method-not-efficient-for-some-numbers
Why is the pollard's (p-1)-Method not efficient for some numbers?
===

Mathematics
Why is the pollard's (p-1)-Method not efficient for some numbers?
Asked 2 years, 5 months ago
Modified 2 years, 5 months ago
Viewed 515 times

1


1
I have an algorithm for the method, where the idea is to choose a random number $a$, and then a bound $B$. Then we find $k=\prod_{\substack{p\in\mathbb{P}\\ p^{e}\leq B}}p^e$ and calculate $\gcd(a^k-1,n)$. And if this is not $1$ or $n$ (the number to be factorized), then we found a divisor. For some numbers this method won't work, for example for $n=132193=163\cdot 811$. But I don't have a concrete explanation why the method doesn't work for that number. I thought it might have to do with the fact that in this case, $p-1$ would be:
$162=2\cdot 3^4$
or $810=2\cdot 3^4 \cdot 5$
in both cases I get a small prime number ($3$) but with a large exponent, so I think that might difficult the selection of the bound $B$, but I don't know exactly how or why...
Could someone help me clarify this doubt? Thank you

number-theory
algorithms
factoring
Share
Cite
Follow
edited Jan 29, 2020 at 20:02
user avatar
Daniel Fischer
200k1818 gold badges250250 silver badges375375 bronze badges
asked Jan 29, 2020 at 19:57
user avatar
M-S-R
33511 silver badge99 bronze badges
In what sense does the method not work for that $n$? If you happen to pick $a = 17$ (which is a cube modulo $163$ but not modulo $811$) and $27 \leqslant B < 81$, then you get the factor $163$. – 
Daniel Fischer
 Jan 29, 2020 at 20:31
Well, that is exactly what I'm trying to find out. I guess the choice of $a$ you made is one of the very few that work – 
M-S-R
 Jan 29, 2020 at 20:38
Few, but probably not very few. Yes, it was deliberately chosen to work. So you want to know why the method works (comparatively) badly for that $n$ (and a number of others)? – 
Daniel Fischer
 Jan 29, 2020 at 20:43
Yes, exactly. In the problem formulation it says that for this specific number one would "need much luck" to factorize $132193$ with the pollard p-1 method... – 
M-S-R
 Jan 29, 2020 at 21:10 
Unless one knows the factorisation, then one can easily find parameters $a$ and $B$ for which the method will succeed. I need to look up how $B$ is picked in the algorithm, that influences how much luck one would need. – 
Daniel Fischer
 Jan 29, 2020 at 21:14
Show 1 more comment
1 Answer
Sorted by:

Highest score (default)

1

The reason why Pollard's $p-1$-method doesn't work well for $n = 163\cdot 811$ is that the largest prime power dividing $163-1$ is the same as the largest prime power that divides $811-1$. Thus in this example $p-1$ and $q-1$ both become $B$-powersmooth for the same $B$.

Generally, the idea of the algorithm is that a prime factor $p$ of $n$ will divide $a^k - 1$ (where $a$ is coprime to $n$) if $k$ is a multiple of $p-1$, but usually a prime factor $q$ of $n$ will not divide it if $k$ is not a multiple of $q-1$. Of course for some $a$, $q$ will nevertheless divide $a^k - 1$, but for that to happen $a$ must be a $\frac{q-1}{\gcd(k,q-1)}$-th power residue modulo $q$, and there aren't too many such.

Since the exponent $k$ is defined as the product of all prime powers $\leqslant B$, all prime factors $p$ of $n$ for which $p-1$ is $B$-powersmooth will divide $a^k - 1$ for all $a$ coprime to $n$, and the prime factors $q$ of $n$ for which $q-1$ is not $B$-powersmooth will only rarely divide $a^k-1$.

Thus when for a squarefree $n = p_1\cdot \ldots \cdot p_r$ all the $p_{\rho}-1$ have the same largest prime power divisor $q^m$, the algorithm can only find a nontrivial divisor of $n$ when $B < q^m$, and the chosen base $a$ is a suitable power residue modulo some but not all of the $p_{\rho}$. (If $n$ is not squarefree, then for a prime $p$ with $p^2 \mid n$ it's likely that $p \mid a^k - 1$ but $p^2 \nmid a^k-1$ for $B \geqslant q^m$, so we'd get a nontrivial factor with high[ish] probability even if $q^m$ is the maximal prime power divisor of all $p_{\rho}-1$.)

If the largest prime power dividing $p_{\rho}-1$ is not the same for all $\rho$, then a value of $B$ between the smallest and the largest of these maximal prime power divisors will find a factor with high probability.

If one executes the algorithm with a fixed $a$ and increments $B$ (starting with $B \geqslant 5$, say) for $n = 163\cdot 811$, one needs a bit of luck to choose an $a$ that is a cubic (or ninth power, or $27^{\text{th}}$ power) residue modulo one of the factors but not the other. One can reduce the amount of luck needed by using several $a$ for each $B$. This of course multiplies the work by the number of bases one tries. A strategy that avoids that multiplication is to execute the algorithm with a fixed base $a$, and when $\gcd(a^k-1,n) = n$ for $k = k(B)$ but $\gcd(a^k-1,n) = 1$ for $k = k(B-1)$, then it's likely that $B$ is the largest prime power dividing each of the $p_{\rho}-1$, say $B = q^m$, and trying several other bases for $k(B-1) = k(B)/q$ has decent chances to find a factor. Since the probability that a randomly chosen number is a $q^{\text{th}}$ power residue modulo a prime $p \equiv 1 \pmod{q}$ is roughly $1/q$, if being a $q^{\text{th}}$ power residue modulo different such primes is independent, the probability of finding a base that is a $q^{\text{th}}$ power residue modulo one of two prime factors is about $\frac{2q-1}{q^2}$. Then we would expect to find a factor within about $q$ tries. If $q$ is large, that's bad, but for small $q$ it's feasible. (Of course there's still luck needed, but we have a guesstimate how much luck we need. However, if our guess that $B$ was the largest prime power divisor of all the $p_{\rho}$ was wrong, our guesstimate may be quite wrong too.)

Share
Cite
Follow
answered Jan 29, 2020 at 22:17
user avatar
Daniel Fischer
200k1818 gold badges250250 silver badges375375 bronze badges
Add a comment
Your Answer
]]]
[[
生日悖论birthday paradox
  1/2 概率发生碰撞 所需数量为O(sqrt(N))
    365==>>23
  N==>>n
  不发生碰撞的概率<N>(n) = N/N * (N-1)/N * ... * (N-n+1)/N <= 1-expected_probability
  Permutation<N>(n) <= N**n * (1-expected_probability)
  近似算法:不发生碰撞的概率<N>(n) ~= ((N-1)/N)**Combination<N>(2)
    每一对 不碰撞的 概率是 ((N-1)/N)
    共有 N*(N-1)/2 对
]]
[[[
wget 'https://github.com/delta003/lenstra_algorithm/blob/master/lenstra.py' -O 'github.com-delta003-lenstra.py.html'
===
import argparse
from random import randint
from fractions import gcd
# Sieve of Eratosthenes
def primes(n):
    b = [True] * (n + 1)
    ps = []
    for p in xrange(2, n + 1):
      if b[p]:
        ps.append(p)
      for i in xrange(p, n + 1, p):
        b[i] = False
    return ps
# Finds modular inverse
# Returns inverse, unused helper and gcd
def modular_inv(a, b):
    if b == 0:
      return 1, 0, a
    q, r = divmod(a, b)
    x, y, g = modular_inv(b, r)
    return y, x - q * y, g
# Addition in Elliptic curve modulo m space
def elliptic_add(p, q, a, b, m):
    # If one point is infinity, return other one
    if p[2] == 0: return q
    if q[2] == 0: return p
    if p[0] == q[0]:
      if (p[1] + q[1]) % m == 0:
        return 0, 1, 0 # Infinity
      num = (3 * p[0] * p[0] + a) % m
      denom = (2 * p[1]) % m
    else:
      num = (q[1] - p[1]) % m
      denom = (q[0] - p[0]) % m
    inv, _, g = modular_inv(denom, m)
    # Unable to find inverse, arithmetic breaks
    if g > 1:
      return 0, 0, denom # Failure
    z = (num * inv * num * inv - p[0] - q[0]) % m
    return z, (num * inv * (p[0] - z) - p[1]) % m, 1
# Multiplication (repeated addition and doubling)
def elliptic_mul(k, p, a, b, m):
    r = (0, 1, 0) # Infinity
    while k > 0:
      # p is failure, return it
      if p[2] > 1:
        return p
      if k % 2 == 1:
        r = elliptic_add(p, r, a, b, m)
      k = k // 2
      p = elliptic_add(p, p, a, b, m)
    return r
# Lenstra's algorithm for factoring
# Limit specifies the amount of work permitted
def lenstra(n, limit):
    g = n
    while g == n:
      # Randomized x and y
      q = randint(0, n - 1), randint(0, n - 1), 1
      # Randomized curve coefficient a, computed b
      a = randint(0, n - 1)
      b = (q[1] * q[1] - q[0] * q[0] * q[0] - a * q[0]) % n
      g = gcd(4 * a * a * a + 27 * b * b, n) # singularity check
      # If we got lucky, return lucky factor
      if g > 1:
        #我:bug: g==n
        if 1: if g==n:continue
        return g
      # increase k step by step until lcm(1, ..., limit)
      for p in primes(limit):
        pp = p
        while pp < limit:
          q = elliptic_mul(p, q, a, b, n)
          # Elliptic arithmetic breaks
          if q[2] > 1:
            return gcd(q[2], n)
          pp = p * pp
    return False
# Command line tool
def main():
  parser = argparse.ArgumentParser(description = 'Process arguments')
  parser.add_argument('--n', type = int,
    help = 'number to factor')
  parser.add_argument('--limit', type = int, default = 1000,
    help = 'work limit (default = 1000)')
  args = parser.parse_args()
  print lenstra(args.n, args.limit)
if __name__ == '__main__':
  main()
]]]
[[[
https://crypto.stackexchange.com/questions/1190/why-is-elliptic-curve-cryptography-not-widely-used-compared-to-rsa
===
Cryptography
Why is elliptic curve cryptography not widely used, compared to RSA?
Asked 10 years, 8 months ago
Modified 2 years ago
Viewed 118k times

173


124
I recently ran across elliptic curve crypto-systems:

An Introduction to the Theory of Elliptic Curves (Brown University)
Elliptic Curve Cryptography (Wikipedia)
Performance analysis of identity management in the Session Initiation Protocol (SIP) (IEEE)
Overview of Elliptic Curve Cryptosystems. (RSA.com)
It seemed to me to be great alternative to RSA as the de-facto cryptosystems to be used in banking and financial systems and in the public key infrastructure for certificates, but is not used! If someone can explain why this is not done, it would be very helpful. A comparison between traditional RSA and an elliptic curve cryptology would be helpful.

To begin with:

Advantage of RSA:

Well established.
Advantages of elliptic curve:

Shorter keys are as strong as long key for RSA (see the IEEE paper)
Low on CPU consumption.
Low on memory usage.
rsa
public-key
elliptic-curves
computational-complexity-theory
Share
Improve this question
Follow
edited Jul 6, 2020 at 8:54
user avatar
R1w
1,86633 gold badges1818 silver badges4343 bronze badges
asked Nov 15, 2011 at 6:19
user avatar
Vineet Menon
1,91533 gold badges1313 silver badges1010 bronze badges
Excellent answers. Regarding adoption of EC, implementation has always been an issue. However, openssl (from 0.9.8) and lately openssh (from openssh 5.7) have elliptic curve built into them, so we should see greater adoption in future. – 
Raghavendra
 Jul 9, 2012 at 18:03
3
@SmitJohnth: 'RSA' faster than 'ECC'? How's that? The lower CPU consumption and lower memory consumption of ECC doesn't automatically translate to a faster algorithm? – 
Vineet Menon
 May 5, 2013 at 13:04
1
@VineetMenon crypto.stackexchange.com/questions/1190/… RSA can use very short public key. This wouldn't word with DH-based ciphers, used with ECC. – 
Smit Johnth
 May 5, 2013 at 13:32 
2
One additional minor advantage for RSA is that it is believed it will hold up better against a quantum computer compared to ECC. I don't think that ever causes anyone to choose RSA over ECC though. – 
Lie Ryan
 Jun 10, 2017 at 14:34 
1
@LieRyan, interesting.. more at Why is ECC more vulnerable than RSA in a post-quantum world? – 
Vineet Menon
 Jun 12, 2017 at 4:43 
Show 4 more comments
4 Answers
Sorted by:

Highest score (default)

155

RSA was there first. That's actually enough for explaining its preeminence. RSA was first published in 1978 and the PKCS#1 standard (which explains exactly how RSA should be used, with unambiguous specification of which byte goes where) has been publicly and freely available since 1993. The idea of using elliptic curves for cryptography came to be in 1985, and relevant standards have existed since the late 1990s. Also, both RSA and elliptic curves have been covered by patents, but the RSA patents have expired in 2000, while some elliptic curve patents are still alive.

One perceived, historical advantage of RSA is that RSA is two algorithms, one for encryption and one for signatures, that could both use the same key and the same core implementation. But this is not a real advantage because it is usually a bad idea to use the same key for both encryption and signatures. Also, you can mathematically use the same private key for ECDH (key exchange) and for ECDSA (signatures), so that's really not an "advantage" of RSA over EC at all.

Another advantage of RSA is that its mathematics are somewhat simpler than those involved for elliptic curves, so many engineers feel that they "understand" RSA more than elliptic curves; again, a fallacious argument, since implementation of cryptographic algorithms is fraught with subtle details and best left to professionals -- and there is no need to understand the internal mathematics of a library to simply use it (we could make this argument semi-valid by pointing out that RSA relies on the hardness of factorization, which has been studied for 2500 years, whereas discrete logarithm on elliptic curves can only sport about 25 years of research).

The only scientifically established advantaged of RSA over elliptic curves cryptography is that public key operations (e.g. signature verification, as opposed to signature generation) are faster with RSA. But public-key operations are rarely a bottleneck, and we are talking about 8000 ECDSA verifications per second, vs 20000 RSA verifications per second.

An additional interoperability issue is that elliptic-curve operations can be made over curves of distinct types, and can be widely optimized if you stick to a specific curve known when the code was written. There is no security issue in using the same curve for many distinct people with distinct key pairs. But it means that most implementations will only support two or three specific curves. NIST has defined 15 standard curves. However, in practice, many implementations only support two of them, P-256 and P-384, because that's what is recommended by NSA (under the name "suite B")(a notorious example is NSS, the cryptography library used by the Firefox Web browser for SSL).

There are two ANSI standards for elliptic curves, X9.62 for signatures (partially redundant with FIPS 186-3, but much more detailed), and X9.63 for asymmetric encryption.

So there is a lot of political push for the adoption of elliptic curves in cryptography, by both academic researchers and institutional organizations. But inertia of the firmly entrenched RSA will take time to defeat. Also, the perceived mathematical complexity, and the potential legal risks related to patents, still hinder wide acceptance of elliptic curves.

(To your list, you can add "key generation time": generating a new key pair for ECDH or ECDSA is widely faster than generating a new RSA key pair.)

Share
Improve this answer
Follow
edited Oct 1, 2017 at 16:33
user avatar
fgrieu♦
124k1111 gold badges267267 silver badges518518 bronze badges
answered Nov 15, 2011 at 15:29
user avatar
Thomas Pornin
84.7k1616 gold badges233233 silver badges309309 bronze badges
10
For me the primary selling point of RSA is that it doesn't leak the private key if your PRNG happens to be badly seeded while signing. While it's possible to avoid this issue, most implementations don't. – 
CodesInChaos
 Apr 18, 2012 at 12:33
14
You can implement RSA from scratch in about 50 lines of python. Try doing that with elliptic curves. Laziness was certainly part of the reason RC4 became so widespread. I think it's true of RSA too! – 
Simon Johnson
 Jul 10, 2012 at 11:04 
4
@curious: I can quote myself. But you can also make benchmarks (with OpenSSL, try openssl speed rsa2048 ecdsap224). – 
Thomas Pornin
 Mar 3, 2013 at 13:34
4
That's because the operation is not exactly the same. With RSA, signature verification uses the public exponent, which can be very short (with RSA, the public exponent typical length is 16 bits, while the privat exponent is as large as the modulus). This gives a huge boost to public key operations in RSA. There's no analog with elliptic curves. – 
Thomas Pornin
 Mar 3, 2013 at 16:53
1
I have a question. I heard that cipher texts encrypted with RSA can possible give hints about the public key used (identify who did or did not encrypt that message) while elliptic curves do not have this weakness. Is this true? – 
Xeoncross
 Jul 9, 2013 at 16:25 
Show 7 more comments

38

This is mostly a supplement to @ThomasPornin's answer, not a complete answer on its own (but too long to fit in a comment).

ECC uses a finite field, so even though elliptical curves themselves are relatively new, most of the math involved in taking a discrete logarithm over the field is much older. In fact, most of the algorithms used are relatively minor variants of factoring algorithms.

The real question (and one that's still open, AFAIK) is whether discrete logarithms over an elliptical curve have the same "smoothness" property as you use in the sieve-based algorithms for factoring the product of large primes. If elliptical curves aren't "smooth" (and quite a few mathematicians seem convinced they're not) then the sieve-style factoring algorithms can't be adapted to taking discrete logarithms over elliptical curves. If they are smooth (and a fair number of other mathematicians seem convinced this is likely to be true), however, the sieve-style algorithms could be adapted. This would be a significant "break" against ECC -- you'd need to increase key sizes substantially to maintain security (probably not to quite as large as RSA for equivalent security, but fairly close).

What this all comes down to is one thing: it's not nearly so clear-cut a difference as 2500 years vs. a few decades. If anything, almost the opposite is actually true: variants of most of the older factoring algorithms can be used to find discrete logarithms over elliptical curves. What does not apply (at least based on present knowledge) to elliptical curves is the research of the last few decades or so into sieve-based algorithms.

As far as the patent situation goes, I think the situation is much more clear than @poncho implies. Yes, Certicom holds some patents (120 currently, though not all of them are on ECC), but what is or isn't covered by those patents has been quite clear for years. Their patents cover some specific ways to optimize ECC, but definitely do not cover ECC itself. In fact, the patents themselves have a "Field of the Invention" (or, in some, "Background of the invention") section that tells you about what was known before the patent, and these have a fairly complete explanation of how to use ECC for both encryption and signatures. For example, see US Patent Number 6,141,420, which has quite a decent explanation of the math involved in elliptical curves, and how to implement ElGamal with elliptical curves -- all in the description of what was known prior to the patent.

Share
Improve this answer
Follow
edited Apr 13, 2017 at 12:48
user avatar
CommunityBot
1
answered Nov 15, 2011 at 16:11
user avatar
Jerry Coffin
1,1141111 silver badges1414 bronze badges
1
Blackberry and Certicom claim over 300 patents in the arena, IIRC. See, for example, the NSA Sublicense FAQ at The National Security Agency’s ECC License Agreement with Certicom Corp. Certicom and Blackberry also claim to have patents that cover what CAs need to issue certificates with elliptic curves (perhaps implementation related?). See, for example, Certicom's IPR Licensing Contributions to the IETF's IKE, SSL, TLS, CMS, and S/MIME. – 
user10496
 Dec 26, 2013 at 4:44 
Add a comment

23

Part of the reason is trust; RSA has been around longer than EC, and people feel they understand it, and they trust it more (and in security, this is important). It's also easier to implement.

However, I believe that a bigger concern (at least for major companies) is the fear of being sued; there's a small company called Certicom that holds a number of EC-related patents, and has threatened to sue anyone who might infringe on their patents (and, of course, without there being any clear definition of what those patents actually cover). They have sued Sony (and eventually settled out of court).

The bottom line: for quite a while, it was just easier for companies to stick with RSA/DH, rather then either pay Certicom or take the legal risk.

Lately, things have shifted; people have figured out they can implement EC using things that can be documented to predate the Certicom patents (and hence are immune to lawsuit); it appears that more common use of Elliptic Curves is not that far away.

Share
Improve this answer
Follow
answered Nov 15, 2011 at 15:25
user avatar
poncho
133k1010 gold badges209209 silver badges336336 bronze badges
3
since you are talking about implementations, wiki says there are open source implementation available in openSSH and others. So, as a programmer if I'm prompted to use that; will it do harm to me or my firm? I guess not!! – 
Vineet Menon
 Nov 15, 2011 at 18:42
At PGP we had implementations of EC in the SDK, but they were stripped on compile specifically due to the patent issue. It's not the core implementations that you have to worry about, it's all of the performance aspects and implementation details that are encumbered. – 
MrEvil
 Jun 10, 2013 at 15:58
Add a comment

10

You forgot to mention one additional advantage of elliptic curves: the generation of keys is much faster than with RSA.

In europe, many government smart card solutions are now based on ECC:

The european electronic pass ports
The Austrian card
The German ID card
The new German health insurance card
Share
Improve this answer
Follow
answered Oct 3, 2015 at 21:09
user27950
2
To whom It may concern, the german ID card does use Brainpool P256r. – 
hdev
 Dec 7, 2016 at 9:18
2
didn't someone prove that the brainpool "r" curves were not, in fact, random... except maybe the 512r? – 
Erik Aronesty
 Sep 11, 2018 at 21:10
Add a comment
]]]
]]]]]]]
[[from: view others/数学/整数分解/factorint.txt
下载:Number Field Sieve
下载:Adleman-Pomerance-Rumely Primality Test
mkdir /sdcard/Download/wget_/factorint/
cd /sdcard/Download/wget_/factorint/
view /sdcard/Download/wget_/factorint/On\ the\ large\ sieve\ inequality\ in\ an\ algebraic\ number\ field(1986)(Schumer).pdf
[[[
[[

Bosma, W. and van der Hulst, M.-P. "Faster Primality Testing." In Advances in Cryptology, Proc. Eurocrypt '89, Houthalen, April 10-13, 1989 (Ed. J.-J. Quisquater). New York: Springer-Verlag, 652-656, 1990.
  libgen没找到？！
  wget http://www.math.ru.nl/~bosma/pubs/EUROCRYPT89.pdf  -O 'Faster Primality Testing(1990)(Bosma).pdf'
EBookDroid miss fonts: ArialBlack -> /sdcard/fonts/
  https://fontsfree.net/arial-black-font-download.html
    https://fontsfree.net//wp-content/fonts/basic/sans-serif/FontsFree-Net-ariblk.ttf
    wget 'https://fontsfree.net//wp-content/fonts/basic/sans-serif/FontsFree-Net-ariblk.ttf' -O 'ariblk.ttf'
      165KB
    !mkdir /sdcard/fonts/
    !mv /sdcard/Download/wget_/factorint/ariblk.ttf  /sdcard/fonts/
]]
===
Cohen, H. and Lenstra, A. K. "Primality Testing and Jacobi Sums." Math. Comput. 42, 297-330, 1984.
  https://www.ams.org/journals/mcom/1984-42-165/S0025-5718-1984-0726006-X/
    https://www.ams.org/journals/mcom/1984-42-165/S0025-5718-1984-0726006-X/S0025-5718-1984-0726006-X.pdf
    wget 'https://www.ams.org/journals/mcom/1984-42-165/S0025-5718-1984-0726006-X/S0025-5718-1984-0726006-X.pdf' -O 'Primality Testing and Jacobi Sums(1984)(Cohen).pdf'
  #https://libgen.lc/edition.php?id=55029286
===
Cohen, H. and Lenstra, A. K. "Implementation of a New Primality Test." Math. Comput. 48, 103-121, 1987.
  https://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866102-2/
    https://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866102-2/S0025-5718-1987-0866102-2.pdf
    wget 'https://www.ams.org/journals/mcom/1987-48-177/S0025-5718-1987-0866102-2/S0025-5718-1987-0866102-2.pdf' -O 'Implementation of a New Primality Test(1987)(Cohen).pdf'
  #https://libgen.lc/edition.php?id=47711192
===
Adleman, L. M.; Pomerance, C.; and Rumely, R. S. "On Distinguishing Prime Numbers from Composite Number." Ann. Math. 117, 173-206, 1983.
https://math.dartmouth.edu/~carlp/
  https://math.dartmouth.edu/~carlp/PDF/paper37.pdf
  wget 'https://math.dartmouth.edu/~carlp/PDF/paper37.pdf' -O 'On Distinguishing Prime Numbers from Composite Number(1983)(Adleman)(Pomerance).pdf'
]]]
[[[
On the large sieve inequality in an algebraic number field(1986)(Schumer).pdf
===
https://libgen.lc/edition.php?id=65778302
wget 'https://libgen.rocks/get.php?md5=6691db1526569e82a3991d7a80bd1f46&key=0WIH1L3SHFXKREPA' -O 'On the large sieve inequality in an algebraic number field(1986)(Schumer).pdf'
]]]
[[[
Modifications to the Number Field Sieve(1993)(Don Coppersmith).pdf
===
https://libgen.lc/edition.php?id=12214848
wget 'https://libgen.rocks/get.php?md5=3fe48464929fefffefd1b3912904a552&key=A61TCDHY982SC96X' -O 'Modifications to the Number Field Sieve(1993)(Don Coppersmith).pdf'
]]]
[[[
Development of the Number Field Sieve(1993)(Lenstra).djvu
===
https://libgen.lc/edition.php?id=135841703
wget 'https://libgen.rocks/get.php?md5=7ae95735f558056a60c6af947d4303ba&key=4BNGI1K84EPN8PPQ' -O 'Development of the Number Field Sieve(1993)(Lenstra).djvu'
]]]
[[[
Area-Time Efficient Implementation of the Elliptic Curve Method of Factoring in Reconfigurable Hardware for Application in the Number Field Sieve(2010)(Gaj).pdf
===
https://libgen.lc/edition.php?id=25642691
#??wget 'https://libgen.rocks/ads.php?md5=a9c14d866bddb57b0c337e8bf2cdcdaf&downloadname=10.1109/tc.2009.191' -O 'Area-Time Efficient Implementation of the Elliptic Curve Method of Factoring in Reconfigurable Hardware for Application in the Number Field Sieve(2010)(Gaj).pdf'
wget 'https://libgen.rocks/get.php?md5=a9c14d866bddb57b0c337e8bf2cdcdaf&key=5BHBEOI6I5KD1CDP' -O 'Area-Time Efficient Implementation of the Elliptic Curve Method of Factoring in Reconfigurable Hardware for Application in the Number Field Sieve(2010)(Gaj).pdf'
  5MB
]]]
[[[
The number field sieve for integers of low weight(2010)(Schirokauer).pdf
===
https://libgen.lc/edition.php?id=74440852
wget 'https://libgen.rocks/get.php?md5=ff934eb4c4907cc24f1d7e7da031431b&key=T7VYJ7CMWDXMVO3E' -O 'The number field sieve for integers of low weight(2010)(Schirokauer).pdf'
]]]
[[[
The multiple number field sieve for medium- and high-characteristic finite fields(2014)(Barbulescu).pdf
===
https://libgen.lc/edition.php?id=79606342
wget 'https://libgen.rocks/get.php?md5=e1a4a4acd78d28ee0b2c95b62e7d37c7&key=7CUDESMA1WWYI6PT' -O 'The multiple number field sieve for medium- and high-characteristic finite fields(2014)(Barbulescu).pdf'
]]]
[[[
Rigorous analysis of a randomised number field sieve(2018)(Lee).pdf
===
https://libgen.lc/edition.php?id=73420663
wget 'https://libgen.rocks/get.php?md5=6ebc8cd4cf73b65208956b750198a9b4&key=OJK7H0HHZOJ571IU' -O 'Rigorous analysis of a randomised number field sieve(2018)(Lee).pdf'
]]]
[[[
A Note on the Behaviour of the Number Field Sieve in the Medium Prime Case: Smoothness of Norms(2018)(Benger).pdf
===
https://libgen.lc/edition.php?id=75824235
wget 'https://libgen.rocks/get.php?md5=d7e2bdf5b32c7621ea2733d9dc0f6a47&key=MDQU0XF2IB1S1IWM' -O 'A Note on the Behaviour of the Number Field Sieve in the Medium Prime Case--Smoothness of Norms(2018)(Benger).pdf'
]]]
[[[
Refined analysis to the extended tower number field sieve(2020)(Zhu Yuqing).pdf
===
https://libgen.lc/edition.php?id=87147005
wget 'https://libgen.rocks/get.php?md5=25c6d5328dab4b1bff52d7b5e4e594a6&key=A7MFU1TYST5C6LW5' -O 'Refined analysis to the extended tower number field sieve(2020)(Zhu Yuqing).pdf'
]]]
[[[
On the effectiveness of a generalization of Miller’s primality theorem(2010)(ZhangZhenxiang).pdf
===
https://libgen.lc/edition.php?id=10031170
wget 'https://libgen.rocks/get.php?md5=d93a8cda629e88294d1f0561220c7b5a&key=Q6RWEMID90EHY5V6' -O 'On the effectiveness of a generalization of Miller_s primality theorem(2010)(ZhangZhenxiang).pdf'
]]]
[[[
On Lucas_s Test for the Primality of Mersenne's Numbers(1935)(Lehmer).pdf
===
https://libgen.lc/edition.php?id=27366284
wget 'https://libgen.rocks/get.php?md5=55bee24548ed7d565255c98ed47b8f37&key=AJF1012WYKWYL2HD' -O 'On Lucas_s Test for the Primality of Mersenne_s Numbers(1935)(Lehmer).pdf'
]]]
[[[
Lucas's criterion for the primality of numbers of the form N = h2n−1(1971)(Stechkin).pdf
===
https://libgen.lc/edition.php?id=12913115
wget 'https://libgen.rocks/get.php?md5=4256ec791df465bb18a6c193f58c55a1&key=L5WS101XEDPGJULS' -O 'Lucas_s criterion for the primality of numbers of the form N = h2n−1(1971)(Stechkin).pdf'
]]]
[[[
A Note on Primality Testing Using Lucas Sequences(1975)(Michael).pdf
===
https://libgen.lc/edition.php?id=42082011
wget 'https://libgen.rocks/get.php?md5=3d286a1b5115a9b63c4f7078aa19bb03&key=1UZXSFP33ACWN7RW' -O 'A Note on Primality Testing Using Lucas Sequences(1975)(Michael).pdf'
]]]
[[[
Supplement to Implementation of a New Primality Test(1987)(Cohen).pdf
===
https://libgen.lc/edition.php?id=52751939
wget 'https://libgen.rocks/get.php?md5=3499219dce8a1a667cca6e1dbca16685&key=W0JLDJUOPVIZT1BC' -O 'Supplement to Implementation of a New Primality Test(1987)(Cohen).pdf'
]]]
[[[
Elliptic curves and primality proving(1993)(Atkin).pdf
===
https://libgen.lc/edition.php?id=52445180
wget 'https://libgen.rocks/get.php?md5=677b21442ec76c52ad402d34729de0d9&key=PGKO6SL22B096J6M' -O 'Elliptic curves and primality proving(1993)(Atkin).pdf'
]]]
[[[
===
wget '' -O ''
  download...xxxxx TODO:download
]]]
[[[
===
wget '' -O ''
]]]
[[[
===
wget '' -O ''
]]]
[[[
e others/数学/p_adic_integer_ring.txt
wget 'https://www.ams.org/journals/mcom/1984-42-165/S0025-5718-1984-0726006-X/S0025-5718-1984-0726006-X.pdf' -O 'Primality Testing and Jacobi Sums(1984)(Cohen).pdf'
p-adic integer
[is_prime p]:
  [p_adic_integer p =[def]= (?[seq :: (@[e<-[1..]] -> [[0..<p**e]])] -> @[e<-[1..]] -> [seq[e+1]%p**e==seq[e]])]
  #coordinatewise addition and multiplication
  [p_adic_integer_add, p_adic_integer_mul :: @[p<-all_primes] -> p_adic_integer p -> p_adic_integer p -> p_adic_integer p]
  [p_adic_integer_add p lhs rhs =[def]= \e -> (lhs[e]+rhs[e])%p**e]
  [p_adic_integer_mul p lhs rhs =[def]= \e -> (lhs[e]*rhs[e])%p**e]
  [p_adic_ring p =[def]= (p_adic_integer_add, p_adic_integer_mul, p_adic_integer p)]
  #subring
  [ZZ <= p_adic_integer p]
    [lift__int2p_adic p :: ZZ -> p_adic_integer p]
    [lift__int2p_adic p =[def]= \i -> \e -> i%p**e]
]]]
]]
