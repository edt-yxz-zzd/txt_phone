
vim cmd:
  :
    :.,.+6s//@@@\0\r\    :::
    :.,.+6s/^\S* /@@@\0\r\    :::
    :.,.+6s/^[^;]*; /@@@\0\r\    :::
    :%s/<F\d\+>//g
    :%s/ \+$//g
  /
    / \+$
    /^\S*\s
    /^[^;]*;\s\?
    /^[^)]*)\s\?


C/C++
  果然只是西方编程语言
  stoi(str, &n, base):
    base of the number (between 2 and 36, inclusive)
    26个英语字母
  字符大小写
    中文字符根本没有这种东西

C++ bug:
    * C++因为使用 基类引用(强引用/共享指针/独占指针)、函数对象（带状态函数、匿名函数），不可能避免 强引用循环，这不是仔细设计析构函数使用智能指针就能解决的问题，没有垃圾回收器，必然存在 内存泄漏！C没有类继承，数据结构简单，仔细设计使用问题反而没那么严重。
      如果 不使用 共享指针、仅使用类实心数据，即 值复制共享指针|独占指针仅用于指向最外层派生类|弱引用，则可大大降低不明不白的引用循环
    * 模版的环境敏感型标识绑定，独立开发分离编译的两个库可能不相容，见下面 pg749[764/1366]，既然 依赖环境，那么 instantiation_point(类似goto标签，但 允许 存在于 命名空间 中)也当作为 模版参数

关注：
  pg604[619/1366]
    protected member
  pg749[764/1366]
    overload+argument-dependent lookup (ADL)+point-of-instantiation binding==>>error-prone
  pg588[603/1366]
    vtable variable in ctor/dtor
  ???
    函数不能 特化，只能 重载
  pg524[539/1366]
    =delete
  pg748[763/1366]
    typename/template






e others/book/The C++ Programming Language(4ed)(2013).txt
e others/book/The\ C++\ Programming\ Language(4ed)(2013).txt

  '/sdcard/0my_files/book/lang/C++/The C++ Programming Language(4ed)(2013).pdf'
    pg103[118/1366]
    pg118[133/1366]
    pg119[134/1366]
    pg123[138/1366]
pg141[156/1366]
pg149[164/1366]
pg151[166/1366]
pg155[170/1366]
pg160[175/1366]
pg166[181/1366]
pg168[183/1366]
pg179[194/1366]
pg191[206/1366]
pg193[208/1366]
pg196[211/1366]
pg217[232/1366]
pg264[279/1366]
pg268[283/1366]
pg282[297/1366]
pg299[314/1366]
pg307[322/1366]
pg313[328/1366]
pg314[329/1366]
pg315[330/1366]
pg319[334/1366]
pg320[335/1366]
pg336[351/1366]
pg340[355/1366]
pg353[368/1366]
pg358[373/1366]
pg366[381/1366]
pg373[388/1366]
pg374[389/1366]
pg377[392/1366]
pg395[410/1366]
pg405[420/1366]
pg413[428/1366]
pg415[430/1366]
pg416[431/1366]
pg423[438/1366]
pg430[445/1366]
pg442[457/1366]
pg443[458/1366]
pg445[460/1366]
pg462[477/1366]
pg474[489/1366]
pg479[494/1366]
pg486[501/1366]
pg487[502/1366]
pg489[504/1366]
pg490[505/1366]
pg492[507/1366]
pg494[509/1366]
pg495[510/1366]
pg496[511/1366]
pg501[516/1366]
pg502[517/1366]
pg504[519/1366]
pg513[528/1366]
pg516[531/1366]
pg517[532/1366]
pg524[539/1366]
pg529[544/1366]
pg530[545/1366]
pg532[547/1366]
pg534[549/1366]
pg536[551/1366]
pg540[555/1366]
pg541[556/1366]
pg544[559/1366]
pg588[603/1366]
pg590[605/1366]
pg593[608/1366]
pg595[610/1366]
pg596[611/1366]
pg603[618/1366]
pg604[619/1366]
pg606[621/1366]
pg608[623/1366]
pg610[625/1366]
pg624[639/1366]
pg633[648/1366]
pg638[653/1366]
pg639[654/1366]
pg643[658/1366]
pg648[663/1366]
pg653[668/1366]
pg655[670/1366]
pg657[672/1366]
pg723[738/1366]
pg724[739/1366]
pg729[744/1366]
pg730[745/1366]
pg731[746/1366]
  pg733[748/1366]
pg736[751/1366]
pg744[759/1366]
pg746[761/1366]
pg747[762/1366]
pg748[763/1366]
pg749[764/1366]
pg755[770/1366]
pg765[780/1366]
pg766[781/1366]
pg771[786/1366]
pg796[811/1366]
pg800[815/1366]
pg814[829/1366]
pg829[844/1366]
pg855[870/1366]
pg866[881/1366]
pg868[883/1366]
pg903[918/1366]
pg966[981/1366]
pg971[986/1366]
pg974[989/1366]
pg985[1000/1366]
pg986[1001/1366]
pg992[1007/1366]
pg994[1009/1366]
pg995[1010/1366]
pg1005[1020/1366]
pg1006[1021/1366]
pg1009[1024/1366]
pg1017[1032/1366]
pg1018[1033/1366]
pg1028[1043/1366]
pg1029[1044/1366]
pg1029[1044/1366]2
pg1030[1045/1366]
pg1033[1048/1366]
pg1034[1049/1366]
pg1043[1058/1366]
pg1048[1063/1366]
pg1051[1066/1366]
pg1052[1067/1366]
pg1058[1073/1366]
  pg1062[1077/1366]
pg1067[1082/1366]







pg770[785/1366] #empty-base optimization


[7] Do not try to use a standard-library facility without#includeing its header; §30.2.
[8] To use a range-foron a built-in array,#include<iterator>; §30.3.2.
see below: [[[Standard_Library_Overview]]]
  * Containers
  * General_Utilities
  * Algorithms
  * Diagnostics
  * Strings_and_Characters
  * Input_Output
  * Localization
  * Language_Support
  * Numerics
  * Concurrency
  * C_Compatibility


Template<typename... Args>
void f(Args... args);
  // parameter pack
  // sizeof... args

[2] Explicitly instantiate if you need exact control of the instantiation environment; §26.2.2.
[3] Explicitly instantiate if you optimize the time needed to generate specializations; §26.2.2.
[6] Keep the binding context unchanged between instantiation points; §26.3.4.

[5] Templates are type-safe, but checking happens too late; §23.3.
substitution failure is not an error.
  The rule is known under the unpronounceable acronym SFINAE (Substitution Failure Is Not An Error).

非常量的非局部的静态变量 理应 改成 局部的静态变量#不知可否用 inline 函数包裹？
  更明确的初始化时机#见下面call_once

extern "C" void f()noexcept;
noexcept --> terminate()
virtual, [[noreturn]]
override, final
  f()... override final;
  class X final{};
compl???
  like: bitor === |
  compl === ~
sizeof, alignof, alignas, decltype?
  alignas: "align as" use to decl/def uninit buffer #see below
#alias:
  const
  constexpr
  enum class.xxx{a, b, c}; //+ switch/case
  template<...> using xxx = typename X::Y::template Z<...>::template W<...>::...;
  using std::string;
    //using-declaration
  using namespace std;
    //using-directive
  namespace Lib = Foundation_library_v2r11;
    //namespace alias
    // This can immensely simplify the task of replacing one version of a library with another.
    // 所以说，命名空间 也该加 参数...


a.*(&T::x)
p->*(&T::x)


operator "" km ()

int main(int argc, char* argv[])
  argc >= 1
  2 <= len(argv) == argc+1
  argv[-1] is argv[argc] == nullptr
  argv[0] === executable/program-name
  all(s is c_string (i.e. s[strlen(s)] == NUL) for s in argv[:-1])






int_max_t

string::npos
  the end of string
  -1???







===
===
===
===
===
===
===
===
===
===
===
pg1071[1086/1366]
37.6 Advice
[1] Use regex for most conventional uses of regular expressions; §37.1.
[2] The regular expression notation can be adjusted to match various standards; §37.1.1, §37.2.
[3] The default regular expression notation is that of ECMAScript; §37.1.1.
[4] For portability, use the character class notation to avoid nonstandard abbreviations; §37.1.1.
[5] Be restrained; regular expressions can easily become a write-only language; §37.1.1.
[6] Prefer raw string literals for expressing all but the simplest patterns; §37.1.1.
[7] Note that "\i" allows you to express a subpattern in terms of a previous subpattern; §37.1.1.
[8] Use "?" to make patterns ‘‘lazy’’; §37.1.1, §37.2.1.
[9]regex can use ECMAScript, POSIX, awk, grep, and egrep notation; §37.2.
[10] Keep a copy of the pattern string in case you need to output it; §37.2.
[11] Use regex_search()for looking at streams of characters and regex_match()to look for fixed layouts; §37.3.2, §37.3.1.



===
pg1067[1082/1366]
  to read later
37.4 Regular Expression Iterators
The regex_search()function allows us to find a single occurrence of a pattern in a data stream.
  What if we wanted to find and do something to all such occurrences?
    If the data is organized as a sequence of easily recognized lines or records, we can iterate over those and use regex_match()for each.
    If what we want to do with each occurrence of a pattern is a simple substitution, we can use regex_replace().
    If we want to iterate over a sequence of characters doing something for each occurrence of a pattern, we use a regex_iterator.



37.4.1 regex_iterator
A regex_iterator is a bidirectional iterator that searches a sequence for the next match of a pattern when incremented:
template<class Bi,
  class C = typename iterator_traits<Bi>::value_type ,
  class Tr = typename regex_traits<C>::type>
class regex_iterator {
  public:
    using regex_type = basic_regex<C,Tr>;
    using value_type = match_results<Bi>;
    using difference_type = ptrdiff_t;
    using pointer = const value_type∗;
    using reference = const value_type&;
    using iterator_category = forward_iterator_tag;
  //...
};

The regex_traits are described in §37.5.
The usual set of aliases is provided:
  using cregex_iterator = regex_iterator<const char∗>;
  using wcregex_iterator = regex_iterator<const wchar_t∗>;
  using sregex_iterator = regex_iterator<string::const_iterator>;
  using wsregex_iterator = regex_iterator<wstring::const_iterator>;



A regex_iterator provides a minimal set of iterator operations:
regex_iterator<Bi,C,Tr>(§iso.28.12.1)
@@@regex_iterator p {};
    :::p is end-of-sequence
@@@regex_iterator p {b,e,pat, flags);
    :::Iterate over [b:e), looking for matches of pat using options flags
@@@regex_iterator p {b,e,pat);
    :::p is initialized with{b,e,pat,regex_constants::match_default}
@@@regex_iterator p {q};
    :::Copy constructor (no move constructor)
@@@p=q
    :::Copy assignment (no move assignment)
@@@p==q
    :::Does p point to the same sub_match as q?
@@@p!=q
    :::!(p==q)
@@@c=∗p
    :::c is the current sub_match
@@@x=p−>m
    :::x=(∗p).m
@@@++p
    :::Make p point to the next occurrence of p’s pattern
@@@q=p++
    :::q=p, then++p


A regex_iterator is a bidirectional iterator, so we cannot directly iterate over an istream.
As an example, we can output all whitespace-separated words in a string:

void test()
{
  string input = "aa as; asd ++eˆasdf asdfg";
  regex pat {R"(\s+(\w+))"};
  for (sregex_iterator p(input.begin(),input.end(),pat); p!=sregex_iterator{}; ++p)
    cout << (∗p)[1] << '\n';
}

This outputs:
  as
  asd
  asdfg

Note that we are missing the first word,aa, because it has no preceding whitespace. If we simplify
the pattern to R"((\ew+))", we get
  aa
  as
  asd
  e
  asdf
  asdfg

You cannot write through a regex_iterator and regex_iterator{}is the only possible end-of-sequence.






37.4.2 regex_token_iterator
A regex_token_iterator is an adaptor for regex_iterator that iterates over sub_matches of the match_results found:
template<class Bi,
  class C = typename iterator_traits<Bi>::value_type ,
  class Tr = typename regex_traits<C>::type>
class regex_token_iterator {
  public:
    using regex_type = basic_regex<C,Tr>;
    using value_type = sub_match<Bi>;
    using difference_type = ptrdiff_t;
    using pointer = const value_type∗;
    using reference = const value_type&;
    using iterator_category = forward_iterator_tag;
  //...
}


The regex_traits are described in §37.5.
The usual set of aliases is provided:
  using cregex_token_iterator = regex_token_iterator<const char∗>;
  using wcregex_token_iterator = regex_token_iterator<const wchar_t∗>;
  using sregex_token_iterator = regex_token_iterator<string::const_iterator>;
  using wsregex_token_iterator = regex_token_iterator<wstring::const_iterator>;



A regex_token_iterator provides a minimal set of iterator operations:
regex_token_iterator(§iso.28.12.2)
@@@regex_token_iterator p {};
    :::p is the end-of-sequence
@@@regex_token_iterator p {b,e,pat,x, flags};
    :::x lists the indices of the sub_matches to be included in the iteration or 0, meaning ‘‘the whole match,’’ or −1, meaning ‘‘represent each character sequence not matched as a sub_match’’; x can be an int, an initializer_list<int>, a const vector<int>&, or a const int (&sub_match)[N]
@@@regex_token_iterator p {b,e,pat,x};
    :::p is initialized with {b,e,pat,x,regex_constants::match_default}
@@@regex_token_iterator p {b,e,pat};
    :::p is initialized with {b,e,pat,0,regex_constants::match_default}
@@@regex_token_iterator p {q};
    :::Copy constructor (no move constructor)
@@@p.˜regex_token_iterator()
    :::Destructor: release all resources
@@@p=q
    :::Copy assignment (no move assignment)
@@@p==q
    :::Does p point to the same sub_match as q?
@@@p!=q
    :::!(p==q)
@@@c=∗p
    :::c is the current sub_match
@@@x=p−>m
    :::x=(∗p).m
@@@++p
    :::Make p point to the next occurrence of p’s pattern
@@@q=p++
    :::q=p, then ++p


The x argument lists the sub_matches to be included in the iteration. For example (iterating over matches 1 and 3):
void test1()
{
  string input {"aa::bb cc::dd ee::ff"};
  regex pat {R"((\w+)([[:punct:]]+)(\w+)\s∗)"};
  sregex_token_iterator end {};
  for (sregex_token_iterator p{input.begin(),input.end(),pat,{1,3}}; p!=end; ++p)
    cout << ∗p << '\n';
}

This gives the output:
  aa
  bb
  cc
  dd
  ee
  ff

The −1 option basically inverts the strategy for reporting matches by representing each character sequence that does not match as a sub_match.
  This is often referred to as token splitting(that is, splitting a character stream into tokens) because when your pattern matches the token separators, option −1 leaves you with the tokens. For example:
void test2()
{
  string s {"1,2 , 3 ,4,5, 6 7"};//input
  regex pat {R"(\s∗,\s∗)"}; //use comma as token separator
  copy(
      sregex_token_iterator{s.begin(),s.end(),pat,−1},
      sregex_token_iterator{},
      ostream_iterator<string>{cout,"\n"}
      );
}

The output is:
  1
  2
  3
  4
  5
  6 7

This could equivalently be written using an explicit loop:
void test3()
{
  sregex_token_iterator end{};
  for (sregex_token_iterator p {s.begin(),s.end(),pat,−1}; p!=end; ++p)
    cout << ∗p << '\n';
}






37.5 regex_traits
A regex_traits<T> represents the correspondence between a character type, a string type, and a locale as needed for a regex implementer:
template<class C>
struct regex_traits {
  public:
    using char_type = C;
    using string_type = basic_string<char_type>;
    using locale_type = locale;
    using char_class_type = /*implementation-defined bitmask type*/;
  //...
};

The standard library provides specialization sregex_traits<char> and regex_traits<wchar_t>.
regex_traits<C>Operations (§iso.28.7)
@@@regex_traits tr {};
    :::Make a default regex_trait<C>
@@@n=tr.length(p)
    :::n is the number of characters in the C-style string p; n=char_traits<C>::length(p); static
@@@c2=tr.translate(c)
    :::c2=c, that is, a no-op
@@@c2=tr.translate_nocase(c)
    :::use_facet<ctype<C>>(getloc()).tolower(c); §39.4.5
@@@s=tr.transform(b,e)
    :::s is a string that can be used to compare [b:e) to others strings; §39.4.1
@@@s=tr.transform_primary(b,e)
    :::s is a string that can be used to compare [b:e) to others strings; ignore case; §39.4.1
@@@s=tr.lookup_collatename(b,e)
    :::s is the string name of the collating element named [b:e) or the empty string
@@@m=tr.lookup_classname(b,e,ign)
    :::m is the string name of the classification mask for the character classification named [b:e); ignore case if ign==true
@@@m=tr.lookup_classname(b,e)
    :::m=tr.lookup_classname(b,e ,false)
@@@tr.isctype(c,m)
    :::Is c classified as an m? m is a class_type
@@@i=tr.value(c,b)
    :::i is the integer value represented by c in base b; b must be 8,10, or 16
@@@loc2=tr.imbue(loc)
    :::Set tr’s locale to loc;loc2 is tr’s previous locale
@@@loc=tr.getloc()
    :::loc is tr’s locale

A transform is used to generate strings for fast comparisons in pattern-matching implementations.
A classification name is one of the character classifications listed in §37.1.1, such as alpha, s, and xdigit.





===
pg1058[1073/1366]
37.2.1 Match Results
Results from a regular expression match are gathered in a match_results object which contains one or more sub_match objects:
template<class Bi>
class sub_match : public pair<Bi,Bi> {
  public:
    using value_type = typename iterator_traits<Bi>::value_type;
    using difference_type = typename iterator_traits<Bi>::difference_type;
    using iterator = Bi;
    using string_type = basic_string<value_type>;
    bool matched; //true if *this contains a match
  //...
};
Bi must be a bidirectional iterator (§33.1.2). A sub_match can be seen as a pair of iterators into the string being matched.


sub_match<Bi> Operations
@@@sub_match sm {};
    :::Default constructor: an empty sequence; constexpr
@@@n=sm.length()
    :::n is the number of characters matched
@@@s=sm
    :::Implicit conversion of a sub_match to a basic_string; s is a basic_string containing the characters matched
@@@s=sm.str()
    :::s is a basic_string containing the characters matched
@@@x=sm.compare(x)
    :::Lexicographical comparison:sm.str().compare(x); x can be a sub_match, a basic_string, or a C-style string
@@@x==y
    :::Is x equal to y? x and y can be a sub_match or a basic_string
@@@x!=y
    :::!(x==y)
@@@x<y
    :::x is lexicographically before y
@@@x>y
    :::y<x
@@@x<=y
    :::!(x>y)
@@@x>=y
    :::!(x<y)
@@@sm.matched
    :::true if sm contains a match;false otherwise














A match_results is a container of sub_matches:
template<class Bi, class A = allocator<sub_match<Bi>>
class match_results {
  public:
    using value_type = sub_match<Bi>;
    using const_reference = const value_type&;
    using reference = const_reference;
    using const_iterator = /*implementation-defined*/;
    using iterator = const_iterator;
    using difference_type = typename iterator_traits<Bi>::difference_type;
    using size_type = typename allocator_traits<A>::size_type;
    using allocator_type = A;
    using char_type = typename iterator_traits<Bi>::value_type;
    using string_type = basic_string<char_type>;
    ˜match_results(); //not virtual
  //...
};
Bi must be a bidirectional iterator (§33.1.2).


As for basic_string and basic_ostream, a few standard aliases are provided for the most common match_results:
  using cmatch = match_results<const char∗>; //C-style string
  using wcmatch = match_results<const wchar_t∗>; //wide C-style string
  using smatch = match_results<string::const_iterator>; //string
  using wsmatch = match_results<wstring::const_iterator>; //wstring

A match_results provides access to its match string, its sub_matches, and the characters before and after the match:
  input_string == m.prefix() ++ m[0] ++ m.suffix()
  m[0] == m[1]...m[m.size()-1]

A match_results provides a conventional set of operations:
regex<C,Tr> Matches and Submatches (§iso.28.9, §iso.28.10)
@@@match_results m {};
    :::Default constructor: use allocator_type{}
@@@match_results m {a};
    :::Use allocator a; explicit
@@@match_results m {m2};
    :::Copy and move constructor
@@@m2=m
    :::Copy assignment
@@@m2=move(m)
    :::Move assignment
@@@m.˜match_results()
    :::Destructor: release all resources
@@@m.ready()
    :::Does m hold a complete match?
@@@n=m.size()
    :::n−1 is the number of subexpressions in m;n==0 if there was no match
@@@n=m.max_size()
    :::n is the largest possible number of sub_matches form
@@@m.empty()
    :::m.size()==0?
@@@r=m[i]
    :::r is a const reference to the ith sub_match of m; m[0] represents the complete match; if i>= size(),m[i] refers to a sub_match representing an unmatched subexpression.
@@@n=m.length(i)
    :::n=m[i].length(); the number of characters of m[i]
@@@n=m.length()
    :::n=m.length(0)
@@@pos=m.position(i)
    :::pos=m[i].first; the first character of m[i]
@@@pos=m.position()
    :::pos=position(0)
@@@s=m.str(i)
    :::s=m[i].str(); a string representation of m[i]
@@@s=m.str()
    :::s=m.str(0)
@@@sm=m.prefix()
    :::sm is a sub_match representing the characters not matched by m in the input string coming before the match
@@@sm=m.suffix()
    :::sm is a sub_match representing the characters not matched by m in the input string coming after the match

regex<C,Tr> Matches and Submatches (continued)(§iso.28.9, §iso.28.10)
p=m.begin() p points to the first sub_match of m
p=m.end() p points to the one-beyond-the-last sub_match of m
p=m.cbegin() p points to the first sub_match of m(const iterator)
p=m.cend() p points to the one-beyond-the-last sub_match of m(const iterator)
a=m.get_allocator() a is m’s allocator
m.swap(m2) Exchange the states of m and m2
m==m2 Are the values of sub_matches of m and m2 equal?
m!=m2 !(m==m2)

We can subscript a regex_match to access a sub_match, for example,m[i]. If a subscript,i, refers to a nonexistent sub_match, the result of m[i] represents an unmatched sub_match. For example:
void test()
{
  regex pat ("(AAAA)(BBB)?");
  string s = "AAAA";
  smatch m;
  regex_search(s,m,pat);
  cout << boolalpha;
  cout << m[0].matched << '\n';//true: we found a match
  cout << m[1].matched << '\n';//true: there was a first sub_match
  cout << m[2].matched << '\n';//false: no second sub_match
  cout << m[3].matched << '\n';//false: there couldn’t be a third sub_match for pat
}














37.2.2 Formatting
In regex_replace(), formatting is done using a format() function:
regex<C,Tr> Formatting (§iso.28.10.5)
Formatting is controlled by match_flag_typeoptions
@@@out=m.format(out,b,e,flags)
    :::Copy [b:e) to out; substituting submatches from m for format characters
@@@out=m.format(out,b,e)
    :::out=m.format(out,b,e ,regex_constants::format_default)
@@@out=m.format(out,fmt,flags)
    :::out=m.format(out,begin(fmt),end(fmt),flags); fmt can be a basic_string or a C-style string
@@@out=m.format(out,fmt)
    :::out=m.format(out,fmt,regex_constants::format_default)
@@@s=m.format(fmt,flags)
    :::Construct s as a copy of fmt; substituting submatches fromm for format characters; fmt can be a basic_string or a C-style string
@@@s=m.format(fmt)
    :::s=m.format(fmt,regex_constants::format_default)


Formats can contain formatting characters:
Format Substitution Notation
@@@$&
    :::The match
@@@$‘
    :::The prefix
@@@$’
    :::The suffix
@@@$i
    :::The ith submatch, e.g.,$1
@@@$ii
    :::The iith submatch, e.g.,$12
@@@$$
    :::Not a match, the $ character

For an example, see §37.3.3.
The details of formatting done by format() are controlled by a set of options (flags):
regex<C,Tr>Formatting Options (regex_constants::match_flag_type; §iso.28.5.2)
@@@format_default
    :::Use ECMAScript (ECMA-262) rules (§iso.28.13)
@@@format_sed
    :::Use POSIX sed notation
@@@format_no_copy
    :::Copy only matches
@@@format_first_only
    :::Only the first occurrence of the regular expression is replaced







37.3 Regular Expression Functions
The functions for applying regular expression patterns to data are
    regex_search()for searching in a sequence of characters
    ,regex_match()for matching a fixed-length sequence of characters
    , and regex_replace()for doing replacement of patterns.

The details of matching are controlled by a set of options (flags):
regex<C,Tr>Matching Options (regex_constants::match_flag_type; §iso.28.5.2)
@@@match_not_bol
    :::The character ˆ is not considered to mean ‘‘beginning of line’’
@@@match_not_eol
    :::The character $ is not considered to mean ‘‘end of line’’
@@@match_not_bow
    :::\b does not match the subsequence [first,first)
@@@match_not_eow
    :::\b does not match the subsequence [last,last)
@@@match_any
    :::If more than one match is possible, then any match is acceptable
@@@match_not_null
    :::Do not match an empty sequence
@@@match_continuous
    :::Match only a subsequence that begins at first
@@@match_prev_avail
    :::(−−first) is a valid iterator position



pg1062[1077/1366]


37.3.1 regex_match()
To look for a pattern matching a whole sequence with a known length, such as a line of text, use regex_match():
Regular Expression Matching (§iso.28.11.2)
Matching is controlled by match_flag_type options (§37.3)
@@@regex_match(b,e ,m,pat,flags)
    :::Does the input [b:e) match the regex pattern pat? place the result in match_results m; use options flags
@@@regex_match(b,e ,m,pat)
    :::regex_match(b,e ,m,pat,regex_constants::match_default)
@@@regex_match(b,e ,pat,flags)
    :::Does the input [b:e) match the regex pattern pat? use options flags
@@@regex_match(b,e ,pat)
    :::regex_match(b,e ,pat,regex_constants::match_default)
@@@regex_match(x,m,pat,flags)
    :::Does the input x match the regex pattern pat?  x can be a basic_string or a C-style string; place the result in match_results m; use options flags
@@@regex_match(x,m,pat)
    ::: regex_match(x,m,pat,regex_constants::match_default)
@@@regex_match(x,pat,flags)
    :::Does the input x match the regex pattern pat? x can be a basic_string or a C-style string; use options flags
@@@regex_match(x,pat)
    ::: regex_match(x,pat,regex_constants::match_default)







37.3.2 regex_search()
To look for a pattern in a part of a sequence, such as a file, use regex_search():
Regular Expression Searching (§iso.28.11.3)
Matching is controlled by match_flag_type options (§37.3)
@@@regex_search(b,e ,m,pat,flags)
    :::Does the input [b:e) contain a match for the regex pattern pat? place the result in match_results m; use options flags
@@@regex_search(b,e ,m,pat)
    :::regex_search(b,e ,m,regex_constants::match_default)
@@@regex_search(b,e ,pat,flags)
    :::Does the input [b:e) contain a match for the the regex pattern pat? use options flags
@@@regex_search(b,e ,pat)
    :::regex_search(b,e ,pat,regex_constants::match_default)
@@@regex_search(x,m,pat,flags)
    :::Does the input x contain a match for the regex pattern pat? x can be a basic_string or a C-style string; place the result in match_results m; use options flags
@@@regex_search(x,m,pat)
    ::: regex_search(x,m,pat,regex_constants::match_default)
@@@regex_search(x,pat,flags)
    :::Does the input x contain a match for the regex pattern pat? x can be a basic_string or a C-style string; use options flags
@@@regex_search(x,pat)
    ::: regex_search(x,pat,regex_constants::match_default)





37.3.3 regex_replace()
To make simple substitutions of a pattern in a part of a sequence, such as a file, use regex_replace():
Regular Expression Replacement (§iso.28.11.4)
Matching is controlled by match_flag_type options (§37.3)
out=regex_replace(out,b,e ,pat,fmt,flags)Copy [b:e) to out, searching for the regex pattern pat; when a match for pat is found, copy it to out using the format fmt controlled by flags; fmt can be a basic_string or a C-style string
out=regex_replace(out,b,e ,pat,fmt)out=regex_replace(out,b,e ,pat,fmt, regex_constants::match_defaults)
s=regex_replace(x,pat,fmt,flags)Copy x to s, searching for the regex pattern pat; when a match for pat is found copy it to s using the format fmt controlled by flags; x can be a basic_string or a C-style string; fmt can be a basic_string or a C-style string
s=regex_replace(x,pat,fmt) s=regex_replace(x,pat,fmt, regex_constants::match_defaults)



Copying a format is done using the regex’s format()(§37.2.2) with the "$" prefix notation, for example, "$&" for the match and "$2" for the second submatch.



By default,regex_match() copies unmatched characters to its output.
  To eliminate those, we can use the format_no_copy option (§37.2.2):
    cout << regex_replace(input,pat,format,regex_constants::format_no_copy);







===
pg1052[1067/1366]
37.1.1 Regular Expression Notation
The regex library can recognize several variants of the notation for regular expressions (§37.2).
    Here, I first present the default notation used, a variant of the ECMA standard used for ECMAScript (more commonly known as JavaScript).

The syntax of regular expressions is based on characters with special meaning:
Regular Expression Special Characters
. Any single character (a ‘‘wildcard’’)
[ Begin character class
] End character class
{ Begin count
} End count
( Begin grouping
) End grouping
\ Next character has a special meaning
∗ Zero or more
+ One or more
? Optional (zero or one)
| Alternative (or)
ˆ Start of line; negation
$ End of line


A pattern can be optional or repeated (the default is exactly once) by adding a suffix:
Repetition
{ n } Exactly n times
{ n, } n or more times
{n,m} At least n and at most m times
∗ Zero or more, that is,{0,}
+ One or more, that is,{1,}
? Optional (zero or one), that is{0,1}

A suffix "?" after any of the repetition notations makes the pattern matcher ‘‘lazy’’ or ‘‘non-greedy.’’
  That is, when looking for a pattern, it will look for the shortest match rather than the longest.
  By default, the pattern matcher always looks for the longest match (similar to C++’s Max Munch rule; §10.3).





The most common character classifications have names:
Character Classes
@@@alnum
    :::Any alphanumeric character
@@@alpha
    :::Any alphabetic character
@@@blank
    :::Any whitespace character that is not a line separator
@@@cntrl
    :::Any control character
@@@d
    :::Any decimal digit
@@@digit
    :::Any decimal digit
@@@graph
    :::Any graphical character
@@@lower
    :::Any lowercase character
@@@print
    :::Any printable character
@@@punct
    :::Any punctuation character
@@@s
    :::Any whitespace character
@@@space
    :::Any whitespace character
@@@upper
    :::Any uppercase character
@@@w
    :::Any word character (alphanumeric characters plus the underscore)
@@@xdigit
    :::Any hexadecimal digit character


Several character classes are supported by shorthand notation:
Character Class Abbreviations
@@@\d
    :::A decimal digit === [[:digit:]]
@@@\s
    :::A space (space, tab, etc.) === [[:space:]]
@@@\w
    :::A letter (a-z) or digit (0-9) or underscore (_) === [_[:alnum:]]
@@@\D
    :::Not\d  === [ˆ[:digit:]]
@@@\S
    :::Not\s  === [ˆ[:space:]]
@@@\W
    :::Not\w  === [ˆ_[:alnum:]]

In addition, languages supporting regular expressions often provide:
Nonstandard (but Common) Character Class Abbreviations
@@@\l
    :::A lowercase character === [[:lower:]]
@@@\u
    :::An uppercase character === [[:upper:]]
@@@\L
    :::Not\l  === [ˆ[:lower:]]
@@@\U
    :::Not\u  === [ˆ[:upper:]]


bool is_identifier(const string& s)
{
  regex pat {"[_[:alpha:]]\\w∗"};
  return regex_match(s,pat);
}









Note the doubling of the backslash to include a backslash in an ordinary string literal. As usual, backslashes can also denote special characters:
Special Characters (§iso.2.14.3, §6.2.3.2)
@@@\n
    :::Newline
@@@\t
    :::Tab
@@@\\
    :::One backslash
@@@\xhh
    :::Unicode characters expressed using two hexadecimal digits
@@@\uhhhh
    :::Unicode characters expressed using four hexadecimal digits


To add to the opportunities for confusion, two further logically different uses of the backslash are provided:
Special Characters (§iso.28.5.2, §37.2.2)
@@@\b
    :::The first or last character of a word (a ‘‘boundary character’’)
@@@\B
    :::Not a \b
@@@\i
    :::The ith sub_match in this pattern










#group

A group(a subpattern) potentially to be represented by a sub_match is delimited by parentheses.
  If you need parentheses that should not define a subpattern, use "(?" rather than plain "(".
  For example:
      (\s|:|,)∗(\d∗)//spaces, colons, and/or commas followed by a number

    Assuming that we were not interested in the characters before the number (presumably separators), we could write:
      (?\s|:|,)∗(\d∗)//spaces, colons, and/or commas followed by a number

    This would save the regular expression engine from having to store the first characters: the "(?" variant has only one subpattern.

Regular Expression Grouping Examples
\d∗\s\w+
    No groups (subpatterns)
(\d∗)\s(\w+)
    Two groups
(\d∗)(\s(\w+))+
    Two groups (groups do not nest)
(\s∗\w∗)+
    One group, but one or more subpatterns; only the last subpattern is saved as as ub_match
<(.∗?)>(.∗?)</\1>
    Three groups; the \1 means ‘‘same as group 1’’

That last pattern is useful for parsing XML. It finds tag/end-of-tag markers. Note that I used a non-greedy match (a lazy match), ".∗?", for the subpattern between the tag and the end tag.
  Had I used plain.∗, this input would have caused a problem:
    "Always look for the <b>bright</b> side of <b>life</b>"



It is possible to vary details of the regular expression notation using options (§37.2).
  For example, if regex_constants::grep is used, "a?x:y" is a sequence of five ordinary characters because "?" does not mean ‘‘optional’’ in grep.










37.2 regex
A regular expression is a matching engine (usually a state machine) constructed from a sequence of characters, such as a string:
template<class C, class traits = regex_traits<C>>
class basic_regex {
  public:
    using value_type = C;
    using traits_type = traits;
    using string_type = typename traits::string_type;
    using flag_type = regex_constants::syntax_option_type;
    using locale_type = typename traits::locale_type;

    ˜basic_regex(); //not virtual; basic_regex is not meant to be used as a base class
  //...
};
The regex_traits are presented in §37.5.
Like string, regex is an alias for the version that uses chars:
using regex = basic_regex<char>;


//////(ECMAScript|basic|extended|awk|grep|egrep)+icase+nosubs+collate+optimize
///default=regex_constants::ECMAScript
///
The meaning of regular expression patterns is controlled by syntax_option_type constants defined identically in regex_constants and regex:
basic_regex<C,Tr>Member Constants (syntax_option_type, §iso.28.5.1)
@@@icase
    :::No case is used when matching
@@@nosubs
    :::No subexpression matches are stored in the match results
@@@optimize
    :::Prefer fast matching to fast regular expression object construction
@@@collate
    :::Character ranges of the form "[a−b]" are locale sensitive
@@@ECMAScript
    :::The regular expression grammar is the one used by ECMAScript in ECMA-262 (with minor modifications; §iso.28.13)
@@@basic
    :::The regular expression grammar is the one used by basic regular expressions in POSIX
@@@extended
    :::The regular expression grammar is the one used by extended regular expressions in POSIX
@@@awk
    :::The regular expression grammar is the one used by POSIX awk
@@@grep
    :::The regular expression grammar is the one used by POSIX grep
@@@egrep
    :::The regular expression grammar is the one used by POSIX grep-E

Use the default unless you have a good reason not to. Good reasons include a large body of existing regular expressions in a non-default notation.


A regex object can be constructed from a string or similar sequence of characters:
basic_regex<C,Tr>Constructors (§iso.28.8.2)
@@@basic_regex r {};
    :::Default constructor: an empty pattern; flags set to regex_constants::ECMAScript
@@@basic_regex r {x, flags};
    :::x can be a basic_regex, a string, a C-style string, or an initializer_list<value_type> with the notation defined by flags; explicit
@@@basic_regex r {x};
    :::
@@@basic_regex r {p,n, flags};
    :::
@@@basic_regex r {p,n};
    :::
@@@basic_regex r {b,e , flags};
    :::
@@@basic_regex r {b,e};
    :::

The main use of regex is through the search, match, and replace functions (§37.3), but there are also a few operations on regex itself:
basic_regex<C,Tr>Operations (§iso.28.8)
@@@r=x
    :::Copy assignment: x can be a basic_regex, a C-style string, a basic_string, or an initializer_list<value_type>
@@@r=move(r2)
    :::Move assignment
@@@r=r.assign(r2)
    :::Copy or move
@@@r=r.assign(x, flags)
    :::Copy or move; set r’s flags to flags x can be a basic_string, a C-style string, or an initializer_list<value_type>
@@@r=r.assign(x)
    :::r=r.assign(x,regex_constants::ECMAScript)
@@@r=r.assign(p,n, flags)
    :::Set r’s pattern to [p:p+n) and r’s flags to flags
@@@r=r.assign(b,e , flags)
    :::Set r’s pattern to [b:e) and r’s flags to flags
@@@r=r.assign(b,e)
    :::r=r.assign(b,e ,regex_constants::ECMAScript)
@@@n=r.mark_count()
    :::n is the number of marked subexpressions in r
@@@x=r.flags()
    :::x is r’s flags
@@@loc2=r.imbue(loc)
    :::r gets the locale loc;loc2 is r’s previous locale
@@@loc=r.getloc()
    :::loc is r’slocale
@@@r.swap(r2)
    :::Exchange values of r and r2







===
pg1051[1066/1366]
<regex>

37.1 Regular Expressions
In<regex>, the standard library provides regular expressions:
•regex_match():
    Match a regular expression against a string (of known size).
•regex_search():
    Search for a string that matches a regular expression in an (arbitrarily long) stream of data.
•regex_replace():
    Search for strings that match a regular expression in an (arbitrarily long) stream of data and replace them.
•regex_iterator:
    iterate over matches and submatches.
•regex_token_iterator:
    iterate over non-matches.



The result of a regex_search()is a collection of matches, typically represented as an smatch:
void use()
{
    ifstream in("file.txt"); //input file
    if (!in) cerr << "no file\n";

    regex pat {R"(\w{2}\s∗\d{5}(−\d{4})?)"}; //U.S. postal code pattern

    int lineno = 0;
    for (string line; getline(in,line);) {
        ++lineno;
        smatch matches; //matched strings go here
        if (regex_search(line , matches, pat)) {
            cout << lineno << ": " << matches[0] << '\n';//the complete match
            if (1<matches.size() && matches[1].matched)
                cout << "\t: " << matches[1] << '\n';//submatch
        }
    }
}
This function reads a file looking for U.S. postal codes, such as "TX77845" and "DC 20500−0001".
  An smatch type is a container of regex results.
    Here, matches[0] is the whole pattern and matches[1] is the optional four-digit subpattern.

I used a raw string (§7.3.2.1) which is particularly suitable for regular expressions because they tend to contain a lot of backslashes. Had I used a conventional string, the pattern definition would have been:
  regex pat {"\\w{2}\\s∗\\d{5}(−\\d{4})?"}; //U.S. postal code pattern




===
pg1048[1063/1366]
string.substr

basic_string<C,Tr,A>Substrings (§iso.21.4.7.8)
s2=s.substr(pos,n) s2=basic_string(&s[pos],m) where m=min(s.size()−n,n)
s2=s.substr(pos) s2=s.substr(pos,string::npos)
s2=s.substr() s2=s.substr(0,string::npos)


===
pg1043[1058/1366]
36.3.5 Numeric Conversions
<string>
  only for string or wstring(note: not basic_string<C,Tr,A>)

Numeric Conversions (§iso.21.5) (continues)
  # s can be a string or a wstring
@@@x=stoi(s,p,b)
    :::String to int;x is an integer; read starting with s[0] if p!=nullptr,∗p is set to the number of characters used for x; b is the base of the number (between 2 and 36, inclusive)
@@@x=stoi(s,p)
    ::: x=stoi(s,p,10); decimal numbers
@@@x=stoi(s)
    :::x=stoi(s,nullptr,10); decimal numbers; don’t report the character count
@@@x=stol(s,p,b)
    :::String to long
@@@x=stoul(s,p,b)
    :::String to unsigned long
@@@x=stoll(s,p,b)
    :::String to long long
@@@x=stoull(s,p,b)
    :::String to unsigned long long
@@@x=stof(s,p)
    :::String to float
@@@x=stod(s,p)
    :::String to double
@@@x=stold(s,p)
    :::String to long double
@@@s=to_string(x)
    ::: s is a string representation of x;x must be an integer or floating-point value
@@@ws=to_wstring(x)
    ::: s is a wstring representation of x;x must be an integer or floating-point value

The sto∗ functions encode their target type in their names. This makes them unsuitable for generic code where the target can be a template parameter. In such cases, consider to<X>(§25.2.5.1).
  // user-defined?





===
pg1034[1049/1366]
36.2.1 Classification Functions
<cctype>
<cwctype>
  equivalent functions for wide characters are provided in <cwctype>.
<locale>
  The character classification functions are sensitive to the"C"locale (§39.5.1, §39.5.2). Equivalent functions for other locales are provided in<locale>(§39.5.1).


Character Classification
isspace(c) Is c whitespace (space' ', horizontal tab'\t', newline'\n', vertical tab'\v', form feed'\f', carriage return'\r')?
@@@isalpha(c)
    :::Is c a letter ('a'..'z','A'..'Z')? note: not underscore'_'
@@@isdigit(c)
    :::Is c a decimal digit ('0'..'9')?
@@@isxdigit(c)
    :::Is c hexadecimal digit (decimal digit or 'a'..'f' or 'A'..'F')?
@@@isupper(c)
    :::Is c an uppercase letter?
@@@islower(c)
    :::Is c a lowercase letter?
@@@isalnum(c)
    ::: isalpha(c) or isdigit(c)
@@@iscntrl(c)
    :::Is c a control character (ASCII 0..31 and 127)?
@@@ispunct(c)
    :::Is c not a letter, digit, whitespace, or invisible control character?
@@@isprint(c)
    :::Is c printable (ASCII' '..'˜')?
@@@isgraph(c)
    ::: isalpha(c) or isdigit(c) or ispunct(c)? note: not space


In addition, the standard library provides two useful functions for removing case differences:
Upper- and Lowercase
@@@toupper(c)
    :::c or c’s uppercase equivalent
@@@tolower(c)
    :::c or c’s lowercase equivalent




One reason that these character classification functions are useful is that character classification can be trickier than it might appear. For example, a novice might write:
    if ('a'<ch && ch<'z') //a character
This is more verbose (and most likely slower) than:
    if (islower(ch)) //a low ercase character
Also, there is no guarantee that the characters are contiguous in a code space. Furthermore, the use of standard character classifications are far easier to convert to another locale:
    if (islower,danish) //a low ercase character in Danish
        //(assuming ‘‘danish’’ is the name for a Danish locale)
Note that Danish has three more lowercase characters than English, so that the initial explicit test using'a'and'z'would be flat wrong.



===
pg1033[1048/1366]

<cctype>(§36.2)
  character classification operations
<string>(§36.3)
  strings with associated operations
<regex>(Chapter 37)
  regular expression matching
<cstring>(§43.4)
  support for C-style strings
<locale> <clocale> <codecvt>
  Handling of different character sets, encodings, and conventions (locales) is discussed in Chapter 39.



===
pg1030[1045/1366]
<typeindex>
  #<typeinfo>
35.5.4 Comparing and Hashing type_info
type_index is created from a type_info(§22.5), specifically to allow such comparison and hashing.
type_index Operations (§iso.20.13)
  ##tip is a pointer to the type_info represented by a type_index
@@@type_index ti {tinf};
    :::ti represents the type_info tinf; noexcept
@@@ti==ti2
    :::ti and ti2 represent the same type_info:∗ti.tip==∗ti2.tip); noexcept
@@@ti!=ti2
    :::!(ti==ti2); noexcept
@@@ti<ti2
    :::ti.tip−>before(ti2.tip); noexcept
@@@ti<=ti2
    :::!ti2.tip−>before(ti.tip); noexcept
@@@ti>ti2
    :::ti2.tip−>before(ti.tip); noexcept
@@@ti>=ti2
    :::!ti.tip−>before(ti2.tip); noexcept
@@@n=ti.hash_code()
    :::n=ti.tip−>hash_code()
@@@p=ti.name()
    :::p = ti.tip−>name()
@@@hash<type_index>
    :::A specialization of hash(§31.4.3.4)



unordered_map<type_index,type_info∗> types;
//...
types[type_index{something}] = &typeid(something);




===
pg1029[1044/1366]2
<utility>
using namespace std::rel_ops;

35.5.3 Relational Operators
Relational Operators instd::rel_ops(§iso.20.2.1)
@@@x!=y
    :::!(x==y)
@@@x>y
    :::y<x
@@@x<=y
    :::!(y<x)
@@@x>=y
    :::!(x<y)
This requires that the programmer has made sure that x==y and x<y work.




===
pg1029[1044/1366]
<utility>
35.5.2 swap()
Other Transformations (§iso.20.2.2)
swap(x,y) Exchange the values of x and y; x and y are passed as non-const references; noexcept if x’s and y’s copy operations are noexcept
swap(a1n,a2n) a1n and a2n are passed as references to arrays:T(&)[N]; noexcept if ∗a1n and ∗a2n’s copy operations are noexcept


The relatively obvious implementation swap() is:
template<typename T>
void swap(T& a, T& b) noexcept(Is_nothrow_move_constructible<T>() && Is_nothrow_move_assignable<T>())
{
  T tmp {move(a)};
  a = move(b);
  b = move(tmp);
}


This implies that swap() cannot be used to exchange rvalues:
  vector<int> v1 {1,2,3,4};
  swap(v,vecor<int>{}); //error : second argument is an rvalue
  v.clear(); //clearer (less obscure)


===
pg1028[1043/1366]
<utility>
35.5.1 move() and forward()
Other Transformations (§iso.20.9.7.6)
x2=forward(x) x2 is an rvalue; x may not be an lvalue; noexcept
x2=move(x) x2 is an rvalue; noexcept
x2=move_if_noexcept(x) If x can be moved, x2=move(x); otherwise x2=x; noexcept




A move()is simply a cast to an rvalue:
template<typename T>
Remove_reference<T>&& move(T&& t) noexcept
{
  return static_cast<Remove_reference<T>&&>(t);
}
In my opinion,move()should have been calledrvalue()
    , because it doesn’t actually move anything
    . Instead, it produces an rvalue for its argument, so that the object referred to can be moved from.
A move() is used to tell the compiler that an object will not be used anymore in a context, so that its value can be moved and an empty object left behind. The simplest example is the implementation of swap()(§35.5.2).



A forward() produces an rvalue from an rvalue only:
template<typename T>
T&& forward(Remove_reference<T>& t) noexcept
{
  return static_cast<T&&>(t);
}
template<typename T>
T&& forward(Remove_reference<T>&& t) noexcept;
{
  static_assert(!Is_lvalue_reference<T>,"forward of lvalue");
  return static_cast<T&&>(t);
}
This pair of forward() functions are meant always to be available together, and selection between them should be done by overload resolution. In that case, any lvalue goes to the first version and every rvalue to the second. For example:
  int i = 7;
  forward(i); //call first version
  forward(7); //call second version
The assert is there for programmer who are too clever for their own good and calls the second version with an explicit template argument and an lvalue.

The archetypical use of forward()is for ‘‘perfect forwarding’’ of an argument from one function to another (§23.5.2.1, §28.6.3). The standard-library make_shared<T>(x)(§34.3.2) is a good example.





Use move() when the intent is to ‘‘steal the representation’’ of an object with a move operation
    , and use forward() for forwarding.
  Thus, forward(x) is safe
    , whereas move(x) marks x for destruction so that move(x) should be used with care.
    The only safe use of an x after a move(x) is destruction or as a target for an assignment.
  Obviously a particular type could provide further guarantees, and ideally the class’s invariant is left intact. However, don’t rely on that unless you really know.



===
pg1018[1033/1366]
35.4 Type Functions
<type_traits>
  type functions (§28.2) to determine properties of types (type traits; §35.4.1) and to generate new types from existing ones (type generators; §35.4.2).

# ::value
The primary type predicates test fundamental properties of a type:
Primary Type Predicates (§iso.20.9.4.1)
@@@is_void<X>
    :::Is X void?
@@@is_integral<X>
    :::Is X an integral type?
@@@is_floating_point<X>
    :::Is X a floating-point type?
@@@is_array<X>
    :::Is X a built-in array?
@@@is_pointer<X>
    :::Is X a pointer (not including pointers to members)?
@@@is_lvalue_reference<X>
    :::Is X an lvalue reference?
@@@is_rvalue_reference<X>
    :::Is X an rvalue reference?
@@@is_member_object_pointer<X>
    :::Is X a pointer to a non-static data member?
@@@is_member_function_pointer<X>
    :::Is X a pointer to a non-static member function?
@@@is_enum<X>
    :::Is X an enum(either plain of class enum)?
@@@is_union<X>
    :::Is X a union?
@@@is_class<X>
    :::Is X a class(including structs, but not enums)?
@@@is_function<X>
    :::Is X a function?






These composite type predicates simply offer notational convenience.
Composite Type Predicates (§iso.20.9.4.2)
@@@is_reference<X>
    :::Is x a reference (lvalue or rvalue reference)?
@@@is_arithmetic<X>
    :::Is x an arithmetic type (integral or floating-point; §6.2.1)?
@@@is_fundamental<X>
    :::Is x a fundamental type (§6.2.1)?
@@@is_object<X>
    :::Is x an object type (not a function)?
@@@is_scalar<X>
    :::Is x a scalar type (not a class or a function)?
@@@is_compound<X>
    :::Is x a compound type (!is_fundamental<X>)?
@@@is_member_pointer<X>
    :::Is x a pointer to a non-static data or function member?






type property predicates provide tests for fundamental aspects of a type:
Type property predicates (§iso.20.9.4.3)
@@@is_const<X>
    :::Is X a const?
@@@is_volatile<X>
    :::Is X a volatile(§41.4)?
@@@is_trivial<X>
    :::Is X a trivial type (§8.2.6)?
@@@is_trivially_copyable<X>
    :::Can X be copied, moved, and destroyed as a simple collection of bits (§8.2.6)?
@@@is_standard_layout<X>
    :::Is X a standard-layout type (§8.2.6)?
@@@is_pod<X>
    :::Is X a POD (§8.2.6)?
@@@is_literal_type<X>
    :::Does X have a constexpr constructor (§10.4.3)?
@@@is_empty<X>
    :::Does X have a member that requires space in an object?
@@@is_polymorphic<X>
    :::Does X have a virtual function?
@@@is_abstract<X>
    :::Does X have a pure virtual function?
@@@is_signed<X>
    :::Is X an arithmetic type and signed?
@@@is_unsigned<X>
    :::Is X an arithmetic type and unsigned?
@@@is_constructible<X,args>
    :::Can an X be constructed from args?
@@@is_default_constructible<X>
    :::Can an X be constructed from {}?
@@@is_copy_constructible<X>
    :::Can an X be constructed from an X&?
@@@is_move_constructible<X>
    :::Can an X be constructed from an X&&?
@@@is_assignable<X,Y>
    :::Can a Y be assigned to an X?
@@@is_copy_assignable<X>
    :::Can an X& be assigned to an X?
@@@is_move_assignable<X>
    :::Can an X&& be assigned to an X?
@@@is_destructible<X>
    :::Can an X be destroyed (i.e.,˜X() has not been deleted)?

@@@is_trivially_constructible<X,args>
    :::Can X be constructed from args using only trivial operations?
#below  §8.2.6
@@@is_trivially_default_constructible<X>
@@@is_trivially_copy_constructible<X>
@@@is_trivially_move_constructible<X>
@@@is_trivially_assignable<X,Y>
@@@is_trivially_copy_assignable<X>
@@@is_trivially_move_assignable<X>
@@@is_trivially_destructible<X>

@@@is_nothrow_constructible<X,args>
    :::Can X be constructed from args using only noexcept operations?
@@@is_nothrow_default_constructible<X>
@@@is_nothrow_copy_constructible<X>
@@@is_nothrow_move_constructible<X>
@@@is_nothrow_assignable<X,Y>
@@@is_nothrow_copy_assignable<X>
@@@is_nothrow_move_assignable<X>
@@@is_nothrow_destructible<X>
@@@has_virtual_destructor<X>
    :::Does X have a virtual destructor?








Like sizeof(T), a property query returns a numeric value related to a type argument:
# :: value
Type Property Queries (§iso.20.9.5)
@@@n=alignment_of<X>
    :::n=alignof(X)
@@@n=rank<X>
    :::If X is an array,n is the number of dimensions; otherwise n==0
@@@n=extent<X,N>
    :::If X is an array,n is the number of elements in the Nth dimension; otherwise n==0
@@@n=extent<X>
    :::n=extent<X,0>





The type relations are predicated on two types:
Type Relations (§iso.20.9.6)
@@@is_same<X,Y>
    :::Is X the same type as Y?
@@@is_base_of<X,Y>
    :::Is X a base of Y?
@@@is_convertible<X,Y>
    :::Can an X be implicitly converted to a Y?



35.4.2 Type Generators
# ::type
const and volatile Modification (§iso.20.9.7.1)
@@@remove_const<X>
    :::Like X, but with any top-level const removed
@@@remove_volatile<X>
    :::Like X, but with any top-level volatile removed
@@@remove_cv<X>
    :::Like X, but with any top-level const or volatile removed
@@@add_const<X>
    :::If X is a reference, function, or const, then X; otherwise const X
@@@add_volatile<X>
    :::If X is a reference, function, or volatile, then X; otherwise volatile X
@@@add_cv<X>
    :::Add const and volatile:add_const<typename add_volatile<T>::type>::type



Reference Modification (§iso.20.9.7.2, §iso.20.9.7.6)
@@@remove_reference<X>
    :::If X is a reference type, the referred-to type; otherwise,X
@@@add_lvalue_reference<X>
    :::If X is an rvalue reference Y&&, Y&; otherwise, X&
@@@add_rvalue_reference<X>
    :::If X is a reference, X; otherwise, X&&(§7.7.3)
@@@decay<X>
    :::The type passed by value for a function argument of type X. The decay functions handles array decay as well as reference dereferencing.




Sign Modification (§iso.20.9.7.3)
@@@make_signed<X>
    :::Remove any (explicit or implied) unsigned modifier and add signed; Xmust be an integral type (except bool or an enumeration)
@@@make_unsigned<X>
    :::Remove any (explicit or implied) signed modifier and add unsigned; Xmust be an integral type (except bool or an enumeration)




Array Modification (§iso.20.9.7.4)
@@@remove_extent<X>
    :::If X is an array type, the element type; otherwise X
@@@remove_all_extents<X>
    :::If X is an array type, the base type (after removing all array modifiers); otherwise X




Pointer Modification (§iso.20.9.7.5)
@@@remove_pointer<X>
    :::If X is a pointer type, the pointed-to type; otherwise X
@@@add_pointer<X>
    :::remove_reference<X>::type∗






Alignments (§iso.20.9.7.6)
@@@aligned_storage<n,a>
    :::A POD type with size of at least n and whose alignment is a divisor of a
@@@aligned_storage<n>
    :::aligned_storage<n,def> where def is the largest alignment required for any object type,T, with sizeof(T)<=n
@@@aligned_union<n,X...>
    :::A POD type with size of at least n that can hold a union with members of type X

The standard mentions this as a possible implementation of aligned_storage:
template<std::size_t N, std::size_t A>
struct aligned_storage {
  using type = struct { alignas(A) unsigned char data[N]; };//N chars aligned to A (§6.2.9)
};




Other Transformations (§iso.20.9.7.6)
@@@enable_if<b,X>
    :::X if b==true; otherwise there is no member::type, leading to substitution failure (§23.5.3.2) for most uses
@@@enable_if<b>
    :::enable_if<b,void>
@@@conditional<b,T,F>
    :::T if b==true; otherwise F
@@@common_type<X...>
    :::The common type of all types of a parameter pack X; two types are common if they can be used as true and false types of a (?:)-expression
@@@underlying_type<X>
    :::X’s underlying type (§8.4); X must be an enumeration
@@@result_of<FX>
    :::The type of the result of F(X); FX must be a type F(X) where F is invoked with an argument list X



template<typename ...T>
struct common_type;

template<typename T>
struct common_type<T> {
  using type = T;
};

template<typename T, typename U>
struct common_type<T, U> {
  using type = decltype(true ? declval<T>() : declval<U>());
};

template<typename T, typename U, typename ... V>
struct common_type<T, U, V...> {
  using type = typename common_type<typename common_type<T, U>::type , V...>::type;
};




Result_ofis used to extract the type of the result of a callable type:
int ff(int) { return 2; }//function
typedef bool (∗PF)(int); //pointer to function
struct Fct {//function object
double operator()(string);
string operator()(int,int);
};
auto fx = [](char ch) { return tolower(ch); };//lambda
Result_of<decltype(&ff)()> r1 = 7;//r1 is a int
Result_of<PF(int)> r2 = true;//r2 is a bool
Result_of<Fct(string)> r3 = 9.9;//r3 is a double
Result_of<Fct(int,int)> r4 = "Hero"; //r4 is a string
Result_of<decltype(fx)(char)> r5 = 'a';//r5 is a char

Note that Result_of can distinguish between the two versions of Fct::operator()().
Curiously enough, the same does not apply to nonmember functions. For example:
int f();//function
string f(int);
Result_of<decltype(&f)()> r1 = 7;//error : no overload resolution for pointer to function
Unfortunately, we don’t do overload resolution for pointers to functions, but why did I use Result_of in such a roundabout way, instead of:
Result_of<ff> r1 = 7;
    //error : no argument specification,
    //and ff is a function rather than a type
Result_of<ff()> r1 = 7;
    //error : the argument to Result_of must be a type
Result_of<decltype(f)()> r2 = 7;/
    /error : decltype(f) is a function type
    //rather than a pointer to function type
Result_of<decltype(f)∗()> r3 = 7;//OK: r3 is an int
Naturally, Result_of is usually found in templates where we can’t easily look up the answer in the program text. For example:
template<typename F, typename A>
auto temp(F f, A a) −> Result_of<F(A)>
{
  //...
}
void f4()
{
  temp(ff,1);
  temp(fx,'a');
  temp(Fct(),"Ulysses");
}
Note that the function ff is converted to a pointer function in the call, so the reliance on pointers to functions in Result_of isn’t as odd as it may seem at first.



declval()(§iso.20.2.4)
@@@declval<T>()
    :::Returns an rvalue for T: typename add_rvalue_reference<T>::type; never use a return value of declval

The declval() type function is unusual in the standard library because it is actually a function (without users needing to wrap it). It returns a value that must never be used. The intent is to use declval<X> as a type where the type of a variable of type X is needed.
template<typename T, size_t N>
void array<T,N> swap(array& y) noexcept(noexcept(swap(declval<T&>(), declval<T&>())))
{
  for (int i=0; i<a.size(); ++i)
  swap((∗this)[i],a[i]);
}




===
pg1017[1032/1366]
35.3 Compile-Time Rational Arithmetic
<ratio>
  compile-time rational arithmetic

template<intmax_t N, intmax_t D = 1>
struct ratio {
  static constexpr intmax_t num;
  static constexpr intmax_t den;
  using type = ratio<num,den>;
};
The basic idea is to encode the numerator and denominator of a rational number as (value) template arguments. The denominator must always be nonzero.



ratio Arithmetic Operations (§iso.20.10.4)
    z=ratio_add<x,y> #? :: type
    z=ratio_subtract<x,y>
    z=ratio_multiply<x,y>
    z=ratio_divide<x,y>
    ratio_equal<x,y> :: value
    ratio_not_equal<x,y>
    ratio_less<x,y>
    ratio_less_equal<x,y>
    ratio_not_equal<x,y>
    ratio_greater<x,y>
    ratio_greater_equal<x,y>



using yocto = ratio<1,1000000000000000000000000>; //conditionally supported
using zepto = ratio<1,1000000000000000000000>; //conditionally supported
using atto= ratio<1,1000000000000000000>;
using femto = ratio<1,1000000000000000>;
using pico= ratio<1,1000000000000>;
using nano= ratio<1,1000000000>;
using micro= ratio<1,1000000>;
using milli= ratio<1,1000>;
using centi= ratio<1,100>;
using deci= ratio<1,10>;
using deca= ratio<10,1>;
using hecto= ratio<100,1>;
using kilo= ratio<1000,1>;
using mega= ratio<1000000,1>;
using giga= ratio<1000000000,1>;
using tera= ratio<1000000000000,1>;
using peta= ratio<1000000000000000,1>;
using exa = ratio<1000000000000000000,1>;
using zetta = ratio<1000000000000000000000,1>; //conditionally supported
using yotta = ratio<1000000000000000000000000,1>; //conditionally supported


===
pg1009[1024/1366]
<chrono>
using namespace std::chrono;
duration
time_point

three clocks:
  system_clock
  steady_clock
  high_resolution_clock

steady_clock::time_point t = steady_clock::now();
//... do something ...
steady_clock::duration d = steady_clock::now()−t; //something took d time units

A clock returns a time_point, and a durationis the difference between two time_points from the same clock.

auto t = steady_clock::now();
//... do something ...
auto d = steady_clock::now()−t; //something took d time units
cout << "something took " << duration_cast<milliseconds>(d).count() << "ms";//print as milliseconds


template<typename Rep, typename Period = ratio<1>>
class duration {
  public:
    using rep = Rep;
    using period = Period;
  //...
};

period is a unit system
pg1013[1028/1366]
The standard library provides some convenience aliases using the SI units from<ratio>(§35.3):
  using nanoseconds = duration<si64,nano>;
  using microseconds = duration<si55,micro>;
  using milliseconds = duration<si45,milli>;
  using seconds = duration<si35>;
  using minutes = duration<si29,ratio<60>>;
  using hours = duration<si23,ratio<3600>>;
Here,siN means ‘‘an implementation-defined signed integer type of at least N bits.’’



The duration_cast is used to get a duration with a known unit of measurement. For example:
  auto t1 = system_clock::now();
  f(x); //do something
  auto t2 = system_clock::now();
  auto dms = duration_cast<milliseconds>(t2−t1);
  cout << "f(x) took " << dms.count() << " milliseconds\n";
  auto ds = duration_cast<seconds>(t2−t1);
  cout << "f(x) took " << ds.count() << " seconds\n";
The reason we need a cast in this example is that we are throwing away information: on the system I used, the system_clock counts in nanoseconds.
The precision of a clock is implementation-dependent.





template<typename Clock, typename Duration = typename Clock::duration>
class time_point {
  public:
    using clock = Clock;
    using duration = Duration;
    using rep = typename duration::rep;
    using period = typename duration::period;
  //...
};

An epoch is a range of time determined by aclock, measured in terms of a duration, starting at the duration::zero():
  time_point tp {};
      Default constructor: start of epoch:duration::zero()
  time_point tp {d};
      Constructor: time point d of epoch:time_point{}+d; explicit
  d=tp.time_since_epoch()
      d is tp’s stored duration





pg1015[1030/1366]

class system_clock {
  public:
    using rep = /*implementation-defined signed type*/;
    using period = /*implementation-defined ratio<>*/;
    using duration = chrono::duration<rep,period>;
    using time_point = chrono::time_point<system_clock>;
  //...
};
All data and function members are static. We don’t explicitly deal with clock objects. Instead, we use clock types:
  Clock Members (§iso.20.11.7)
    is_steady
        Is this clock type steady?
    That is, is c.now()<=c.now() for all consecutive calls of now() and is the time between clock ticks constant? static

Clock Types (§iso.20.11.7)
    system_clock
        The system’s real-time clock
        ; the system’s clock may be reset (jump forward or backward) to match external clocks
    steady_clock
        A clock where time moves steadily forward
        ; that is, time does not go backward and the time between clock ticks is constant
    high_resolution_clock
        A clock with the shortest time increment on a system
These three clocks need not be different; a standard-library clock name may be an alias.




===
pg1006[1021/1366]
<memory> #raw_storage_iterator
raw_storage_iterator :: Output_iterator{assigment} -> Output_iterator{copy_constructor/emplacement_new}
template<typename Output_iterator, typename T> class raw_storage_iterator;
  #??T=typename iterator_traits<Output_iterator>::value_type >


===
pg1005[1020/1366] #Temporary Buffers
template<typename T>
pair<T∗,ptrdiff_t> get_temporary_buffer(ptrdiff_t); //allocate, don’t initialize
template<typename T>
void return_temporary_buffer(T∗); //deallocate, don’t destroy


A get_temporary_buffer<X>(n) operation tries to allocate space for n or more objects of type X.
    If it succeeds in allocating some memory, it returns a pointer to the first uninitialized space and the number of objects of type X that will fit into that space
    ; otherwise, the second value of the pair is zero.

A buffer obtained by get_temporary_buffer() must be freed for other use by a call of return_temporary_buffer().
    Just as get_temporary_buffer() allocates without constructing, return_temporary_buffer() frees without destroying.

Because get_temporary_buffer()is low-level and likely to be optimized for managing temporary buffers, it should not be used as an alternative to new or allocator::allocate() for obtaining longer-term storage.




===
pg995[1010/1366] #allocator
basic allocator functions are:
  p=a.allocate(n); //acquire space for n objects of type T
  a.deallocate(p,n); //release space for n objects of type T pointed to by p
  ##uninitialized!!!

DefaultConstructor() {}
using value_type = T;
T∗ allocate(size_t n);
void deallocate(T∗ p, size_t n);

===
pg994[1009/1366]
ptr =
  {logical_subobject
  ,control_block
  }
control_block =
  {owner_object
  ,use_count
  ,deleter
  ,weak_use_count
  }

weak_ptr<T>(§iso.20.7.2.3)
@@@n=wp.use_count()
    ::: n is the number of shared_ptrs to ∗cp; noexcept
@@@wp.expired()
    ::: Are there any shared_ptrs to ∗cp? noexcept
@@@sp=wp.lock()
    ::: Make a new shared_ptr for ∗cp; noexcept



===
pg992[1007/1366]

shared_ptr<T>Helpers (§iso.20.7.2.2.6, §iso.20.7.2.2.7) (continues)
@@@sp=make_shared(args)
    ::: sp is a shared_ptr<T>for an object of type T constructed from the arguments args; allocated using new
@@@sp=allocate_shared(a,args)
    ::: sp is a shared_ptr<T>for an object of type T constructed from the arguments args; allocated using allocator a
@@@sp2=static_pointer_cast(sp)
    ::: static_cast for shared pointers: sp2=shared_ptr<T>(static_cast<T∗>(sp.cp)); noexcept
@@@sp2=dynamic_pointer_cast(sp)
    ::: dynamic_cast for shared pointers: sp2=shared_ptr<T>(dynamic_cast<T∗>(sp.cp)); noexcept
@@@sp2=const_pointer_cast(sp)
    ::: const_cast for shared pointers: sp2=shared_ptr<T>(const_cast<T∗>(sp.cp)); noexcept
@@@dp=get_deleter<D>(sp)
    ::: If sp has a deleter of typeD,∗dp is sp’s deleter; otherwise,dp==nullptr; noexcept
@@@os<<sp
    ::: Write sp to ostream os



===
pg986[1001/1366]
<memory>

‘‘smart pointers’’ to express ownership:
•unique_ptr(§34.3.1) to represent exclusive ownership
•shared_ptr(§34.3.2) to represent shared ownership
•weak_ptr(§34.3.3) to break loops in circular shared data structures

#T[]
  unique_ptr<Shape> ps {new Circle{p,20}}; //OK
  unique_ptr<Shape[]> pa {new Circle[] {Circle{p,20}, Circle{p2,40}}; //error



===
pg985[1000/1366]
array
pair
tuple
make_pair
make_tuple

#t::T
#T = array|pair|tuple
tuple_size<T>::value
tuple_element<N,T>::type
get<N>(t)

tuple<Types...>Helpers (§iso.20.4.2.4, §iso.20.4.2.9) (continues)
@@@t=make_tuple(args)
    ::: Make tuple from args
@@@t=forward_as_tuple(args)
    ::: t is a tuple of rvalue references to the elements in args  so you can forward the elements of args throught
@@@t=tie(args)
    ::: t is a tuple of lvalue references to the elements of args so you can assign to the elements of args throught
@@@t=tuple_cat(args)Concatenate
    ::: tuples: args is one or more tuples; t has the members of the tuples in args in order

拆包
    For example,tie() can be used to extract elements from a tuple:
        auto t = make_tuple(2.71828,299792458,"Hannibal");
        double c;
        string name;
        tie(c,ignore,name) = t;//c=299792458; name="Hannibal"
    The name ignore refers to an object of a type that ignores assignments. Thus, an ignore in a tie()
    implies that attempts to assign to its tuple position are ignored. An alternative would be:
        double c = get<0>(t); //c=299792458
        string name = get<2>(t); //name="Hannibal"


===
pg974[989/1366]
<tuple>
<utility>#pair
<bitset>#big_endian vs vector<bool>little_endian
<array>

‘‘ Almost Containers’’
@@@T[N]
    ::: Built-in array: a fixed-size continuously allocated sequence of N elements of type T; implicitly converts to a T∗
@@@array<T,N>
    ::: A fixed-size continuously allocated sequence of N elements of type T; like the built-in array, but with most problems solved
@@@bitset<N>
    ::: A fixed-size sequence of N bits
@@@vector<bool>A
    ::: sequence of bits compactly stored in a specialization of vector
@@@pair<T,U>
    ::: Two elements of types T and U
@@@tuple<T...>
    ::: A sequence of an arbitrary number of elements of arbitrary types
@@@basic_string<C>
    ::: A sequence of characters of type C; provides string operations
@@@valarray<T>
    ::: An array of numeric values of type T; provides numeric operations

example:
•pair and tuple are heterogeneous
  ; all other containers are homogeneous (all elements are of the same type).
•array,vector, and tuple elements are contiguously allocated
  ; forward_list and map are linked structures.
•bitset and vector<bool> hold bits and access them through proxy objects
  ; all other standard-library containers can hold a variety of types and access elements directly.
•basic_string requires its elements to be some form of character and to provide string manipulation, such as concatenation and locale-sensitive operations (Chapter 39)
  and valarray requires its elements to be numbers and to provide numerical operations.
All of these containers can be seen as providing specialized services needed by large communities of programmers.
  No single container could serve all of these needs because some needs are contradictory, for example
      , ‘‘ability to grow’’ vs. ‘‘guaranteed to be allocated in a fixed location,’’
      and ‘‘elements do not move when elements are added’’ vs. ‘‘contiguously allocated.’’
  Furthermore, a very general container would imply overhead deemed unacceptable for individual containers.


===
pg971[986/1366]
reverse_iterator::base()->original_underlying_iter
move_iterator

===
pg966[981/1366]
<functional>
  std::placeholders::_1
  bind(f,_2,_1)("hello",2); //reverse order of arguments: also calls f(2,"hello");
  #curious#感觉不太行，因为placeholders本身也可作为实际参数！必须指明哪些用作实际参数！
  # my_bind(f,actual_arg("hello"),placeholder<1>{})(2);

33.4 Function Objects
Note that logical_and and logical_or always evaluate both their arguments (&& and || do not).

Predicates (§iso.20.8.5, §iso.20.8.6, §iso.20.8.7)
@@@p=equal_to<T>(x,y)
    ::: p(x,y) means x==y when  x and y are of  type T
@@@p=not_equal_to<T>(x,y)
    ::: p(x,y) means x!=y when  x and y are of  type T
@@@p=greater<T>(x,y)
    ::: p(x,y) means x>y when  x and y are of  type T
@@@p=less<T>(x,y)
    ::: p(x,y) means x<y when  x and y are of  type T
@@@p=greater_equal<T>(x,y)
    ::: p(x,y) means x>=y when  x and y are of  type T
@@@p=less_equal<T>(x,y)
    ::: p(x,y) means x<=y when  x and y are of  type T
@@@p=logical_and<T>(x,y)
    ::: p(x,y) means x&&y when  x and y are of  type T
@@@p=logical_or<T>(x,y)
    ::: p(x,y) means x||y when  x and y are of  type T
@@@p=logical_not<T>(x)
    ::: p(x) means !x when x is of  type T
@@@p=bit_and<T>(x,y)
    ::: p(x,y) means x&y when  x and y are of  type T
@@@p=bit_or<T>(x,y)
    ::: p(x,y) means x|y when  x and y are of  type T
@@@p=bit_xor<T>(x,y)
    ::: p(x,y) means xˆy when  x and y are of  type T


Arithmetic Operations (§iso.20.8.4)
@@@f=plus<T>(x,y)
    ::: f(x,y) means x+y when  x and y are of  type T
@@@f=minus<T>(x,y)
    ::: f(x,y) means x−y when  x and y are of  type T
@@@f=multiplies<T>(x,y)
    ::: f(x,y) means x∗y when  x and y are of  type T
@@@f=divides<T>(x,y)
    ::: f(x,y) means x/y when  x and y are of  type T
@@@f=modulus<T>(x,y)
    ::: f(x,y) means x%y when  x and y are of  type T
@@@f=negate<T>(x)
    ::: f(x) means −x when x is of  type T

Adaptors (§iso.20.8.9, §iso.20.8.10, §iso.20.8.8)
@@@g=bind(f,args)
    ::: g(args2) is equivalent to f(args3) where args3 is obtained by replacing placeholders in args with arguments from args2 for the use of placeholders, such as_1,_2, and _3
@@@g=mem_fn(f)
    ::: g(p,args) means p−>f(args) if p is a pointer and p.mf(args) if p is not; args is a (possibly empty) list of arguments
@@@g=not1(f)
    ::: g(x) means !f(x)
@@@g=not2(f)
    ::: g(x,y) means !f(x,y)

The bind() and mem_fn() adaptors do argument binding, also called Currying or partial evaluation.
  bind(f,_2,_1)("hello",2); //reverse order of arguments: also calls f(2,"hello");
  auto pow2 = bind(pow,_1,2); //error : which pow()?
  auto pow2 = bind((double(∗)(double ,double))pow,_1,2); //OK (but ugly)
  for_each(v.begin(),v.end(),mem_fn(&Shape::draw));
}


#相当于lambda函数 的 传参方式 是选用 传值 还是 传引用？
reference_wrapper<T>(§iso.20.8.3)
@@@r=ref(t)
    ::: r is a reference_wrapper for T& t; noexcept
@@@r=cref(t)
    ::: r is a reference_wrapper for a const T& t; noexcept

bind(f,...)(ref(x));


===
pg903[918/1366]
  //无需重新分配内存，自然也无需移动所有元素，指针保持有效性
  The notion of capacity allows for iterators into a vector to be valid unless a reallocation actually happens.
      ---
      The standard does not specify by how much capacity is increased when it is exceeded, but adding half the size is common.
        I used to be careful about using reserve() when I was reading into a vector.
        I was surprised to find that for essentially all of my uses, calling reserve() did not measurably affect performance.
        The default growth strategy worked just as well as my estimates, so I stopped trying to improve performance using reserve().
        Instead, I use it to increase predictability of reallocation delays and to prevent invalidation of pointers and iterators.


===
pg868[883/1366]
  30.4 Error Handling
  The standard library consists of components developed over a period of almost 40 years. Thus, their style and approaches to error handling are not consistent:
      •C-style libraries consist of functions, many of which set errno to indicate that an error happened; see §13.1.2 and §40.3.
      •Many algorithms operating on a sequence of elements return an iterator to the one-past-the-last element to indicate ‘‘not found’’ or ‘‘failure’’; see §33.1.1.
      •The I/O streams library relies on a state in each stream to reflect errors and may (if the user requests it) throw exceptions to indicate errors; see §38.3.
      •Some standard-library components, such as vector,string, and bitset, throw exceptions to indicate errors.

  The standard library is designed so that all facilities obey ‘‘the basic guarantee’’ (§13.2); that is, even if an exception is thrown, no resource (such as memory) is leaked and no invariant for a standard-library class is broken.




===
pg866[881/1366] #include standard-library instead of writr forward-declarations manually
  #不要手写标准库声明！
[7] Do not try to use a standard-library facility without #include-ing its header; §30.2.
[8] To use a range-for on a built-in array,#include<iterator>; §30.3.2.
  ---
  A user or a library implementer is not allowed to add or subtract declarations from the standard headers.
    Nor is it acceptable to try to change the contents of a header by defining macros to change the meaning of declarations in a header (§15.2.3).
    Any program or implementation that plays such games does not conform to the standard, and programs that rely on such tricks are not portable.
    Even if they work today, the next release of any part of an implementation may break them. Avoid such trickery.

  For a standard-library facility to be used, its header must be included.
    Writing out the relevant declarations yourself is not a standards-conforming alternative.
    The reason is that some implementations optimize compilation based on standard header inclusion, and others provide optimized implementations of standard-library facilities triggered by the headers.
    In general, implementers use standard headers in ways programmers cannot predict and shouldn’t have to know about.
    A programmer can, however, specialize utility templates, such as swap()(§35.5.2), for non-standard-library, user-defined types.


  pg863[878/1366]
  A standard header with a name starting with the letter c is equivalent to a header in the C standard library.
    For every header <X.h> defining part of the C standard library in the global namespace and also in namespacestd, there is a header <cX> defining the same names.
    Ideally, the names from a <cX> header do not pollute the global namespace (§15.2.4), but unfortunately (due to complexities of maintaining multilanguage, multi-operating-system environments) most do.
+++++
[[[Standard_Library_Overview]]]:begin
Standard-Library Overview
  * Containers
  * General_Utilities
  * Algorithms
  * Diagnostics
  * Strings_and_Characters
  * Input_Output
  * Localization
  * Language_Support
  * Numerics
  * Concurrency
  * C_Compatibility

+++++
Containers
@@@<vector>
    ::: One-dimensional resizable array§31.4.2
@@@<deque>
    ::: Double-ended queue§31.4.2
@@@<forward_list>
    ::: Singly-linked list§31.4.2
@@@<list>
    ::: Doubly-linked list§31.4.2
@@@<map>
    ::: Associative array §31.4.3
@@@<set>
    ::: Set §31.4.3
@@@<unordered_map>
    ::: Hashed associative array §31.4.3.2
@@@<unordered_set>
    ::: Hashed set§31.4.3.2
@@@<queue>
    ::: Queue §31.5.2
@@@<stack>
    ::: Stack §31.5.1
@@@<array>
    ::: One-dimensional fixed-size array§34.2.1
@@@<bitset>
    ::: Array of bool§34.2.2
-----
The associative containers multimap and multiset can be found in <map> and <set>, respectively.
The priority_queue(§31.5.3) is declared in <queue>.

+++++
General_Utilities
@@@<utility>
    ::: Operators and pairs§35.5, §34.2.4.1
@@@<tuple>
    ::: Tuples §34.2.4.2
@@@<type_traits>
    ::: Type traits§35.4.1
@@@<typeindex>
    ::: Use a type_info as a key or a hash code§35.5.4
@@@<functional>
    ::: Function objects§33.4
@@@<memory>
    ::: Resource management pointers§34.3
@@@<scoped_allocator>
    ::: Scoped allocators§34.4.4
@@@<ratio>
    ::: Compile-time rational arithmetic§35.3
@@@<chrono>
    ::: Time utilities§35.2
@@@<ctime>
    ::: C-style date and time§43.6
@@@<iterator>
    ::: Iterators and iterator support§33.1
-----
Iterators provide the mechanism to make standard algorithms generic (§3.4.2, §33.1.4).


+++++
Algorithms
@@@<algorithm>
    ::: General algorithms§32.2
@@@<cstdlib>
    ::: bsearch(),qsort()§43.7
-----
A typical general algorithm can be applied to any sequence (§3.4.2, §32.2) of any type of element.
The C standard library functions bsearch() and qsort() apply to built-in arrays with elements of types without user-defined copy constructors and destructors only (§12.5).

+++++
Diagnostics
@@@<exception>
    ::: Exception class§30.4.1.1
@@@<stdexcept>
    ::: Standard exceptions §30.4.1.1
@@@<cassert>
    ::: Assert macro§30.4.2
@@@<cerrno>
    ::: C-style error handling§13.1.2
@@@<system_error>
    ::: System error support§30.4.3
-----
Assertions using exceptions are described in §13.4.

+++++
Strings_and_Characters
@@@<string>
    ::: String of T Chapter 36
@@@<cctype>
    ::: Character classification§36.2.1
@@@<cwctype>
    ::: Wide-character classification§36.2.1
@@@<cstring>
    ::: C-style string functions§43.4
@@@<cwchar>
    ::: C-style wide-character string functions§36.2.1
@@@<cstdlib>
    ::: C-style allocation functions§43.5
@@@<cuchar>
    ::: C-style multibyte characters
@@@<regex>
    ::: Regular expression matching Chapter 37
-----
The <cstring> header declares the strlen(),strcpy(), etc., family of functions. The <cstdlib> declares atof() and atoi() which convert C-style strings to numeric values.

+++++
Input_Output
@@@<iosfwd>
    ::: Forward declarations of I/O facilities §38.1
@@@<iostream>
    ::: Standardiostreamobjects and operations§38.1
@@@<ios>
    ::: iostreambases §38.4.4
@@@<streambuf>
    ::: Stream buffers §38.6
@@@<istream>
    ::: Input stream template§38.4.1
@@@<ostream>
    ::: Output stream template§38.4.2
@@@<iomanip>
    ::: Manipulators §38.4.5.2
@@@<sstream>
    ::: Streams to/from strings§38.2.2
@@@<cctype>
    ::: Character classification functions§36.2.1
@@@<fstream>
    ::: Streams to/from files§38.2.1
@@@<cstdio>
    ::: printf()family of I/O§43.3
@@@<cwchar>
    ::: printf()-style I/O of wide characters§43.3
-----
Manipulators are objects used to manipulate the state of a stream (§38.4.5.2).

+++++
Localization
@@@<locale>
    ::: Represent cultural differences Chapter 39
@@@<clocale>
    ::: Represent cultural differences C-style
@@@<codecvt>
    ::: Code conversion facets §39.4.6
-----
A locale localizes differences such as the output format for dates, the symbol used to represent currency, and string collation criteria that vary among different natural languages and cultures.

+++++
Language_Support
@@@<limits>
    ::: Numeric limits§40.2
@@@<climits>
    ::: C-style numeric scalar-limit macros§40.2
@@@<cfloat>
    ::: C-style numeric floating-point limit macros§40.2
@@@<cstdint>
    ::: Standard integer type names§43.7
@@@<new>
    ::: Dynamic memory management§11.2.3
@@@<typeinfo>
    ::: Run-time type identification support§22.5
@@@<exception>
    ::: Exception-handling support§30.4.1.1
@@@<initializer_list>
    ::: initializer_list§30.3.1
@@@<cstddef>
    ::: C library language support§10.3.1
@@@<cstdarg>
    ::: Variable-length function argument lists§12.2.4
@@@<csetjmp>
    ::: C-style stack unwinding
@@@<cstdlib>
    ::: Program termination§15.4.3
@@@<ctime>
    ::: System clock§43.6
@@@<csignal>
    ::: C-style signal handling
-----
The <cstddef> header defines the type of values returned by sizeof(), size_t, the type of the result of pointer subtraction and of array subscripts, ptrdiff_t(§10.3.1), and the infamous NULL macro (§7.2.2).
C-style stack unwinding (using setjmp and longjmp from <csetjmp>) is incompatible with the use of destructors and with exception handling (Chapter 13, §30.4) and is best avoided.
  C-style stack unwinding and signals are not discussed in this book.

+++++
Numerics
@@@<complex>
    ::: Complex numbers and operations§40.4
@@@<valarray>
    ::: Numeric vectors and operations§40.5
@@@<numeric>
    ::: Generalized numeric operations§40.6
@@@<cmath>
    ::: Standard mathematical functions§40.3
@@@<cstdlib>
    ::: C-style random numbers§40.7
@@@<random>
    ::: Random number generators§40.7
-----
For historical reasons, abs()and div() are found in <cstdlib> rather than in <cmath> with the rest of the mathematical functions (§40.3).

+++++
Concurrency
@@@<atomic>
    ::: Atomic types and operations§41.3
@@@<condition_variable>
    ::: Waiting for an action§42.3.4
@@@<future>
    ::: Asynchronous task§42.4.4
@@@<mutex>
    ::: Mutual exclusion classes§42.3.1
@@@<thread>
    ::: Threads §42.2
-----
C provides standard-library facilities of varying relevance to C++ programmers. The C++ standard library provides access to all such facilities:

+++++
C_Compatibility
@@@<cinttypes>
    ::: Aliases for common integer types§43.7
@@@<cstdbool>
    ::: C bool
@@@<ccomplex>
    ::: <complex>
@@@<cfenv>
    ::: Floating-point environment
@@@<cstdalign>
    ::: C alignment
@@@<ctgmath>
    ::: C ‘‘type generic math’’: <complex> and <cmath>
-----
The <cstdbool> header will not define macros bool,true, or false. The <cstdalign> header will not define a macro alignas. The .h equivalents to <cstdbool>,<ccomplex>,<calign>, and <ctgmath> approximate C++ facilities for C. Avoid them if you can.
The <cfenv> header provides types (such as fenv_t andf except_t), floating-point status flags, and control modes describing an implementation’s floating-point environment.

+++++
[[[Standard_Library_Overview]]]:end



+++++

===
pg855[870/1366] #fused operations
  This technique is based on the idea of using compile-time analysis and closure objects to transfer evaluation of a subexpression into an object representing a composite operation.
    It can be applied to a variety of problems with the common attribute that several pieces of information need to be gathered into one function before evaluation can take place.
    I refer to the objects generated to defer evaluation as composition closure objects, or simply compositors.

  If this composition technique is used to delay execution of all operations, it is referred to as expression templates [Vandevoorde,2002] [Veldhuizen,1995].
    Expression templates systematically use function objects to represent expressions as abstract syntax trees (ASTs).


===
pg829[844/1366] #Enable_if+is_XxxConcept<T>()
  We can define an output function for use in debugging like this:
    template<typename M>
    Enable_if<Matrix_type<M>(),ostream&>
    operator<<(ostream& os, const M& m)
    {
      os << '{';
      for (size_t i = 0; i!=rows(m); ++i) {
        os << m[i];
        if (i+1!=rows(m)) os << ',';
      }
      return os << '}';
    }
  Here,Matrix_type is a concept (§24.3).


===
pg814[829/1366]
28.6.3 Forwarding
One of the major uses of variadic templates is forwarding from one function to another.
  Consider how to write a function that takes as arguments something to be called and a possibly empty list of arguments to give to the ‘‘something’’ as arguments:
      template<typename F, typename ... T>
      void call(F&& f, T&&... t)
      {
        f(forward<T>(t)...);
      }
  That is pretty simple and not a hypothetical example.

===
pg800[815/1366]
question ‘‘Can we call f(x) if x is of type X?’’
  ==>> has_f

  struct substitution_failure { }; //represent a failure to declare something
  template<typename T>
  struct substitution_succeeded : std::true_type
  { };
  template<>
  struct substitution_succeeded<substitution_failure> : std::false_type
  { };

  //std::true_type::value == true
  //std::false_type::value == false

  template<typename T>
  struct has_f
  : substitution_succeeded<typename get_f_result<T>::type>
  { };
  template<typename T>
  struct get_f_result {
    private:
      template<typename X>
      static auto check(X const& x) −> decltype(f(x)); //can call f(x)
      static substitution_failure check(...); //cannot call f(x)
    public:
      using type = decltype(check(std::declval<T>()));
  };

  template<typename T>
  class X {
    //...
    Enable_if<Has_f<T>()> use_f(const T&)
    {
      //...
      f(t);
      //...
    }
    //...
  };


===
pg796[811/1366]
// 对于 类模版的成员函数 或 模版函数（非构析）
//      函数的返回类型 编译期计算失败 则 取消 该函数的声明 而非 报错
  template<typename T>
  class Smart_pointer {
    //...
    T& operator∗(); //return reference to whole object
    Enable_if<Is_class<T>(),T>∗ operator−>(); //select a member (for classes only)
    //...
  }


  template<bool B, typename T>
  using Enable_if = typename std::enable_if<B,T>::type;
  template<typename T> bool Is_class()
  {
    return std::is_class<T>::value;
  }

  If Enable_if’s condition evaluates to true, its result is its second argument (here,T).
    If Enable_if’s condition evaluates to false, the whole function declaration of which it is part is completely ignored.
    In this case, if T is a class, we get a definition of operator−>() returning a T∗, and if it is not, we don’t declare anything.


===
pg771[786/1366]
  /////
  avoid virtual base class
    avoid classical multiple-inheritance ‘‘diamond’’ hierarchy
  use empty class as interface class
  /////

  27.4.2 Linearizing Class Hierarchies
  ‘‘Internal Program Representation’’ (IPR) [DosReis,2011] is a general and systematic representation of C++ code as typed abstract syntax trees.


  namespace empty_interface;
    // empty: no non-static data members
    // pure virtual
    ///
  struct empty_interface::Dispatchor; //Visitor
  class empty_interface::I {
    public:
      virtual void accept(Dispatchor&)=0;
      virtual ~I();
        // shared for all derived class
        ///
    protected:
      I(...);
    public:
      virtual ...func...()=0;
  };
  class empty_interface::IA : empty_interface::I {
    protected:
      IA(...);
    public:
      virtual ...func...()=0;
  };
  class empty_interface::IB : empty_interface::IA {
    protected:
      IB(...);
    public:
      virtual ...func...()=0;
  };
  // ... <: ID <: IC <: IB <: IA <: I

  struct empty_interface::Dispatchor {
    virtual void on_I(empty_interface::I&) =0;
    virtual void on_IA(empty_interface::IA&) =0;
    virtual void on_IB(empty_interface::IB&) =0;
    ... ...
  };


  namespace impl;
    //concrete class template
    ///
  template <typename interface>
  class impl::C : interface {
    public:
      using interface_t = interface;
        // shared for all derived class
        ///
      using upper_interface_t = empty_interface::I;
      static_assert(issubclass<interface, upper_interface_t>());

    public:
      void accept(Dispatchor& ops) override {ops.on_I(*this);}
      C(...);
      ...func...() override;
    private:
      ...data members...;
  };
  template <typename interface>
  class impl::CA : impl::C<interface> {
    public:
      using upper_interface_t = empty_interface::IA;
      static_assert(issubclass<interface, upper_interface_t>());

    public:
      void accept(Dispatchor& ops) override {ops.on_IA(*this);}
      CA(...);
      ...func...() override;
    private:
      ...data members...;
  };
  template <typename interface>
  class impl::CB : impl::CA<interface> {
    public:
      using upper_interface_t = empty_interface::IB;
      static_assert(issubclass<interface, upper_interface_t>());

    public:
      void accept(Dispatchor& ops) override {ops.on_IB(*this);}
      CB(...);
      ...func...() override;
    private:
      ...data members...;
  };
  // ... <: CD<interface> <: CC<interface> <: CB<interface> <: CA<interface> <: C<interface> <: interface <: empty_interface::I
  // 具象类 个数 o(n^2): forall CX <: C. forall interface <: I). CX<interface>


===
pg770[785/1366] #empty-base optimization
  I benefit from the empty-base optimization.
  The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8).

===
pg766[781/1366] #avoid overparameterize
  // try to avoid parameters that affect only a few members.

  For this shape example, the Color_scheme and Canvas parameters are unlikely to affect the interface much:
    most member functions will not have them as part of their function type.
    These parameters are an ‘‘implementation detail’’ that escaped into the interface – with likely serious performance implications.
    It is not really the whole hierarchy that needs those parameters;
      it is a few configuration functions and (most likely) a few lower-level drawing/rendering functions.
  It is generally not a good idea to ‘‘overparameterize’’ (§23.4.6.3):
    try to avoid parameters that affect only a few members.
    If only a few member functions are affected by a parameter, try to make those function templates with that parameter. For example:
        class Shape {
          template<typename Color_scheme , typename Canvas>
          void configure(const Color_scheme&, const Canvas&);
          //...
        };
        ////或者 直接 输入 IConfigure& 完全无需 使用模版

  ===
  pg765[780/1366]
    The template parameter lists of a template and one of its template members cannot be combined. For example:
      template<typename T, typename T2>//error
      Ptr<T>::operator Ptr<T2>()
      {
        return Ptr<T2>(p);
      }

      template<typename T>
          template<typename T2>       //ok
      Ptr<T>::operator Ptr<T2>()
      {
        return Ptr<T2>{p};
      }


===
pg755[770/1366]
  It is a good idea to avoid fully general (completely unconstrained) function templates in headers that also contain type definitions, but that’s hard to avoid.
      If you need one, protecting it with a constraints check is often worthwhile.

    template<typename In, typename Out,
        typename = enable_if(
                      Input_iterator<In>()
                      && Output_iterator<Out>()
                      && Assignable<Value_type<Out>,Value_type<In>>()
        )>
    Out copy(In p1, In p2, Out q)
    {
      //...
    }


===
pg749[764/1366] #overload+argument-dependent lookup (ADL)+point-of-instantiation binding==>>error-prone
  26.3.3 Point-of-Instantiation Binding
    //十分惊人！不能接受！
    // 无限定/无印 的 非局部标识 的 绑定既然依赖于 使用的地点，环境敏感，岂不意味着 带相同实参的模版 可能有 多份不同绑定的实现？？
    //    环境敏感！宏！
    // 若 允许同一实参化标识 有不同定义，则 逻辑上 有问题
    // 若 禁止，则 分离编译的两个库 可能无法兼容

  26.3.4 Multiple Instantiation Points
    // C++选择 禁止（见上面 第二选项）
    // 但 环境？是否 融合所有 使用地点 以找出 最佳绑定？
    //  ???环境=?=每个使用地点|每个编译单元中的所有使用地点|可执行文件的所有编译单元中的所有使用地点???
    To avoid surprising name bindings, try to limit context dependencies in templates.
  [6] Keep the binding context unchanged between instantiation points; §26.3.4.
  [2] Explicitly instantiate if you need exact control of the instantiation environment; §26.2.2.

===
pg748[763/1366] #typename/template
  # T::xxx
  # typename T::xxx
  # T::template xxx
  # p->template xxx<...>
  # x.template xxx<...>
  #我想，关键在于如何 解释 『<』，小于号？模版参数括号？
  Compared to the use of typename to explicitly state that a name is assumed to name a type, the use of template to explicitly state that a name is assumed to name a template is rare.
    Note the difference in the placement of the disambiguating keyword:typename appears before the qualified name and template immediately before the template name.

        template<typename Container>
        void fct(Container& c)
        {
          Container::value_type v1 = c[7];//syntax error: value_type is assumed to be a non-type name
          typename Container::value_type v2 = c[9];//OK: value_type assumed to name a type
          auto v3 = c[11];//OK: let the compiler figure it out
          //...
        }

    We can avoid such awkward use of typename by introducing a type alias (§23.6). For example:
        template<typename T>
        using Value_type<T> = typename T::value_type;
        template<typename Container>
        void fct2(Container& c)
        {
          Value_type<Container> v1 = c[7];//OK
          //...
        }
    Naming a member template after a.(dot),−>, or::requires similar use of the keyword template.
        For example:
        class Pool {//some allocator
          public:
            template<typename T> T∗ get();
            template<typename T> void release(T∗);
            //...
        };
        template<typename Alloc>
        void f(Alloc& all)
        {
          int∗ p1 = all.get<int>(); //syntax error: get is assumed to name a non-template
          int∗ p2 = all.template get<int>(); //OK: get() is assumed to be a template
          //...
        }
        void user(Pool& pool){
        {
          f(pool);
          //...
        }

===
pg747[762/1366]
  #实参表达式(函数调用实参，函数模版实例化实参)、函数类型
  a function call is said to depend on a template argument if and only if one of these conditions holds:
      [1] The type of the actual argument depends on a template parameter T according to the type deduction rules (§23.5.2), for example,f(T(1)),f(t),f(g(t)), and f(&t), assuming thatt is a T.
      [2] The function called has a parameter that depends on T according to the type deduction rules (§23.5.2), for example,f(T),f(list<T>&), and f(const T∗).
  Basically, the name of a called function is dependent if it is obviously dependent by looking at its arguments or at its formal parameters.
  A call that by coincidence has an argument that matches an actual template parameter type is not dependent.

  pg748[763/1366]
  When the compiler sees a template definition, it determines which names are dependent (§26.3.1). If a name is dependent, looking for its declaration is postponed until instantiation time (§26.3.3).



===
pg746[761/1366] #name binding
  The process of finding the declaration for each name explicitly or implicitly used in a template is called name binding. The general problem with template name binding is that three contexts are involved in a template instantiation and they cannot be cleanly separated:
      [1] The context of the template definition
      [2] The context of the argument type declaration
      [3] The context of the use of the template

  When defining a function template, we want to assure that enough context is available for the template definition to make sense in terms of its actual arguments without picking up ‘‘accidental stuff’’ from the environment of a point of use.
    To help with this, the language separates names used in a template definition into two categories:
      [1]Dependent names:
          names that depend on a template parameter. Such names are bound at a point of instantiation (§26.3.3).
          In the sum() example, the definition of + can be found in the instantiation context because it takes operands of the template argument type.
      [2]Nondependent names:
          names that don’t depend on a template parameter. Such names are bound at the point of definition of the template (§26.3.2).
          In the sum() example, the template vector is defined in the standard header<vector>, and the Boolean tracing is in scope when the definition of sum() is encountered by the compiler.

  To be considered, both dependent and independent names must either be in scope at their point of use or be found by argument-dependent lookup (ADL; §14.2.4).


===
pg744[759/1366]
  // 隐式实例化 只生成用户用到的部分(例外:虚函数，以此包括一切依赖)，可避免 某些 编译错误（泛型，但实际参数 不支持）
  // 显式实例化，生成 所有 静态对象，成员函数；因为 是用于 分离式编译，可能 用作 静态链接库，必须 全部生成。并且 不得重复 实例化！（不论 显式、隐式、特化）
  // 如何避免 重复实例化？外部实例化声明！

    // 头文件，模版声明
    template<typename T> class MyVector;
    template<typename T> class MyVector<T*>;
    template<> class MyVector<void*>;
    // 头文件，模版定义
    template<typename T> class MyVector{...};
    template<typename T> class MyVector<T*>{...};
    template<> class MyVector<void*>{...};
    // 头文件，外部实例化声明，阻止 隐式实例化
    extern template class MyVector<int>;
      //suppresses implicit instantiation
      //explicitly instantiate elsewhere

    // 源文件，显式实例化定义，只此一处实例化
    template class MyVector<int>;

===
pg736[751/1366]
  It is essential that every use of a template for a given set of template arguments be implemented by the same specialization.
    If not, the type system is broken, so that identical uses of a template in different places may yield different results and objects created in different parts of a program may not be compatible.
    Clearly that would be disastrous, so a programmer must take care that explicit specialization is consistent throughout a program.
    In principle, implementations are capable of detecting inconsistent specialization, but the standard does not require them to and some don’t.


  All specializations of a template must be declared in the same namespace as the primary template.
    If used, a specialization that is explicitly declared (as opposed to generated from a more general template) must also be explicitly defined somewhere (§23.7).
    In other words, explicitly specializing a template implies that no (other) definition is generated for that specialization.


===
pg731[746/1366]pg733[748/1366] #code bloat代码爆炸~type erasure类型擦除
  The default behavior of most C++ implementations is to replicate the code for template functions. This is usually good for run-time performance, but unless care is taken, it leads to code bloat in critical cases such as the Vector example.
  Fortunately, there is an obvious solution. Containers of pointers can share a single implementation. This can be expressed through specialization. First, we define a version (a specialization) of Vector for pointers to void:
    template<>
    class Vector<void∗> { //complete specialization
      void∗∗ p;
      //...
      void∗& operator[](int i);
    };
  This specialization can then be used as the common implementation for all Vectors of pointers.
  Another use would be to implement unique_ptr<T> based on a single shared implementation class storing a void∗.
    ///
  To define a specialization that is used for every Vector of pointers and only for Vectors of pointers, we can write:
    template<typename T>
    class Vector<T∗> : private Vector<void∗> { //partial specialization
      ...
    };

  /////
    template<typename T> class Vector {...}; //general vector type
    template<typename T> class Vector<T∗> : private Vector<void∗> {...}; //partial specialization
    template<> class Vector<void∗> {...}; //complete specialization
  /////
  pg733[748/1366]
    Variants of the technique of using a single run-time representation for values of a number of types and relying on the (static) type system to ensure that they are used only according to their declared type has been called type erasure. In the context of C++, it was first documented in the original template paper [Stroustrup,1988].


===
pg730[745/1366] #policy+default vs type-traits
  The technique of supplying a policy through a template argument and then defaulting that argument to supply the most common policy is almost universal in the standard library (e.g., §32.4).
      Curiously enough, it is not used for basic_string(§23.2, Chapter 36) comparisons. Instead, the standard-library string relies on char_traits(§36.2.2). Similarly, the standard algorithms rely on iterator_traits(§33.1.3) and the standard-library containers rely on allocators(§34.4). The use of traits is presented in §28.2.4.

===
pg729[744/1366]
  The semantic checking of a default argument for a template parameter is done only if that default argument is actually used.
    In particular, as long as we refrain from using the default template argument less<Key>, we can compare() values of a type X for which less<X> wouldn’t compile.
    This point is crucial in the design of the standard containers (e.g.,std::map), which rely on a template argument to specify default values (§31.4).




===
pg724[739/1366] #template value parameter
  An argument for a template value parameter can be (§iso.14.3.2):
    •An integral constant expression (§10.4)
    •A pointer or a reference to an object or a function with external linkage (§15.2)
    •A nonoverloaded pointer to member (§20.6)
    •A null pointer (§7.2.2)
  A pointer used as a template argument must be of the form "&of", where "of" is the name of an object or a function, or of the form "f", where "f" is the name of a function.
    A pointer to member must be of the form "&X::of", where "of" is the name of a member.
    In particular, a string literal is not acceptable as a template argument:
    template<typename T, char∗ label>
    class X {
      //...
    };
    X<int,"BMW323Ci"> x1;//error : str ing literal as template argument
    char lx2[] = "BMW323Ci";
    X<int,lx2> x2;//OK: lx2 has exter nal linkage
  This restriction, like the one against floating-point template value arguments, exists to simplify implementation of separately compiled translation units.
    It is best to think of template value arguments as a mechanism for passing integers and pointers to functions. Resist the temptation to try something more clever.
    Unfortunately (for no fundamental reason), literal types (§10.4.3) cannot be used as template value parameters.
    The value template arguments are the mechanism for some more advanced compile-time computation techniques (Chapter 28).

  ///自相矛盾，前面说 只有 整数 才行，下面 直接上 std::string
  A type template parameter can be used as a type later in a template parameter list. For example:
    template<typename T, T default_value>
    class Vec {
      //...
    };
    Vec<int,42> c1;
    Vec<string,""> c2;
  This becomes particularly useful when combined with a default template argument (§25.2.5); for example:
    template<typename T, T default_value = T{}>
    class Vec {
      //...
    };
    Vec<int,42> c1;
    Vec<int> c11;//default_value is int{}, that is, 0
    Vec<string,"for tytwo"> c2;
    Vec<string> c22;//default_value is string{}; that is, ""

===
pg723[738/1366]
  To be used as a template argument, a type must be in scope and accessible. For example:
    class X {
      class M { /*...*/ };
      //...
      void mf();
    };
    void f()
    {
      struct S { /*...*/ };
      vector<S> vs;//OK
      vector<X::M> vm;//error : X::M is private
      //...
    }
    void M::mf()
    {
      vector<S> vs;//error : no S in scope
      vector<M> vm;//OK
      //...
    };

===
pg657[672/1366]
  It is best to avoid calling virtual functions during construction and destruction.
  ///虚函数表 指针 在构析过程中，一直在变化，虚函数 并非 最外派生类


===
pg655[670/1366]
  visitor pattern

  struct Dispatchor; //Visitor
  struct I{
    virtual void accept(Dispatchor&)=0;
      // not: virtual void accept(const Dispatchor&)const =0;
  };
  struct X : I {
    void accept(Dispatchor& ops) override {ops.on_X(*this);}
  };
  struct Y : I {
    void accept(Dispatchor& ops) override {ops.on_Y(*this);}
  };
  struct Dispatchor{
    virtual void on_X(X&)=0;
    virtual void on_Y(Y&)=0;
      // not: virtual void on_Y(const Y&)const =0;
      // maybe: virtual void on(Y&)=0;
  };


===
pg653[668/1366] #double dispatch === double dynamic dispatch
  22.3.1 Double Dispatch
    class X;
    class Y;
    struct I{
      void f(const I& i)const {i.flip_f(*this);}
      virtual void flip_f(const I&)const=0;
      virtual void f(const X&)const=0;
      virtual void f(const Y&)const=0;
    };
    struct X: public I{
      void flip_f(const I& i)const override {i.f(*this);}
      void f(const X&)const override{...}
      void f(const Y&)const override{...}
    };
    struct Y: public I{
      void flip_f(const I& i)const override {i.f(*this);}
      void f(const X&)const override{...}
      void f(const Y&)const override{...}
    };


===
pg648[663/1366]
  22.2.3 static_cast and dynamic_cast
    A dynamic_cast can cast from a polymorphic virtual base class to a derived class or a sibling class (§22.2.1).
      A static_cast(§11.5.2) does not examine the object it casts from, so it cannot:
        void g(Radio& r)
        {
          Receiver∗ prec = &r;//Receiver is an ordinary base of Radio
          Radio∗ pr = static_cast<Radio∗>(prec); //OK, unchecked
          pr = dynamic_cast<Radio∗>(prec); //OK, run-time checked

          Storable∗ ps = &r;//Storable is a virtual base of Radio
          pr = static_cast<Radio∗>(ps); //error : cannot cast from virtual base
          pr = dynamic_cast<Radio∗>(ps); //OK, run-time checked
        }
    The dynamic_cast requires a polymorphic operand because there is no information stored in a non-polymorphic object that can be used to find the objects for which it represents a base.
      In particular, an object of a type with layout constraints determined by some other language – such as Fortran or C – may be used as a virtual base class.
          For objects of such types, only static type information will be available.
      However, the information needed to provide run-time type identification includes the information needed to implement the dynamic_cast.
    Why would anyone want to use a static_cast for class hierarchy navigation? There is a run-time cost associated with the use of a dynamic_cast(§22.2.1).
      More significantly, there are millions of lines of code that were written before dynamic_cast became available.
        This code relies on alternative ways of making sure that a cast is valid, so the checking done by dynamic_cast is seen as redundant.
        However, such code is typically written using the C-style cast (§11.5.3); often obscure errors remain. Where possible, use the safer dynamic_cast.


    /// void*
    The compiler cannot assume anything about the memory pointed to by a void∗.
      This implies that dynamic_cast – which must look into an object to determine its type – cannot cast from a void∗.
      For that, a static_cast is needed. For example:
        Radio∗ f1(void∗ p)
        {
          Storable∗ ps = static_cast<Storable∗>(p); //trust the programmer
          return dynamic_cast<Radio∗>(ps);
        }


===
pg643[658/1366]
  22.2.1 dynamic_cast
  // fail ==>> nullptr|throw bad_cast() exception
  //    upcast: to non-public baseclass
  //    upcast: to too many replicated baseclass
  //    downcast: from virtual baseclass to too mamy replicated intermediate replicated derived_class
  //    downcast or crosscast: required ptr/ref to polymorphic type


===
pg639[654/1366] #mixin
  A class that provides some – but not all – of the implementation for a virtual base class is often called a mixin.


===
pg638[653/1366] #浮动共享空基类 还是 重复接口
  How do we choose between virtual base classes and replicated base classes for our interfaces?
    Most often, of course, we don’t get a choice because we have to conform to an existing design.
    When we do have a choice, we can take into account that (surprisingly)
        the replicated base solution tends to lead to slightly smaller objects (because there is no need for data structures supporting sharing)
        and that we often get our interface objects from ‘‘virtual constructors’’ or ‘‘factory functions’’ (§21.2.4).

===
pg633[648/1366] #virtual base containing data
  Why would someone want to use a virtual base containing data? I can think of three obvious ways for two classes in a class hierarchy to share data:
    [1] Make the data nonlocal (outside the class as a global or namespace variable).
    [2] Put the data in a base class.
    [3] Allocate an object somewhere and give each of the two classes a pointer.
  Option [1], nonlocal data, is usually a poor choice because we cannot control what code accesses the data and how.
      It breaks all notions of encapsulation and locality.
  Option [2], put the data in a base class, is usually the simplest.
      However, for single inheritance that solution makes useful data (and functions) ‘‘bubble up’’ to a common base class; often it ‘‘bubbles’’ all the way to the root of an inheritance tree.
      This means that every member of the class hierarchy gets access. That is logically very similar to using nonlocal data and suffers from the same problems.
      So we need a common base that is not the root of a tree – that is, a virtual base.
  Option [3], sharing an object accessed through pointers, makes sense.
      However, then constructor(s) need to set aside memory for that shared object, initialize it, and provide pointers to the shared object to objects needing access.
      That is roughly what constructors do to implement a virtual base.
  If you don’t need sharing, you can do without virtual bases, and your code is often better and typically simpler for it. However, if you do need sharing within a general class hierarchy, you basically have a choice between using a virtual base and laboriously constructing your own variants of the idea.




===
pg624[639/1366] #factory
  Passing arguments to such ‘‘virtual constructors’’ is a bit tricky. In particular, we cannot override the base class functions that represent the interface with different arguments in different derived classes. This implies that a fair bit of foresight is required to design the factory class’s interface.

  ///
  // uniform ?frontend === interface === no mutable state class
  // diff version backend === implementation inheritance
  // user see interface inheritance only + main() driver use factory class of diff version
  // inherit one implementation but impl many interface


===
pg610[625/1366] #contravariance
  20.6.3 Base and Derived Members
  A derived class has at least the members that it inherits from its base classes. Often it has more.
    This implies that we can safely assign a pointer to a member of a base class to a pointer to a member of a derived class, but not the other way around.
    This property is often called contravariance.

  This contravariance rule appears to be the opposite of the rule that says we can assign a pointer to a derived class to a pointer to its base class.
    In fact, both rules exist to preserve the fundamental guarantee that a pointer may never point to an object that doesn’t at least have the properties that the pointer promises.

===
pg608[623/1366]
  A pointer to member can be obtained by applying the address-of operator,&, to a fully qualified class member name, for example,&Std_interface::suspend. A variable of type ‘‘pointer to member of class X’’ is declared using a declarator of the form X::∗.
    using Pstd_mem = void (Std_interface::∗)(); //pointer-to-member type
    void f(Std_interface∗ p)
    {
      Pstd_mem s = &Std_interface::suspend;//pointer to suspend()
      p−>suspend(); //direct call
      p−>∗s(); //call through pointer to member
        // <==> (*p).*s()
    }

  ///
  using Pmfi = void (C::∗)(int); //pointer to member function of C taking an int
  using Pm = const char∗ C::∗; //pointer to char* data member of C


===
pg606[621/1366]
  20.5.2.1 Multiple Inheritance and Access Control
  If the name of a base class can be reached through multiple paths in a multiple-inheritance lattice (§21.3), it is accessible if it is accessible through any path. For example:
    struct B {
      int m;
      static int sm;
      //...
    };
    class D1 : public virtual B { /*...*/ } ;
    class D2 : public virtual B { /*...*/ } ;
    class D12 : public D1, private D2 { /*...*/ };
    D12∗ pd = new D12;
    B∗ pb = pd;//OK: accessible through D1
    int i1 = pd−>m;//OK: accessible through D1



  If a single entity is reachable through several paths, we can still refer to it without ambiguity. For example:
    class X1 : public B { /*...*/ } ;
    class X2 : public B { /*...*/ } ;
    class XX : public X1, public X2 { /*...*/ };
    XX∗ pxx = new XX;
    int i1 = pxx−>m;//error, ambiguous: XX::X1::B::m or XX::X2::B::m?
    int i2 = pxx−>sm;//OK: there is only one B::sm in an XX (sm is a static member)




===
pg604[619/1366]
  A derived class can access a base class’s protected members only for objects of its own type:
    class Buffer {
    protected:
      char a[128];
      //...
    };
    class Linked_buffer : public Buffer {
      //...
    };
    class Circular_buffer : public Buffer {
      //...
      void f(Linked_buffer∗ p)
      {
        a[0] = 0;//OK: access to Circular_buffer’s own protected member
        p−>a[0] = 0;//error : access to protected member of different type
      }
    };
  This prevents subtle errors that would otherwise occur when one derived class corrupts data belonging to other derived classes.


  ///
  Members declared protected are far more open to abuse than members declared private. In particular, declaring data members protected is usually a design error. Placing significant amounts of data in a common class for all derived classes to use leaves that data open to corruption. Worse, protected data, like public data, cannot easily be restructured because there is no good way of finding every use. Thus, protected data becomes a software maintenance problem.

===
pg603[618/1366]
  A compiler may reorder sections of a class with separate access specifiers (§8.2.6). For example:
    class S {
      public: int m1;
      public: int m2;
    };
  The compiler may decide for m2 to precede m1 in the layout of an S object. Such reordering could come as a surprise to the programmer and is implementation-dependent, so don’t use multiple access specifiers for data members without good reason.

  // protected unchecked version
  20.5.1 protected Members
  When designing a class hierarchy, we sometimes provide functions designed to be used by implementers of derived classes but not by the general user.
    For example, we may provide an (efficient) unchecked access function for derived class implementers and (safe) checked access for others.
    Declaring the unchecked version protected achieves that. For example:


===
pg596[611/1366]
  20.3.6 Return Type Relaxation
    There is a relaxation of the rule that the type of an overriding function must be the same as the type of the virtual function it overrides.
      That is, if the original return type was B∗, then the return type of the overriding function may be D∗, provided B is a public base of D.
       Similarly, a return type ofB& may be relaxed to D&.
       This is sometimes called the covariant return rule.
    This relaxation applies only to return types that are pointers or references, and not to ‘‘smart pointers’’ such as unique_ptr(§5.2.1). In particular, there is not a similar relaxation of the rules for argument types because that would lead to type violations.


===
pg595[610/1366]
  20.3.5.1 Inheriting Constructors
    struct B1 {
      B1(int) { }
    };
    struct D1 : B1 {
      using B1::B1; //implicitly declares D1(int)
        // <==> D1(int i) : B1(i) { }
      string s;//string has a default constructor
      int x;//we ‘‘forgot’’ to provide for initialization of x
        // int x {0};//note: x is initialized
    };
    void test()
    {
      D1 d {6};//oops: d.x is not initialized
      D1 e;//error : D1 has no default constructor
    }


===
pg593[608/1366]
  20.3.5 using Base Members
  Functions do not overload across scopes (§12.3.3). For example:
    struct Base {
      void f(int);
    };
    struct Derived : Base {
      void f(double);
    };
    void use(Derived d)
    {
      d.f(1); //call Derived::f(double)
      Base& br = d
      br.f(1); //call Base::f(int)
    }
  This can surprise people, and sometimes we want overloading to ensure that the best matching member function is used. As for namespaces,using-declarations can be used to add a function to a scope. For example:
    struct D2 : Base {
      using Base::f;//bring all fs from Base into D2
      void f(double);
    };
    void use2(D2 d)
    {
      d.f(1); //call D2::f(int), that is, Base::f(int)
      Base& br = d
      br.f(1); //call Base::f(int)
    }
  We cannot use using-directives to bring all members of a base class into a derived class.


===
pg590[605/1366]
  The override specifier comes last in a declaration, after all other parts.
  Curiously,override/final is not a keyword; it is what is called a contextual keyword.

===
pg588[603/1366]
  A virtual function invoked from a constructor or a destructor reflects that the object is partially constructed or partially destroyed (§22.4). It is therefore typically a bad idea to call a virtual function from a constructor or a destructor.
  // 虚函数表 指针 会在 构析 过程中 变动？


===
pg544[559/1366] #conversion function
  Note that the type being converted to is part of the name of the operator and cannot be repeated as the return value of the conversion function:
      Tiny::operator int() const { return v; }//right
      int Tiny::operator int() const { return v; }//error
  In this respect also, a conversion operator resembles a constructor.


  If both user-defined conversions and user-defined operators are defined, it is possible to get ambiguities between the user-defined operators and the built-in operators. For example:
      int operator+(Tiny,Tiny);
      void f(Tiny t, int i)
      {
        t+i; //error, ambiguous: ‘‘operator+(t,Tiny(i))’’ or ‘‘int(t)+i’’?
      }
  It is therefore often best to rely on user-defined conversions or user-defined operators for a given type, but not both.


===
pg541[556/1366]
18.3.4 Literals

  class complex {
  public:
    constexpr complex(double r =0, double i =0) : re{r}, im{i} { }
    //...
  }
  constexpr complex z2 {1.2,12e3}; //guaranteed compile-time initialization



  It is possible to go further and introduce a user-defined literal (§19.2.6) in support of our complex type. In particular, we could defineito be a suffix meaning ‘‘imaginary.’’ For example:
    constexpr complex<double> operator "" i(long double d)//imaginary literal
    {
      return {0,d};//complex is a literal type
    }

    complex z1 {1.2+12e3i};
    complex f(double d)
    {
      auto x {2.3i};
      return x+sqrt(d+12e3i)+12e3i;
    }
  This user-defined literal gives us one advantage over what we get from constexpr constructors:
    we can use user-defined literals in the middle of expressions
    where the {} notation can only be used when qualified by a type name.
    The example above is roughly equivalent to:
      complex z1 {1.2,12e3};
      complex f(double d)
      {
        complex x {0,2.3};
        return x+sqrt(complex{d,12e3})+complex{0,12e3};
      }

===
pg540[555/1366]
  An object constructed by explicit or implicit use of a constructor in an expression is automatic and will be destroyed at the first opportunity (see §10.3.4).

  No implicit user-defined conversions are applied to the left-hand side of a.(or a−>). This is the case even when the . is implicit. For example:
    void g(complex z)
    {
      3+z; //OK: complex(3)+z
      3.operator+=(z); //error : 3 is not a class object
      3+=z; //error : 3 is not a class object
    }
  Thus, you can approximate the notion that an operator requires an lvalue as its left-hand operand by making that operator a member. However, that is only an approximation because it is possible to access a temporary with a modifying operation, such as operator+=():
    complex x {4,5}
    complex z {sqrt(x)+={1,2}};//like tmp=sqrt(x), tmp+={1,2}


===
pg536[551/1366]

  complex operator+(complex a, complex b)
  {
    return a += b;//access representation through +=
  }

  Composite assignment operators such as += and ∗= tend to be simpler to define than their ‘‘simple’’ counterparts + and ∗.
    This surprises most people at first, but it follows from the fact that three objects are involved in a + operation (the two operands and the result), whereas only two objects are involved in a += operation.
    In the latter case, run-time efficiency is improved by eliminating the need for temporary variables. For example:
      inline complex& complex::operator+=(complex a)
      {
        re += a.re;
        im += a.im;
        return ∗this;
      }
  This does not require a temporary variable to hold the result of the addition and is simple for a compiler to inline perfectly.

  //但如果考虑到 『异常保证』，先实现不破坏 输入 的 +()，再用 swap()实现 +=() 更合理。
  //      模版的话，如何 保证 im += a.im 无异常？


===
pg534[549/1366]
  Consider a binary operator@. If x is of type X and y is of type Y, x@yis resolved like this:
    •If X is a class, look for operator@ as a member of X or as a member of a base of X; and
    •look for declarations of operator@ in the context surrounding x@y; and
    •if X is defined in namespace N, look for declarations of operator@ in N; and
    •if Y is defined in namespace M, look for declarations of operator@ in M.

  Declarations for several operator@s may be found and overload resolution rules (§12.3) are used to find the best match, if any.
    This lookup mechanism is applied only if the operator has at least one operand of a user-defined type.
    Therefore, user-defined conversions (§18.3.2, §18.4) will be considered.
    Note that a type alias is just a synonym and not a separate user-defined type (§6.5).

  Unary operators are resolved analogously.

  Note that in operator lookup no preference is given to members over nonmembers.
    This differs from lookup of named functions (§14.2.4).
    The lack of hiding of operators ensures that built-in operators are never inaccessible and that users can supply new meanings for an operator without modifying existing class declarations.

    X operator!(X);
    struct Z {
      Z operator!(); //does not hide ::operator!()
      X f(X x) { /*...*/ return !x; }//invoke ::operator!(X)
      int f(int x) { /*...*/ return !x; }//invoke the built-in ! for ints
    };


===
pg532[547/1366]
18.2.3 Operators and User-Defined Types
  An operator function must either be a member or take at least one argument of a user-defined type (functions redefining thenew and delete operators need not).
    This rule ensures that a user cannot change the meaning of an expression unless the expression contains an object of a user-defined type.
    In particular, it is not possible to define an operator function that operates exclusively on pointers. This ensures that C++ is extensible but not mutable (with the exception of operators=,&, and,for class objects).

===
pg530[545/1366]

  any binary operator @:
    [aa@bb] === [aa.operator@(bb)]or[operator@(aa,bb)]

  any prefix unary operator @:
    [@aa] === [aa.operator@()]or[operator@(aa)]
  any postfix unary operator @:
    [aa@] === [aa.operator@(int)]or[operator@(aa,int)]


  The operators operator=(§18.2.2),operator[](§19.2.1),operator()(§19.2.2), and operator−> (§19.2.3) must be non-static member functions.
    #cannot be non-member functions
    #cannot be free functions

  The default meaning of &&,||, and ,(comma) involves sequencing: the first operand is evaluated before the second (and for && and || the second operand is not always evaluated). This special rule does not hold for user-defined versions of &&,||, and ,(comma); instead these operators are treated exactly like other binary operators.
    #!!!!  operator,   ?????



===
pg529[544/1366]
  The following operators cannot be defined by a user:
    ::
      scope resolution (§6.3.4, §16.2.12)
    .
      member selection (§8.2)
    .∗
      member selection through pointer to member (§20.6)
    ?:
      conditional evaluation (§9.4.1)
    sizeof
      size of object (§6.2.8)
    alignof
      alignment of object (§6.2.9)
    typeid
      type_infoof an object (§22.5)

===
pg524[539/1366] # =delete
  we can delete any function that we can declare. For example, we can eliminate a specialization from the set of possible specializations of a function template:
    template<class T>
    T∗ clone(T∗ p) //return copy of *p
    {
      return new T{∗p};
    };
    Foo∗ clone(Foo∗) = delete; //don’t try to clone a Foo
    void f(Shape∗ ps, Foo∗ pf)
    {
      Shape∗ ps2 = clone(ps); //fine
      Foo∗ pf2 = clone(pf); //error : clone(Foo*) deleted
    }


    ===
    class Not_on_stack {
      //...
      ˜Not_on_stack() = delete;
    };
    class Not_on_free_store {
      //...
      void∗ operator new(size_t) = delete;
    };


    void f()
    {
      Not_on_stack v1; //error : can’t destroy
      Not_on_free_store v2;//OK
      Not_on_stack∗ p1 = new Not_on_stack; //OK
      Not_on_free_store∗ p2 = new Not_on_free_store; //error : can’t allocate
    }


===
pg517[532/1366]
17.6 Generating Default Operations
  By default, a class provides:
    •A default constructor:X()
    •A copy constructor:X(const X&)
    •A copy assignment:X& operator=(const X&)
    •A move constructor:X(X&&)
    •A move assignment:X& operator=(X&&)
    •A destructor:˜X()


  if the programmer takes control by defining one or more of those operations, the generation of related operations is suppressed:
  •If the programmer declares any constructor for a class, the default constructor is not generated for that class.
  •If the programmer declares a copy operation, a move operation, or a destructor for a class, no copy operation, move operation, or destructor is generated for that class.
  Unfortunately, the second rule is only incompletely enforced: for backward compatibility, copy constructors and copy assignments are generated even if a destructor is defined. However, that generation is deprecated in the ISO standard (§iso.D), and you should expect a modern compiler to warn against it.
  If necessary, we can be explicit about which functions are generated (§17.6.1) and which are not (§17.6.4).
    =default;
    =delete;



===
pg516[531/1366] #move constructor/assignment
  template<class T>
  void swap(T& a, T& b)//"perfect swap" (almost)
  {
    T tmp = std::move(a);
    a = std::move(b);
    b = std::move(tmp);
  }




===
pg513[528/1366] #slicing: copy base of derived
  This phenomenon is called slicing. It may be exactly what you intended (e.g., see the copy constructor for D in §17.5.1.2 where we pass selected information to a base class), but typically it is a subtle bug. If you don’t want slicing, you have two major tools to prevent it:
    [1] Prohibit copying of the base class:deletethe copy operations (§17.6.4).
    [2] Prevent conversion of a pointer to a derived to a pointer to a base: make the base class a private or protected base (§20.5).


===
pg504[519/1366]
  17.4.4 In-Class Initializers
    class A {
    public:
      int a {7};
      int b = 77;
    };
  // 任何 构造函数，只要 漏掉 数据成员 的 初始化，则 使用 声明 时 的 初始化。
  default in-class initializers provide an opportunity for documentation of common cases.

===
pg502[517/1366]
  17.4.3 Delegating Constructors
  class X {
    int a;
    public:
    X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
    X() :X{42} { }
    X(string s) :X{to<int>(s)} { }//§25.2.5.1
    //...
  };
  That is, a member-style initializer using the class’s own name (its constructor name) calls another constructor as part of the construction. Such a constructor is called a delegating constructor (and occasionally a forwarding constructor).


  An object is not considered constructed until its constructor completes (§6.4.2). When using a delegating constructor, the object is not considered constructed until the delegating constructor completes – just completing the delegated-to constructor is not sufficient. A destructor will not be called for an object unless its original constructor completed.
    // 这毫无道理，既然叫『构造函数』，那它执行结束，自然有一个新对象(不变式 以建立，资源 以获取)！纵是 委托/转发 又如何？原来的 委托方 构造函数 其函数体 可视为 成员函数 修改 状态 但 维持 不变式。
    //    除非 委托构造函数 并不是 构造函数，仅止是 不完全的 构造 前置 函数。那应该 给予 新称呼，不该叫 构造函数。


===
pg501[516/1366]
  The members’ constructors are called before the body of the containing class’s own constructor is executed (§17.2.3).
    The constructors are called in the order in which the members are declared in the class rather than the order in which the members appear in the initializer list.

  If a member constructor needs no arguments, the member need not be mentioned in the member initializer list.
    Note that an ‘‘implicitly initialized’’ member of a built-in type is left uninitialized (§17.3.1).

  A reference member or aconstmember must be initialized (§7.5, §7.7, §17.3.3).


===
pg496[511/1366]
17.3.4.1 initializer_list Constructor Disambiguation
  •If either a default constructor or an initializer-list constructor could be invoked, prefer the default constructor.
•If both an initializer-list constructor and an ‘‘ordinary constructor’’ could be invoked, prefer the initializer-list constructor.
    necessary to avoid different resolutions based on different numbers of elements.
    if T{a,b} not ok, then try T(a,b)


===
pg495[510/1366] #in-class member initializer
  References and consts must be initialized (§7.7, §7.5). Therefore, a class containing such members cannot be default constructed unless the programmer supplies in-class member initializers (§17.4.4) or defines a default constructor that initializes them (§17.4.1). For example:
    int glob {9};
    struct X {
      const int a1 {7};//OK
      const int a2;//error : requires a user-defined constructor
      const int& r {9};//OK
      int& r1 {glob};//OK
      int& r2;//error : requires a user-defined constructor
    };
    X x;//error : no default constructor for X



===
pg494[509/1366]
  for a built-in type the default constructor is not invoked for uninitialized non-static variables (§17.3). The default value of a built-in type is 0 for integers,0.0 for floating-point types, and nullptr for pointers.
    #0 for enum!!
===
pg492[507/1366]
  {}initialization === universal initialization
      the notation can be used everywhere
  {}initialization is uniform

  vector<int> v1 {77};//one element with the value 77
  vector<int> v2(77);//77 elements with the default value 0
===
pg490[505/1366]
  vs:
    //非静态变量
    T beta;
    T beta {};

  for local variables and free-store objects, the default initialization is done only for members of class type, and members of built-in type are left uninitialized, so the value of beta is {"","",unknown}.
  The reason for this complication is to improve performance in rare critical cases. For example:
    struct Buf {
      int count;
      char buf[16∗1024];
    };


===
pg489[504/1366]
  17.3.1 Initialization Without Constructors
  we can initialize objects of a class for which we have not defined a constructor using
    •memberwise initialization,
      T x { {}, {}, a, ...};
      memberwise initialization works only if we can access the members.
    •copy initialization, or
      //? T x = y;
      T x {y}; //? //从类型上看，数据成员类型 严格小于 整个结构体 类型，与上面 无歧义，没毛病
    •default initialization (without an initializer or with an empty initializer list).
      T x {};

===
pg487[502/1366]
  memberwise initialization can be used if initializers are needed. For example:
    struct X { X(int); };
    struct S2 {
      X x;
    };
    S2 x1;//error :
    S2 x2 {1}; //OK: x2.x is initialized with 1
  See also §17.3.1.

===
pg486[501/1366]
  Constructors and destructors interact correctly with class hierarchies (§3.2.4, Chapter 20). A constructor builds a class object ‘‘from the bottom up’’:
    [1] first, the constructor invokes its base class constructors,
    [2] then, it invokes the member constructors, and
    [3] finally, it executes its own body.

  A destructor ‘‘tears down’’ an object in the reverse order:
    [1] first, the destructor executes its own body,
    [2] then, it invokes its member destructors, and
    [3] finally, it invokes its base class destructors.
  In particular, a virtual base is constructed before any base that might use it and destroyed after all such bases (§21.3.5.1). This ordering ensures that a base or a member is not used before it has been initialized or used after it has been destroyed.

  Constructors execute member and base constructors in declaration order (not the order of initializers): if two constructors used a different order, the destructor could not (without serious overhead) guarantee to destroy in the reverse order of construction. See also §17.4.


===
pg479[494/1366]
  [8] Make a function a member only if it needs direct access to the representation of a class; §16.3.2.
  [9] Use a namespace to make the association between a class and its helper functions explicit; §16.3.2.

===
pg474[489/1366]
  enum class X{a=1};
  X x{}; // x is not a; x===0!!!! === a^a as-if bit-op ^ & | are working

===
pg462[477/1366]
    16.2.9.2 Physical and Logical Constness
    * mutable data member
    * ptr to non-const obj

===
pg445[460/1366]
  [10] Distinguish between users’ interfaces and implementers’ interfaces; §15.3.2.
  [11] Distinguish between average users’ interfaces and expert users’ interfaces; §15.3.2.

===
pg443[458/1366]
  15.4.3 Program Termination
  A program can terminate in several ways:
    [1] By returning from main()
    [2] By calling exit()
    [3] By calling abort()
    [4] By throwing an uncaught exception
    [5] By violating noexcept
    [6] By calling quick_exit()

  In addition, there are a variety of ill-behaved and implementation-dependent ways of making a program crash (e.g., dividing adoubleby zero).


  If a program is terminated using the standard-library function exit(), the destructors for constructed static objects are called (§15.4.1, §16.2.12).
    However, if the program is terminated using the standard-library function abort(), they are not.
    Note that this implies that exit()does not terminate a program immediately. Calling exit()in a destructor may cause an infinite recursion.

  void exit(int);
  Like the return value of main()(§2.2.1),exit()’s argument is returned to ‘‘the system’’ as the value of the program.
    Zero indicates successful completion.

  Calling exit()means that the local variables of the calling function and its callers will not have their destructors invoked.
    Throwing an exception and catching it ensures that local objects are properly destroyed (§13.5.1).
    Also, a call of exit()terminates the program without giving the caller of the function that called exit()a chance to deal with the problem.
      It is therefore often best to leave a context by throwing an exception and letting a handler decide what to do next. For example, main()may catch every exception (§13.5.2.2).

  The C (and C++) standard-library function atexit()offers the possibility to have code executed at program termination.
  An argument toatexit()cannot take arguments or return a result, and there is an implementation-defined limit to the number of atexit functions. A nonzero value returned by atexit()indicates that the limit is reached. These limitations make atexit()less useful than it appears at first glance. Basically,atexit()is a C workaround for the lack of destructors.
  The destructor of a constructed statically allocated object (§6.4.2) created before a call of atexit(f)will be invoked after f is invoked. The destructor of such an object created after a call of atexit(f)will be invoked before f is invoked.

  The quick_exit()function is like exit()except that it does not invoke any destructors. You register functions to be invoked by quick_exit()using at_quick_exit().

  The exit(),abort(),quick_exit(),atexit(), andat_quick_exit()functions are declared in<cstdlib>.


===
pg442[457/1366]
  15.4.1 Initialization of Nonlocal Variables
  In principle, a variable defined outside any function (that is, global, namespace, and class static variables) is initialized before main()is invoked.

  There is no guaranteed order of initialization of global variables in different translation units.
    Consequently, it is unwise to create order dependencies between initializers of global variables in different compilation units.

  In particular, dynamically linked libraries do not coexist happily with global variables that have complicated dependencies.

  The initialization of a local static is thread-safe (§42.3.3).

  The initialization of nonlocal (statically allocated) variables is controlled by whatever mechanism an implementation uses to start up a C++ program. This mechanism is guaranteed to work properly only if main()is executed.
    Consequently, one should avoid nonlocal variables that require run-time initialization in C++ code intended for execution as a fragment of a non-C++ program.
    Note that variables initialized by constant expressions (§10.4) cannot depend on the value of objects from other translation units and do not require run-time initialization. Such variables are therefore safe to use in all cases.

===
pg430[445/1366] #
  15.2.6 Linkage and Pointers to Functions
  extern "C"
  extern "C" {...}
    # C linkage
    # 这就是 数据指针 与 函数指针 不相容 的 原因 吗？
    #   linkage 似乎不是类型的一部分，但静态类型检查 却需要考虑它？既然如此，为何不算作类型的一部分？
===
pg423[438/1366]
  15.2.1 File-Local Names
  If you must use global variables, at least restrict their use to a single source file. This restriction can be achieved in one of two ways:
    [1] Place declarations in an unnamed namespace.
    [2] Declare an entity static.

  An unnamed namespace (§14.4.8) can be used to make names local to a compilation unit. The effect of an unnamed namespace is very similar to that of internal linkage.


===
pg416[431/1366] #c-header #backward compatibility
  //stdio.h:
    #include<cstdio>
    //err too much: using namespace std;
    using std::...;
    using std::...;
    using std::...;
    using std::...;

===
pg415[430/1366]
  14.4.8 Unnamed Namespaces

===
pg413[428/1366]
  versioning:inline namespace
  namespace xxx {
    inline namespace v3 { ... }
    namespace v2 { ... }
    namespace v1 { ... }
  }

  // xxx |>=| xxx::v3

===
pg405[420/1366]
  namespace xxx_interface4user{}
  namespace xxx_interface4impl{}
===
pg395[410/1366] #Argument-Dependent Lookup(ADL)
  // 感觉不行！
  // 应该 提供一个注册用的命名空间，就像hs::class，用户 重载的函数namespace mine{f(){}} 自己用 namespace xxx_interface{using mine::f;} 注册进去
  // 模版函数 调用时: xxx_interface::f(...) 或 using namespace xxx_interface; (重载 运算符)

14.2.4 Argument-Dependent Lookup
  A function taking an argument of user-defined type X is more often than not defined in the same namespace as X. Consequently, if a function isn’t found in the context of its use, we look in the namespaces of its arguments. For example:

    namespace Chrono {
      class Date { /*...*/ };
      bool operator==(const Date&, const std::string&);
      std::string format(const Date&);//make str ing representation
      //...
    }

    void f(Chrono::Date d, int i)
    {
      std::string s = format(d); //Chrono::for mat()
      std::string t = format(i); //error : no for mat() in scope
    }

  This lookup rule (called argument-dependent lookup or simply ADL) saves the programmer a lot of typing compared to using explicit qualification, yet it doesn’t pollute the namespace the way a using-directive (§14.2.3) can.
    It is especially useful for operator operands (§18.2.5) and template arguments (§26.3.5), where explicit qualification can be quite cumbersome.
  Note that the namespace itself needs to be in scope and the function must be declared before it can be found and used.


  In the standard, the rules for argument-dependent lookup are phrased in terms of associated namespaces (§iso.3.4.2). Basically:
    •If an argument is a class member, the associated namespaces are the class itself (including its base classes) and the class’s enclosing namespaces.
    •If an argument is a member of a namespace, the associated namespaces are the enclosing namespaces.
    •If an argument is a built-in type, there are no associated namespaces.



===
pg377[392/1366] #&*p <<-- std::uninitialized_fill():
  // uninitialized_fill #src is T&
  // uninitialized_fill_n
  // uninitialized_copy #src is T[]
  // forward-iterator
  template<class For, class T>
  void uninitialized_fill(For beg, For end, const T& x)
  {
    For p;
    try {
      for (p=beg; p!=end; ++p)
        ::new(static_cast<void∗>(&∗p)) T(x);//construct copy of x in *p (§11.2.4)
    }
    catch (...) {
      for (For q = beg; q!=p; ++q)
        (&∗q)−>˜T(); //destroy element (§11.2.4)
      throw;//rethrow (§13.5.2.1)
    }
  }
  The curious construct &∗p takes care of iterators that are not pointers.
    In that case, we need to take the address of the element obtained by dereference to get a pointer.


  The calls to alloc.construct() in the vector constructors are simply syntactic sugar for this placement new. Similarly, the alloc.destroy()call simply hides explicit destruction (like(&∗q)−>˜T()).


===
pg374[389/1366] #catch(...)+current_exception()
  // packaged_task-promise-current_exception
  try {
    //... do the work ...
  }
  catch(...) {
    promise.set_exception(current_exception());
  }

===
pg373[388/1366] #terminate #catch(...)@main()
  // [27] Have main() catch and report all exceptions; §13.5.2.2, §13.5.2.4.
  // [34] A library shouldn’t unilaterally terminate a program. Instead, throw an exception and let a caller decide; §13.4.
  // [35] A library shouldn’t produce diagnostic output aimed at an end user. Instead, throw an exception and let a caller decide; §13.1.3.

  The specific rules for calling terminate() are (§iso.15.5.1)
    •When no suitable handler was found for a thrown exception
    •When a noexcept function tries to exit with a throw
    •When a destructor invoked during stack unwinding tries to exit with a throw
    •When code invoked to propagate an exception (e.g., a copy constructor) tries to exit with a throw
    •When someone tries to rethrow (throw;) when there is no current exception being handled
    •When a destructor for a statically allocated or thread-local object tries to exit with a throw
    •When an initializer for a statically allocated or thread-local object tries to exit with a throw
    •When a function invoked as an atexit() function tries to exit with a throw

  In such cases, the function std::terminate()is called. In addition, a user can call terminate()if less drastic approaches are infeasible.
  By ‘‘tries to exit with a throw,’’ I mean that an exception is thrown somewhere and not caught so that the run-time system tries to propagate it from a function to its caller.
  By default,terminate() will call abort()(§15.4.3). This default is the correct choice for most users – especially during debugging. If that is not acceptable, the user can provide a terminate handler function by a callstd::set_terminate() from <exception>:

  The return value is the previous function given to set_terminate().
    For example, a terminate handler could be used to abort a process or maybe to re-initialize a system. The intent is for terminate()to be a drastic measure to be applied when the error recovery strategy implemented by the exception-handling mechanism has failed and it is time to go to another level of a fault tolerance strategy.
      If a terminate handler is entered, essentially nothing can be assumed about a program’s data structures; they must be assumed to be corrupted. Even writing an error message using cerr must be assumed to be hazardous.
    A terminate handler cannot return to its caller. If it tries to,terminate()will callabort().

    Note that abort()indicates abnormal exit from the program. The function exit()can be used to exit a program with a return value that indicates to the surrounding system whether the exit is normal or abnormal (§15.4.3).


  It is implementation-defined whether destructors are invoked when a program is terminated because of an uncaught exception. On some systems, it is essential that the destructors are not called so that the program can be resumed from the debugger. On other systems, it is architecturally close to impossible not to invoke the destructors while searching for a handler.
    If you want to ensure cleanup when an otherwise uncaught exception happens, you can add a catch-all handler (§13.5.2.2) tomain()in addition to handlers for exceptions you really care about.



===
pg372[387/1366] #noexcept destructor
  If you managed to have two exceptions active at one time (in the same thread, which you can’t), the system would have no idea which of the exceptions to try to handle: your new one or the one it was already trying to handle.
    Note that an exception is considered handled immediately upon entry into a catch-clause. Rethrowing an exception (§13.5.2.1) or throwing a new exception from within a catch-clause is considered a new throw done after the original exception has been handled. You can throw an exception from within a destructor (even during stack unwinding) as long as you catch it before it leaves the destructor.


===
pg366[381/1366] #conditionally noexcept
  conditionally noexcept
    template<typename T>
      void my_fct(T& x) noexcept(Is_pod<T>());

    template<typename T>
      void call_f(vector<T>& v) noexcept(noexcept(f(v[0]))
      {
        for (auto x : v)
          f(x);
      }

    template<class T, size_t N>
      void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(∗a, ∗b)));


===
pg358[373/1366]
  RAII(+lambda) 可完全替代 try...finally
    除了 vector构造函数 或者说 uninitialized_fill 之类

===
pg353[368/1366] #exception guarantee
  //illustrate:pg381[396/1366] 13.6.3 Assignment //vector impl

  The C++ standard library provides a generally useful conceptual framework for design for exception-safe program components. The library provides one of the following guarantees for every library operation:
    •The basic guarantee for all operations: The basic invariants of all objects are maintained, and no resources, such as memory, are leaked. In particular, the basic invariants of every built-in and standard-library type guarantee that you can destroy an object or assign to it after every standard-library operation (§iso.17.6.3.1).
    •The strong guarantee for key operations: in addition to providing the basic guarantee, either the operation succeeds, or it has no effect. This guarantee is provided for key operations, such as push_back(), single-element insert() on a list, and uninitialized_copy().
    •The nothrow guarantee for some operations: in addition to providing the basic guarantee, some operations are guaranteed not to throw an exception. This guarantee is provided for a few simple operations, such as swap() of two containers and pop_back().


  Both the basic guarantee and the strong guarantee are provided on the condition that
    •user-supplied operations (such as assignments andswap()functions) do not leave container elements in invalid states,
    •user-supplied operations do not leak resources, and
    •destructors do not throw exceptions (§iso.17.6.5.12).


===
pg340[355/1366] #predefined macros
  12.6.2 Predefined Macros
  A few macros are predefined by the compiler (§iso.16.8, §iso.8.4.1):
    •__cplusplus: defined in a C++ compilation (and not in a C compilation). Its value is 201103L in a C++11 program; previous C++ standards have lower values.
    •__DATE__: date in ‘‘yyyy:mm:dd’’ format.
    •__TIME__: time in ‘‘hh:mm:ss’’ format.
    •__FILE__: name of current source file.
    •__LINE__: source line number within the current source file.
    •__FUNC__: an implementation-defined C-style string naming the current function.
    •__STDC_HOSTED__:1 if the implementation is hosted (§6.1.1); otherwise 0.


  In addition, a few macros are conditionally defined by the implementation:
    •__STDC__: defined in a C compilation (and not in a C++ compilation)
    •__STDC_MB_MIGHT_NEQ_WC__:1 if, in the encoding for wchar_t, a member of the basic character set (§6.1) might have a code value that differs from its value as an ordinary character literal
    •__STDCPP_STRICT_POINTER_SAFETY__:1 if the implementation has strict pointer safety (§34.5); otherwise undefined.
    •__STDCPP_THREADS__:1 if a program can have more than one thread of execution; otherwise undefined.


===
pg336[351/1366] #ptr to func
  A pointer to function must reflect the linkage of a function (§15.2.6). Neither linkage specification nor noexcept may appear in type aliases:
    using Pc = extern "C" void(int); //error : linkage specification in alias
    using Pn = void(int) noexcept; //error : noexcept in alias

===
pg333[348/1366] #ptr to func
  using CFT = int(const void∗, const void∗);

===
pg320[335/1366] #initializer_list argument take priority@ambiguity
  If there is a possible ambiguity, an initializer_list parameter takes priority.
  The reason that a function with an initializer_list argument take priority is that it could be very confusing if different functions were chosen based on the number of elements of a list. It is not possible to eliminate every form of confusion in overload resolution (for example, see §4.4, §17.3.4.1), but giving initializer_list parameters priority for{}-list arguments seems to minimize confusion.


===
pg319[334/1366] #reference-to-array
  Note that the number of elements is part of a reference-to-array type. That makes such references far less flexible than pointers and containers (such as vector).
    void f(int(&r)[4]);

  The main use of references to arrays is in templates, where the number of elements is then deduced. For example:
    template<class T, int N> void f(T(&r)[N])
    {
      //...
    }

===
pg315[330/1366] #static-local+call_once==>>data-race-free
  A static local variable allows the function to preserve information between calls without introducing a global variable that might be accessed and corrupted by other functions (see also §16.2.12).
  Initialization of a static local variable does not lead to a data race (§5.3.1) unless you enter the function containing it recursively or a deadlock occurs (§iso.6.7). That is, the C++ implementation must guard the initialization of a local static variable with some kind of lock-free construct (e.g., a call_once; §42.3.3). The effect of initializing a local static recursively is undefined. For example:
    int fn(int n)
    {
      static int n1 = n;//OK
      static int n2 = fn(n−1)+1;//undefined
      return n;
    }
  A static local variable is useful for avoiding order dependencies among nonlocal variables (§15.4.1).



===
pg314[329/1366] #[[noreturn]]
  A construct[[...]]is called an attribute and can be placed just about anywhere in the C++ syntax.
  In general, an attribute specifies some implementation-dependent property about the syntactic entity that precedes it. In addition, an attribute can be placed in front of a declaration. There are only two standard attributes (§iso.7.6), and[[noreturn]]is one of them. The other is[[carries_dependency]](§41.3).
  Placing[[noreturn]]at the start of a function declaration indicates that the function is not expected to return.
  //   see:pg307, pg314



===
pg313[328/1366] #
  12.1.6.2 Conditional Evaluation
  A branch of a conditional expression that is not taken in aconstexprfunction is not evaluated. This implies that a branch not taken can require run-time evaluation. For example:
    constexpr int check(int i)
    {
      return (low<=i && i<high) ? i : throw out_of_range();
    }
    constexpr int low = 0;
    constexpr int high = 99;
    //...
    constexpr int val = check(f(x,y,z));
  //   see:pg264, pg313


===
pg307[322/1366] #
  struct S {
    [[noreturn]] static constexpr virtual inline auto f() −> void const noexcept =0 =default =delete final override;
  };
  //   see:pg307, pg314


===
pg299[314/1366] #homemade narrow_cast<>
  template<class Target, class Source>
  Target narrow_cast(Source v)
  {
    auto r = static_cast<Target>(v); //convert the value to the target type
    if (static_cast<Source>(r)!=v)
      throw runtime_error("narrow_cast<>() failed");
    return r;
  }


  auto c2 = narrow_cast<char>(−64); //will throw if chars are unsigned
  auto c3 = narrow_cast<char>(264); //will throw if chars are 8-bit and signed



===
pg282[297/1366] #
  To deallocate space allocated by new,delete and delete[] must be able to determine the size of the object allocated. This implies that an object allocated using the standard implementation of new will occupy slightly more space than a static object. At a minimum, space is needed to hold the object’s size. Usually two or more words per allocation are used for free-store management. Most modern machines use 8-byte words. This overhead is not significant when we allocate many objects or large objects, but it can matter if we allocate lots of small objects (e.g.,ints or Points) on the free store.


===
pg268[283/1366] #narrowing ==>> narrow_cast<>, list_initializer
  The {}-initializer syntax prevents narrowing (§6.3.5).
    void f(double d)
    {
      char c {d};//error : double-precision floating-point to char conversion
    }
  If potentially narrowing conversions are unavoidable, consider using some form of run-time checked conversion function, such as narrow_cast<>()(§11.5).

===
pg265[280/1366] #constexpr constructor ==>> literal type
  A class with a constexpr constructor is called a literal type. To be simple enough to be constexpr, a constructor must have an empty body and all members must be initialized by potentially constant expressions.

===
pg264[279/1366] #constexpr
  The condition of a ?: is evaluated and then the selected alternative is evaluated. The alternative not selected is not evaluated and might even not be a constant expression. Similarly, operands of && and || that are not evaluated need not be constant expressions. This feature is primarily useful in constexpr functions that are sometimes used as constant expressions and sometimes not.
  // 也可用作 检查输入输出、中间状态、报错
  //   see:pg264, pg313

===
pg217[232/1366]
  union
    anonymous union #匿名
    tagged union === discriminated union
      #mine:cased
    new(&s) string{ss};//placement new: explicitly construct string (§11.2.4)



===
pg196[211/1366]
  T& & === T&
  T&& & === T&
  T& && === T&
  T&& && === T&&




===
pg193[208/1366]
  reference classify:
    non-const lvalue reference
      接受 部分 赋值: 左值(声明的右值自动变左值)
    const lvalue reference
      接受 任何 赋值: 左值(声明的右值自动变左值)，临时值，字面常量
    rvalue reference
      接受 部分 赋值: 临时值，字面常量



===
pg191[206/1366] #const T& = ... 可能复制并保留该临时值
  Initialization of a reference is trivial when the initializer is an lvalue (an object whose address you can take; see §6.4). The initializer for a ‘‘plain’’ T& must be an lvalue of type T.
  The initializer for a "const T&" need not be an lvalue or even of type T. In such cases:
    [1] First, implicit type conversion to T is applied if necessary (see §10.5).
    [2] Then, the resulting value is placed in a temporary variable of type T.
    [3] Finally, this temporary variable is used as the value of the initializer.

  Consider:
    double& dr = 1;//error : lvalue needed
    const double& cdr {1};//OK

  The interpretation of this last initialization might be:
    double temp = double{1}; //first create a temporary with the right value
    const double& cdr {temp};//then use the temporary as the initializer for cdr

  A temporary created to hold a reference initializer persists until the end of its reference’s scope.
  References to variables and references to constants are distinguished because introducing a temporary for a variable would have been highly error-prone; an assignment to the variable would become an assignment to the – soon-to-disappear – temporary. No such problem exists for references to constants, and references to constants are often important as function arguments (§18.2.4).



===
pg179[194/1366]
    u8"" utf8 string
    u"" utf16 string
    U"" utf32 string
    L"" wchar_t[]
    ==
    R"tag(...)tag" multi-line raw string allow true newline
    ==
    UR not RU
    R not r
===
pg168[183/1366]
  // except char..._t, wchar_t
  The _t suffix is conventional for aliases (‘‘typedefs’’). The int16_t,int32_t, and other such aliases can be found in<stdint>(§43.7).
  Note that naming a type after its representation rather than its pur- pose is not necessarily a good idea (§6.3.3).
  template<...> using xxx = ...;

===
pg166[181/1366]
  key properties for addressing/copying/moving:
    movable
    has_identity #addressable

  classify:
    [not movable][not has_identity] <==> not C++ obj
    [not movable][has_identity] <==> lvalue
    [movable][has_identity] <==> xvalue
    [movable][not has_identity] <==> prvalue
    glvalue = lvalue | xvalue
    rvalue = xvalue | prvalue
    ==
    l = lhs
    r = rhs
    g = generalized
    p = pure
    x = extraordinary / expert-only
    ==
    std::move() -> &&

  #see:pg193[208/1366]
  reference classify:
    non-const lvalue reference
    const lvalue reference
    rvalue reference

===
pg160[175/1366]
  T x {}; // avoid become func-decl: "T x();"
  alway use {}(list initialization):
  * except auto
      auto z1 {99};//z1 is an initializer_list<int>
      auto z2 = 99;//z2 is an int
      // So prefer = when using auto.
  * except non-list-initialization constructor has diff.meaning:
      vector<int> v1 {99};//v1 is a vector of 1 element with the value 99
        // == [99]
      vector<int> v2(99);//v2 is a vector of 99 elements each with the default value 0
        // == [0]*99


===
pg155[170/1366]
  _ 用于 命名:
    必须是 local
    必须是 _[0-9a-z]...

  Nonlocal names starting with an underscore are reserved for special facilities in the implementation and the run-time environment, so such names should not be used in application programs.
  Similarly, names starting with a double underscore (__) or an underscore followed by an uppercase letter (e.g.,_Foo) are reserved (§iso.17.6.4.3).


===
pg151[166/1366] #alignas+uninitialized_copy

void user(const vector<X>& vx)
{
  constexpr int bufmax = 1024;
  alignas(X) buffer[bufmax]; //uninitialized
  const int max = min(vx.size(),bufmax/sizeof(X));
  uninitialized_copy(vx.begin(),vx.begin()+max,buffer);
  //...
}


===
pg149[164/1366]
  基本类型 大小比较
  #omit sizeof, unit:char
  1 == char <= {(short <= int), bool, wchar_t} <= long <= long long
    xxx == signed xxx == unsigned xxx
  float <= double <= long double

  #omit bit_of, unit:bit
  8 <= char
  16 <= short
  32 <= long
  ===
  ！！！如果 char==4byte，那 char16_t/int16_t 是什么？
    u8"" utf8 string
    u"" utf16 string
    U"" utf32 string
  ===
  其实 有些奇怪
  基本类型 的 大小/对齐 依 宿主机器（内存、CPU寄存器） 而定 ==>> char
  而 面向通信（网络协议）、存储（文件格式），则 必须 明确 比特数 ==>> byte/bit
  C++似乎 没能很明确地 支持如何处理这问题
  <cstddef>::size_t/ptrdiff_t
    size_t is an implementation-defined unsigned integer type that can hold the size in bytes of every object. Consequently, it is used where we need to hold an object size.
    void∗ allocate(size_t n); //get n bytes? #char!
    ptrdiff_t for holding the result of subtracting two pointers to get a number of elements.

  但是 文件大小/tell()呢？显然 不能用 size_t
    文件指针fp呢？显然 不能用 (void*)


===
pg141[156/1366]
  [err: A char fits in 1 byte.]
    There are embedded processors without byte accessing hardware for which a char is 4 bytes.
  第六章 让我震惊！
  char 多少byte？文件读写 怎么办？毕竟 字节 与 char 不对应！
  字符、字符串 的 转义字符:
    * 注意 长度没有上限！
      \oooooo
      \xhhhhh
    * 并不能确定是那个字符
      相当于 整数 赋值给 字符
      字符集 并不确定，移植性 有问题
        所以 实际上 不是 字符串，而是 整数流
      (wchar_t*) L"" 更严重，连 字符串 的 长度 都无法确定（依赖于 编译器实现）
      只有 unicode字符串 是 确定的
        (char32_t) U'\Uxxxxxxxx'
        (char16_t) u'\uxxxx'
    * char vs signed char vs unsigned char
      与 整数 交换 值，有 移植性问题
    * 字母 不一定 连续
      字符集 不一定 是 ascii
      比如: i,j 不相邻

===
pg123[138/1366]
  future+promise <-- packaged_task
    + thread ==>> sync with shared-data #显式运行线程，任务之间可通信
    + async ==>> cannot communicate, there may or maynot be thread used to work #可能 所有任务 并行，也可能 串行，即使部分串行，任务之间 也不可能 通信。





===
pg119[134/1366] # mutex + condition_variable
  void consumer()
  {
    while(true) {
      unique_lock<mutex> lck{mmutex}; //acquire mmutex
      while (mcond.wait(lck)) /*do nothing*/; //release lck and wait;
      //re-acquire lck upon wakeup
      auto m = mqueue.front(); //get the message
      mqueue.pop();
      lck.unlock(); //release lck
      //... process m ...
    }
  }

  void producer()
  {
    while(true) {
      Message m;
      //... fill the message ...
      unique_lock<mutex> lck {mmutex}; //protect operations
      mqueue.push(m);
      mcond.notify_one(); //notify
    }//release lock (at end of scope)
  }





===
pg118[133/1366] #防止死锁deadlock
  unique_lock<mutex> lck1 {m1,defer_lock}; //defer_lock: don’t yet try to acquire the mutex
  unique_lock<mutex> lck2 {m2,defer_lock};
  unique_lock<mutex> lck3 {m3,defer_lock};
  lock(lck1,lck2,lck3); //acquire all three locks






===
pg103[118/1366]
  contiguous 邻接的，无中断的，连续的
  chrono-  [前缀]用于组词表示计时相关的词
    $ ls ~/../usr/include/c++/v1/chrono
    /data/data/com.termux/files/home/../usr/include/c++/v1/chrono
    view /data/data/com.termux/files/usr/include/c++/v1/deque
      deque::operator[] O(1)???
        std has only seq: vector/array/deque/list/forward_list??? vector/array require contiguous memory ==>> size-limited???

      ref:
        pg886[901/1366]
          A deque(pronounced ‘‘deck’’) is a mixture of linked-list and contiguous allocation.
        pg894[909/1366]
          The standard-library operations have complexity guarantees:
            deque::operator[] O(1)
              how can it be possible if use list<array<T,N>>?
                ???it seems using vector<array<T,N>>???
          我觉得 deque 可用 两个 vector 实现，一反向，一正向。允许 头部空洞（所有元素只在一侧）
            ？？？如何避免contiguous，以防内存高度碎片化无法分配大量连续内存，而同时保留random-access-O(1)？？？
            random-access-O(1)==>>必然使用数组/连续内存
            但可分级，总级数固定或有上限(<<==O(1))，这样各层级的数组大小有上限，不至于太大(<<==对内存高度碎片化的容忍力)，但多层情形下，整体总容量足够大

view /data/data/com.termux/files/usr/include/c++/v1/__split_buffer
  typedef __split_buffer<pointer, __pointer_allocator> __map;
  protected:
    __map __map_;
    size_type __start_;
template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::operator[](size_type __i)
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}


