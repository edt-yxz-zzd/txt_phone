

C++ bug:
    * C++因为使用 基类引用(强引用/共享指针/独占指针)、函数对象（带状态函数、匿名函数），不可能避免 强引用循环，这不是仔细设计析构函数使用智能指针就能解决的问题，没有垃圾回收器，必然存在 内存泄漏！C没有类继承，数据结构简单，仔细设计使用问题反而没那么严重。
      如果 不使用 共享指针、仅使用类实心数据，即 值复制共享指针|独占指针仅用于指向最外层派生类|弱引用，则可大大降低不明不白的引用循环
    * 模版的环境敏感型标识绑定，独立开发分离编译的两个库可能不相容，见下面 pg749[764/1366]，既然 依赖环境，那么 instantiation_point(类似goto标签，但 允许 存在于 命名空间 中)也当作为 模版参数


e others/book/The C++ Programming Language(4ed)(2013).txt
e others/book/The\ C++\ Programming\ Language(4ed)(2013).txt

  '/sdcard/0my_files/book/lang/C++/The C++ Programming Language(4ed)(2013).pdf'
    pg103[118/1366]
    pg118[133/1366]
    pg119[134/1366]
    pg123[138/1366]
pg141[156/1366]
pg149[164/1366]
pg151[166/1366]
pg155[170/1366]
pg160[175/1366]
pg166[181/1366]
pg168[183/1366]
pg179[194/1366]
pg191[206/1366]
pg193[208/1366]
pg196[211/1366]
pg217[232/1366]
pg264[279/1366]
pg268[283/1366]
pg282[297/1366]
pg299[314/1366]
pg307[322/1366]
pg313[328/1366]
pg314[329/1366]
pg315[330/1366]
pg319[334/1366]
pg320[335/1366]
pg336[351/1366]
pg340[355/1366]
pg353[368/1366]
pg358[373/1366]
pg366[381/1366]
pg373[388/1366]
pg374[389/1366]
pg377[392/1366]
pg395[410/1366]
pg405[420/1366]
pg413[428/1366]
pg415[430/1366]
pg416[431/1366]
pg423[438/1366]
pg430[445/1366]
pg442[457/1366]
pg443[458/1366]
pg445[460/1366]
pg462[477/1366]
pg474[489/1366]
pg479[494/1366]
pg486[501/1366]
pg487[502/1366]
pg489[504/1366]
pg490[505/1366]
pg492[507/1366]
pg494[509/1366]
pg495[510/1366]
pg496[511/1366]
pg501[516/1366]
pg502[517/1366]
pg504[519/1366]
pg513[528/1366]
pg516[531/1366]
pg517[532/1366]
pg524[539/1366]
pg529[544/1366]
pg530[545/1366]
pg532[547/1366]
pg534[549/1366]
pg536[551/1366]
pg540[555/1366]
pg541[556/1366]
pg544[559/1366]
pg588[603/1366]
pg590[605/1366]
pg593[608/1366]
pg595[610/1366]
pg596[611/1366]
pg603[618/1366]
pg604[619/1366]
pg606[621/1366]
pg608[623/1366]
pg610[625/1366]
pg624[639/1366]
pg633[648/1366]
pg638[653/1366]
pg639[654/1366]
pg643[658/1366]
pg648[663/1366]
pg653[668/1366]
pg655[670/1366]
pg657[672/1366]
pg723[738/1366]
pg724[739/1366]
pg729[744/1366]
pg730[745/1366]
pg731[746/1366]
  pg733[748/1366]
pg736[751/1366]
pg744[759/1366]
pg746[761/1366]
pg747[762/1366]
pg748[763/1366]
pg749[764/1366]
pg755[770/1366]
pg765[780/1366]
pg766[781/1366]
pg771[786/1366]
pg796[811/1366]
pg800[815/1366]
pg814[829/1366]
pg829[844/1366]
pg855[870/1366]
pg866[881/1366]
pg868[883/1366]
pg903[918/1366]







pg770[785/1366] #empty-base optimization


[7] Do not try to use a standard-library facility without#includeing its header; §30.2.
[8] To use a range-foron a built-in array,#include<iterator>; §30.3.2.
see below: [[[Standard_Library_Overview]]]
  * Containers
  * General_Utilities
  * Algorithms
  * Diagnostics
  * Strings_and_Characters
  * Input_Output
  * Localization
  * Language_Support
  * Numerics
  * Concurrency
  * C_Compatibility


Template<typename... Args>
void f(Args... args);
  // parameter pack
  // sizeof... args

[2] Explicitly instantiate if you need exact control of the instantiation environment; §26.2.2.
[3] Explicitly instantiate if you optimize the time needed to generate specializations; §26.2.2.
[6] Keep the binding context unchanged between instantiation points; §26.3.4.

[5] Templates are type-safe, but checking happens too late; §23.3.
substitution failure is not an error.
  The rule is known under the unpronounceable acronym SFINAE (Substitution Failure Is Not An Error).

非常量的非局部的静态变量 理应 改成 局部的静态变量#不知可否用 inline 函数包裹？
  更明确的初始化时机#见下面call_once

extern "C" void f()noexcept;
noexcept --> terminate()
virtual, [[noreturn]]
override, final
  f()... override final;
  class X final{};
compl???
  like: bitor === |
  compl === ~
sizeof, alignof, alignas, decltype?
  alignas: "align as" use to decl/def uninit buffer #see below
#alias:
  const
  constexpr
  enum class.xxx{a, b, c}; //+ switch/case
  template<...> using xxx = typename X::Y::template Z<...>::template W<...>::...;
  using std::string;
    //using-declaration
  using namespace std;
    //using-directive
  namespace Lib = Foundation_library_v2r11;
    //namespace alias
    // This can immensely simplify the task of replacing one version of a library with another.
    // 所以说，命名空间 也该加 参数...


a.*(&T::x)
p->*(&T::x)


operator "" km ()

int main(int argc, char* argv[])
  argc >= 1
  2 <= len(argv) == argc+1
  argv[-1] is argv[argc] == nullptr
  argv[0] === executable/program-name
  all(s is c_string (i.e. s[strlen(s)] == NUL) for s in argv[:-1])

===
===
===
===
===
===
===
===
===
===
===
pg903[918/1366]
  //无需重新分配内存，自然也无需移动所有元素，指针保持有效性
  The notion of capacity allows for iterators into a vector to be valid unless a reallocation actually happens.
      ---
      The standard does not specify by how much capacity is increased when it is exceeded, but adding half the size is common.
        I used to be careful about using reserve() when I was reading into a vector.
        I was surprised to find that for essentially all of my uses, calling reserve() did not measurably affect performance.
        The default growth strategy worked just as well as my estimates, so I stopped trying to improve performance using reserve().
        Instead, I use it to increase predictability of reallocation delays and to prevent invalidation of pointers and iterators.


===
pg868[883/1366]
  30.4 Error Handling
  The standard library consists of components developed over a period of almost 40 years. Thus, their style and approaches to error handling are not consistent:
      •C-style libraries consist of functions, many of which set errno to indicate that an error happened; see §13.1.2 and §40.3.
      •Many algorithms operating on a sequence of elements return an iterator to the one-past-the-last element to indicate ‘‘not found’’ or ‘‘failure’’; see §33.1.1.
      •The I/O streams library relies on a state in each stream to reflect errors and may (if the user requests it) throw exceptions to indicate errors; see §38.3.
      •Some standard-library components, such as vector,string, and bitset, throw exceptions to indicate errors.

  The standard library is designed so that all facilities obey ‘‘the basic guarantee’’ (§13.2); that is, even if an exception is thrown, no resource (such as memory) is leaked and no invariant for a standard-library class is broken.




===
pg866[881/1366] #include standard-library instead of writr forward-declarations manually
  #不要手写标准库声明！
[7] Do not try to use a standard-library facility without #include-ing its header; §30.2.
[8] To use a range-for on a built-in array,#include<iterator>; §30.3.2.
  ---
  A user or a library implementer is not allowed to add or subtract declarations from the standard headers.
    Nor is it acceptable to try to change the contents of a header by defining macros to change the meaning of declarations in a header (§15.2.3).
    Any program or implementation that plays such games does not conform to the standard, and programs that rely on such tricks are not portable.
    Even if they work today, the next release of any part of an implementation may break them. Avoid such trickery.

  For a standard-library facility to be used, its header must be included.
    Writing out the relevant declarations yourself is not a standards-conforming alternative.
    The reason is that some implementations optimize compilation based on standard header inclusion, and others provide optimized implementations of standard-library facilities triggered by the headers.
    In general, implementers use standard headers in ways programmers cannot predict and shouldn’t have to know about.
    A programmer can, however, specialize utility templates, such as swap()(§35.5.2), for non-standard-library, user-defined types.


  pg863[878/1366]
  A standard header with a name starting with the letter c is equivalent to a header in the C standard library.
    For every header <X.h> defining part of the C standard library in the global namespace and also in namespacestd, there is a header <cX> defining the same names.
    Ideally, the names from a <cX> header do not pollute the global namespace (§15.2.4), but unfortunately (due to complexities of maintaining multilanguage, multi-operating-system environments) most do.
+++++
[[[Standard_Library_Overview]]]:begin
Standard-Library Overview
  * Containers
  * General_Utilities
  * Algorithms
  * Diagnostics
  * Strings_and_Characters
  * Input_Output
  * Localization
  * Language_Support
  * Numerics
  * Concurrency
  * C_Compatibility

+++++
Containers
@@@<vector>
    ::: One-dimensional resizable array§31.4.2
@@@<deque>
    ::: Double-ended queue§31.4.2
@@@<forward_list>
    ::: Singly-linked list§31.4.2
@@@<list>
    ::: Doubly-linked list§31.4.2
@@@<map>
    ::: Associative array §31.4.3
@@@<set>
    ::: Set §31.4.3
@@@<unordered_map>
    ::: Hashed associative array §31.4.3.2
@@@<unordered_set>
    ::: Hashed set§31.4.3.2
@@@<queue>
    ::: Queue §31.5.2
@@@<stack>
    ::: Stack §31.5.1
@@@<array>
    ::: One-dimensional fixed-size array§34.2.1
@@@<bitset>
    ::: Array of bool§34.2.2
-----
The associative containers multimap and multiset can be found in <map> and <set>, respectively.
The priority_queue(§31.5.3) is declared in <queue>.

+++++
General_Utilities
@@@<utility>
    ::: Operators and pairs§35.5, §34.2.4.1
@@@<tuple>
    ::: Tuples §34.2.4.2
@@@<type_traits>
    ::: Type traits§35.4.1
@@@<typeindex>
    ::: Use a type_info as a key or a hash code§35.5.4
@@@<functional>
    ::: Function objects§33.4
@@@<memory>
    ::: Resource management pointers§34.3
@@@<scoped_allocator>
    ::: Scoped allocators§34.4.4
@@@<ratio>
    ::: Compile-time rational arithmetic§35.3
@@@<chrono>
    ::: Time utilities§35.2
@@@<ctime>
    ::: C-style date and time§43.6
@@@<iterator>
    ::: Iterators and iterator support§33.1
-----
Iterators provide the mechanism to make standard algorithms generic (§3.4.2, §33.1.4).


+++++
Algorithms
@@@<algorithm>
    ::: General algorithms§32.2
@@@<cstdlib>
    ::: bsearch(),qsort()§43.7
-----
A typical general algorithm can be applied to any sequence (§3.4.2, §32.2) of any type of element.
The C standard library functions bsearch() and qsort() apply to built-in arrays with elements of types without user-defined copy constructors and destructors only (§12.5).

+++++
Diagnostics
@@@<exception>
    ::: Exception class§30.4.1.1
@@@<stdexcept>
    ::: Standard exceptions §30.4.1.1
@@@<cassert>
    ::: Assert macro§30.4.2
@@@<cerrno>
    ::: C-style error handling§13.1.2
@@@<system_error>
    ::: System error support§30.4.3
-----
Assertions using exceptions are described in §13.4.

+++++
Strings_and_Characters
@@@<string>
    ::: String of T Chapter 36
@@@<cctype>
    ::: Character classification§36.2.1
@@@<cwctype>
    ::: Wide-character classification§36.2.1
@@@<cstring>
    ::: C-style string functions§43.4
@@@<cwchar>
    ::: C-style wide-character string functions§36.2.1
@@@<cstdlib>
    ::: C-style allocation functions§43.5
@@@<cuchar>
    ::: C-style multibyte characters
@@@<regex>
    ::: Regular expression matching Chapter 37
-----
The <cstring> header declares the strlen(),strcpy(), etc., family of functions. The <cstdlib> declares atof() and atoi() which convert C-style strings to numeric values.

+++++
Input_Output
@@@<iosfwd>
    ::: Forward declarations of I/O facilities §38.1
@@@<iostream>
    ::: Standardiostreamobjects and operations§38.1
@@@<ios>
    ::: iostreambases §38.4.4
@@@<streambuf>
    ::: Stream buffers §38.6
@@@<istream>
    ::: Input stream template§38.4.1
@@@<ostream>
    ::: Output stream template§38.4.2
@@@<iomanip>
    ::: Manipulators §38.4.5.2
@@@<sstream>
    ::: Streams to/from strings§38.2.2
@@@<cctype>
    ::: Character classification functions§36.2.1
@@@<fstream>
    ::: Streams to/from fi les§38.2.1
@@@<cstdio>
    ::: printf()family of I/O§43.3
@@@<cwchar>
    ::: printf()-style I/O of wide characters§43.3
-----
Manipulators are objects used to manipulate the state of a stream (§38.4.5.2).

+++++
Localization
@@@<locale>
    ::: Represent cultural differences Chapter 39
@@@<clocale>
    ::: Represent cultural differences C-style
@@@<codecvt>
    ::: Code conversion facets §39.4.6
-----
A locale localizes differences such as the output format for dates, the symbol used to represent currency, and string collation criteria that vary among different natural languages and cultures.

+++++
Language_Support
@@@<limits>
    ::: Numeric limits§40.2
@@@<climits>
    ::: C-style numeric scalar-limit macros§40.2
@@@<cfloat>
    ::: C-style numeric floating-point limit macros§40.2
@@@<cstdint>
    ::: Standard integer type names§43.7
@@@<new>
    ::: Dynamic memory management§11.2.3
@@@<typeinfo>
    ::: Run-time type identification support§22.5
@@@<exception>
    ::: Exception-handling support§30.4.1.1
@@@<initializer_list>
    ::: initializer_list§30.3.1
@@@<cstddef>
    ::: C library language support§10.3.1
@@@<cstdarg>
    ::: Variable-length function argument lists§12.2.4
@@@<csetjmp>
    ::: C-style stack unwinding
@@@<cstdlib>
    ::: Program termination§15.4.3
@@@<ctime>
    ::: System clock§43.6
@@@<csignal>
    ::: C-style signal handling
-----
The <cstddef> header defines the type of values returned by sizeof(), size_t, the type of the result of pointer subtraction and of array subscripts, ptrdiff_t(§10.3.1), and the infamous NULL macro (§7.2.2).
C-style stack unwinding (using setjmp and longjmp from <csetjmp>) is incompatible with the use of destructors and with exception handling (Chapter 13, §30.4) and is best avoided.
  C-style stack unwinding and signals are not discussed in this book.

+++++
Numerics
@@@<complex>
    ::: Complex numbers and operations§40.4
@@@<valarray>
    ::: Numeric vectors and operations§40.5
@@@<numeric>
    ::: Generalized numeric operations§40.6
@@@<cmath>
    ::: Standard mathematical functions§40.3
@@@<cstdlib>
    ::: C-style random numbers§40.7
@@@<random>
    ::: Random number generators§40.7
-----
For historical reasons, abs()and div() are found in <cstdlib> rather than in <cmath> with the rest of the mathematical functions (§40.3).

+++++
Concurrency
@@@<atomic>
    ::: Atomic types and operations§41.3
@@@<condition_variable>
    ::: Waiting for an action§42.3.4
@@@<future>
    ::: Asynchronous task§42.4.4
@@@<mutex>
    ::: Mutual exclusion classes§42.3.1
@@@<thread>
    ::: Threads §42.2
-----
C provides standard-library facilities of varying relevance to C++ programmers. The C++ standard library provides access to all such facilities:

+++++
C_Compatibility
@@@<cinttypes>
    ::: Aliases for common integer types§43.7
@@@<cstdbool>
    ::: C bool
@@@<ccomplex>
    ::: <complex>
@@@<cfenv>
    ::: Floating-point environment
@@@<cstdalign>
    ::: C alignment
@@@<ctgmath>
    ::: C ‘‘type generic math’’: <complex> and <cmath>
-----
The <cstdbool> header will not define macros bool,true, or false. The <cstdalign> header will not define a macro alignas. The .h equivalents to <cstdbool>,<ccomplex>,<calign>, and <ctgmath> approximate C++ facilities for C. Avoid them if you can.
The <cfenv> header provides types (such as fenv_t andf except_t), floating-point status flags, and control modes describing an implementation’s floating-point environment.

+++++
[[[Standard_Library_Overview]]]:end



+++++

===
pg855[870/1366] #fused operations
  This technique is based on the idea of using compile-time analysis and closure objects to transfer evaluation of a subexpression into an object representing a composite operation.
    It can be applied to a variety of problems with the common attribute that several pieces of information need to be gathered into one function before evaluation can take place.
    I refer to the objects generated to defer evaluation as composition closure objects, or simply compositors.

  If this composition technique is used to delay execution of all operations, it is referred to as expression templates [Vandevoorde,2002] [Veldhuizen,1995].
    Expression templates systematically use function objects to represent expressions as abstract syntax trees (ASTs).


===
pg829[844/1366] #Enable_if+is_XxxConcept<T>()
  We can define an output function for use in debugging like this:
    template<typename M>
    Enable_if<Matrix_type<M>(),ostream&>
    operator<<(ostream& os, const M& m)
    {
      os << '{';
      for (siz e_t i = 0; i!=rows(m); ++i) {
        os << m[i];
        if (i+1!=rows(m)) os << ',';
      }
      return os << '}';
    }
  Here,Matrix_type is a concept (§24.3).


===
pg814[829/1366]
28.6.3 Forwarding
One of the major uses of variadic templates is forwarding from one function to another.
  Consider how to write a function that takes as arguments something to be called and a possibly empty list of arguments to give to the ‘‘something’’ as arguments:
      template<typename F, typename ... T>
      void call(F&& f, T&&... t)
      {
        f(forward<T>(t)...);
      }
  That is pretty simple and not a hypothetical example.

===
pg800[815/1366]
question ‘‘Can we call f(x) if x is of type X?’’
  ==>> has_f

  struct substitution_failure { }; //represent a failure to declare something
  template<typename T>
  struct substitution_succeeded : std::true_type
  { };
  template<>
  struct substitution_succeeded<substitution_failure> : std::false_type
  { };

  //std::true_type::value == true
  //std::false_type::value == false

  template<typename T>
  struct has_f
  : substitution_succeeded<typename get_f_result<T>::type>
  { };
  template<typename T>
  struct get_f_result {
    private:
      template<typename X>
      static auto check(X const& x) −> decltype(f(x)); //can call f(x)
      static substitution_failure check(...); //cannot call f(x)
    public:
      using type = decltype(check(std::declval<T>()));
  };

  template<typename T>
  class X {
    //...
    Enable_if<Has_f<T>()> use_f(const T&)
    {
      //...
      f(t);
      //...
    }
    //...
  };


===
pg796[811/1366]
// 对于 类模版的成员函数 或 模版函数（非构析）
//      函数的返回类型 编译期计算失败 则 取消 该函数的声明 而非 报错
  template<typename T>
  class Smart_pointer {
    //...
    T& operator∗(); //return reference to whole object
    Enable_if<Is_class<T>(),T>∗ operator−>(); //select a member (for classes only)
    //...
  }


  template<bool B, typename T>
  using Enable_if = typename std::enable_if<B,T>::type;
  template<typename T> bool Is_class()
  {
    return std::is_class<T>::value;
  }

  If Enable_if’s condition evaluates to true, its result is its second argument (here,T).
    If Enable_if’s condition evaluates to false, the whole function declaration of which it is part is completely ignored.
    In this case, if T is a class, we get a definition of operator−>() returning a T∗, and if it is not, we don’t declare anything.


===
pg771[786/1366]
  /////
  avoid virtual base class
    avoid classical multiple-inheritance ‘‘diamond’’ hierarchy
  use empty class as interface class
  /////

  27.4.2 Linearizing Class Hierarchies
  ‘‘Internal Program Representation’’ (IPR) [DosReis,2011] is a general and systematic representation of C++ code as typed abstract syntax trees.


  namespace empty_interface;
    // empty: no non-static data members
    // pure virtual
    ///
  struct empty_interface::Dispatchor; //Visitor
  class empty_interface::I {
    public:
      virtual void accept(Dispatchor&)=0;
      virtual ~I();
        // shared for all derived class
        ///
    protected:
      I(...);
    public:
      virtual ...func...()=0;
  };
  class empty_interface::IA : empty_interface::I {
    protected:
      IA(...);
    public:
      virtual ...func...()=0;
  };
  class empty_interface::IB : empty_interface::IA {
    protected:
      IB(...);
    public:
      virtual ...func...()=0;
  };
  // ... <: ID <: IC <: IB <: IA <: I

  struct empty_interface::Dispatchor {
    virtual void on_I(empty_interface::I&) =0;
    virtual void on_IA(empty_interface::IA&) =0;
    virtual void on_IB(empty_interface::IB&) =0;
    ... ...
  };


  namespace impl;
    //concrete class template
    ///
  template <typename interface>
  class impl::C : interface {
    public:
      using interface_t = interface;
        // shared for all derived class
        ///
      using upper_interface_t = empty_interface::I;
      static_assert(issubclass<interface, upper_interface_t>());

    public:
      void accept(Dispatchor& ops) override {ops.on_I(*this);}
      C(...);
      ...func...() override;
    private:
      ...data members...;
  };
  template <typename interface>
  class impl::CA : impl::C<interface> {
    public:
      using upper_interface_t = empty_interface::IA;
      static_assert(issubclass<interface, upper_interface_t>());

    public:
      void accept(Dispatchor& ops) override {ops.on_IA(*this);}
      CA(...);
      ...func...() override;
    private:
      ...data members...;
  };
  template <typename interface>
  class impl::CB : impl::CA<interface> {
    public:
      using upper_interface_t = empty_interface::IB;
      static_assert(issubclass<interface, upper_interface_t>());

    public:
      void accept(Dispatchor& ops) override {ops.on_IB(*this);}
      CB(...);
      ...func...() override;
    private:
      ...data members...;
  };
  // ... <: CD<interface> <: CC<interface> <: CB<interface> <: CA<interface> <: C<interface> <: interface <: empty_interface::I
  // 具象类 个数 o(n^2): forall CX <: C. forall interface <: I). CX<interface>


===
pg770[785/1366] #empty-base optimization
  I benefit from the empty-base optimization.
  The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8).

===
pg766[781/1366] #avoid overparameterize
  // try to avoid parameters that affect only a few members.

  For this shape example, the Color_scheme and Canvas parameters are unlikely to affect the interface much:
    most member functions will not have them as part of their function type.
    These parameters are an ‘‘implementation detail’’ that escaped into the interface – with likely serious performance implications.
    It is not really the whole hierarchy that needs those parameters;
      it is a few configuration functions and (most likely) a few lower-level drawing/rendering functions.
  It is generally not a good idea to ‘‘overparameterize’’ (§23.4.6.3):
    try to avoid parameters that affect only a few members.
    If only a few member functions are affected by a parameter, try to make those function templates with that parameter. For example:
        class Shape {
          template<typename Color_scheme , typename Canvas>
          void configure(const Color_scheme&, const Canvas&);
          //...
        };
        ////或者 直接 输入 IConfigure& 完全无需 使用模版

  ===
  pg765[780/1366]
    The template parameter lists of a template and one of its template members cannot be combined. For example:
      template<typename T, typename T2>//error
      Ptr<T>::operator Ptr<T2>()
      {
        return Ptr<T2>(p);
      }

      template<typename T>
          template<typename T2>       //ok
      Ptr<T>::operator Ptr<T2>()
      {
        return Ptr<T2>{p};
      }


===
pg755[770/1366]
  It is a good idea to avoid fully general (completely unconstrained) function templates in headers that also contain type definitions, but that’s hard to avoid.
      If you need one, protecting it with a constraints check is often worthwhile.

    template<typename In, typename Out,
        typename = enable_if(
                      Input_iterator<In>()
                      && Output_iterator<Out>()
                      && Assignable<Value_type<Out>,Value_type<In>>()
        )>
    Out copy(In p1, In p2, Out q)
    {
      //...
    }


===
pg749[764/1366] #overload+argument-dependent lookup (ADL)+point-of-instantiation binding==>>error-prone
  26.3.3 Point-of-Instantiation Binding
    //十分惊人！不能接受！
    // 无限定/无印 的 非局部标识 的 绑定既然依赖于 使用的地点，环境敏感，岂不意味着 带相同实参的模版 可能有 多份不同绑定的实现？？
    //    环境敏感！宏！
    // 若 允许同一实参化标识 有不同定义，则 逻辑上 有问题
    // 若 禁止，则 分离编译的两个库 可能无法兼容

  26.3.4 Multiple Instantiation Points
    // C++选择 禁止（见上面 第二选项）
    // 但 环境？是否 融合所有 使用地点 以找出 最佳绑定？
    //  ???环境=?=每个使用地点|每个编译单元中的所有使用地点|可执行文件的所有编译单元中的所有使用地点???
    To avoid surprising name bindings, try to limit context dependencies in templates.
  [6] Keep the binding context unchanged between instantiation points; §26.3.4.
  [2] Explicitly instantiate if you need exact control of the instantiation environment; §26.2.2.

===
pg748[763/1366] #typename/template
  # T::xxx
  # typename T::xxx
  # T::template xxx
  # p->template xxx<...>
  # x.template xxx<...>
  #我想，关键在于如何 解释 『<』，小于号？模版参数括号？
  Compared to the use of typename to explicitly state that a name is assumed to name a type, the use of template to explicitly state that a name is assumed to name a template is rare.
    Note the difference in the placement of the disambiguating keyword:typename appears before the qualified name and template immediately before the template name.

        template<typename Container>
        void fct(Container& c)
        {
          Container::value_type v1 = c[7];//syntax error: value_type is assumed to be a non-type name
          typename Container::value_type v2 = c[9];//OK: value_type assumed to name a type
          auto v3 = c[11];//OK: let the compiler figure it out
          //...
        }

    We can avoid such awkward use of typename by introducing a type alias (§23.6). For example:
        template<typename T>
        using Value_type<T> = typename T::value_type;
        template<typename Container>
        void fct2(Container& c)
        {
          Value_type<Container> v1 = c[7];//OK
          //...
        }
    Naming a member template after a.(dot),−>, or::requires similar use of the keyword template.
        For example:
        class Pool {//some allocator
          public:
            template<typename T> T∗ get();
            template<typename T> void release(T∗);
            //...
        };
        template<typename Alloc>
        void f(Alloc& all)
        {
          int∗ p1 = all.get<int>(); //syntax error: get is assumed to name a non-template
          int∗ p2 = all.template get<int>(); //OK: get() is assumed to be a template
          //...
        }
        void user(Pool& pool){
        {
          f(pool);
          //...
        }

===
pg747[762/1366]
  #实参表达式(函数调用实参，函数模版实例化实参)、函数类型
  a function call is said to depend on a template argument if and only if one of these conditions holds:
      [1] The type of the actual argument depends on a template parameter T according to the type deduction rules (§23.5.2), for example,f(T(1)),f(t),f(g(t)), and f(&t), assuming thatt is a T.
      [2] The function called has a parameter that depends on T according to the type deduction rules (§23.5.2), for example,f(T),f(list<T>&), and f(const T∗).
  Basically, the name of a called function is dependent if it is obviously dependent by looking at its arguments or at its formal parameters.
  A call that by coincidence has an argument that matches an actual template parameter type is not dependent.

  pg748[763/1366]
  When the compiler sees a template definition, it determines which names are dependent (§26.3.1). If a name is dependent, looking for its declaration is postponed until instantiation time (§26.3.3).



===
pg746[761/1366] #name binding
  The process of finding the declaration for each name explicitly or implicitly used in a template is called name binding. The general problem with template name binding is that three contexts are involved in a template instantiation and they cannot be cleanly separated:
      [1] The context of the template definition
      [2] The context of the argument type declaration
      [3] The context of the use of the template

  When defining a function template, we want to assure that enough context is available for the template definition to make sense in terms of its actual arguments without picking up ‘‘accidental stuff’’ from the environment of a point of use.
    To help with this, the language separates names used in a template definition into two categories:
      [1]Dependent names:
          names that depend on a template parameter. Such names are bound at a point of instantiation (§26.3.3).
          In the sum() example, the definition of + can be found in the instantiation context because it takes operands of the template argument type.
      [2]Nondependent names:
          names that don’t depend on a template parameter. Such names are bound at the point of definition of the template (§26.3.2).
          In the sum() example, the template vector is defined in the standard header<vector>, and the Boolean tracing is in scope when the definition of sum() is encountered by the compiler.

  To be considered, both dependent and independent names must either be in scope at their point of use or be found by argument-dependent lookup (ADL; §14.2.4).


===
pg744[759/1366]
  // 隐式实例化 只生成用户用到的部分(例外:虚函数，以此包括一切依赖)，可避免 某些 编译错误（泛型，但实际参数 不支持）
  // 显式实例化，生成 所有 静态对象，成员函数；因为 是用于 分离式编译，可能 用作 静态链接库，必须 全部生成。并且 不得重复 实例化！（不论 显式、隐式、特化）
  // 如何避免 重复实例化？外部实例化声明！

    // 头文件，模版声明
    template<typename T> class MyVector;
    template<typename T> class MyVector<T*>;
    template<> class MyVector<void*>;
    // 头文件，模版定义
    template<typename T> class MyVector{...};
    template<typename T> class MyVector<T*>{...};
    template<> class MyVector<void*>{...};
    // 头文件，外部实例化声明，阻止 隐式实例化
    extern template class MyVector<int>;
      //suppresses implicit instantiation
      //explicitly instantiate elsewhere

    // 源文件，显式实例化定义，只此一处实例化
    template class MyVector<int>;

===
pg736[751/1366]
  It is essential that every use of a template for a given set of template arguments be implemented by the same specialization.
    If not, the type system is broken, so that identical uses of a template in different places may yield different results and objects created in different parts of a program may not be compatible.
    Clearly that would be disastrous, so a programmer must take care that explicit specialization is consistent throughout a program.
    In principle, implementations are capable of detecting inconsistent specialization, but the standard does not require them to and some don’t.


  All specializations of a template must be declared in the same namespace as the primary template.
    If used, a specialization that is explicitly declared (as opposed to generated from a more general template) must also be explicitly defined somewhere (§23.7).
    In other words, explicitly specializing a template implies that no (other) definition is generated for that specialization.


===
pg731[746/1366]pg733[748/1366] #code bloat代码爆炸~type erasure类型擦除
  The default behavior of most C++ implementations is to replicate the code for template functions. This is usually good for run-time performance, but unless care is taken, it leads to code bloat in critical cases such as the Vector example.
  Fortunately, there is an obvious solution. Containers of pointers can share a single implementation. This can be expressed through specialization. First, we define a version (a specialization) of Vector for pointers to void:
    template<>
    class Vector<void∗> { //complete specialization
      void∗∗ p;
      //...
      void∗& operator[](int i);
    };
  This specialization can then be used as the common implementation for all Vectors of pointers.
  Another use would be to implement unique_ptr<T> based on a single shared implementation class storing a void∗.
    ///
  To define a specialization that is used for every Vector of pointers and only for Vectors of pointers, we can write:
    template<typename T>
    class Vector<T∗> : private Vector<void∗> { //partial specialization
      ...
    };

  /////
    template<typename T> class Vector {...}; //general vector type
    template<typename T> class Vector<T∗> : private Vector<void∗> {...}; //partial specialization
    template<> class Vector<void∗> {...}; //complete specialization
  /////
  pg733[748/1366]
    Variants of the technique of using a single run-time representation for values of a number of types and relying on the (static) type system to ensure that they are used only according to their declared type has been called type erasure. In the context of C++, it was first documented in the original template paper [Stroustrup,1988].


===
pg730[745/1366] #policy+default vs type-traits
  The technique of supplying a policy through a template argument and then defaulting that argument to supply the most common policy is almost universal in the standard library (e.g., §32.4).
      Curiously enough, it is not used for basic_string(§23.2, Chapter 36) comparisons. Instead, the standard-library string relies on char_traits(§36.2.2). Similarly, the standard algorithms rely on iterator_traits(§33.1.3) and the standard-library containers rely on allocators(§34.4). The use of traits is presented in §28.2.4.

===
pg729[744/1366]
  The semantic checking of a default argument for a template parameter is done only if that default argument is actually used.
    In particular, as long as we refrain from using the default template argument less<Key>, we can compare() values of a type X for which less<X> wouldn’t compile.
    This point is crucial in the design of the standard containers (e.g.,std::map), which rely on a template argument to specify default values (§31.4).




===
pg724[739/1366] #template value parameter
  An argument for a template value parameter can be (§iso.14.3.2):
    •An integral constant expression (§10.4)
    •A pointer or a reference to an object or a function with external linkage (§15.2)
    •A nonoverloaded pointer to member (§20.6)
    •A null pointer (§7.2.2)
  A pointer used as a template argument must be of the form "&of", where "of" is the name of an object or a function, or of the form "f", where "f" is the name of a function.
    A pointer to member must be of the form "&X::of", where "of" is the name of a member.
    In particular, a string literal is not acceptable as a template argument:
    template<typename T, char∗ label>
    class X {
      //...
    };
    X<int,"BMW323Ci"> x1;//error : str ing literal as template argument
    char lx2[] = "BMW323Ci";
    X<int,lx2> x2;//OK: lx2 has exter nal linkage
  This restriction, like the one against floating-point template value arguments, exists to simplify implementation of separately compiled translation units.
    It is best to think of template value arguments as a mechanism for passing integers and pointers to functions. Resist the temptation to try something more clever.
    Unfortunately (for no fundamental reason), literal types (§10.4.3) cannot be used as template value parameters.
    The value template arguments are the mechanism for some more advanced compile-time computation techniques (Chapter 28).

  ///自相矛盾，前面说 只有 整数 才行，下面 直接上 std::string
  A type template parameter can be used as a type later in a template parameter list. For example:
    template<typename T, T default_value>
    class Vec {
      //...
    };
    Vec<int,42> c1;
    Vec<string,""> c2;
  This becomes particularly useful when combined with a default template argument (§25.2.5); for example:
    template<typename T, T default_value = T{}>
    class Vec {
      //...
    };
    Vec<int,42> c1;
    Vec<int> c11;//default_value is int{}, that is, 0
    Vec<string,"for tytwo"> c2;
    Vec<string> c22;//default_value is string{}; that is, ""

===
pg723[738/1366]
  To be used as a template argument, a type must be in scope and accessible. For example:
    class X {
      class M { /*...*/ };
      //...
      void mf();
    };
    void f()
    {
      struct S { /*...*/ };
      vector<S> vs;//OK
      vector<X::M> vm;//error : X::M is private
      //...
    }
    void M::mf()
    {
      vector<S> vs;//error : no S in scope
      vector<M> vm;//OK
      //...
    };

===
pg657[672/1366]
  It is best to avoid calling virtual functions during construction and destruction.
  ///虚函数表 指针 在构析过程中，一直在变化，虚函数 并非 最外派生类


===
pg655[670/1366]
  visitor pattern

  struct Dispatchor; //Visitor
  struct I{
    virtual void accept(Dispatchor&)=0;
      // not: virtual void accept(const Dispatchor&)const =0;
  };
  struct X : I {
    void accept(Dispatchor& ops) override {ops.on_X(*this);}
  };
  struct Y : I {
    void accept(Dispatchor& ops) override {ops.on_Y(*this);}
  };
  struct Dispatchor{
    virtual void on_X(X&)=0;
    virtual void on_Y(Y&)=0;
      // not: virtual void on_Y(const Y&)const =0;
      // maybe: virtual void on(Y&)=0;
  };


===
pg653[668/1366] #double dispatch === double dynamic dispatch
  22.3.1 Double Dispatch
    class X;
    class Y;
    struct I{
      void f(const I& i)const {i.flip_f(*this);}
      virtual void flip_f(const I&)const=0;
      virtual void f(const X&)const=0;
      virtual void f(const Y&)const=0;
    };
    struct X: public I{
      void flip_f(const I& i)const override {i.f(*this);}
      void f(const X&)const override{...}
      void f(const Y&)const override{...}
    };
    struct Y: public I{
      void flip_f(const I& i)const override {i.f(*this);}
      void f(const X&)const override{...}
      void f(const Y&)const override{...}
    };


===
pg648[663/1366]
  22.2.3 static_cast and dynamic_cast
    A dynamic_cast can cast from a polymorphic virtual base class to a derived class or a sibling class (§22.2.1).
      A static_cast(§11.5.2) does not examine the object it casts from, so it cannot:
        void g(Radio& r)
        {
          Receiver∗ prec = &r;//Receiver is an ordinary base of Radio
          Radio∗ pr = static_cast<Radio∗>(prec); //OK, unchecked
          pr = dynamic_cast<Radio∗>(prec); //OK, run-time checked

          Storable∗ ps = &r;//Storable is a virtual base of Radio
          pr = static_cast<Radio∗>(ps); //error : cannot cast from virtual base
          pr = dynamic_cast<Radio∗>(ps); //OK, run-time checked
        }
    The dynamic_cast requires a polymorphic operand because there is no information stored in a non-polymorphic object that can be used to find the objects for which it represents a base.
      In particular, an object of a type with layout constraints determined by some other language – such as Fortran or C – may be used as a virtual base class.
          For objects of such types, only static type information will be available.
      However, the information needed to provide run-time type identification includes the information needed to implement the dynamic_cast.
    Why would anyone want to use a static_cast for class hierarchy navigation? There is a run-time cost associated with the use of a dynamic_cast(§22.2.1).
      More significantly, there are millions of lines of code that were written before dynamic_cast became available.
        This code relies on alternative ways of making sure that a cast is valid, so the checking done by dynamic_cast is seen as redundant.
        However, such code is typically written using the C-style cast (§11.5.3); often obscure errors remain. Where possible, use the safer dynamic_cast.


    /// void*
    The compiler cannot assume anything about the memory pointed to by a void∗.
      This implies that dynamic_cast – which must look into an object to determine its type – cannot cast from a void∗.
      For that, a static_cast is needed. For example:
        Radio∗ f1(void∗ p)
        {
          Storable∗ ps = static_cast<Storable∗>(p); //trust the programmer
          return dynamic_cast<Radio∗>(ps);
        }


===
pg643[658/1366]
  22.2.1 dynamic_cast
  // fail ==>> nullptr|throw bad_cast() exception
  //    upcast: to non-public baseclass
  //    upcast: to too many replicated baseclass
  //    downcast: from virtual baseclass to too mamy replicated intermediate replicated derived_class
  //    downcast or crosscast: required ptr/ref to polymorphic type


===
pg639[654/1366] #mixin
  A class that provides some – but not all – of the implementation for a virtual base class is often called a mixin.


===
pg638[653/1366] #浮动共享空基类 还是 重复接口
  How do we choose between virtual base classes and replicated base classes for our interfaces?
    Most often, of course, we don’t get a choice because we have to conform to an existing design.
    When we do have a choice, we can take into account that (surprisingly)
        the replicated base solution tends to lead to slightly smaller objects (because there is no need for data structures supporting sharing)
        and that we often get our interface objects from ‘‘virtual constructors’’ or ‘‘factory functions’’ (§21.2.4).

===
pg633[648/1366] #virtual base containing data
  Why would someone want to use a virtual base containing data? I can think of three obvious ways for two classes in a class hierarchy to share data:
    [1] Make the data nonlocal (outside the class as a global or namespace variable).
    [2] Put the data in a base class.
    [3] Allocate an object somewhere and give each of the two classes a pointer.
  Option [1], nonlocal data, is usually a poor choice because we cannot control what code accesses the data and how.
      It breaks all notions of encapsulation and locality.
  Option [2], put the data in a base class, is usually the simplest.
      However, for single inheritance that solution makes useful data (and functions) ‘‘bubble up’’ to a common base class; often it ‘‘bubbles’’ all the way to the root of an inheritance tree.
      This means that every member of the class hierarchy gets access. That is logically very similar to using nonlocal data and suffers from the same problems.
      So we need a common base that is not the root of a tree – that is, a virtual base.
  Option [3], sharing an object accessed through pointers, makes sense.
      However, then constructor(s) need to set aside memory for that shared object, initialize it, and provide pointers to the shared object to objects needing access.
      That is roughly what constructors do to implement a virtual base.
  If you don’t need sharing, you can do without virtual bases, and your code is often better and typically simpler for it. However, if you do need sharing within a general class hierarchy, you basically have a choice between using a virtual base and laboriously constructing your own variants of the idea.




===
pg624[639/1366] #factory
  Passing arguments to such ‘‘virtual constructors’’ is a bit tricky. In particular, we cannot override the base class functions that represent the interface with different arguments in different derived classes. This implies that a fair bit of foresight is required to design the factory class’s interface.

  ///
  // uniform ?frontend === interface === no mutable state class
  // diff version backend === implementation inheritance
  // user see interface inheritance only + main() driver use factory class of diff version
  // inherit one implementation but impl many interface


===
pg610[625/1366] #contravariance
  20.6.3 Base and Derived Members
  A derived class has at least the members that it inherits from its base classes. Often it has more.
    This implies that we can safely assign a pointer to a member of a base class to a pointer to a member of a derived class, but not the other way around.
    This property is often called contravariance.

  This contravariance rule appears to be the opposite of the rule that says we can assign a pointer to a derived class to a pointer to its base class.
    In fact, both rules exist to preserve the fundamental guarantee that a pointer may never point to an object that doesn’t at least have the properties that the pointer promises.

===
pg608[623/1366]
  A pointer to member can be obtained by applying the address-of operator,&, to a fully qualified class member name, for example,&Std_interface::suspend. A variable of type ‘‘pointer to member of class X’’ is declared using a declarator of the form X::∗.
    using Pstd_mem = void (Std_interface::∗)(); //pointer-to-member type
    void f(Std_interface∗ p)
    {
      Pstd_mem s = &Std_interface::suspend;//pointer to suspend()
      p−>suspend(); //direct call
      p−>∗s(); //call through pointer to member
        // <==> (*p).*s()
    }

  ///
  using Pmfi = void (C::∗)(int); //pointer to member function of C taking an int
  using Pm = const char∗ C::∗; //pointer to char* data member of C


===
pg606[621/1366]
  20.5.2.1 Multiple Inheritance and Access Control
  If the name of a base class can be reached through multiple paths in a multiple-inheritance lattice (§21.3), it is accessible if it is accessible through any path. For example:
    struct B {
      int m;
      static int sm;
      //...
    };
    class D1 : public virtual B { /*...*/ } ;
    class D2 : public virtual B { /*...*/ } ;
    class D12 : public D1, private D2 { /*...*/ };
    D12∗ pd = new D12;
    B∗ pb = pd;//OK: accessible through D1
    int i1 = pd−>m;//OK: accessible through D1



  If a single entity is reachable through several paths, we can still refer to it without ambiguity. For example:
    class X1 : public B { /*...*/ } ;
    class X2 : public B { /*...*/ } ;
    class XX : public X1, public X2 { /*...*/ };
    XX∗ pxx = new XX;
    int i1 = pxx−>m;//error, ambiguous: XX::X1::B::m or XX::X2::B::m?
    int i2 = pxx−>sm;//OK: there is only one B::sm in an XX (sm is a static member)




===
pg604[619/1366]
  A derived class can access a base class’s protected members only for objects of its own type:
    class Buffer {
    protected:
      char a[128];
      //...
    };
    class Linked_buffer : public Buffer {
      //...
    };
    class Circular_buffer : public Buffer {
      //...
      void f(Linked_buffer∗ p)
      {
        a[0] = 0;//OK: access to Circular_buffer’s own protected member
        p−>a[0] = 0;//error : access to protected member of different type
      }
    };
  This prevents subtle errors that would otherwise occur when one derived class corrupts data belonging to other derived classes.


  ///
  Members declared protected are far more open to abuse than members declared private. In particular, declaring data members protected is usually a design error. Placing significant amounts of data in a common class for all derived classes to use leaves that data open to corruption. Worse, protected data, like public data, cannot easily be restructured because there is no good way of finding every use. Thus, protected data becomes a software maintenance problem.

===
pg603[618/1366]
  A compiler may reorder sections of a class with separate access specifiers (§8.2.6). For example:
    class S {
      public: int m1;
      public: int m2;
    };
  The compiler may decide for m2 to precede m1 in the layout of an S object. Such reordering could come as a surprise to the programmer and is implementation-dependent, so don’t use multiple access specifiers for data members without good reason.

  // protected unchecked version
  20.5.1 protected Members
  When designing a class hierarchy, we sometimes provide functions designed to be used by implementers of derived classes but not by the general user.
    For example, we may provide an (efficient) unchecked access function for derived class implementers and (safe) checked access for others.
    Declaring the unchecked version protected achieves that. For example:


===
pg596[611/1366]
  20.3.6 Return Type Relaxation
    There is a relaxation of the rule that the type of an overriding function must be the same as the type of the virtual function it overrides.
      That is, if the original return type was B∗, then the return type of the overriding function may be D∗, provided B is a public base of D.
       Similarly, a return type ofB& may be relaxed to D&.
       This is sometimes called the covariant return rule.
    This relaxation applies only to return types that are pointers or references, and not to ‘‘smart pointers’’ such as unique_ptr(§5.2.1). In particular, there is not a similar relaxation of the rules for argument types because that would lead to type violations.


===
pg595[610/1366]
  20.3.5.1 Inheriting Constructors
    struct B1 {
      B1(int) { }
    };
    struct D1 : B1 {
      using B1::B1; //implicitly declares D1(int)
        // <==> D1(int i) : B1(i) { }
      string s;//string has a default constructor
      int x;//we ‘‘forgot’’ to provide for initialization of x
        // int x {0};//note: x is initialized
    };
    void test()
    {
      D1 d {6};//oops: d.x is not initialized
      D1 e;//error : D1 has no default constructor
    }


===
pg593[608/1366]
  20.3.5 using Base Members
  Functions do not overload across scopes (§12.3.3). For example:
    struct Base {
      void f(int);
    };
    struct Derived : Base {
      void f(double);
    };
    void use(Derived d)
    {
      d.f(1); //call Derived::f(double)
      Base& br = d
      br.f(1); //call Base::f(int)
    }
  This can surprise people, and sometimes we want overloading to ensure that the best matching member function is used. As for namespaces,using-declarations can be used to add a function to a scope. For example:
    struct D2 : Base {
      using Base::f;//bring all fs from Base into D2
      void f(double);
    };
    void use2(D2 d)
    {
      d.f(1); //call D2::f(int), that is, Base::f(int)
      Base& br = d
      br.f(1); //call Base::f(int)
    }
  We cannot use using-directives to bring all members of a base class into a derived class.


===
pg590[605/1366]
  The override specifier comes last in a declaration, after all other parts.
  Curiously,override/final is not a keyword; it is what is called a contextual keyword.

===
pg588[603/1366]
  A virtual function invoked from a constructor or a destructor reflects that the object is partially constructed or partially destroyed (§22.4). It is therefore typically a bad idea to call a virtual function from a constructor or a destructor.
  // 虚函数表 指针 会在 构析 过程中 变动？


===
pg544[559/1366] #conversion function
  Note that the type being converted to is part of the name of the operator and cannot be repeated as the return value of the conversion function:
      Tiny::operator int() const { return v; }//right
      int Tiny::operator int() const { return v; }//error
  In this respect also, a conversion operator resembles a constructor.


  If both user-defined conversions and user-defined operators are defined, it is possible to get ambiguities between the user-defined operators and the built-in operators. For example:
      int operator+(Tiny,Tiny);
      void f(Tiny t, int i)
      {
        t+i; //error, ambiguous: ‘‘operator+(t,Tiny(i))’’ or ‘‘int(t)+i’’?
      }
  It is therefore often best to rely on user-defined conversions or user-defined operators for a given type, but not both.


===
pg541[556/1366]
18.3.4 Literals

  class complex {
  public:
    constexpr complex(double r =0, double i =0) : re{r}, im{i} { }
    //...
  }
  constexpr complex z2 {1.2,12e3}; //guaranteed compile-time initialization



  It is possible to go further and introduce a user-defined literal (§19.2.6) in support of our complex type. In particular, we could defineito be a suffix meaning ‘‘imaginary.’’ For example:
    constexpr complex<double> operator "" i(long double d)//imaginar y literal
    {
      return {0,d};//complex is a literal type
    }

    complex z1 {1.2+12e3i};
    complex f(double d)
    {
      auto x {2.3i};
      return x+sqrt(d+12e3i)+12e3i;
    }
  This user-defined literal gives us one advantage over what we get from constexpr constructors:
    we can use user-defined literals in the middle of expressions
    where the {} notation can only be used when qualified by a type name.
    The example above is roughly equivalent to:
      complex z1 {1.2,12e3};
      complex f(double d)
      {
        complex x {0,2.3};
        return x+sqrt(complex{d,12e3})+complex{0,12e3};
      }

===
pg540[555/1366]
  An object constructed by explicit or implicit use of a constructor in an expression is automatic and will be destroyed at the first opportunity (see §10.3.4).

  No implicit user-defined conversions are applied to the left-hand side of a.(or a−>). This is the case even when the . is implicit. For example:
    void g(complex z)
    {
      3+z; //OK: complex(3)+z
      3.operator+=(z); //error : 3 is not a class object
      3+=z; //error : 3 is not a class object
    }
  Thus, you can approximate the notion that an operator requires an lvalue as its left-hand operand by making that operator a member. However, that is only an approximation because it is possible to access a temporary with a modifying operation, such as operator+=():
    complex x {4,5}
    complex z {sqrt(x)+={1,2}};//like tmp=sqrt(x), tmp+={1,2}


===
pg536[551/1366]

  complex operator+(complex a, complex b)
  {
    return a += b;//access representation through +=
  }

  Composite assignment operators such as += and ∗= tend to be simpler to define than their ‘‘simple’’ counterparts + and ∗.
    This surprises most people at first, but it follows from the fact that three objects are involved in a + operation (the two operands and the result), whereas only two objects are involved in a += operation.
    In the latter case, run-time efficiency is improved by eliminating the need for temporary variables. For example:
      inline complex& complex::operator+=(complex a)
      {
        re += a.re;
        im += a.im;
        return ∗this;
      }
  This does not require a temporary variable to hold the result of the addition and is simple for a compiler to inline perfectly.

  //但如果考虑到 『异常保证』，先实现不破坏 输入 的 +()，再用 swap()实现 +=() 更合理。
  //      模版的话，如何 保证 im += a.im 无异常？


===
pg534[549/1366]
  Consider a binary operator@. If x is of type X and y is of type Y, x@yis resolved like this:
    •If X is a class, look for operator@ as a member of X or as a member of a base of X; and
    •look for declarations of operator@ in the context surrounding x@y; and
    •if X is defined in namespace N, look for declarations of operator@ in N; and
    •if Y is defined in namespace M, look for declarations of operator@ in M.

  Declarations for several operator@s may be found and overload resolution rules (§12.3) are used to find the best match, if any.
    This lookup mechanism is applied only if the operator has at least one operand of a user-defined type.
    Therefore, user-defined conversions (§18.3.2, §18.4) will be considered.
    Note that a type alias is just a synonym and not a separate user-defined type (§6.5).

  Unary operators are resolved analogously.

  Note that in operator lookup no preference is given to members over nonmembers.
    This differs from lookup of named functions (§14.2.4).
    The lack of hiding of operators ensures that built-in operators are never inaccessible and that users can supply new meanings for an operator without modifying existing class declarations.

    X operator!(X);
    struct Z {
      Z operator!(); //does not hide ::operator!()
      X f(X x) { /*...*/ return !x; }//invoke ::operator!(X)
      int f(int x) { /*...*/ return !x; }//invoke the built-in ! for ints
    };


===
pg532[547/1366]
18.2.3 Operators and User-Defined Types
  An operator function must either be a member or take at least one argument of a user-defined type (functions redefining thenew and delete operators need not).
    This rule ensures that a user cannot change the meaning of an expression unless the expression contains an object of a user-defined type.
    In particular, it is not possible to define an operator function that operates exclusively on pointers. This ensures that C++ is extensible but not mutable (with the exception of operators=,&, and,for class objects).

===
pg530[545/1366]

  any binary operator @:
    [aa@bb] === [aa.operator@(bb)]or[operator@(aa,bb)]

  any prefix unary operator @:
    [@aa] === [aa.operator@()]or[operator@(aa)]
  any postfix unary operator @:
    [aa@] === [aa.operator@(int)]or[operator@(aa,int)]


  The operators operator=(§18.2.2),operator[](§19.2.1),operator()(§19.2.2), and operator−> (§19.2.3) must be non-static member functions.
    #cannot be non-member functions
    #cannot be free functions

  The default meaning of &&,||, and ,(comma) involves sequencing: the first operand is evaluated before the second (and for && and || the second operand is not always evaluated). This special rule does not hold for user-defined versions of &&,||, and ,(comma); instead these operators are treated exactly like other binary operators.
    #!!!!  operator,   ?????



===
pg529[544/1366]
  The following operators cannot be defined by a user:
    ::
      scope resolution (§6.3.4, §16.2.12)
    .
      member selection (§8.2)
    .∗
      member selection through pointer to member (§20.6)
    ?:
      conditional evaluation (§9.4.1)
    sizeof
      size of object (§6.2.8)
    alignof
      alignment of object (§6.2.9)
    typeid
      type_infoof an object (§22.5)

===
pg524[539/1366] # =delete
  we can delete any function that we can declare. For example, we can eliminate a specialization from the set of possible specializations of a function template:
    template<class T>
    T∗ clone(T∗ p) //return copy of *p
    {
      return new T{∗p};
    };
    Foo∗ clone(Foo∗) = delete; //don’t try to clone a Foo
    void f(Shape∗ ps, Foo∗ pf)
    {
      Shape∗ ps2 = clone(ps); //fine
      Foo∗ pf2 = clone(pf); //error : clone(Foo*) deleted
    }


    ===
    class Not_on_stack {
      //...
      ˜Not_on_stack() = delete;
    };
    class Not_on_free_store {
      //...
      void∗ operator new(siz e_t) = delete;
    };


    void f()
    {
      Not_on_stack v1; //error : can’t destroy
      Not_on_free_store v2;//OK
      Not_on_stack∗ p1 = new Not_on_stack; //OK
      Not_on_free_store∗ p2 = new Not_on_free_store; //error : can’t allocate
    }


===
pg517[532/1366]
17.6 Generating Default Operations
  By default, a class provides:
    •A default constructor:X()
    •A copy constructor:X(const X&)
    •A copy assignment:X& operator=(const X&)
    •A move constructor:X(X&&)
    •A move assignment:X& operator=(X&&)
    •A destructor:˜X()


  if the programmer takes control by defining one or more of those operations, the generation of related operations is suppressed:
  •If the programmer declares any constructor for a class, the default constructor is not generated for that class.
  •If the programmer declares a copy operation, a move operation, or a destructor for a class, no copy operation, move operation, or destructor is generated for that class.
  Unfortunately, the second rule is only incompletely enforced: for backward compatibility, copy constructors and copy assignments are generated even if a destructor is defined. However, that generation is deprecated in the ISO standard (§iso.D), and you should expect a modern compiler to warn against it.
  If necessary, we can be explicit about which functions are generated (§17.6.1) and which are not (§17.6.4).
    =default;
    =delete;



===
pg516[531/1366] #move constructor/assignment
  template<class T>
  void swap(T& a, T& b)//"perfect swap" (almost)
  {
    T tmp = std::move(a);
    a = std::move(b);
    b = std::move(tmp);
  }




===
pg513[528/1366] #slicing: copy base of derived
  This phenomenon is called slicing. It may be exactly what you intended (e.g., see the copy constructor for D in §17.5.1.2 where we pass selected information to a base class), but typically it is a subtle bug. If you don’t want slicing, you have two major tools to prevent it:
    [1] Prohibit copying of the base class:deletethe copy operations (§17.6.4).
    [2] Prevent conversion of a pointer to a derived to a pointer to a base: make the base class a private or protected base (§20.5).


===
pg504[519/1366]
  17.4.4 In-Class Initializers
    class A {
    public:
      int a {7};
      int b = 77;
    };
  // 任何 构造函数，只要 漏掉 数据成员 的 初始化，则 使用 声明 时 的 初始化。
  default in-class initializers provide an opportunity for documentation of common cases.

===
pg502[517/1366]
  17.4.3 Delegating Constructors
  class X {
    int a;
    public:
    X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
    X() :X{42} { }
    X(string s) :X{to<int>(s)} { }//§25.2.5.1
    //...
  };
  That is, a member-style initializer using the class’s own name (its constructor name) calls another constructor as part of the construction. Such a constructor is called a delegating constructor (and occasionally a forwarding constructor).


  An object is not considered constructed until its constructor completes (§6.4.2). When using a delegating constructor, the object is not considered constructed until the delegating constructor completes – just completing the delegated-to constructor is not sufficient. A destructor will not be called for an object unless its original constructor completed.
    // 这毫无道理，既然叫『构造函数』，那它执行结束，自然有一个新对象(不变式 以建立，资源 以获取)！纵是 委托/转发 又如何？原来的 委托方 构造函数 其函数体 可视为 成员函数 修改 状态 但 维持 不变式。
    //    除非 委托构造函数 并不是 构造函数，仅止是 不完全的 构造 前置 函数。那应该 给予 新称呼，不该叫 构造函数。


===
pg501[516/1366]
  The members’ constructors are called before the body of the containing class’s own constructor is executed (§17.2.3).
    The constructors are called in the order in which the members are declared in the class rather than the order in which the members appear in the initializer list.

  If a member constructor needs no arguments, the member need not be mentioned in the member initializer list.
    Note that an ‘‘implicitly initialized’’ member of a built-in type is left uninitialized (§17.3.1).

  A reference member or aconstmember must be initialized (§7.5, §7.7, §17.3.3).


===
pg496[511/1366]
17.3.4.1 initializer_list Constructor Disambiguation
  •If either a default constructor or an initializer-list constructor could be invoked, prefer the default constructor.
•If both an initializer-list constructor and an ‘‘ordinary constructor’’ could be invoked, prefer the initializer-list constructor.
    necessary to avoid different resolutions based on different numbers of elements.
    if T{a,b} not ok, then try T(a,b)


===
pg495[510/1366] #in-class member initializer
  References and consts must be initialized (§7.7, §7.5). Therefore, a class containing such members cannot be default constructed unless the programmer supplies in-class member initializers (§17.4.4) or defines a default constructor that initializes them (§17.4.1). For example:
    int glob {9};
    struct X {
      const int a1 {7};//OK
      const int a2;//error : requires a user-defined constructor
      const int& r {9};//OK
      int& r1 {glob};//OK
      int& r2;//error : requires a user-defined constructor
    };
    X x;//error : no default constructor for X



===
pg494[509/1366]
  for a built-in type the default constructor is not invoked for uninitialized non-static variables (§17.3). The default value of a built-in type is 0 for integers,0.0 for floating-point types, and nullptr for pointers.
    #0 for enum!!
===
pg492[507/1366]
  {}initialization === universal initialization
      the notation can be used everywhere
  {}initialization is uniform

  vector<int> v1 {77};//one element with the value 77
  vector<int> v2(77);//77 elements with the default value 0
===
pg490[505/1366]
  vs:
    //非静态变量
    T beta;
    T beta {};

  for local variables and free-store objects, the default initialization is done only for members of class type, and members of built-in type are left uninitialized, so the value of beta is {"","",unknown}.
  The reason for this complication is to improve performance in rare critical cases. For example:
    struct Buf {
      int count;
      char buf[16∗1024];
    };


===
pg489[504/1366]
  17.3.1 Initialization Without Constructors
  we can initialize objects of a class for which we have not defined a constructor using
    •memberwise initialization,
      T x { {}, {}, a, ...};
      memberwise initialization works only if we can access the members.
    •copy initialization, or
      //? T x = y;
      T x {y}; //? //从类型上看，数据成员类型 严格小于 整个结构体 类型，与上面 无歧义，没毛病
    •default initialization (without an initializer or with an empty initializer list).
      T x {};

===
pg487[502/1366]
  memberwise initialization can be used if initializers are needed. For example:
    struct X { X(int); };
    struct S2 {
      X x;
    };
    S2 x1;//error :
    S2 x2 {1}; //OK: x2.x is initialized with 1
  See also §17.3.1.

===
pg486[501/1366]
  Constructors and destructors interact correctly with class hierarchies (§3.2.4, Chapter 20). A constructor builds a class object ‘‘from the bottom up’’:
    [1] first, the constructor invokes its base class constructors,
    [2] then, it invokes the member constructors, and
    [3] finally, it executes its own body.

  A destructor ‘‘tears down’’ an object in the reverse order:
    [1] first, the destructor executes its own body,
    [2] then, it invokes its member destructors, and
    [3] finally, it invokes its base class destructors.
  In particular, a virtual base is constructed before any base that might use it and destroyed after all such bases (§21.3.5.1). This ordering ensures that a base or a member is not used before it has been initialized or used after it has been destroyed.

  Constructors execute member and base constructors in declaration order (not the order of initializers): if two constructors used a different order, the destructor could not (without serious overhead) guarantee to destroy in the reverse order of construction. See also §17.4.


===
pg479[494/1366]
  [8] Make a function a member only if it needs direct access to the representation of a class; §16.3.2.
  [9] Use a namespace to make the association between a class and its helper functions explicit; §16.3.2.

===
pg474[489/1366]
  enum class X{a=1};
  X x{}; // x is not a; x===0!!!! === a^a as-if bit-op ^ & | are working

===
pg462[477/1366]
    16.2.9.2 Physical and Logical Constness
    * mutable data member
    * ptr to non-const obj

===
pg445[460/1366]
  [10] Distinguish between users’ interfaces and implementers’ interfaces; §15.3.2.
  [11] Distinguish between average users’ interfaces and expert users’ interfaces; §15.3.2.

===
pg443[458/1366]
  15.4.3 Program Termination
  A program can terminate in several ways:
    [1] By returning from main()
    [2] By calling exit()
    [3] By calling abort()
    [4] By throwing an uncaught exception
    [5] By violating noexcept
    [6] By calling quick_exit()

  In addition, there are a variety of ill-behaved and implementation-dependent ways of making a program crash (e.g., dividing adoubleby zero).


  If a program is terminated using the standard-library function exit(), the destructors for constructed static objects are called (§15.4.1, §16.2.12).
    However, if the program is terminated using the standard-library function abort(), they are not.
    Note that this implies that exit()does not terminate a program immediately. Calling exit()in a destructor may cause an infinite recursion.

  void exit(int);
  Like the return value of main()(§2.2.1),exit()’s argument is returned to ‘‘the system’’ as the value of the program.
    Zero indicates successful completion.

  Calling exit()means that the local variables of the calling function and its callers will not have their destructors invoked.
    Throwing an exception and catching it ensures that local objects are properly destroyed (§13.5.1).
    Also, a call of exit()terminates the program without giving the caller of the function that called exit()a chance to deal with the problem.
      It is therefore often best to leave a context by throwing an exception and letting a handler decide what to do next. For example, main()may catch every exception (§13.5.2.2).

  The C (and C++) standard-library function atexit()offers the possibility to have code executed at program termination.
  An argument toatexit()cannot take arguments or return a result, and there is an implementation-defined limit to the number of atexit functions. A nonzero value returned by atexit()indicates that the limit is reached. These limitations make atexit()less useful than it appears at first glance. Basically,atexit()is a C workaround for the lack of destructors.
  The destructor of a constructed statically allocated object (§6.4.2) created before a call of atexit(f)will be invoked after f is invoked. The destructor of such an object created after a call of atexit(f)will be invoked before f is invoked.

  The quick_exit()function is like exit()except that it does not invoke any destructors. You register functions to be invoked by quick_exit()using at_quick_exit().

  The exit(),abort(),quick_exit(),atexit(), andat_quick_exit()functions are declared in<cstdlib>.


===
pg442[457/1366]
  15.4.1 Initialization of Nonlocal Variables
  In principle, a variable defined outside any function (that is, global, namespace, and class static variables) is initialized before main()is invoked.

  There is no guaranteed order of initialization of global variables in different translation units.
    Consequently, it is unwise to create order dependencies between initializers of global variables in different compilation units.

  In particular, dynamically linked libraries do not coexist happily with global variables that have complicated dependencies.

  The initialization of a local static is thread-safe (§42.3.3).

  The initialization of nonlocal (statically allocated) variables is controlled by whatever mechanism an implementation uses to start up a C++ program. This mechanism is guaranteed to work properly only if main()is executed.
    Consequently, one should avoid nonlocal variables that require run-time initialization in C++ code intended for execution as a fragment of a non-C++ program.
    Note that variables initialized by constant expressions (§10.4) cannot depend on the value of objects from other translation units and do not require run-time initialization. Such variables are therefore safe to use in all cases.

===
pg430[445/1366] #
  15.2.6 Linkage and Pointers to Functions
  extern "C"
  extern "C" {...}
    # C linkage
    # 这就是 数据指针 与 函数指针 不相容 的 原因 吗？
    #   linkage 似乎不是类型的一部分，但静态类型检查 却需要考虑它？既然如此，为何不算作类型的一部分？
===
pg423[438/1366]
  15.2.1 File-Local Names
  If you must use global variables, at least restrict their use to a single source file. This restriction can be achieved in one of two ways:
    [1] Place declarations in an unnamed namespace.
    [2] Declare an entity static.

  An unnamed namespace (§14.4.8) can be used to make names local to a compilation unit. The effect of an unnamed namespace is very similar to that of internal linkage.


===
pg416[431/1366] #c-header #backward compatibility
  //stdio.h:
    #include<cstdio>
    //err too much: using namespace std;
    using std::...;
    using std::...;
    using std::...;
    using std::...;

===
pg415[430/1366]
  14.4.8 Unnamed Namespaces

===
pg413[428/1366]
  versioning:inline namespace
  namespace xxx {
    inline namespace v3 { ... }
    namespace v2 { ... }
    namespace v1 { ... }
  }

  // xxx |>=| xxx::v3

===
pg405[420/1366]
  namespace xxx_interface4user{}
  namespace xxx_interface4impl{}
===
pg395[410/1366] #Argument-Dependent Lookup(ADL)
  // 感觉不行！
  // 应该 提供一个注册用的命名空间，就像hs::class，用户 重载的函数namespace mine{f(){}} 自己用 namespace xxx_interface{using mine::f;} 注册进去
  // 模版函数 调用时: xxx_interface::f(...) 或 using namespace xxx_interface; (重载 运算符)

14.2.4 Argument-Dependent Lookup
  A function taking an argument of user-defined type X is more often than not defined in the same namespace as X. Consequently, if a function isn’t found in the context of its use, we look in the namespaces of its arguments. For example:

    namespace Chrono {
      class Date { /*...*/ };
      bool operator==(const Date&, const std::string&);
      std::string format(const Date&);//make str ing representation
      //...
    }

    void f(Chrono::Date d, int i)
    {
      std::string s = format(d); //Chrono::for mat()
      std::string t = format(i); //error : no for mat() in scope
    }

  This lookup rule (called argument-dependent lookup or simply ADL) saves the programmer a lot of typing compared to using explicit qualification, yet it doesn’t pollute the namespace the way a using-directive (§14.2.3) can.
    It is especially useful for operator operands (§18.2.5) and template arguments (§26.3.5), where explicit qualification can be quite cumbersome.
  Note that the namespace itself needs to be in scope and the function must be declared before it can be found and used.


  In the standard, the rules for argument-dependent lookup are phrased in terms of associated namespaces (§iso.3.4.2). Basically:
    •If an argument is a class member, the associated namespaces are the class itself (including its base classes) and the class’s enclosing namespaces.
    •If an argument is a member of a namespace, the associated namespaces are the enclosing namespaces.
    •If an argument is a built-in type, there are no associated namespaces.



===
pg377[392/1366] #&*p <<-- std::uninitialized_fill():
  // uninitialized_fill #src is T&
  // uninitialized_fill_n
  // uninitialized_copy #src is T[]
  // forward-iterator
  template<class For, class T>
  void uninitialized_fill(For beg, For end, const T& x)
  {
    For p;
    try {
      for (p=beg; p!=end; ++p)
        ::new(static_cast<void∗>(&∗p)) T(x);//construct copy of x in *p (§11.2.4)
    }
    catch (...) {
      for (For q = beg; q!=p; ++q)
        (&∗q)−>˜T(); //destroy element (§11.2.4)
      throw;//rethrow (§13.5.2.1)
    }
  }
  The curious construct &∗p takes care of iterators that are not pointers.
    In that case, we need to take the address of the element obtained by dereference to get a pointer.


  The calls to alloc.construct() in the vector constructors are simply syntactic sugar for this placement new. Similarly, the alloc.destroy()call simply hides explicit destruction (like(&∗q)−>˜T()).


===
pg374[389/1366] #catch(...)+current_exception()
  // packaged_task-promise-current_exception
  try {
    //... do the work ...
  }
  catch(...) {
    promise.set_exception(current_exception());
  }

===
pg373[388/1366] #terminate #catch(...)@main()
  // [27] Have main() catch and report all exceptions; §13.5.2.2, §13.5.2.4.
  // [34] A library shouldn’t unilaterally terminate a program. Instead, throw an exception and let a caller decide; §13.4.
  // [35] A library shouldn’t produce diagnostic output aimed at an end user. Instead, throw an exception and let a caller decide; §13.1.3.

  The specific rules for calling terminate() are (§iso.15.5.1)
    •When no suitable handler was found for a thrown exception
    •When a noexcept function tries to exit with a throw
    •When a destructor invoked during stack unwinding tries to exit with a throw
    •When code invoked to propagate an exception (e.g., a copy constructor) tries to exit with a throw
    •When someone tries to rethrow (throw;) when there is no current exception being handled
    •When a destructor for a statically allocated or thread-local object tries to exit with a throw
    •When an initializer for a statically allocated or thread-local object tries to exit with a throw
    •When a function invoked as an atexit() function tries to exit with a throw

  In such cases, the function std::terminate()is called. In addition, a user can call terminate()if less drastic approaches are infeasible.
  By ‘‘tries to exit with a throw,’’ I mean that an exception is thrown somewhere and not caught so that the run-time system tries to propagate it from a function to its caller.
  By default,terminate() will call abort()(§15.4.3). This default is the correct choice for most users – especially during debugging. If that is not acceptable, the user can provide a terminate handler function by a callstd::set_terminate() from <exception>:

  The return value is the previous function given to set_terminate().
    For example, a terminate handler could be used to abort a process or maybe to re-initialize a system. The intent is for terminate()to be a drastic measure to be applied when the error recovery strategy implemented by the exception-handling mechanism has failed and it is time to go to another level of a fault tolerance strategy.
      If a terminate handler is entered, essentially nothing can be assumed about a program’s data structures; they must be assumed to be corrupted. Even writing an error message using cerr must be assumed to be hazardous.
    A terminate handler cannot return to its caller. If it tries to,terminate()will callabort().

    Note that abort()indicates abnormal exit from the program. The function exit()can be used to exit a program with a return value that indicates to the surrounding system whether the exit is normal or abnormal (§15.4.3).


  It is implementation-defined whether destructors are invoked when a program is terminated because of an uncaught exception. On some systems, it is essential that the destructors are not called so that the program can be resumed from the debugger. On other systems, it is architecturally close to impossible not to invoke the destructors while searching for a handler.
    If you want to ensure cleanup when an otherwise uncaught exception happens, you can add a catch-all handler (§13.5.2.2) tomain()in addition to handlers for exceptions you really care about.



===
pg372[387/1366] #noexcept destructor
  If you managed to have two exceptions active at one time (in the same thread, which you can’t), the system would have no idea which of the exceptions to try to handle: your new one or the one it was already trying to handle.
    Note that an exception is considered handled immediately upon entry into a catch-clause. Rethrowing an exception (§13.5.2.1) or throwing a new exception from within a catch-clause is considered a new throw done after the original exception has been handled. You can throw an exception from within a destructor (even during stack unwinding) as long as you catch it before it leaves the destructor.


===
pg366[381/1366] #conditionally noexcept
  conditionally noexcept
    template<typename T>
      void my_fct(T& x) noexcept(Is_pod<T>());

    template<typename T>
      void call_f(vector<T>& v) noexcept(noexcept(f(v[0]))
      {
        for (auto x : v)
          f(x);
      }

    template<class T, siz e_t N>
      void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(∗a, ∗b)));


===
pg358[373/1366]
  RAII(+lambda) 可完全替代 try...finally
    除了 vector构造函数 或者说 uninitialized_fill 之类

===
pg353[368/1366] #exception guarantee
  //illustrate:pg381[396/1366] 13.6.3 Assignment //vector impl

  The C++ standard library provides a generally useful conceptual framework for design for exception-safe program components. The library provides one of the following guarantees for every library operation:
    •The basic guarantee for all operations: The basic invariants of all objects are maintained, and no resources, such as memory, are leaked. In particular, the basic invariants of every built-in and standard-library type guarantee that you can destroy an object or assign to it after every standard-library operation (§iso.17.6.3.1).
    •The strong guarantee for key operations: in addition to providing the basic guarantee, either the operation succeeds, or it has no effect. This guarantee is provided for key operations, such as push_back(), single-element insert() on a list, and uninitialized_copy().
    •The nothrow guarantee for some operations: in addition to providing the basic guarantee, some operations are guaranteed not to throw an exception. This guarantee is provided for a few simple operations, such as swap() of two containers and pop_back().


  Both the basic guarantee and the strong guarantee are provided on the condition that
    •user-supplied operations (such as assignments andswap()functions) do not leave container elements in invalid states,
    •user-supplied operations do not leak resources, and
    •destructors do not throw exceptions (§iso.17.6.5.12).


===
pg340[355/1366] #predefined macros
  12.6.2 Predefined Macros
  A few macros are predefined by the compiler (§iso.16.8, §iso.8.4.1):
    •__cplusplus: defined in a C++ compilation (and not in a C compilation). Its value is 201103L in a C++11 program; previous C++ standards have lower values.
    •__DATE__: date in ‘‘yyyy:mm:dd’’ format.
    •__TIME__: time in ‘‘hh:mm:ss’’ format.
    •__FILE__: name of current source file.
    •__LINE__: source line number within the current source file.
    •__FUNC__: an implementation-defined C-style string naming the current function.
    •__STDC_HOSTED__:1 if the implementation is hosted (§6.1.1); otherwise 0.


  In addition, a few macros are conditionally defined by the implementation:
    •__STDC__: defined in a C compilation (and not in a C++ compilation)
    •__STDC_MB_MIGHT_NEQ_WC__:1 if, in the encoding for wchar_t, a member of the basic character set (§6.1) might have a code value that differs from its value as an ordinary character literal
    •__STDCPP_STRICT_POINTER_SAFETY__:1 if the implementation has strict pointer safety (§34.5); otherwise undefined.
    •__STDCPP_THREADS__:1 if a program can have more than one thread of execution; otherwise undefined.


===
pg336[351/1366] #ptr to func
  A pointer to function must reflect the linkage of a function (§15.2.6). Neither linkage specification nor noexcept may appear in type aliases:
    using Pc = extern "C" void(int); //error : linkage specification in alias
    using Pn = void(int) noexcept; //error : noexcept in alias

===
pg333[348/1366] #ptr to func
  using CFT = int(const void∗, const void∗);

===
pg320[335/1366] #initializer_list argument take priority@ambiguity
  If there is a possible ambiguity, an initializer_list parameter takes priority.
  The reason that a function with an initializer_list argument take priority is that it could be very confusing if different functions were chosen based on the number of elements of a list. It is not possible to eliminate every form of confusion in overload resolution (for example, see §4.4, §17.3.4.1), but giving initializer_list parameters priority for{}-list arguments seems to minimize confusion.


===
pg319[334/1366] #reference-to-array
  Note that the number of elements is part of a reference-to-array type. That makes such references far less flexible than pointers and containers (such as vector).
    void f(int(&r)[4]);

  The main use of references to arrays is in templates, where the number of elements is then deduced. For example:
    template<class T, int N> void f(T(&r)[N])
    {
      //...
    }

===
pg315[330/1366] #static-local+call_once==>>data-race-free
  A static local variable allows the function to preserve information between calls without introducing a global variable that might be accessed and corrupted by other functions (see also §16.2.12).
  Initialization of a static local variable does not lead to a data race (§5.3.1) unless you enter the function containing it recursively or a deadlock occurs (§iso.6.7). That is, the C++ implementation must guard the initialization of a local static variable with some kind of lock-free construct (e.g., a call_once; §42.3.3). The effect of initializing a local static recursively is undefined. For example:
    int fn(int n)
    {
      static int n1 = n;//OK
      static int n2 = fn(n−1)+1;//undefined
      return n;
    }
  A static local variable is useful for avoiding order dependencies among nonlocal variables (§15.4.1).



===
pg314[329/1366] #[[noreturn]]
  A construct[[...]]is called an attribute and can be placed just about anywhere in the C++ syntax.
  In general, an attribute specifies some implementation-dependent property about the syntactic entity that precedes it. In addition, an attribute can be placed in front of a declaration. There are only two standard attributes (§iso.7.6), and[[noreturn]]is one of them. The other is[[carries_dependency]](§41.3).
  Placing[[noreturn]]at the start of a function declaration indicates that the function is not expected to return.
  //   see:pg307, pg314



===
pg313[328/1366] #
  12.1.6.2 Conditional Evaluation
  A branch of a conditional expression that is not taken in aconstexprfunction is not evaluated. This implies that a branch not taken can require run-time evaluation. For example:
    constexpr int check(int i)
    {
      return (low<=i && i<high) ? i : throw out_of_rang e();
    }
    constexpr int low = 0;
    constexpr int high = 99;
    //...
    constexpr int val = check(f(x,y,z));
  //   see:pg264, pg313


===
pg307[322/1366] #
  struct S {
    [[noreturn]] static constexpr virtual inline auto f() −> void const noexcept =0 =default =delete final override;
  };
  //   see:pg307, pg314


===
pg299[314/1366] #homemade narrow_cast<>
  template<class Target, class Source>
  Targ et narrow_cast(Source v)
  {
    auto r = static_cast<Target>(v); //convert the value to the target type
    if (static_cast<Source>(r)!=v)
      throw runtime_error("narrow_cast<>() failed");
    return r;
  }


  auto c2 = narrow_cast<char>(−64); //will throw if chars are unsigned
  auto c3 = narrow_cast<char>(264); //will throw if chars are 8-bit and signed



===
pg282[297/1366] #
  To deallocate space allocated by new,delete and delete[] must be able to determine the size of the object allocated. This implies that an object allocated using the standard implementation of new will occupy slightly more space than a static object. At a minimum, space is needed to hold the object’s size. Usually two or more words per allocation are used for free-store management. Most modern machines use 8-byte words. This overhead is not significant when we allocate many objects or large objects, but it can matter if we allocate lots of small objects (e.g.,ints or Points) on the free store.


===
pg268[283/1366] #narrowing ==>> narrow_cast<>, list_initializer
  The {}-initializer syntax prevents narrowing (§6.3.5).
    void f(double d)
    {
      char c {d};//error : double-precision floating-point to char conversion
    }
  If potentially narrowing conversions are unavoidable, consider using some form of run-time checked conversion function, such as narrow_cast<>()(§11.5).

===
pg265[280/1366] #constexpr constructor ==>> literal type
  A class with a constexpr constructor is called a literal type. To be simple enough to be constexpr, a constructor must have an empty body and all members must be initialized by potentially constant expressions.

===
pg264[279/1366] #constexpr
  The condition of a ?: is evaluated and then the selected alternative is evaluated. The alternative not selected is not evaluated and might even not be a constant expression. Similarly, operands of && and || that are not evaluated need not be constant expressions. This feature is primarily useful in constexpr functions that are sometimes used as constant expressions and sometimes not.
  // 也可用作 检查输入输出、中间状态、报错
  //   see:pg264, pg313

===
pg217[232/1366]
  union
    anonymous union #匿名
    tagged union === discriminated union
      #mine:cased
    new(&s) string{ss};//placement new: explicitly construct string (§11.2.4)



===
pg196[211/1366]
  T& & === T&
  T&& & === T&
  T& && === T&
  T&& && === T&&




===
pg193[208/1366]
  reference classify:
    non-const lvalue reference
      接受 部分 赋值: 左值(声明的右值自动变左值)
    const lvalue reference
      接受 任何 赋值: 左值(声明的右值自动变左值)，临时值，字面常量
    rvalue reference
      接受 部分 赋值: 临时值，字面常量



===
pg191[206/1366] #const T& = ... 可能复制并保留该临时值
  Initialization of a reference is trivial when the initializer is an lvalue (an object whose address you can take; see §6.4). The initializer for a ‘‘plain’’ T& must be an lvalue of type T.
  The initializer for a "const T&" need not be an lvalue or even of type T. In such cases:
    [1] First, implicit type conversion to T is applied if necessary (see §10.5).
    [2] Then, the resulting value is placed in a temporary variable of type T.
    [3] Finally, this temporary variable is used as the value of the initializer.

  Consider:
    double& dr = 1;//error : lvalue needed
    const double& cdr {1};//OK

  The interpretation of this last initialization might be:
    double temp = double{1}; //first create a temporar y with the right value
    const double& cdr {temp};//then use the temporar y as the initializer for cdr

  A temporary created to hold a reference initializer persists until the end of its reference’s scope.
  References to variables and references to constants are distinguished because introducing a temporary for a variable would have been highly error-prone; an assignment to the variable would become an assignment to the – soon-to-disappear – temporary. No such problem exists for references to constants, and references to constants are often important as function arguments (§18.2.4).



===
pg179[194/1366]
    u8"" utf8 string
    u"" utf16 string
    U"" utf32 string
    L"" wchar_t[]
    ==
    R"tag(...)tag" multi-line raw string allow true newline
    ==
    UR not RU
    R not r
===
pg168[183/1366]
  // except char..._t, wchar_t
  The _t suffix is conventional for aliases (‘‘typedefs’’). The int16_t,int32_t, and other such aliases can be found in<stdint>(§43.7).
  Note that naming a type after its representation rather than its pur- pose is not necessarily a good idea (§6.3.3).
  template<...> using xxx = ...;

===
pg166[181/1366]
  key properties for addressing/copying/moving:
    movable
    has_identity #addressable

  classify:
    [not movable][not has_identity] <==> not C++ obj
    [not movable][has_identity] <==> lvalue
    [movable][has_identity] <==> xvalue
    [movable][not has_identity] <==> prvalue
    glvalue = lvalue | xvalue
    rvalue = xvalue | prvalue
    ==
    l = lhs
    r = rhs
    g = generalized
    p = pure
    x = extraordinary / expert-only
    ==
    std::move() -> &&

  #see:pg193[208/1366]
  reference classify:
    non-const lvalue reference
    const lvalue reference
    rvalue reference

===
pg160[175/1366]
  T x {}; // avoid become func-decl: "T x();"
  alway use {}(list initialization):
  * except auto
      auto z1 {99};//z1 is an initializer_list<int>
      auto z2 = 99;//z2 is an int
      // So prefer = when using auto.
  * except non-list-initialization constructor has diff.meaning:
      vector<int> v1 {99};//v1 is a vector of 1 element with the value 99
        // == [99]
      vector<int> v2(99);//v2 is a vector of 99 elements each with the default value 0
        // == [0]*99


===
pg155[170/1366]
  _ 用于 命名:
    必须是 local
    必须是 _[0-9a-z]...

  Nonlocal names starting with an underscore are reserved for special facilities in the implementation and the run-time environment, so such names should not be used in application programs.
  Similarly, names starting with a double underscore (__) or an underscore followed by an uppercase letter (e.g.,_Foo) are reserved (§iso.17.6.4.3).


===
pg151[166/1366] #alignas+uninitialized_copy

void user(const vector<X>& vx)
{
  constexpr int bufmax = 1024;
  alignas(X) buffer[bufmax]; //uninitialized
  const int max = min(vx.size(),bufmax/siz eof(X));
  uninitialized_copy(vx.begin(),vx.begin()+max,buffer);
  //...
}


===
pg149[164/1366]
  基本类型 大小比较
  #omit sizeof, unit:char
  1 == char <= {(short <= int), bool, wchar_t} <= long <= long long
    xxx == signed xxx == unsigned xxx
  float <= double <= long double

  #omit bit_of, unit:bit
  8 <= char
  16 <= short
  32 <= long
  ===
  ！！！如果 char==4byte，那 char16_t/int16_t 是什么？
    u8"" utf8 string
    u"" utf16 string
    U"" utf32 string
  ===
  其实 有些奇怪
  基本类型 的 大小/对齐 依 宿主机器（内存、CPU寄存器） 而定 ==>> char
  而 面向通信（网络协议）、存储（文件格式），则 必须 明确 比特数 ==>> byte/bit
  C++似乎 没能很明确地 支持如何处理这问题
  <cstddef>::size_t/ptrdiff_t
    size_t is an implementation-defined unsigned integer type that can hold the size in bytes of every object. Consequently, it is used where we need to hold an object size.
    void∗ allocate(size_t n); //get n bytes? #char!
    ptrdiff_t for holding the result of subtracting two pointers to get a number of elements.

  但是 文件大小/tell()呢？显然 不能用 size_t
    文件指针fp呢？显然 不能用 (void*)


===
pg141[156/1366]
  [err: A char fits in 1 byte.]
    There are embedded processors without byte accessing hardware for which a char is 4 bytes.
  第六章 让我震惊！
  char 多少byte？文件读写 怎么办？毕竟 字节 与 char 不对应！
  字符、字符串 的 转义字符:
    * 注意 长度没有上限！
      \oooooo
      \xhhhhh
    * 并不能确定是那个字符
      相当于 整数 赋值给 字符
      字符集 并不确定，移植性 有问题
        所以 实际上 不是 字符串，而是 整数流
      (wchar_t*) L"" 更严重，连 字符串 的 长度 都无法确定（依赖于 编译器实现）
      只有 unicode字符串 是 确定的
        (char32_t) U'\Uxxxxxxxx'
        (char16_t) u'\uxxxx'
    * char vs signed char vs unsigned char
      与 整数 交换 值，有 移植性问题
    * 字母 不一定 连续
      字符集 不一定 是 ascii
      比如: i,j 不相邻

===
pg123[138/1366]
  future+promise <-- packaged_task
    + thread ==>> sync with shared-data #显式运行线程，任务之间可通信
    + async ==>> cannot communicate, there may or maynot be thread used to work #可能 所有任务 并行，也可能 串行，即使部分串行，任务之间 也不可能 通信。





===
pg119[134/1366] # mutex + condition_variable
  void consumer()
  {
    while(true) {
      unique_lock<mutex> lck{mmutex}; //acquire mmutex
      while (mcond.wait(lck)) /*do nothing*/; //release lck and wait;
      //re-acquire lck upon wakeup
      auto m = mqueue.front(); //get the message
      mqueue.pop();
      lck.unlock(); //release lck
      //... process m ...
    }
  }

  void producer()
  {
    while(true) {
      Message m;
      //... fill the message ...
      unique_lock<mutex> lck {mmutex}; //protect operations
      mqueue.push(m);
      mcond.notify_one(); //notify
    }//release lock (at end of scope)
  }





===
pg118[133/1366] #防止死锁deadlock
  unique_lock<mutex> lck1 {m1,defer_lock}; //defer_lock: don’t yet try to acquire the mutex
  unique_lock<mutex> lck2 {m2,defer_lock};
  unique_lock<mutex> lck3 {m3,defer_lock};
  lock(lck1,lck2,lck3); //acquire all three locks






===
pg103[118/1366]
  contiguous 邻接的，无中断的，连续的
  chrono-  [前缀]用于组词表示计时相关的词
    $ ls ~/../usr/include/c++/v1/chrono
    /data/data/com.termux/files/home/../usr/include/c++/v1/chrono
    view /data/data/com.termux/files/usr/include/c++/v1/deque
      deque::operator[] O(1)???
        std has only seq: vector/array/deque/list/forward_list??? vector/array require contiguous memory ==>> size-limited???

      ref:
        pg886[901/1366]
          A deque(pronounced ‘‘deck’’) is a mixture of linked-list and contiguous allocation.
        pg894[909/1366]
          The standard-library operations have complexity guarantees:
            deque::operator[] O(1)
              how can it be possible if use list<array<T,N>>?
                ???it seems using vector<array<T,N>>???
          我觉得 deque 可用 两个 vector 实现，一反向，一正向。允许 头部空洞（所有元素只在一侧）
            ？？？如何避免contiguous，以防内存高度碎片化无法分配大量连续内存，而同时保留random-access-O(1)？？？
            random-access-O(1)==>>必然使用数组/连续内存
            但可分级，总级数固定或有上限(<<==O(1))，这样各层级的数组大小有上限，不至于太大(<<==对内存高度碎片化的容忍力)，但多层情形下，整体总容量足够大

view /data/data/com.termux/files/usr/include/c++/v1/__split_buffer
  typedef __split_buffer<pointer, __pointer_allocator> __map;
  protected:
    __map __map_;
    size_type __start_;
template <class _Tp, class _Allocator>
inline
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::operator[](size_type __i)
{
    size_type __p = __base::__start_ + __i;
    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);
}


