
e TODO20241006.txt
  <-- e TODO20240704.txt

DONE:丮厈-括号之@vim


TODO:
  e ../../python3_src/seed/for_libs/-py_original-/README.txt
  纯py代码<各标准库>
TODO:
  支持词典序:
    e others/数学/编程/设计/自定义字符编码.txt
  heapq: C-lib => wrap@ABC
    merge rngss
    merge it_it
    heap<it>
  (++)vs(+):不可交换:
    左减，右减
    乘除
TODO:getter.a.b[k].c()
  operator.attrgetter
  why not lambda?
  getter.a.b[k].c((), *args)
   mk tuple
  getter.a.b[k].c(..., *args, **kwargs)
    partial-call
  getter.a.b[k].c(0, *args, **kwargs)(0, *args, **kwargs)()
    call
    operator.methodcaller
TODO:面向未来的语法:
  LL1:关键词 领起的 内敛式纟未来
  a* b --> x* (a x*)* b x*
  遇到 未知关键词 则 查找相应的内敛识别器
  而且 内敛式纟未来 依赖于自身特定 料符串化，若非 原子性的/叶型，也当 允许 未知关键词 被 料符串化，并更改 状态纟串化程序 ... 串化 与 识别 纠缠不清，同时进行...
  料符识别器 应当静态声明 头符集+尾前瞻符集:
    两个 料符识别器 的 串联 之间，凡是 第一个 料符识别器 的 尾前瞻符集 不与 未知关键词 头符 冲突的 并且 第二个 料符识别器 的 头符集 不与 未知关键词 头符 冲突的，均可 插入『诡复式纟非空内敛式冃未知关键词领起的用户自定义的超符』
  内敛...要不要 显式表明结束？这不就是 XML???
    毛病出在:不够紧凑:大数据:词典/数组...
    类似xml:节点分类:
      * 紧凑型叶型节点:内置基础类型？保存字符串 提供给高层 解读
      * 紧凑型树型节点:内置类型容器？
      * 叶型节点:保存字符串 提供给高层 解读
          ？注解 放在哪？#注解型节点
          注解型节点所在:
            * 若下面的 树型节点 是 全文件匿名节点，则 仍旧有效，只是 注解 父节点 => 全文注解型节点
            * 树型节点 的 首子节点 => 注解 父节点/树型节点
            * 树型节点 的 非首子节点:
              * 兄节点 是 注解型节点 => 注解 兄节点所注解的节点
              * 兄节点 不是 注解型节点 => 注解 兄节点
          !! 可能需要 注解 注解型节点
          => 注解型节点 也是 树型节点

      * 树型节点: 除了 语法书 规定的 必要 子节点，其他地方 可以 任意 插入 不相干的额外节点
        ？不同应用 之间 如何 确保 自定义标签 不相互干扰？
          文件级别的导入 标签前缀纟应用
          具象应用本身 看不到 这些 标签前缀，由 读写程序 维护这些 标签前缀(字符串) 并对应到 相应具象应用(符号)
        * 注解型节点:
          * 节点注解型节点:
          * 全文注解型节点:
            比如:提示性的标签前缀讠名纟应用
              之所以是『提示性』是因为不存在通用的全局无冲突的命名规范{『名纟应用』}，只能靠用户心领神会


困境冫封装纟框架化:
  毛病出在当下函数的组织形式:结构化，但 只提供 当前层的return
    低层函数的返回值 还得经过 当前函数 转发
      错误处理:不同山头统一下降/瀑布型回落{定义:等高线}:忆起被『结构化编程』封禁的『goto』
    这也是 异常出现的需求之一吧？
  或许可以 传入返回地址，由 被调用函数自行决定 何种况态返回何处

  void *vtable;
  if (!PyCapsule_IsValid(capsule, "mymodule.CAPI") {
          PyErr_SetString(PyExc_ValueError, "argument type invalid");
          return NULL;
  }
  vtable = PyCapsule_GetPointer(capsule, "mymodule.CAPI");

[[
树状结构
  tag==属性名/位置+构造器纟属性值
]]

[[
半相对型路径:相对型路径vs绝对型路径
根路径-->泛化:相对型根路径-->泛化:多级别相对型根路径
  先相对寻址 特定级别的 根路径，再由该 跟路径 往下进行 绝对型路径定位
]]

[[[
===
[[
形容词-技术上讲，其实就是『判定谓语动词』
命题=?=形容词+名词=?=先声明一下 变量名(名词)，然后再各种限定(前提条件/交集/...)，
形容词 也是 谓语动词，陈述句 跟 断言/命题 到底有什么区别？
外观限定(不同切面属性的继承与限定)+内容定义+交流用命名/接口/引脚...
]] [[
副词/修饰语纟动词/限定词纟动词:
  kw:额外配置参数
形容词/修饰语纟名词/限定词纟名词:
  无关:无序:x{a&b}
    xxx logic-and
    xxx [a(x) and b(x)]
    set-intersection
    [a,b :: set<v> -> set<v>]
    [out := a(x) /-\ b(x)]
  依赖:有序:x{a.b}
    set-intersection
    [a,b :: set<v> -> set<v>]
    [out := b(a(x))]
  融并:无序:x{a|b}
    set-intersection
    [a,b :: set<v> -> set<v>]
    [out := a(x) \-/ b(x)]
]] [[
困境冫组合命名规范:
  f(obj, ...)
  obj.f(...)
  g(a,b,...)
  a.g(b,...)
  b.g(a,...) # 『**』
  ===
  文件路径:
    /.../xxx.fmt
      /.../xxx/fmt
      /fmt/.../xxx
      比如:配置{版本号,编译器,链接库{欤调试,欤并行},目标系统}
      比如:文件格式:头文件-源代码-目标文件-可执行文件/库文件
      比如:用户,作者,...
      比如:版本号,备份日期...
    树状结构-线形路径
  ===
  stricmp: case-insensitive string comparisons
  cmp__str__case_insensitive
  cmp__str__case_sensitive
  cmp__bytes__case_sensitive
  cmp__int
  vs:
  int_cmp
  str_cmp...
  两个 对象 的 组合，并且 无 特定次序，依照 扮演的角色不同而定位，又 不想 给 角色 命名，或者说 无序集合 串化 并不能 满足 所有 排序要求:相关性高齐聚(对象方法:到底是按对象类型汇聚，还是按 方法功能汇聚？)
]] [[
路径 节点 标识名 应该是啥类型:
  str
    identifier-only
  bytes
  int
  any data
  我觉得 没有限制的必要:
    x. 12
    x. "--xxx"
    x. b"--xx\0"
    x. {1,2,""}
]]
]]]


[[[
===

组合冫标志位:加性丷乘性/加型丷乘型:
  (a <+> b) <=> (a|b)/(Either a b)
    offset+a
    offset+(max_a+1)+b #<<==小端序
  (a <*> b) <=> (a,b)
    offset+a+(max_a+1)*b #<<==小端序
    简并态 数量 == (max_a+1)*(max_b+1)
    简并态 <=> {单态纟并行态}
    并行态 的 单态 数量 = (max_a+1)+(max_b+1)

TODO:突然意识到:其实 使用 全序字母表(即使无限大，比如 自然数/字符串) 的 正则表达式 可以将 输入符号 归类为 O(N) 各分区，之前一直误认为O(2**N)，料符串化<有限料符集合> 成为可能
  不过，考虑到 统合码 的 奇葩属性 分布，只怕 分区会非常多...而且 随版本变更...
    也许该限制字符Age属性...++限定 属性的Unicode版本
      还是太多分区，也许该提前声明文本所使用的字符集，若是溢出则报错(或许可以放宽:所有不使用统合码不稳定属性的状态，可以独列一套分区表:规模受控正比于正则表达式的长度)
    字符->分区
    分区->种符纟分区
    种符纟分区->前置状态集
    [当前有效状态集=[def]=圆满的当前状态集/-\前置状态集]
    [当前有效状态集:=极大的有后的当前状态集/-\前置状态集]
        !! 圆满的当前终态色集 已提前提取
    前置状态->种符纟分区->后置状态
    当前有效状态集->种符纟分区->不圆满的后继状态集
    状态->直达状态
    状态->圆满的直达状态集
    #终态 着色 --> 圆满时提取
    状态->圆满的终态色集
    不圆满的后继状态集->圆满的后继终态色集
    #有直达但无后继的状态 --> 圆满后再亏损:只保留有后状态
    不圆满的后继状态集->圆满的后继状态集
      -->:更新为:
      不圆满的后继状态集->极大的有后的后继状态集
        !! 圆满的后继终态色集 已提前提取
    ---
  抽象类:极简:考虑枚举状态:允许 itree 表达的状态(子节点 指向 父节点)，不能 正向使用，但 仅用于 输出乊枚举 (前置状态,种符,后置状态)+(状态,直达状态)，还是 可以的
  class:+O000+x 略大，略小，+oo，-oo
  ===
  简并状态 不容易
]]]

???py.with Either as payload
???py.match either: case Either True payload
???py.match either: case Right payload



值对象vs活对象
  久值对象 不可修改:固实
  久值对象 可保存
  久值对象 没有 固定地址:
    * 可以在初始化时:归一化
    * 也可以在判定相同时:归一化
        解引用接口变更:
          deref(ref ref4obj) -> (obj*)
          deref(ref* ptr4ref) -> (obj*)
          [ref is ref] 要么不可靠 要么必须先解引用 耗时
    => 地址 可能不可靠，不能用作 长久 址引
    DAG?
    ？结构性等同 还是 逻辑性等同？
      似乎只能 内置支持 结构性等同

  瞬值活对象 可修改，瞬时值 可转换为 久值对象 保存 #循环引用？
  鬼活对象 可修改，自我唯一，不可保存，只能声明引用乊特定场合乊特定语言


TODO:py.news:目前看到:3.2
发现:py新关键词:
  view /sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-text/tutorial/controlflow.txt
    4. More Control Flow Tools
    4.6. "match" Statements
  view /sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-text/whatsnew/3.10.txt
  ==>>:
  view ../lots/NOTE/Python/news/match-case.txt
  ==>>:
  TODO:
    /sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-text/whatsnew/*
感觉很有用:ResourceWarning: py  -Wdefault
发现:memoryview 需要 with
发现:ctrl+D 而非 quit(), quit 原版就是 字符串，新版++__call__
#此前发现『:=』

[[
]]

[[
233:resurrected

<<==:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/3.2.html
The callable() builtin function from Py2.x was resurrected. It provides a concise, readable alternative to using an abstract base class in an expression like isinstance(x, collections.Callable):

>>> callable(max)
True
>>> callable(20)
False
(See bpo-10518.)
]]

[[
感觉很有用:ResourceWarning: py  -Wdefault

<<==:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/3.2.html
A new warning category, ResourceWarning, has been added. It is emitted when potential issues with resource consumption or cleanup are detected. It is silenced by default in normal release builds but can be enabled through the means provided by the warnings module, or on the command line.

A ResourceWarning is issued at interpreter shutdown if the gc.garbage list isn’t empty, and if gc.DEBUG_UNCOLLECTABLE is set, all uncollectable objects are printed. This is meant to make the programmer aware that their code contains object finalization issues.

A ResourceWarning is also issued when a file object is destroyed without having been explicitly closed. While the deallocator for such object ensures it closes the underlying operating system resource (usually, a file descriptor), the delay in deallocating the object could produce various issues, especially under Windows. Here is an example of enabling the warning from the command line:

$ python -q -Wdefault
>>> f = open("foo", "wb")
>>> del f
__main__:1: ResourceWarning: unclosed file <_io.BufferedWriter name='foo'>
(Added by Antoine Pitrou and Georg Brandl in bpo-10093 and bpo-477863.)
]]

[[
view others/数学/编程/永恒代码/毛病纟异常bug-try-catch.txt
其他异常不行，AttributeError也不见得行，低层函数的异常不是本身的异常（？我附庸的附庸不是我的附庸？）
<<==:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/3.2.html
The hasattr() function works by calling getattr() and detecting whether an exception is raised. This technique allows it to detect methods created dynamically by __getattr__() or __getattribute__() which would otherwise be absent from the class dictionary. Formerly, hasattr would catch any exception, possibly masking genuine errors. Now, hasattr has been tightened to only catch AttributeError and let other exceptions pass through:

>>> class A:
...     @property
...     def f(self):
...         return 1 // 0
...
>>> a = A()
>>> hasattr(a, 'f')
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
(Discovered by Yury Selivanov and fixed by Benjamin Peterson; bpo-9666.)
]]

[[
确认之前的疑惑: 异常变量会被隐式删除
<<==:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/3.2.html
Previously it was illegal to delete a name from the local namespace if it occurs as a free variable in a nested block:

def outer(x):
    def inner():
        return x
    inner()
    del x
This is now allowed. Remember that the target of an except clause is cleared, so this code which used to work with Python 2.6, raised a SyntaxError with Python 3.1 and now works again:

def f():
    def print_error():
        print(e)
    try:
        something
    except Exception as e:
        print_error()
        # implicit "del e" here
(See bpo-4617.)
]]

[[
发现:memoryview 需要 with
<<==:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/3.2.html

memoryview objects now have a release() method and they also now support the context management protocol. This allows timely release of any resources that were acquired when requesting a buffer from the original object.

>>> with memoryview(b'abcdefgh') as v:
...     print(v.tolist())
[97, 98, 99, 100, 101, 102, 103, 104]
(Added by Antoine Pitrou; bpo-9757.)
]]

[[

简洁化冫树状数据表达:共性抽取提前
  比如:命名空间
  比如:容器元素的类型
  可以指明 共性属性值的作用深度，乃至无限制递归直到被覆盖取代或被取消
  压缩数据:
    命名冫对象
    命名冫数据:用标识符替代数据
      比如:高频常量大数据
    命名冫共性修饰器
      比如:上述的 共性抽取提前:同一模式 可能 分散分布于 各处，可用 标识符 取代(多个正交化，或可考虑 减法...)，方便更新，方便阅读


/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/2.7.html
Namespace handling has also been improved. All xmlns:<whatever> declarations are now output on the root element, not scattered throughout the resulting XML. You can set the default namespace for a tree by setting the default_namespace attribute and can register new prefixes with register_namespace(). In XML mode, you can use the true/false xml_declaration parameter to suppress the XML declaration.
]]

[[
信息流动控制:
  对于『纯粹型代码』而言，是 无关于 具象系统信息 的
  但是 调试 或者 类似应用 可能需要 具象系统信息
  区分 模块类型:
      脏库 可以使用 净库
      净库 不能使用 脏库
        #通过 平台标准库 隔离
        #平台标准库 是 外净内脏:对外声明是净库，实则内部具现是脏库
  净代码 确保 输出不变 ==>> 抽象值 不能有副作用 不能依赖实机信息
    不用考虑:资源管理
  但是，纯计算的话，很多希望能自动化批量执行的操作 就不被支持:类似 文件系统 操作，不可能 跨平台 一致(文件系统不同:文件信息格式不同，权限不同...)
  脏库:
    *可中断程序 返回 (待续|败讯屮成果)

/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/2.7.html
Long integers are now stored internally either in base 2**15 or in base 2**30, the base being determined at build time. Previously, they were always stored in base 2**15. Using base 2**30 gives significant performance improvements on 64-bit machines, but benchmark results on 32-bit machines have been mixed. Therefore, the default is to use base 2**30 on 64-bit machines and base 2**15 on 32-bit machines; on Unix, there’s a new configure option --enable-big-digits that can be used to override this default.

Apart from the performance improvements this change should be invisible to end users, with one exception: for testing and debugging purposes there’s a new structseq sys.long_info that provides information about the internal format, giving the number of bits per digit and the size in bytes of the C type used to store each digit:

>>> import sys
>>> sys.long_info
sys.long_info(bits_per_digit=30, sizeof_digit=4)
(Contributed by Mark Dickinson; bpo-4258.)

Another set of changes made long objects a few bytes smaller: 2 bytes smaller on 32-bit systems and 6 bytes on 64-bit. (Contributed by Mark Dickinson; bpo-5260.)
]]
[[
py 标志库 增删 极为频繁
  C++ 也一样

困境冫标准库
  欤保持回顾性兼容
同名库增长是大概率事件:
  * 旧系统 不支持 新脚本
  脚本 不够通用
  应该 另取新名/或-模块名后附版本号
    这样，旧系统 可以 通过安装 新版 模块 而 增强
不保持回顾性兼容:
  * 旧系统 不支持 新脚本
  * 新系统 不支持 旧脚本
  脚本 不够通用
  源代码 若不够通用，还有什么意义？
  虚拟机 若不够通用，还有什么意义？
]]

[[
TODO:设计:文件格式:引用外部文件 必须 放在 头部，紧致且尽量靠前，格式简单，结束符清楚，以方便外部程序解读，提取依赖关系。
  必须声明 本模块 所实现的 接口文件(多个，非空)
  必须声明 导入模块 所实现的 接口文件(多个，非空)
  必须声明 内部使用的 非凡常量，就某种程度而言，它们也是 输入参数/可重配置参数
    文件路径模板
    正则表达式
    内置的加密用常量参数
    ...
  接口文件 不可更改，只能改版另名
  #动态参数方面:比如说:伪随机数生成器.(名+算法参数+初始状态)，报告中必须列出完整输入信息
    #如果使用到datetime.now()???应当记录下来？如果timeit调用很多次？
    #副作用隐式互动:不同进程之间分配的内存空间会相互压迫，内存耗尽 不一定是 当前进程 造成的，错误难再现
import ...
    # python
    即使是函数内部的『import』也该在文件头 提前声明（惰性，并不立即执行）
#include <...>
    // C++
    即使是 实现的片段 而非  头文件，也该 提前声明
$环境变量名
    #bash脚本 引用 环境变量: $CPPFLAGS
    #可以 用编译器 报错暨辅助提取，以 提前声明 所有导入的环境变量(作为 脚本的隐式输入)
    #这么看，路径 要不要 也 提前声明？
    #   作为 脚本一部分(source,bash/exec,...) 显然应该声明
    #   作为 数据... 任何影响脚本输出的东西 都该 提前声明，因为都是 输入

===
源起:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/2.3.html
===
The Distutils Extension class now supports an extra constructor argument named depends for listing additional source files that an extension depends on. This lets Distutils recompile the module if any of the dependency files are modified. For example, if sampmodule.c includes the header file sample.h, you would create the Extension object like this:

ext = Extension("samp",
                sources=["sampmodule.c"],
                depends=["sample.h"])
Modifying sample.h would then cause the module to be recompiled. (Contributed by Jeremy Hylton.)

===
Other minor changes to Distutils: it now checks for the CC, CFLAGS, CPP, LDFLAGS, and CPPFLAGS environment variables, using them to override the settings in Python’s configuration (contributed by Robert Weber).
===
]]
[[
TODO:设计:自定义自己的类型体系:
  类似:__get__,__set__
  任何 重要方面 都必需 独立设计 一套接口
    比如:私用区,私用缓存区(hash),公众缓存区(单参数繁重运算:hash,外赋属性),核心变量区(repr,pickle...)...
      属性形式:
        * 公开宽松接口:obj[sym:]
        * 受保护严格接口:obj[:sym]
        * 私用接口:obj[::sym]
      调用形式(含:零参数情形):
        * obj[sym:, ...]
        * obj[:sym, ...]
        * obj[::sym, ...]
  超符:
    比如说:may obj  #允缺参数
    比如说:lazy obj #惰性参数
    一旦该值不在自定义类型体系中，则当作 超符 对待
  深入型约束声明:
    深入累计型属性声明:固实，固化，只读视图，...
  继承之方法覆盖:必需 各方法 独立声明 自身的许可覆盖种类，并且 声明 必须 后顾兼容
    比如:声明 禁止任何隐式覆盖
    比如:声明 次序无关协作(无序累计)
    比如:声明 禁止使用被覆盖方法(没有super())
    比如:冻结类型之后，禁止窜改:这样一来，访问的时候 所有方法 可以集中于 具象类型的私用区...
    比如:声明 冻结之后 允许注册 外赋属性(符号(id作hash) 作 址引)
      可自由添加 任意外赋方法，而不与 内禀方法 冲突:在使用上 进行区分:
        sf[名纟内禀方法,...]
        sf[:名纟外赋方法,...]
    是否可以更新？是否独立冻结？(在整体冻结之后，仍可窜改，允许窜改几次？)
  冻结:类型、实例，初始化 只有在 声明 完成后 才算 不变量关系式 成立
  种属关系:分支构造器:分支类型(种)vs外观类型(属)
    循环引用:分支类型 与 外观类型 相互引用
      所以 冻结操作 必须独立出来
      打破循环引用，可使用 循环引用组
        对象==循环引用组+址引(或 裸指针/弱引用)
    未冻结对象 被记录下来，每逢 冻结操作，要求 指明批量冻结的对象 是 所有 未冻结对象(或者 依照 先入先出 次序，必须是 最旧一批 未冻结对象) 并且 必须是 循环引用，合成 循环引用组 一起冻结
===
源起:
/sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/2.3.html
===
The method resolution order used by new-style classes has changed, though you’ll only notice the difference if you have a really complicated inheritance hierarchy. Classic classes are unaffected by this change.
  Python 2.2 originally used a topological sort of a class’s ancestors
  , but 2.3 now uses the C3 algorithm as described in the paper “A Monotonic Superclass Linearization for Dylan”.
  To understand the motivation for this change, read Michele Simionato’s article The Python 2.3 Method Resolution Order
    , or read the thread on python-dev starting with the message at https://mail.python.org/pipermail/python-dev/2002-October/029035.html.
  Samuele Pedroni first pointed out the problem and also implemented the fix by coding the C3 algorithm.
]]
[[
/sdcard/0/0my_files/unzip/py_doc/python-3.12.4-docs-html/whatsnew/2.6.html
===
PEP 3116: New I/O Library

Python’s built-in file objects support a number of methods, but file-like objects don’t necessarily support all of them. Objects that imitate files usually support read() and write(), but they may not support readline(), for example. Python 3.0 introduces a layered I/O library in the io module that separates buffering and text-handling features from the fundamental read and write operations.

There are three levels of abstract base classes provided by the io module:

  * RawIOBase defines raw I/O operations: read(), readinto(), write(), seek(), tell(), truncate(), and close(). Most of the methods of this class will often map to a single system call. There are also readable(), writable(), and seekable() methods for determining what operations a given object will allow.

    Python 3.0 has concrete implementations of this class for files and sockets, but Python 2.6 hasn’t restructured its file and socket objects in this way.

  * BufferedIOBase is an abstract base class that buffers data in memory to reduce the number of system calls used, making I/O processing more efficient. It supports all of the methods of RawIOBase, and adds a raw attribute holding the underlying raw object.

    There are five concrete classes implementing this ABC. BufferedWriter and BufferedReader are for objects that support write-only or read-only usage that have a seek() method for random access. BufferedRandom objects support read and write access upon the same underlying stream, and BufferedRWPair is for objects such as TTYs that have both read and write operations acting upon unconnected streams of data. The BytesIO class supports reading, writing, and seeking over an in-memory buffer.

  * TextIOBase: Provides functions for reading and writing strings (remember, strings will be Unicode in Python 3.0), and supporting universal newlines. TextIOBase defines the readline() method and supports iteration upon objects.

    There are two concrete implementations. TextIOWrapper wraps a buffered I/O object, supporting all of the methods for text I/O and adding a buffer attribute for access to the underlying object. StringIO simply buffers everything in memory without ever writing anything to disk.

]]



