TODO2
用 文件管理器 重命名 文件夹时，文件夹内的文件全部丢失！
  /sdcard/0my_files/tmp/dot/
    draw -> draw-plantri-adc3m3-[4-16]d--png
  用termux::mv则未曾丢失



view ../lots/NOTE/abbr/word_old1.txt
  pseudo
view others/数学/编程/术语/我的术语.txt
?TODO
.DONE
!WORKING

@All
?Some
&Recur
\Abstract
$Let
[proposition]
->
::
<:

『醒目文本』
    普通文本的醒目强调形式
〖特义词条〗
    被赋予特殊语义的词条
    一般都是已定义/将定义的技术性词条
【醒目特义词条】
    特义词条的醒目强调形式

==================================[ZZZ
==================================]ZZZ


注意:编译、+x脚本 均不得在storage即/sdcard/中进行，用户权限问题

github 网页直接上传文件 25MB 选25000KB
rar 进后台会中断
tar -xzf rebol.tar.gz
tar -xzf rebol.tar.gz -C ./
  The result will be a new directory containing the files.
  -x extract
  -z gz
  -f fname
pip --default-timeout=1000 install networkx

enew
read !ls /sdcard/0my_files/novel/
  #阅读器：小说 按 名字 排序，但没有 搜索功能，极难定位

view others/app/termux/apt_pkg.txt
view /storage/emulated/0/0my_files/git_repos/txt_phone/txt/others/app/termux/lftp.txt
view others/app/termux/wget/wget.txt
  wget -k -r -l1 https://www.latexlive.com/help
view ../lots/NOTE/internet/download/curl/cmd.txt
      curl --continue-at - -L --retry 99 -O https://github.com/scipy/scipy/releases/download/v1.5.4/scipy-1.5.4.tar.xz
下边出现广告的处理方法: 导航栏 切换 app -> [安全中心->清理加速->勾选并清除bilibili垃圾] -> [termux->『rm -r /sdcard/Android/data/tv.danmaku.bili/cache/*』] -> 重回bilibili

/storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/CJK/CJK_data/raw/
=======
DONE py module & id for ctrl+p
  view /storage/emulated/0/0my_files/git_repos/python3_src/自己的相关数据/py_modules.txt
  view /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/app/app_output/count_identifiers.py.out/py_doc_381_words.txt
  view ../../python3_src/useful.txt
教程 见others/app/网/哔哩哔哩-教程.txt
  unity3d教程
  manim 教程




133*1651*1058

$ find . -name .ef0b4ddacc046d054f437ba0af966623 -delete
pi cf count by bit_len; [3]++[...]
规范 98MB ...
	"[20200713]zip_selected__e_book_数据_content.txt"中的"简繁对比"缺"通用规范汉字表 2013 pdf 99MB"

upload_book.txt
IRawFile
	multi_files
FrozenRangeSet

py.lzma + head+f[?:]+f[:?] + split


刷牙 洗澡 刮胡子 手机值 工

血：xue4 书面语〖一针见血 除外〗 xie3 口语〖单独成词〗 ????


10.1 看 增城招工 租房 搬家费



紫外灯
吃蛋壳 yes 捣蒜砵9.9元/个 慢研 水萃取粉末？
夹腰 束腰
手表在卖为何不关电
为何米袋故意打洞？
鸡蛋 4.8元/斤 5个2.9元
  ==>> 6毛/个 8个/斤 63克/个
咸蛋腌制:料酒、醋、保鲜膜、盐
为何白醋可用塑料瓶装或用塑料瓶盖？
料酒、酒、醋 区别
腊肠 肠衣 可不可以吃？
20200929 腊肠 32元/kg, 鸡蛋 8元/kg
here
DONE 注音符号 来源 与全拼音对照




?TODO
.DONE
!WORKING
?汉字部首?
.一两笔的汉字
!纯汉字标识内部编程


e ../../python3_src/README\[汉字处理相关数据及脚本].txt
e ../../python3_src/nn_ns/CJK/CJK_data/raw/我的汉字分解原则.txt
e hz/TODO-笔顺码分解.txt
e hz/TODO-汉字部件清单_潘德孚_20030617.txt
e hz/TODO-汉字粗拆分working.txt
e hz/TODO-纵横字体.txt
e hz/TODO-汉字拆分设计.txt



䏮u43EEh#U3400pg74 䏮 JA4-753E

####################
######g肉 vs g月
##  肦胊胐脁脧膧+䏓䑃
##  肦u80A6h胊u80CAh胐u80D0h脁u8101h脧u8127h膧u81A7h䏓u43D3h䑃u4443h
##
##  朌朐朏朓朘朣+朊朦
##  朌u670Ch朐u6710h朏u670Fh朓u6713h朘u6718h朣u6723h朊u670Ah朦u6726h
####################


####################
如果『字底艹万』是『力』，『字头艹负』是『刀』，则笔顺码都该是53
  㗗u35D7h㗗 T5-3E3D#U3400pg10 另 字底艹万
  色字头上一把刀
  刀版色:=㔃，T3_457D，上部的右部，上刀下巴/t源的：㔃u3503h㔢u3522h
####################





e others/数学/编程/ill/竟然.txt
竟然
pip 竟然不是 断点续传！
echo 竟然不支持 "--"
  echo "$REPLY"
    what if "-n"
shell的shebang的毛病:
  .sh的shebang示例:『#! /bin/bash』
    毛病:强行指定执行器的硬路径



六经注我








index
  索引
    下标/附标
    指针
  检索/查找
  变址
  标引
  示[食]指 (=index finger)










yield
  i -> o
  i -> (mo, mi->o)
  $ArrYield o mo mi = Return o | Send mo (ArrGenerator mi o mo mi)
  $ArrGenerator i o mo mi = i -> ArrYield o mo mi

  i -> m o
  i -> m (mo, mi-> m o)
  $MonadYield m o mo mi = Return o | Send mo (MonadGenerator m mi o mo mi)
  $MonadGenerator m i o mo mi = i -> m (MonadYield m o mo mi)






e others/数学/编程/co归纳inductive.txt
  coinductive
data Co :: Type
data Co =
  | NotRecursive
  | Inductive
  | Coinductive
data T :: Co -> Co -> Type -> Type
data T x y a b =
  | TC1 (co_set x a) b
  | TC2 (co_set (not y) b)
  | TC3 (co_set (co_get (T x y a b)) b)
  | TC4 (T (not x) Coinductive a b))
  | TC4 (co_set (not $ co_get (T x y a b)) (T y x a b))
  | ...
keyword:
  co_set :: Co -> Type -> Type
  co_set Coinductive t = coinductive<t>
  co_set Inductive t = inductive<t>
  co_set NotRecursive t = t

  co_get :: Type -> Co



let !a = co_set Inductive a
let $a = co_set Coinductive a
cofunc:
  $i 0.. -> 1 $o
  !i 0.. -> 0..1 !o
  result cmp is unsafe
    结果可能是 $o
    除非相等比较的另一边是 !o，且使用惰性求值 #half_unsafe
func:
  $i 0.. -> 1 $o
  !i 0.. -> 1 !o

mapping: i 0.. -> 1 o
injection: i 0..1 -> 1 o
bijection: i 1 -> 1 o
surjection: i 1.. -> 1 o











new version
  new syntax construct / suger
    #normally new parser know old version
    old abstract syntax tree construction + convert ==>> new ast
      Haskell [| |]
  new std lib API
    new primitive
    more primitive
      old primitive become sugar API
    sugar API


















实现NFA=简单版+复杂版.txt

我来翻译NFA:有限并行状态机

有限状态自动机
  极小化

Nondeterministic Finite Automata (NFA)
非确定型有限状态自动机
形式语言 formal language


NFA - 简单版 复杂版
简单版#对应最基本的regex
  约束:
    一起一止
    起=/=止
    起无入，止无出
  两个基本NFA:
    起-[]->止
    起-[符]->止
  三种结构:
    注意:旧止取消结束标记
    注:『指向』即插入 无符转移有向边
    并联union
      #两个NFA起止分别合并
      新起指向两旧起，两旧止指向新止
    串联concatation
      #一NFA的止与另一NFA的起合并
      一NFA止指向另一NFA起
    闭包closure
      #NFA起止合并
      新起旧止皆指向旧起新止

复杂版#难用regex表达
  先独立建点，再画有向边
    有符线/无符线/诞影线
    简称:实线/虚线/影线
    节点有色
      终点颜色 是个有用的输出，用于 词法分析 中，对结果进行粗归类/粗标记。
      颜色 亦用于 灭影断言 中。
      为简单起见，要求 终点的颜色 与 非终点的颜色 不同
      影线 需标上 颜色集，当作影行者的终点色
    影行者 即是 原行者的约束
      目的是实现『前瞻后顾断言』
      当原行者抵达终点后，影行者仍可前行抵达它自己的终点
      当原行者抵达终点后，分几种情况处理:
        *要求 无有影行者 或 影行者 已灭
        *要求 影行者 也抵达它自己的终点
        *要求 影行者 不在抵达它自己的终点
        *影行者仍可前行抵达它自己的终点
            由于 需要 句外信息，这显然不是 句法/语法。
            假设 搜索最短前缀，还行
            假设 搜索最长前缀，则要求影行者记忆之前的可能终点，？不太行？
                ？但是，可将？？搜索最长 转化为 搜索最短？？
    灭影节点:
      甲类是 原行者 行至时，触发
      乙类是 影行者 行至时，触发
      断言若失败则原行者死
      原行者死，则影行者死
      ===
      断言相遇
      断言不相遇
      甲类断言影行者抵达带指定颜色之一的节点
      乙类断言原行者抵达带指定颜色之一的节点
      乙类断言『真』即直接灭影
      如果
  如何融合？与或非
  影行者 针对 其原行者（可能也是影行者）
    行者 即行于 节点网络 中，亦行于 输入符流 中。
      网络节点-简称『点』『节点』『地点』(适用于各种变形: 出生地)
      输入符流的索引-简称『指』『符指』『位指』
    要求一:影行者 从分身起 便走入 独立网络
      需求动机:
        不可能 参与 原网络 的 循环，避免 无限分身
        由于 影行者 的 并行数 受限于 节点数，影行者 的 影行者 的 层数 受限于 要求一，故而 必然是 有限状态。
    『要求一』泛化:
      从 生成影行者的无符有向边 出发，无法回到它的源端
      命名:〖影行者不得重返出生地〗
        *〖诞影线不重入〗
        *〖诞影线重入之前已灭影〗
          比如:『与』型影，将期望在指定节点与原行者复合(灭影)

  状态:
    原状态=原行者+所在节点+相应的所有的影状态
    如果 影状态 不同，则 原行者 即使 在 同一节点 也不得合并。
    ===注意:影行者 本来就会对应多个 原行者，因为 原行者 会进行 实体分身！
    逻辑上 如果 原行者所在节点不同，则 影行者 即使 在 影状态 相同的情况下 也不得合并。
        但 这只是概念上的，实际实现时，为了节省空间，可 允许 状态相同的影行者合并。
        如果 允许 影状态 合并，则 一影状态将有多个原行者，当说的『原行者』时，便是指合并前的复数个原行者。
        一切 操作 需与 不合并的情形 操作结果相同

  前瞻后顾断言:
    指定异端
      当 影行者 踩点时，触发断言
    指定异端边界
      当 原行者 踩点时，？触发断言
    异端自由
      当有 正行者 抵达 止点，？分情况，可能影行者还要前行


regex的语法:
  采用 多字符转义
  字符转义
    [[uXXXXh]]:
      unicode转义
      如:
        [[u0h]]
    [[/转义负载/]]
      如:
        [[/全文起点/]]
        [[/换行/]]
        [[/循环*/]]
        [[/循环+/]]
        [[/循环?/]]
    [[[协议/转义负载/]]]
    [[([协议/)转义负载(/])]]
      如:
        [[([生肉/)直接字符串(/])]]
  字符集描述:
    阳性字符集:[[+字符列+]]
    阴性字符集:[[-字符列-]]
  字符 可能是 阳符#语法中的终止符
    必然涉及 长名引用
    阳符集并补表达式:
      并集:
        +阳符集名+阳符集名
      补集:
        +阳符集名-阳符集名
        -阳符集名
    阳符句串联表达式:
      #允许 空
      ,阳符集并补表达式,阳符集并补表达式
    阳符句并联表达式:
      #允许 空
      ;阳符句串联表达式;阳符句串联表达式
    多个阳符集引用:
      #单阳符 可视为 单元素集合
      [[:阳符集名:]]
      [[:阳符集并补表达式:]]
        如:
          [[:+阳符集名+阳符集名-阳符集名:]]
          [[:-阳符集名+阳符集名-阳符集名:]]
    阳符集 的 串联/并联:
      [[.阳符句串联表达式.]]
      [[|阳符句并联表达式|]]







他空行
  可用于 跳过 空白/注释


语法
  ^优先并联输出名:@可选标记名
    /路径规则名 = 引用名@可选标记名
    /中间名/.../规则名 = 引用名@名...@标记名

  |互斥并联输出名:@可选标记名
    /路径规则名 = 引用名@可选标记名
    /中间名/.../规则名 = 引用名@名...@标记名

  ,串联输出名:@可选标记名
    .路径属性名 = 引用名@可选标记名
    .中间名.....属性名 = 引用名@名...@标记名
    !!!         #用于 优先并联，是我 提前锁定

  &自新输出名 = 引用名@可选标记名

  ====勤性
  $循环输出名 = 引用名*@可选标记名
  $循环输出名 = 引用名+@可选标记名
  $循环输出名 = 引用名?@可选标记名
  ====惰性
  $?循环输出名 = 引用名*? 引用名
    $?ysz = y*? z
    ==>>
    ^ys0:
      /ys1 = ys1
      /y0 = pass
    ,ys1
      .hd = y
      .tl = ys0
    ^ysz:
      /z = z
      /yysz = yysz
    ,yysz:
      .y = y
      .ysz = ysz


  『优先并联』于『勤性/惰性』的区分实现是必须的
  『自新输出名』-假如不支持循环，手写的话，显然需要对结果进行合并，即由链表变成数组，这时就需要一个真正的引用名
  『引用名』是『输出名』/『输入名』
    ！！！对于『优先并联』而言，分支名 亦可被引用，含义为自此以降，可用于 优先级不同的多个 二元运算符 构成的表达式 自我引用中
  『并联』情形，由于『引用名』必然不同，故『规则名』，也可以是『并联输出名@引用名』，但『路径规则名』可能更达意
  『规则名』=『并联输出名@引用名』/『并联输出名/路径规则名...』/『其他输出名』
      用于『语法树的规则节点』
      并非『引用名』
    『路径规则名』『可选标记名』主要用于『数据变换』
    『可选标记名』-数量任意，无序集合












注释
  注释出现的位置太随意了
  很难融入到CFG语法中，也难以从语法树中复原
    #考虑下，Python不遵守缩进规则的注释
  基本只能当作噪声去掉
  为了能统一处理/复原注释，我们需要将注释纳入语法体系，空白字符也一样
  具象语法vs抽象语法
    只需对〖具象语法〗中的『引用名』作标记和归类，便可定义 不同 程度的〖抽象语法〗






勤性求值/惰性求值/重复求值
  ？重复求值，值永远是表达式，每次匹配从新求值
    无法想象

已知 有向无环图 的 节点数 及 出度上限，入度不限，各点颜色不同，问：有几个图？
  假设 节点数n，出度上限o
  假设 节点的深度 指 节点到源的最长距离
  按 深度 分层，设 层数m
  m>=1，每层至少一个节点，除了源，其他节点 必在 上层某一节点 有边
  分层的组合数:
    层非空，所以对某一排列的节点 进行染色
惰性求值 与 引用计数
  假设 数据只读
  数据完全展开就是一个有向图
  强连通分量视为一个大点，则是有向无环图
    此时，引用计数便有用武之地
    引用计数 与 强连通分量 一一对应
  ====乙区
  甲区 说反了
  1. 虽然 数据 从用户角度看 结果是只读的，但 既然有从 表达式 到 值 的变化，显然实际上 不是只读的。
  2. 由于一开始 惰性表达式 代表数据而存在，如果把表达式看成一个点(实际上是有向图)，那么这个点将会分裂成(或被取代)多个点，关键是这些新点整体上指向外部的边 是『不增反减』的(将指向同一外点的边当作一条)

  ====甲区
  但是由于是惰性求值，有些节点和边并未出现
    好消息是，由于数据只读，强连通分量不减。
    (比只读更弱的要求:只要引用的对象的集合不变就行，甚至只要保持强连通分量不减就行)
    坏消息是，在新点新边加入后，检测循环并不容易
      ，与C++判断是否子类是同样难度
      给出 有向无环图 中的两个点，判断它们是否相通
      有向无环图 的 数量？编码？信息论 比较信息比特位
      注意:数据循环是受类型循环控制的
      所以 可认为 出度 有上限
      我们将类型相同的放在一起(析构函数可省)，再将互相引用的类型放在一起，这里说的类型 是 不含 参数变量 的
      因此 有向图 的 节点数 可知
      已知 有向无环图 的 节点数 及 出度上限，入度不限，各点颜色不同，问：有几个图？
  受控的环境:
    新点 由表达式而来，新边 由赋值而来
    a = f b
    a 将去哪里？多个地点
    b 将去哪里？
    f 的上下文？自由变量
    ===
    循环函数(相互引用的函数)
    ===
    数据循环 是怎么被引入的？
    必然是由于允许:
      *1
        x = f x
        x = f [1,x] # 返回值x 是 输入列表 后代
        x = f (g x)
      *2
        x = f y
        y = g x
        打包:
        c.x = f c.y
        c.y = g c.x
        ==>> c = fg c
    标记: 函数的本次调用，返回值是某个输入的后代(含 自身)
      当 函数是构造器时，形成循环
      注意:数据循环是受类型循环控制的
        所以 需要 标记的输入只有？
    其实 可以这样:
      x = f weakref(y)
      y = f weakref(x)
      但 外部 拆开 x，指向中间节点怎么办？
        还是需要 合并 强连通分量
        x = 2:3: if g i then [] else x
      正常<x> = f 强引用但拆包要标记<x>
        正常<x> 不论 拆包 还是 直接 被构造器捕获，都正常
        强引用但拆包要标记<x>
          #注意:多变量情形，则x换成 变量包
          *拆包:
            同循环类子节点 也要作 相同标记
            并且 记录 父节点，即保存唯一的向上路径
            ！行！
          *直接 被构造器捕获:
            试图 向上 合并，但父节点是动态增加的
              外部的拆包 在此之前！！
              但外部 看到的 都是正常节点！！
            好在调用路径只有一条，沿着 自顶向下 的 赋值=(但？尾递归优化-深度变浅！) 与 构造器(但？有多个分支！) 可得到一条路径
              ！错！
            更正:见上面 拆包，保存 唯一的向上路径，可行！
    ===
    综上，重述
    第一，只读假设，可得:之后定义的变量可以引用之前定义的变量，反之则不可
    第二，因此，实际上，一次只有一个变量被定义，称之为〖根变量〗
      相互引用？letrec？
      被定义的其实是一个变量包，相互引用的乃是它的属性，或者更广泛地讲，是它的后代
    第三，后代定义过程中引用的〖根变量〗只能是被标记的，称之为〖代理根变量〗
      后代被赋值时的右侧表达式中，最外层函数的该次调用，将绑定唯一的〖根变量〗
        后代本身或亲戚相互引用时，仍旧绑定原来的〖根变量〗。
    第四，〖代理根变量〗拆包时，其所有后代均被标记，称之为〖代理变量〗
      注意:变量包定义之外，对它及其后代的引用，都是正常的，无标记的，未被代理。
      〖代理变量〗直指〖代理根变量〗
      〖根变量〗及其后代及它们的代理，均共享同一个〖引用计数〗
    第五，构造器最后一次调用，在生成新后代时，如果发现本次调用







编译
  阳符 必须 表明 起止点，仅保留 起点 是不够的
    1) p, p+1 的 假设是错的
      字节流 -> 字符流 -> 带噪声的重符流 -> 无噪声的重符流 -> ... -> 更高层句法的重符流
      光是 字节流 到 字符流 的 解码，就使得+1不足
    2) 额外位置信息
      如：行列位置
    3) 多个 止点
      如：输入其实是 正则表达式/非确定性状态转移表，而非 数据流


wwwww



匿名/无名
  无名 胜 有名
    java 万物皆类，listener很好，但单独一个回调函数本无需名字，最后还是有了lambda
    无名即是普世通用名
  有名 胜 无名
    支持同时并存多个实现(可能是无关的多作者)
    为何能无名？
    输入输出，输入描述使用组合名
    哪些类型构成哪些关系，其关系的实现若默认唯一，则无需命名
    无名简洁，但无法区分



？饥饿 等待 阻塞 无锁？
并发算法分类/我的想法
  #注：与标准规范定义不同！
  #标准：并发对象分类，而非 并发算法分类
  一）在任意时刻，暂停任意多线程
  ，看看剩下的线程在干嘛
  ，若它们的工作无法取得进展
  ，则可称『阻塞』
  #这里的『阻塞』定义 与 标准同
  ==>>锁 必 阻塞，但 无锁 也可能 阻塞
    #这里 与 标准不同
    #标准说法是：==>>排他锁 必 阻塞；活锁 可 无阻塞(特指 单线程情景无阻塞)；无锁 必 无阻塞 ，可『等待』而非可『阻塞』

  二）安排任意多的线程
  ，控制它们的停顿与执行
  ，看看是否有线程一直在浪费机器时间
  ，若存在这种可能
  ，则可称『饥饿』或『等待』
  #这里的『饥饿』/『等待』定义 与 标准同



=====以下 皆是 标准定义
标准定义:
  无等待/无饥饿-关注 局部 进步
    所有局部皆进步
  无锁-着眼 全局 进步
    作为一个整体来看有进步
  无阻塞-单线程情景无阻塞
    ，比 阻塞 好不到哪去
    ，基本是无用概念，并发环境下 不可能 假设 单线程
    其实 有用，它 可能比 无锁 更快
    ，至于 如何成功？
    可以在数次 失败后 转用 无锁 实现。
    也就是 将 无阻塞有活锁 提升为 无锁
    ，同理 可将 无锁有饥饿 提升为 无饥饿。
    这种提升方法叫 fast-path-slow-path

  看看别人的定义:
    不是线程，而是对象/并发对象
    wait-free <: lock-free <: obstruction-free == non-blocking
    non-blocking
      obstruction-free
        #单线程情景无阻塞
        #多线程可能相互干预，无法前进
        #可能存在 活锁livelock
        存在f
        ，在任意时刻env，任选一线程继续运行，暂停其他线程
        #n=f(env) #显然 与情景相关
        ，被选中线程调用的 该对象 的操作保证能在f(env)步里完成
        想不出，怎样的对象会是这样子
          活锁livelock例子：见下面
      lock-free
        #多线程情景无阻塞
        #总有前进者
        例：CAS/compare_and_swap
        存在f
        ，在任意时刻env，任选n线程继续运行，暂停其他线程
        ，被选中线程调用的 该对象 的操作保证能在f(env,n)步里完成
      wait-free
        #多线程情景无饥饿
        #皆是前进者
        FAA/fetch_and_add
        存在f
        ，在任意时刻env，任选n线程继续运行，暂停其他线程
        ，被选中线程调用的 该对象 的操作保证能在f(env)步里完成


？饥饿 等待 阻塞 无锁？
====并发对象分类
wait-free queue(2016)
  A Wait-free Queue as Fast as Fetch-and-Add
    Chaoran Yang, John Mellor-Crummey

  There are three levels of progress guarantees for non-blocking data structures. A concurrent object is:
    - obstruction-free if a thread can perform an arbitrary operation in a finite number of steps when it executes in isolation
    - lock-free if some thread performing an arbitrary operation on the object will complete in a finite number of steps
    - wait-free if every thread can perform an arbitrary operation on the object in a finite number of steps

====活锁livelock实例
wait-free queue(2016)
  无阻塞有活锁的队列
    活锁 触发:
      频繁出现 队列头指针乙 == 队列止指针丙
      入队
        初时1 ==
        分配完2 <
        暂停3 ==
        CAS失败，循环
      出队
        初时2 <
        分配完3 ==
        CAS成功
        暂停2 <
        循环

  初始化：
    type 数据指针 = 自然数
    type 泛数据指针一
      = 指针值未初始化
      | 真数据指针 数据指针
    type 泛数据指针二
      = 指针值未初始化
      | 指针值不可覆盖
      | 真数据指针 数据指针
    无限长数组甲 :: [泛数据指针二]
    无限长数组甲 = 重复 指针值未初始化
    队列头指针乙 :: 数据指针
    队列头指针乙 = 0
    队列止指针丙 :: 数据指针
    队列止指针丙 = 0

    全局约束:
      无限长数组甲 的 元素 只能 修改一次
      @i. [队列头指针乙 <= i] -> [无限长数组甲[i] != 指针值不可覆盖]
      @i. @a. [队列止指针丙 <= i] -> [无限长数组甲[i] != 真数据指针 a]
      ==>> @i. [max 队列头指针乙 队列止指针丙 <= i] -> [无限长数组甲[i] == 指针值未初始化]

  def 入队（数据指针子）:
    #循环 定位/分配内存
    1）var 原队列止指针丑 = 调用 FAA（&队列止指针丙，1）
    2）var 是否成功寅 = 调用 CAS（目标=无限长数组甲+原队列止指针丑，旧值=指针值未初始化，新值=真数据指针 数据指针子）
    3）成功则 返回，失败则 跳回1）

  def 出队（）-> 泛数据指针一:
    1）若 队列止指针丙 <= 队列头指针乙，则 返回 指针值未初始化
    #循环 定位/消费内存
    2）var 原队列头指针卯 = 调用 FAA（&队列头指针乙，1）
    3）var 是否成功寅 = 调用 CAS（目标=无限长数组甲+原队列头指针卯，旧值=指针值未初始化，新值=指针值不可覆盖）
    4）失败则 返回 无限长数组甲[原队列头指针卯]
    5）跳回1）








CAS 与 ABA
  循环CAS 必然『饥饿』
    总能安排一个永远的失败者
  多生产者，无消费者，单链表队列：
    CAS 可以正常工作
  加上 单消费者呢？
    也没太大问题
    消费者 可一举将 整个链表 摘下
  多消费者呢？
    其实，消费端 才是 ABA重灾区
    消费 首节点(stack)
    ，将链头 由 指向首节点 改为指向 次节点
    ，这时候，可能 原来的首节点 已被消费释放内存，又被分配内存，重新被生产者接入链头
    ，ABA！过时的首节点 重新有效，本身是没问题，但 次节点 已不同，将 过时的次节点 接入链头 是错的。
    消费 末节点(queue)
    ，将 末节点 移出，就得保证 次末节点 还有效
    ，如何保证？
    我觉得可以这样：
      1）确保当前节点有效
      2）在当前节点打下自己的标签，表明占用下一个节点的内容，并负责当前节点的内存释放（当然，若当前节点是链头便无需释放）。
      3）内存释放的时机，由于有无数线程还试图在当前节点打下标签，所以很可能永远无法释放。
      失败！
    ====
    『假设被暂停万年，如何保证手头的节点依然有效』是首要问题
    必须明确 如何共享 节点内存，谁负责释放，当 读取共享节点时必须保证已经获取了它的部分所有权！
      下面这篇论文就不行！读节点信息前没有任何保证！
      lock-free queue(1996).pdf
        Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms (Maged M. MichaelMichael L. Scott)
    ？？错:突然发现，节点全是通过共享指针引用的话，实现会很简单
      消费者在头端，生产者在尾端
      由共享指针决定谁来析构！
      ====
      但是 不行！
      这样一来便要求：next 是共享指针
      但暴露在共享环境中的 共享指针 其复制是个问题
      第一，要 确保控制块不被释放
      第二，要 原子读 共享指针 本身
      第三，要 原子增加 引用计数
      第一个问题 导致 能添加 但 不能提前释放
      ，如果 有一个线程获取一个节点的共享指针后
        ，被暂停万年
        ，后面的所有节点均不能释放
        ，而生产者又在尾端
        ，将有无数内存无法释放！
      可选项：让生产者在头端！
        单链表 意味着 消费者 必须 跑全场
        但 无论如何 消费者也得重头 开跑
        好处是，由于 尾端 不再增长，暂停万年也只能导致有限内存不被释放。
      下面 我给出一个更好的方案，片段承包制！
    ====
    ABA的产生与生产者，脱不了关系
    ，假设突然没有生产者呢？
    A不可能再次出现！
    链头 不断 变化，不是坚实的基础
    可以把自己伪装成生产者，插入 他删隔离点
    一来隔离生产者
    二来声明负责之后的部分片段的链表的析构
    两个方向:
      从本节点向链头方向，称之为 左
      从本节点向链尾方向，称之为 右
      节点的右节点 即 节点 右边 的 下一个节点
      节点的左节点 即 节点 左边 的 下一个节点
    主链表 含3类节点:
      他删隔离点
      数据点
      元始点
    术语:
        称 构建 节点 的 线程 为 该节点的 构线程
        称 负责析构 节点 的 线程 为 该节点的 析线程
        节点的 析线程 是 该节点左边（不含 自身）的 下一个他删隔离点（可能是将来）的 构线程
        称 他删隔离点 的 右节点 为 起步失联点
        ，必然存在，链表 初始化时自带一个 元始点
        起步失联点 是 删除的起点

    内存释放:
        每个 他删隔离点 的 构线程 各自 负责主链表 的某个非空片段 的内存释放
        他删隔离点辛 的 构线程 负责的片段如下：
          [他删隔离点辛，不含] -> [数据点i，任意多个]* -> [他删隔离点某 或 元始点甲，包含]
        由于 不含 他删隔离点辛，故称『他删』

    各消费者的垃圾堆:
        垃圾堆-单链表，元素 是 起步失联点
        单链-使用 起步失联点 的 左指针
        遵循 单链表多生产者单消费者 模型

    节点 有以下部分:
      标记位:
        节点种类:他删隔离点/数据点/元始点
        是否禁止进入
          是则表明此后（含此）的数据均已被占用
          元始点 初始化 本属性为『是』
          他删隔离点/数据点 初始化 本属性为『否』

      元始点 无更多数据
      他删隔离点/数据点:
        右指针
          指向右节点
        左指针=0
          0或者指向左节点
        他删隔离点 还有以下部分:
          进入线程数=0
          垃圾堆指针
            指向本节点的构线程的拥有的垃圾堆
        数据点 还有以下部分:
          数据

    总体初始化:
      var 元始点甲 = 新建 元始点:
        .节点种类 = "元始点"
        .是否禁止进入 = "禁止进入"
      var 主链表乙 = 新建 主链表:
        .链头 = &元始点甲

    def 生产者动作:
      输入: &主链表乙，&生产者子
      #与 单链表多生产者单消费者 模型 中的 生产者 动作 一致
      1）var 数据丙 = 调用 生产者子.生产数据（）
      2）var 数据点丁 = 新建 数据点:
          .节点种类 = "数据点"
          .是否禁止进入 = "允许进入"
          .右指针 = 0
          .左指针 = 0
          .数据 = 数据丙
      3）调用 插入右向单链表（主链表乙，数据点丁）
      4）跳回1）

    #饥饿
    def 单消费者消费单链表:
      输入: &链表戊
      1）var 原链头寅 = 链表戊.链头
      2）若 原链头寅 == 0，则 返回 原链头寅
      3）#用CAS尝试将 链表头指向 0
        var 是否成功卯 = 调用 CAS（目标=&链表戊.链头，旧值=原链头寅，新值=0）
      3）失败则跳回1）；成功则返回 原链头寅

    #饥饿
    def 插入右向单链表:
      输入: &链表戊，&节点己
      1）var 原链头寅 = 节点己.右指针 = 链表戊.链头
      2）#用CAS尝试将 链表头指向 节点己
        var 是否成功卯 = 调用 CAS（目标=&链表戊.链头，旧值=节点己.右指针，新值=&节点己）
      3）失败则跳回1）；成功则返回 原链头寅

    #饥饿
    def 插入左向单链表:
      输入: &链表戊，&节点己
      1）var 原链头寅 = 节点己.左指针 = 链表戊.链头
      2）#用CAS尝试将 链表头指向 节点己
        var 是否成功卯 = 调用 CAS（目标=&链表戊.链头，旧值=节点己.左指针，新值=&节点己）
      3）失败则跳回1）；成功则返回 原链头寅

    def 消费者动作:
      输入: &主链表乙，&消费者丑
      0）初始化 自己的垃圾堆
        var 垃圾堆庚 = 新建 垃圾堆单链表:
          .链头 = 0
      1）调用 消费前准备（主链表乙，垃圾堆庚）
      2）#伪装成生产者
      2.1）var 他删隔离点辛 = 新建 他删隔离点:
          .节点种类 = "他删隔离点"
          .是否禁止进入 = "允许进入"
          .右指针 = 0
          .左指针 = 0
          .进入线程数 = 0
          .垃圾堆指针 = &垃圾堆庚
      2.2）var 起步失联点指针壬 = 调用 插入右向单链表（主链表乙，他删隔离点辛）
      2.3）他删隔离点辛 = 0
        #由于是『他删』，自挂上起，万年过去，可认为已经死了
        #起步失联点指针壬 也可能已经被放入 垃圾堆中

      3）#向右步进然后调头
        #从自己的起步失联点向链尾步进
        #若遇到 禁止进入的 节点，则 调头
        #  ，不可能到达 链尾
        #若 发现节点的 上一个节点 属性 还未被初始化，则 给它赋值
        #每次经过 他删隔离点，便将该节点的『进入线程数』加一

      3.1）#向右准备动作
        3.1.1）#bug: 起步失联点指针壬 他删隔离点辛.右指针
        3.1.2）var 当前节点指针癸 = 起步失联点指针壬
      #循环
      3.2）若 当前节点指针癸->是否禁止进入 == "禁止进入"，则 转至4.4）#不是 4）
      3.3）若 当前节点指针癸->节点类型 == "他删隔离点"，则:
      3.3.1）当前节点指针癸->进入线程数 += 1
      3.3.2）若 当前节点指针癸->是否禁止进入 == "禁止进入"，则 转至4）#不是 4.4）
      3.4）当前节点指针癸->右指针->左指针 = 当前节点指针癸
      3.5）当前节点指针癸 = 当前节点指针癸->右指针
      3.6）跳回3.2）

      4）#向自己的起步失联点前进，消费数据
        #现在是向自己的起步失联点前进
        #每次遇到 数据点
        #  ，便试将该节点的『禁止进入』置真
        #    ，成功则消费数据（阻止任何异常）
        #  ；若 它是 自己的本轮开始的 起步失联点
        #    ，则离开链表，否则 继续前进
        #每次遇到 他删隔离点
        #，便将该节点的『禁止进入』置真
        #，将『进入线程数』减一
        #  ，若结果为零，则 将右边的 起步失联点 放入 垃圾堆
        #  ，但 这时可能又有新线程进入！小心！
      #循环
      4.1）var 是否成功辰 = 调用 CAS（目标=&当前节点指针癸->是否禁止进入，旧值="允许进入"，新值="禁止进入"）
      4.2）若 成功 且 当前节点指针癸->节点类型 == "数据点"，则
        4.2.1）阻止异常并消费数据{调用 消费者丑.使用数据(&当前节点指针癸->数据)}
      4.3）若 当前节点指针癸->节点类型 == "他删隔离点"，则:
      4.3.1）当前节点指针癸->进入线程数 -= 1
      4.3.2）若 当前节点指针癸->进入线程数 == 0，则:
      4.3.2.1）var 允零右指针午 = 当前节点指针癸->右指针
      4.3.2.2）若 允零右指针午 != 0，则:
      4.3.2.2.1）var 是否成功巳 = 调用 CAS（目标=&当前节点指针癸->右指针，旧值=允零右指针午，新值=0）
      4.3.2.2.2）成功则 调用 插入左向单链表（*当前节点指针癸->垃圾堆指针，*允零右指针午）
      #可能来自 3.2）
      4.4）若 当前节点指针癸 == 起步失联点指针壬，则 转至5）
      4.5）当前节点指针癸 = 当前节点指针癸->左指针
      4.6）跳回4.1）

      5）#本轮消费结束
        跳回1）

    def 消费前准备:
      输入: &主链表乙，&垃圾堆庚
      全局输入: &系统调用
      1）调用 消费前准备一清空垃圾堆（垃圾堆庚）
      2）var 是否为空未 = 调用 消费前准备二检查主链表是否为空（主链表乙）
      3）非空则 返回
      4）调用 系统调用.休眠（）
      5）跳回1）

    def 消费前准备二检查主链表是否为空:
      输入: &主链表乙
      1）返回 "非空"

    def 消费前准备一清空垃圾堆:
      输入: &垃圾堆庚
      1）var 原链头寅 = 调用 单消费者消费单链表（垃圾堆庚）
      2）调用 默认版释放以右向单链表为元素的左向单链表（原链头寅）
      3）返回

    def 默认版释放以右向单链表为元素的左向单链表:
      输入: 允零当前节点指针戌
      1）调用 释放左向单链表（允零当前节点指针戌，默认版释放右向单链表）
      2）返回

    def 默认版释放右向单链表:
      输入: 允零当前节点指针申
      全局输入: &系统调用
      1）调用 释放右向单链表（允零当前节点指针申，系统调用.释放内存）
      2）返回

    def 释放右向单链表:
      输入: 允零当前节点指针申，释放函数
      1）若 允零当前节点指针申 == 0，则 返回
      2）var 允零右指针酉 = 允零当前节点指针申.右指针
      3）调用 释放函数（允零当前节点指针申）
      4）允零当前节点指针申 = 允零右指针酉
      5）跳回1）

    def 释放左向单链表:
      输入: 允零当前节点指针戌，释放函数
      1）若 允零当前节点指针戌 == 0，则 返回
      2）var 允零左指针亥 = 允零当前节点指针戌.左指针
      3）调用 释放函数（允零当前节点指针戌）
      4）允零当前节点指针戌 = 允零左指针亥
      5）跳回1）

    ====
    成功！完全避免ABA，消费无阻塞，所有数据的对所有消费者透明，确定性有限内存的释放过程被阻塞！我是真的牛逼！
      #饥饿/等待 只发生在 链头，不论是 主链表 还是 垃圾堆
      #     只是 消费者 也参与 伪生产，所以 消费动作 可能 永远无法 发生！
      #     同样 生产动作 可能 永远无法 发生！
      可以这样：新建 另一链表，让消费者 提出 挂载 请求？
    需求:
      原子操作:
        CAS/compare_and_swap，FAA/fetch_and_add
      任一时刻的线程数量不超过 原子操作 所能处理的最大机器字的上限（引用计数）。
    ====
    还可以优化！
    没必要 那么多『禁止进入』CAS，可用FAA投票瓜分
    右向步进 加速:
      右向到达一个 他删隔离点/元始点 后
      ，若 投票标记 已被开启（元始点 初始化 开启），则 反弹
      ，赋予 本片段节点数，用于决定投票人数上限
      如果如果 之前的 他删隔离点 非空，则 赋予 一个加速链接 直达 当前的 他删隔离点
    最后片段 投票:
      当 某个线程 触底反弹 时，必是在 非数据点，且 投票 开启
      查看 总瓜分数
      ，若 大于等于 本片段 数据点 总数，则 参与瓜分太迟，结束本轮消费 或 返回 前一 他删隔离点 若 可能的话
      ，否则 使用 FAA 参与投票瓜分 数据点...
  投票标记 可命名为 开启本片段数据瓜分并禁止进入右片段
    在增加 右片段 的 共享引用计数 后，必须 重新 检查此标记
    在减少 右片段 的 共享引用计数 之前，必须先 开启此标记
    其实 本标记 直接就可以是 投票结果/已投票参与瓜分的人次（每人可多投几票）
    ======
    解决饥饿问题！！！！！
    其实很简单，那些需要挂到链头的线程在自己的公开属性上，声明请求，挂载前尽量搜集请求，一并挂载
      或 一次挂载两个
        ，其中一个可能为空，是从下一个需要帮助的失败线程中取得的请求
        ，同一个挂载请求可能会被挂载多次
        对标受助者 自动更改
        不行！还是有饥饿存在
        看来，不论成功是不是受助的，都必须帮助对标者
        ，若存在一个不断失败的线程，则最后必是所有其他线程都来帮助它！效率？














线程通信
  *通过 共享的 并发对象 通信
  *通过 访问 受保护的 共享的 非并发对象
    某一线程对 非并发对象 的 写访问，必须与 其他线程的 读写访问 隔离开
    隔离 则是通过 共享的 并发对象 实现
  如何 共享 对象？
    如何 分发 对象？
      分发 也是 通信！
      根源:
        *空降 全局并发对象
        *单线程通信
          由 父线程 分发给 运行前的子线程
    如何 保证 对象 生存期？
      *营享-使用权
        裸观
      *股享-所有权
        *独享
        *比享
          引用计数
夭寿-见下面
多个动作被并行执行 与 对象被并发访问
？并发对象 的 分享方法 与 共享对象
  存在性共享 与 并发访问性共享
  并发访问性共享 必然 要求 存在性共享
  并发对象 的 分发/传播 并不简单
  并发访问性共享 又可分为 单线程异步等待并发/？单线程随机调度？/多线程随机调度并发（单核串行多线程并发/多核并行多线程并发）
  调度器线程
    一切线程的祖先
    最寿线程
    负责启动主线程
    负责析构全局变量
  并发对象 的 分发方式
    1）寿父线程 在启动 夭子线程 时 作为参数传入
      调度器线程 作为 寿父线程
    1.1）偏享并发对象
      偏享-不享有所有权，但分享 使用权
      寿父线程 担保 并发对象的存在性（寿于 夭子线程）
      全局并发对象 即是 重要特例
    1.2）析享并发对象
      析享-共享所有权并享有使用权
      析享并发对象 必然含有 引用计数
      线程 得到 析享并发对象 的 裸指针 有用吗？
        线程 已享有的情况下 复制指针不难
          因为 对象 必然存在，只需 增加 引用计数 即可
        难的是 线程 未享有的情况
          此时 裸指针 毫无意义！
          暂停万年，对象已死
          事实上 无法增加 引用计数
        所以 引用计数 必是 别的线程 提前 加上的
        如：
          生产者 将 析享指针 放入 共享并发容器
          ，消费者 从 共享并发容器 中得到 析享指针
        该过程 也可以 这样说：
          生产者 将 引用计数 加一，再将 裸指针 放入 共享并发容器
          ，消费者 从 共享并发容器 中得到 裸指针，提前占有一个 计数值。
        当然，若 裸指针 一直停留在容器中直至容器析构
          ，则 容器也需要 将 计数值 减一
          ，所以 容器 也必须是 拥有者
        不是线程拥有，而是容器拥有
    2）线程 通过 已有的 共享并发对象 分发 新的 析享并发对象
      其他线程 作为 寿父线程:
        通过 调度器线程 提供的 全局并发对象 向 调度器线程 发送消息
  保存于 并发访问性共享对象 中的 非并发对象，需要 控制访问

  内存模型:
    单个内存地址读写 的 原子性
      并发访问而无竞争
    多个内存地址读写 的 原子性
      什么情况下 能保证 多个操作 如同 原子操作
      要求 使用 排他锁
      或 使用 可线性化的并发对象 提供的 单个 操作
    内存数据 的 可见性
      什么情况下 一线程写入的内存数据在另一线程可见？
      ===脏值刷出，旧值更新
      java.volatile变量 是 并发对象
      c++.volatile变量 不是 并发对象
        仅用于 中断时 中断处理函数 与同一单线程下的被中断函数 之间的信息交互
    多个内存地址读写 的 有序性
      什么情况下 能保证 读次序 与 写次序 一致？
      要求 写方 写前写/修改后刷出脏值 与 读方 读后读/更新旧值后读取
      但为保证 非并发对象 的读写不发生竞争，其修改序列 对应于不同线程的片段 必须 由 原子变量 的 读写 隔离，确保『先于』以防止『竞争』，故而 类似锁，原子变量读后其他变量读写，原子变量写前其他变量读写。

  单线程异步等待并发 的特点
    异步等待==>>可见性、有序性
      异步等待点 相当于 内存栏栅
      而且 也是 唯一的调度点
    但 多个操作的原子性 仍是个问题
    只要中间发生 异步等待，原子性 便遭到破坏
    反之，只要这 多个操作均有原子性，则 整个操作序列 也具有 原子性！
  单线程随机调度并发 的特点
    ====
    见c++.volatile，中断处理函数 与 被中断函数 实际上就是同一线程
      ，单变量的可见性 并不自动满足
    ====
    单线程怎么随机调度？既然随机调度，那还是单线程么？
    比如：脚本解释器，并允许单线程下无关的脚本语句交换次序？
    似乎也只能是解释执行，但凡使用机器中断，也就变成多线程调度
    但也可以 插入无数个 中断安全点 以供 中断，只是 用户 不能控制 这些中断
    ====
    单线程随机调度==>>要求 禁用 语句次序交换优化 ==>>有序性
    但 原子性、可见性 有问题
    单线程==>>可见性 可轻松实现
      只需 指定变量 在 中断安全点 刷出/更新 即可，内存栏栅？？？
  单核串行多线程并发 的特点
    原子性、有序性、可见性 都有问题
    函数的单线程假设优化，会导致脏值不能随调度而即时刷出，旧值也不会自动更新
    单核串行==>>基本类型单地址的原子操作 可轻松实现
    单核串行==>>可见性 可轻松实现
      只需 针对指定变量 禁止部分优化
      ，或 只允许 读/写 两类操作
      ，相当于 只有 read/store 两个操作的原子变量
      ，相应的 内存栏栅 该怎样？为什么？
    可以有 编译优化，但 源代码使用的概念及API与 多核并行多线程并发 并无不同！
      故 将它们归入『多线程随机调度并发』
  多核并行多线程并发 的特点
    原子性、有序性、可见性 都有问题
    即使是 基本类型单地址的原子操作，也需要 机器的特别支持




编程

数据的内存布局
  类:
    最外层类
    非最外层类
    ===
    任何一个类 都可以用来声明数据，此时作为 最外层类
      要求 一整块 连续 内存
      包含 所有成员
      还可以包含 其他东西
        如：
          动态 类静态信息表指针
            语言 可提供给用户自定义 追加静态信息 的功能
          空类 要求 非空填充
          其他 语言本身 所需的实现细节用 数据
            如：
              引用计数
              并发用 锁
              垃圾回收用 标记位
          语言 提供给用户的自定义 追加信息 的功能
            全局
            某类的所有子类
            某些类组合的所有子类
            符合特定条件的类(如：上面 空类 就被识别)
              条件与破坏
                同一条件被不同自定义规则识别，并各自破坏该条件 怎么办？
                如：空类 要求 非空填充
                  可其他条件规则可能导致空类非空
                  所以 空类 识别应当放在最后
                    ，可这样一来，各规则便有优先级
                    ，而各规则必是独立起源，不可能统一
                    ，只能类似解方程组的方式？
                  但还是有问题，API没问题，但ABI有问题
                    全局性规则 的 不同 必导致ABI改变
                      所以全局性规则 必须集中起来 并参与 各独立模块的编译
                    局部性规则 通过依赖传递 达成同样的效果

    任何一个类 都可以被其他类型用于声明成员，此时作为 非最外层类
      不必 一整块 连续 内存
        缓存效率低？
        如：浮动的 虚基类
        数组 分两类
          各元素 独立 的 真数组
            支持 原生指针 加减
            各元素自身完整连续
            支持直接内存复制
          各元素 混合 的 伪数组
            是 多个同类型成员 的 泛化版，借用 数组接口
            若长度太大，则静态信息爆炸
              未必
              *可以先分小组，小组内混合，小组的数组 及 剩余尾元素 构成 整个伪数组
              *各成员 独立 构成 数组，各数组 构成 整个伪数组
                支持 原生指针 加减
                各元素自身不连续

      不必包含 静态信息表指针
        #见下面，即 相当于 无 自解浮动数据成员
        #   而 他解浮动数据成员 的 内存布局表 通过 与 共享指针 捆绑传入
        #
        特别是 高层语言 只使用引用(外加 纯值传递POD) 的 情况，如：shared_ptr，可以这样:
        共享指针 的 权指针 指向 堆上的 最外层类 的对象
        ，值指针 指向 其某个子对象(属性的属性任意级)
        ，但 最外层类信息表+子对象静态类型声明 无法确定 子对象的 真实的内存 布局
        ，需要 额外的 内存布局表 / 子对象的 完整路径名
        # 或一 外共享指针 -> {共享控制块}{子对象指针/值指针，子对象内存布局表指针(->含 整对象位移，但没必要)，内共享指针->{共享控制块}{整对象/权指针所指} }
        # 或二 外大指针=={子对象指针/值指针，子对象内存布局表指针(->含 整对象位移，但没必要)，内共享指针->{共享控制块}{整对象/权指针所指} }
        # 或三 外大指针=={子对象完整路径名，内共享指针->{共享控制块}{整对象/权指针所指(含 整类信息表指针->含 {子对象完整路径名:位移(配合 权指针 得 值指针)+内存布局表})} }
        ，最大的问题是访问数据成员需要解引用多次，时间效率低，对缓存不友好
        ，虽然 shared_ptr本身 访问效率也不高
        ，但可提前解引用一次，同一函数内 后续使用 裸指针
        ，但 高层语言的函数 只接受 共享指针
        ，但 可在 函数内 解引用 一次，在需要传入其他高层函数时才用 共享指针 封装
        ，其实 可以一直使用 裸指针，直到 高层语言 给 引用成员 赋值，才需要 封装(enable_shared_from_this)
        ，[！！！输入 可用 裸指针，但输出 只能用 共享指针，保存 返回值 也只能用 共享指针 ！！！]
        ，但是 1）栈帧 是否 独立？若 函数对象 不能 保存 栈帧，那也需要 保存 捆绑 的 栈变量，即 定义 有 自由变量 的 函数对象 时，相当于 引用成员 赋值
        ，2）enable_shared_from_this只能给 最外层类对象
        ，2.1）每个子对象都保存整对象指针，自解用，但 这相当于/强于 保存 静态信息表指针
        ，或2.2）不存在 不完整的子对象，成员对象不存在他解浮动数据成员，比如：是引用，纯值传递POD（高层语言 不能引用 的 纯值）...
按位置的访问方式区分数据成员
    作为 非最外层类 或 最外层类 时
      *固定数据成员
        由 静态类型声明 即可计算出 数据成员 的 位移
        固定数据成员 一起 构成 子对象的本体
        若无固定成员，其实也没必要区分 整对象指针 与 子对象指针
        只是为了 由 静态类型声明得到 静态位移，才需要 子对象指针
      *自解浮动数据成员
        因为对象本身可能是子对象，静态类型声明 显然 不包含 最外层类 的 静态信息
        部分数据成员 虽然无法由 静态类型声明 确定位移
          ，但是 存在 固定数据成员 指向 浮动数据成员 内存布局表
          ，可仅通过 静态类型声明+this裸指针 便能动态得知 浮动数据成员 位移，故称『自解』。
        例：
          动态数据：
            虚基类
          静态数据：
            自己：
              虚函数
              浮动数据成员 内存布局表
            自己*整体：
              整对象位移
              自己的完整路径名
            整体：
              最外层类信息表
      *他解浮动数据成员
        仅凭 静态类型声明+this裸指针 无法动态得知 的 浮动数据成员，需要 外部环境提供 浮动数据成员 内存布局表，故称『他解』。
    自解浮动数据成员 的 存在 隐含 固定数据成员 的 必然存在
      即使 该固定数据成员 是对用户透明
      因为至少需要 自解 所需的信息
    他解浮动数据成员 的 存在性 相对独立
      ，但 在设计良好的 系统中：
        ，自解浮动数据成员 的 存在 隐含 他解浮动数据成员 的 不存在
    即 有6种共存方式：
      *无数据成员
      *固定数据成员
      *自解浮动数据成员+固定数据成员
      *他解浮动数据成员+固定数据成员
      *他解浮动数据成员
        #奇怪，但确实可以有
      *他解浮动数据成员+自解浮动数据成员+固定数据成员
        #系统设计不统一，或者 无法统一
        # (不同语言层次的设计，或 独立设计的系统的糅合)
    C++ 显然没有 他解浮动数据成员
      ，因为 this 无法访问 等于 不存在
    由于 他解 与 最外层类 相关
    ，故 即使静态类型声明 相同的两个对象 其 内存布局表 也不同
    ，实际上要求 某种形式的『大指针』
    ，各引用独立 捆绑 内存布局表 或 更多的 整类相关的静态信息
  引用 分类：
    小指针：
      不含 他解
      特别声明的最外层类对象 及 无需他解的子对象
      无需他解的子对象 由其原来的 静态类型声明 即可确定
      但 是否是 最外层类对象 是无法从 静态类型声明 看出来的，需要 特殊声明 层层审批
      其实 也可看作一个 自打包类型，截胡固定所有浮动数据成员，打包静态信息
      与其说是 声明最外层类对象，倒不如说 其静态类型(打包后) 本来就 无需他解

    大指针：
      含 他解

  按命名与否区分数据成员：
    无名，则以 静态类型声明 为名
  按共享与否区分数据成员：
    浮动是为了共享，不共享则固定即可
    故 浮动 隐含 共享
      ？？也不一定，浮动可能只是为了减少填充，比如:数组 将 各数据成员 归为一组
    但 共享 不一定 浮动，固定共享归流
    1+2*2=5种
    *浮动共享
      浮动共享 相当于 匿名函数的自由变量
    *固定向上共享与否?*固定向下归流其他共享与否?
      固定向上共享 相当于 对外输出变量
      固定向下归流其他共享 相当于 给子对象的自由变量 赋值
      ===
      为了避免 多个子对象 固定向上共享 引起的冲突
      ，『固定向上共享』只表达『可接受』，不表达『必须』
      ，若 大对象 可指派 其他兄弟 的 浮动共享 归流固定到 特定子对象。（自身的 浮动共享，若 归流给 子对象，其实只是 别名）
      固定向下归流其他共享 可有选择地 截胡
        #可截胡固定子对象的浮动数据成员
    可分流直接子对象间的同名共享数据成员至不同名，合流不同名共享数据成员至同名
      无名 也是 名
      分流直接子对象间的同名浮动共享数据成员至不同名
        相当于 将 自身的不同名自由变量 各自赋值给 部分子对象的同名自由变量
      合流不同名共享数据成员至同名
        相当于 将 自身的同名自由变量 赋值给 部分子对象的不同名自由变量

  本体=固定数据成员+填充+对齐方式
    声明 大小 及 对齐 即可 分配本体所需内存
    声明 填充 可供 外部利用
      如：标记位、来自其他对象的 浮动数据成员
      但 这样一来 就不能 直接一次内存复制了
      但 可分步复制
    声明 静态信息相关的固定数据成员 只读
      内存复制时需避开这些成员
    声明 带约束数据成员
      用户数据 只能由成员函数修改
      语言实现用数据 只能由运行机构读写
      禁止内存复制
  构造/析构/赋值
    重点:是否父类？有无资源？
      无 浮动数据成员（最外层子类 即无 浮动数据成员）
    构造
      *无需构造===未初始化
        要求:无需析构，无资源所有权
      *零值构造
        用于静态变量初始化，无需保存初始值
        无资源
      *定值构造
        用于静态变量初始化，可能需保存初始值
        建立 内值约束
          资源 可视为 外值约束
        无资源
      *覆盖构造
        允许在不经析构的情况下多次构造
        无需析构
        无 静态信息相关的固定数据成员
        无 浮动数据成员
        无资源
      *析值构造
        允许在经过至少一次析构后构造一次
        析值 是 析构后的值
          如: 有效的 阱值，无效的 坏值
        要求:无 浮动数据成员
    析构
      *无需析构===无资源所有权
        可有 静态信息相关的固定数据成员
        可有 浮动数据成员
        无资源
      *零值析构
        零值 是 有效值
        无 静态信息相关的固定数据成员
        无 浮动数据成员
        无资源
      *定值析构
        定值 是 有效值
        无 静态信息相关的固定数据成员
        无 浮动数据成员
        无资源
      *阱值析构
        连续多次析构等价于一次析构
        阱值 是 有效值
        可有 静态信息相关的固定数据成员
        可有 浮动数据成员
        阱值 无资源，但 非阱值 可有资源
      *坏值析构
        不允许在不经构造的情况下多次析构
        坏值 是 无效值
        静态约束遭破坏
          实际已经无效但静态声明有限的资源
            悬空的指针
    赋值
      *析构+析值构造（复制构造/移动构造）
      *覆盖构造


？std::deque的元素指针是否稳定？
  每元素一new，自然就稳定！
  ====
  一开始 肯定不能分配太多保留内存
  若 要求 元素指针稳定，一旦前期缓存满，势必需要分层
  层数，多层数组 #每级
    1, [a]
    2, [[a]] 或 vector<[a]>
    3, [[[a]]]
  其实只有最底层数组非空时不能删，其他数组用户不可见，可随意处理
  单向stack还好，可以 多级并存，各级最底层数组长度无需统一，可静态确定
  双向deque
    若 多级并存，会很麻烦，
    若 只有一级多层，则 由 元素指针稳定性 可得：各级最底层数组
  好在不论是否稳定，若元素只是 引用/POD 即可移动 且 无外部指针，则 无妨。主要是 高层语言 的 用例。
容器 分类
  修改后，还存在于容器中的元素指针是否稳定
  是否序列？如何访问元素？随机读写？








枯坐三课后
  -先生何以教我？
  -不愤不启
  ===
  -老师，你为何一言不发？我是否举止不当，惹你不快？
  -若你没有疑问，我便也没有什么可教的。
  -现在我就有问题，你真打算就这么一直枯坐下去，这真的是正常的教学吗？
不愤不启，不穷不变，不困不思，不用不学，不见不欲
  没有问题，人就不会思考
  ===
  什么是问题？
  比如试着分类成，主动发现的问题、被动遭遇的问题，合适吗？
  人若麻醉，就不会有任何问题。
  可见不存在无条件的『被动遭遇的问题』
  两者之间并无明确界限。
  身体出毛病，疼痛就是『被动遭遇的问题』
  强烈意识到生存受到威胁，就是『被动遭遇的问题』
  意识到利益受损，就是『被动遭遇的问题』
  看到听到别人提出的问题，就是『被动遭遇的问题』
  『主动发现的问题』通常是指更为间接更为久远更为抽象的问题。一般在思考如何解决手头问题、如何达成既定目标时，会出现更多问题，这些就是『主动发现的问题』。
  也可尝试着分类成『为什么』『会怎样』『怎么办』『是什么』？
  为什么会出现这种情况？
  会与我利害相关吗？
  怎么利用怎么避免？
  怎么达成既定目标？
  有什么相似相反的东西，如何归类，如何细分？




夭寿
  本意表征 存在时间段的的短长
  这里表征 自此刻算起的存在期短长
    ，也就是表征 消亡时刻的先后
  前人/后人-出生时刻的先后
  前鬼/后鬼-死亡时刻的先后

？how to union shared_ptr & weak_ptr？
  std::variant C++17
最简单的安全语言？引用计数版-难点:引用数组
  ===待处理:
    strict指针？
    如何声明，以表示两数组不重合？任何地址皆无别名？
  ===
  引用计数+收敛构造+引用成员只读
    POD成员仍可修改，包括 引用计数
      这里的POD不含引用成员，本身也只能值传递
      memcopy/memzero
      std::tuple 实现 POD
    收敛构造+引用只读==>>无环==>>引用计数可正常工作
  有可修改的POD数组，但无可修改的引用数组
    这可能是个问题
    只被栈帧共享的堆上数组
      ，所有权归调用栈
      ，由于不被对象拥有，引用数组也可修改
      ，但 函数对象 怎么办？上下文 无法包含 引用数组！也不能指向栈帧！

  类型的秩
    实际类型的秩为n的对象（含 可修改引用数组）
      ，其只读引用属性只能接受实际类型的秩小于等于n的对象的引用
      ，其可修改引用属性只能接受实际类型的秩小于n的对象的引用
  模版
    现在 参数类型 多了个 类型秩
  秩的控制
    秩-可自由设定，但只能静态设定
    引用成员只读的类类型 通常为0/-oo，可修改POD数组，只读引用数组
    可修改引用数组 通常为1
    可为负整数
    动态查询 还是 静态控制？
    动态查询
      对象的类型信息指针->(类型，秩)
    静态控制
      T <: S
      mi<=ni<=no<mo < n <= m
      T@n@no@ni <: S@m@mo@mi
      类型@类型本身的秩下限@类型可修改强引用成员输出时的秩的下限@类型可修改强引用成员接受的对象的秩的上限
      n,no可放大，ni可减小
      重点在 函数签名/接口类的设计 及 类模版
        f(X@_, Y@a, Z@b) -> R@m
          with m=1+max(a,b)
        max根本不该出现，因为模版匹配时会将小的秩增大！
        f(X@_, Y@n@no@ni, Z@n@no@ni) -> R@m@mo@mi
          with m=1+n,mo=n,mi=n
        template<T@n> class C@m with m=n
      不行啊，类属性的属性的属性 一连串可修改 怎么办？
        固定 no=n-1
        t@n@ni
        (t.x)@(n-1)@(ni-1)
        显然 有的属性被拖累
    看来 还是得动静结合，一旦静态不行，动态上
  虽然无需垃圾回收，但可能需要碎片整理
    其实 对象足够小 也不需要 碎片整理
    问题在于数组
      最典型的大对象就是那种很长的字符串以及数组
    std::deque 替换 std::array/vector
  析构函数 自救问题？
    需要将自己输出到外部
    由于不能将自己赋值给树下游后代
    所以只能输出到全局可修改引用数组 或 全局引用
    应该把 析构函数this静态类型秩声明为+oo
    其次 不得显式调用 析构函数（不论 对象 还是 引用本身），成员对象 还可能有 外部引用
    所有 类类型 有同一个空接口类祖先，空抽象析构函数
  只读数组 与 可修改数组 之间的关系
    POD数组:
      可修改POD数组 <: 只读POD数组
      错！应该是接口间的关系
      除了成员函数的 this 指针，函数签名 的 输入输出类型 只能是 接口
      可修改POD序列接口@n <: 只读POD序列接口@n
    引用数组:
      可修改引用序列接口@n <: 只读引用序列接口@n
      可修改引用序列接口@n <: 只读引用序列接口@n@(n-1)
        n是自身的秩
        n-1是元素的秩
  弱引用！
    可修改的引用成员 可以 指向任何秩对象
    见:e others/数学/编程/C++/c++智能指针weak_ptr+enable_shared_from_this+diamond-inherit.txt
  全局泄漏
    如果 把所有对象保存在一个全局容器中，其他引用皆为弱引用，这样其实就是泄漏

  考虑 属性/成员/元素/子对象/变量 的 生存期控制
    #甲-子，乙-整
    定义〖久于〗:
      甲对象 久于 乙对象
      ，指 甲死亡时间必须在乙的死亡时间之后
      #主要问题在于返回值，其死亡时间延长不确定
      #     裸观 子对象 不同意 祖先延寿
      #优于〖早于〗的是：〖偏享〗无需 共享指针
    定义〖早于〗:
      甲对象 早于 乙对象
      ，指 甲出生时间必须在乙的出生时间之前
      #共享指针 最好能区分 多线程版 与 单线程版(并存)
      #其实，可以 每线程最多一个 多线程共享指针(强弱并存)，多个 单线程共享指针指向 该多线程共享指针
      #反正，竞争复制 非局部 共享指针 时，也需要 同步，不如干脆 再来一层 共享指针。
      #     atomic_load_explicit/atomic_store_explicit/atomic_exchange_explicit...
      # 这个问题其实比较复杂，若 通过 并发对象 发布 共享指针，则 要求 该指针是多线程版，而通过它得到的 单线程共享指针 必须 明确区分 是否 线程独占/线程裸观
      #原子操作 太慢，50倍耗时，这也是 提出〖久于〗〖偏享〗的初衷
    定义〖小早于〗:
      甲对象 小早于 乙对象
      ，指（甲的秩 小于 乙的秩）或（秩相等 且 甲 早于 乙）

    子对象 分类/先按 久于 分类:
      #属性 是否 可修改？
      #属性 是否 可为空？
      #正交 这4种可能
      独占-负责析构子对象
        立即数
          -不含 任何形式的引用
          -可以是 数组，类，结构体，联合体
        裸占
          裸久
            -子对象 久于 整对象
            -若移出，则移至的目标对象 必须:
              久于 子对象 原先的属性位置（当然 更久于 整对象）
              但 又不能 久于 子对象的任何裸观后代
          裸暂
            -子对象 不必 久于 整对象
            -可提前删除
      偏享
        裸观
            -子对象 久于 整对象
            -不负责析构子对象
      共享
        -分 单线程/多线程
        -可 假设 皆是 单线程 共享指针
        -因为 多线程 共享指针 需要特别的 操作
        - 除了 所有权，这些与 裸暂 差不多
        强引
          -强引用，共享析构权
        弱引
          -弱引用，动态安全观测，不负责析构
          -使用数据前，必须 先变成 强引用
      混用
        裸混#variant
          -从 需要裸观属性的对象 的角度看
          -     裸暂 不可『观』，无价值
          === 裸久 混 裸观
            -仅用于 区分负责析构与否
            -子对象 久于 整对象
        混引#variant
          -从 需要共享属性的对象 的角度看
          -     强引 弱引 只有别于 所有权
          === 强引 混 弱引
    子对象 中的 立即数、裸久、裸观、裸混，久于 整对象
      唯有 裸暂、共享、混引 情况不明
      为阻止产生数据析构死循环，需进一步 分类
      只有 裸暂、强引 会引起 死循环
        同样可用 秩 控制
    返回问题
      返回===裸久 属性 移出
      裸观 属性 不同意 祖先延寿
      可预先指定 裸久属性 的 可能的最长寿命(对比给定的某个传入的虚拟对象)
      最短寿命 由基本定义直接可知，即是属性位置本身
      不指定 最长寿命的话，默认为 最短寿命，此时 等价于 只读属性
        比如：帧上对象，就是 帧的只读属性，不能返回(返回的只能是对象的值，非对象本身)
        只读 指 属性位置本身，不是属性指向的对象
        为了避免误解，不再叫 只读属性
        改称 裸固属性
      非固定的裸久属性 称之为 裸移属性

      当 甲 的 最短寿命 久于 乙 的 最长寿命，则 甲 可以 成为 乙 的 裸观 属性。

  秩 = 自然数 n | ?n. 数组<n,秩>
  长度补 (自然数 n) = -1
  长度补 (n, ls) = n
  秩甲 < 秩乙 | 长度补 秩甲 < 长度补 秩乙 = 真
  自然数 n < 自然数 m = n < m
  (n, xs) < (n, ys) = ?i <-[0..n]. [@j<-[0..i-1]. xs[j] < ys[j]][xs[i] < ys[i]]


崖异绝俗vs和光同尘
阴符vs阳神
  阴符 是 兵书？

崖岸涯
学海无涯 吾生有涯 心不由己
  幽之戚
昏昏昭昭

=====
=====


最简单的安全语言？垃圾回收版-同步太难！
  垃圾回收 ==>> 并发
    对象访问 需要 原子操作？

  对象=堆上对象=堆上类对象|堆上数组
    类对象 或 数组 的 元素 是 立即数

  立即数=POD | 对象引用
    POD 无本身引用 + 元素是非引用非指针非函数指针的基本数据类型
    立即数 有 明确的操作(立即数 归类原因):
      默认构造
      默认析构
      赋值
      复制构造
      全部操作无异常！
      无需额外堆空间
      实际占地大小/对齐方式 固定

  函数签名接口类 爆炸形式:
    interface Call<R,T...>{
      R __call__(T...);
    }
  POD的类化类 爆炸形式:
    class POD2class<T::POD>{
      T data;
    }

  数据 只有:
    调用栈
      函数帧？
      执行地址/状态？
    立即数
    对象
    全局持久只读 的 静态类型信息
      ？成员函数？

如何实现 实时垃圾回收？
  是不是与 引用计数 一样，复制引用时需要原子操作-修改标记位？毕竟有黑户反复橫跳的可能。
  实时垃圾回收 即意味着 并行！
  全局持久数据 并不在 调用栈 上
    ，被引用时 无需 修改〖又被引用〗标记位
    ，但需要 检查〖全局持久〗标记位，此查询须原子操作？
      并发环境下，只读数据 的 读取 也需要 原子操作吗？毕竟 其他进程 可能持有 原地址 的 过时数据。可又好像 见到过 只读数据 无需 原子操作 的 说法。




调用栈=数组〖直接半帧〗 | 数组〖半初始化完整帧的引用〗 | 链表〖半初始化完整帧〗 | 链表〖片段帧〗
  ？唯有 数组〖直接半帧〗 只能固定大小，除非确保帧上数据皆可复制，比如：全是引用/基本类型且无指针泄漏
    其实 链表〖数组〖直接半帧〗〗可破！

  函数对象 上下文 保存问题？
  值 是否 依赖于 调用栈？
  唯有 链表〖片段帧〗 可以 保存 调用栈历史
  若 值 依赖于 调用栈，又无法保存 调用栈历史
    ，引用该值时 静态类型 添加标签『只能出现于下游帧』
    ，确保 一切 克隆值/引用 的所有权 属于 下游帧

循环优于尾递归
  如果 析构 不能在 尾调用 之前进行，则 尾递归 不能优化为 循环
  所以 循环 仍是 首选方式
  (x, t) = loop -> (X,T):
    ...init...
    jump g(...)
    step g(...):
      ... jump h(...)
      ... jump g(...)
      ... jump p(...).q(...)
      ... break y::(X,T)
      ... return z::R
    step h(...):
      ...
    scope p(...):
      ...init...
      step q(...):
        ...
    #不含return的循环就是一表达式
  或者 用jump替代return，代表先 析构 再 尾调用？
    return f(...)
      <==>
        tmp = f(...)
        ...析构...
        ret tmp
    jump f(...)
      <==>
        args = (...)
        ...析构...
        mov args
        tmp = f args
        ret tmp


模版 与 爆炸控制
  类型-对象的静态声明类型
  类组-类型的归类，对象的物理访问接口
    类型 用于声明 对象的数据成员 时，占多大空间？对齐方式？
    类型 用于声明 函数帧上的变量 时，占多大空间？对齐方式？
    类型 用于声明 函数签名的参数 时，对象传递方式？复制？
    构造/析构？时机？
      如果 析构 不能在 尾调用 之前进行，则 尾递归 不能优化为 循环
      所以 循环 仍是 首选方式
    如何 解释 属性？
    有哪些 语义切面接口？
      只读接口 const&
    需不需要 传入 类型对象？
      类型 擦除后，某些功能可能无法使用，需要 类型对象 提供必要信息
      既然 同一类组 不允许引起 模版爆炸
        ，该类型对象 只能 在执行期 提供信息
        ，即 执行期动态传入 类型对象

  类型 可擦除，类组 不能擦除，值 不能擦除
  模版爆炸 一定是 类组实参及值实参的组合爆炸
  模版参数声明:
    别名形参声明:
      #(无需模版调用赋予的实参)
      形参名=形参名/真名/立即值
    形参约束:
      [f(..., 形参名, ...)]

    类组形参声明:
      类组形参名::"类组"
    类组形参功能增强:
      类组形参名<:类组名
      类组形参名<:类组形参名

    类型形参声明:
      类型形参名::类组形参名
      类型形参名::类组名
    类型形参功能增强:
      类型形参名<:类型形参名
      类型形参名<:类型名

    值形参声明:
      值形参名::类型形参名
      值形参名::类型名

类继承 问题
  只继承接口，则接口冲突的解决还简单
    ，若继承实现，则同一接口的实现冲突的解决则很困难
  ===
  源代码三方*新旧版本:
    父类作者
    子类作者
    使用端
    #只考虑API，不考虑ABI
  对父类作者的要求:
    修改父类时
    1）子类可见的 属性名 可新增，不可删减
      数据成员 没问题，最多 命名冲突
        构造函数不变+私有数据成员+公开只读属性
      ？？
      父类 一增加 新的抽象成员函数，具象子类 就得完蛋
        ，除非 声明暨定义
    2）？？输出类型 若改变 只能变成 原类型的子类？？
      可读属性
      成员函数签名 返回类型
        ？？
        使用端 希望是 原类型的子类
        子类作者 覆写时则希望是 原类型的父类
          ，调用时 与 使用端 相同。
        见下面:可读可替换属性
          父类、子类 成员函数返回类型
            分别是 读类型、替换类型
    3）输入类型 若改变 只能变成 原类型的父类
      可替换属性
      成员函数签名 输入类型
        ？？
        使用端 希望是 原类型的父类
        子类作者 覆写时则希望是 原类型的子类
          ，调用时 与 使用端 相同。
        见下面:可读可替换属性
          父类、子类 成员函数输入类型
            分别是 替换类型、读类型
    4）子类可见数据成员类型 若改变 新类型的接口 只能是 原类型的接口的子类
      可读可替换属性 读类型 是 替换类型 的 父类
      即 数据成员 可以 声明两个类型: 读类型 及 替换类型
      声明的替换类型 必须是 声明的读类型 的 子类
      为何 读类型 不直接使用 替换类型？
        版本！这两个类型的中间范围 即是 以后版本的 修改允许范围
        新版本 可以 缩小 这个允许范围
  ？为使替换不被发现，类型测试只能测试『是否子类』而不能测试『是否真子类』『是否严格该类』
      错！应该禁止类型测试，否则仍可列举一些子类进行测试，一旦通过，即表明是真子类
  资源争夺:
    1）名称碰撞 #哪里声明的接口
      父类 增加 新成员:
        *子类 已有
        *子类 的 另一父类 已有
      解决:
        *子类 将 父类版本 固化
          但 同一程序中多版本并存 对接口的设计不友好
            在 子类 固化 父类版本 的 情况下，新版本 相当于 新接口，并不能实现 拓展 接口的目标
        *父类 的 新成员 只能 私有
          但 控制权 既不在于 子类作者，也不在于 语言作者
          父类作者 显然 可删除 重建
        *控制属性引用
          1）子类控制
            子类 只引入 父类 的 某些属性
            通过 显式指明 父类哪些属性被引入
              ？或 指明特定父类版本的成员有效
                不行！因为属性与版本的关联控制权在父类作者手中
            但是 这意味着 声明的类型 由父类改成子类后，部分源代码 反而无法使用
          2）使用端控制
            各.属性 指明其声明/定义源自 哪个父类/接口/外挂接口
            用于解决上述 1）子类控制 出现的问题
            子类控制 仅用于 转发 部分父类属性，乃方便法门
            使用端显式指明 独立属性 的 由来(定义所在父类，声明引入的子类 都行)
              即 在使用端将 独立属性 与 唯一特定类 捆绑
              这意味着 不同类 各自 定义的 同名属性 无法在使用端以同名的面目被使用，必须 通过使用端的别名机制
    2）定义碰撞 #接口挂载哪里的实现，调用哪里的实现
      使用端（包括 父类）调用成员函数时
      ，（按上面的〖使用端控制〗）一般只指明所用接口在哪里声明，即明确挂载点
      ，此时 有名无印，默认的挂载实现版本即是 最外层子类 设定的 版本
      （似乎有问题？若 某父类 的实现被弃用，链接是否断开？该父类 的 有名无印 调用 是否仍 直指 最外层子类？）
      。若指明使用的实现在哪里定义，在 有名有印。
      名-别名/挂载点/声明所在
      印-具象类名/挂载物所在/定义所在
      子类 继承 两个父类，若 这两个父类 又实现同一接口，则 子类 同名两印
      有几个问题:
        *只需要一个实现，选哪个都行，结果一致，随机选？
          ？
        *只需要一个实现，选哪个都行，余者弃用，选谁？
          这里重点考虑
        *需要所有实现，一个不能落下，如何协作？
          见下面 协作成员函数的命名对象的形参管理与实参分配
      非抽象子类 由于要 具象化，即有实例/对象，此实例 可转化为 接口类型，可接口由两个父类实现，必须 指明 哪些接口途经哪个父类，除非只有一个 非接口父类
      *局部路由
        指明 哪些接口 经由 哪些父类
        类似 默认参数
        只要 编译单元 的 局部路由 不冲突即可
          ，无需 全局统一
        由于『局部』，所以 可由 子类作者 完全控制！
        同一模块中 只需 声明一次 即可
      *单一非接口父类
      *接口名即是印
        声明 即 定义
        *final
        *统合后再转发
          obj[接口类].成员函数名(...)
            === 接口类::成员函数名(obj,...)
          obj[接口类，最外层].成员函数名(...)
            === 之最外层类(obj).get(接口类, 成员函数名)(obj,...)

    3）协作成员函数的命名对象的形参管理与实参分配
      类似Python.__new__
      无序mixin类 的 同名接口实现 如何 协作？
    4）数据独占权/约束定义权
      私有基类 类似 私有数据成员
        只是 可能 有基类优化，如共享虚函数表指针
        而数据成员 各有各的的表指针
        其实 就地数据成员 也可 与 私有基类 一样 剥离 表指针
      多继承 共享公开基类 由谁初始化？
        如果 由 最外层子类 初始化，即 意味着 所有类 皆无控制权，无约束，基类相当于公开数据成员，只是位置待定
      私有就地成员(含 私有基类)vs公开浮动就地成员vs引用堆数据成员
        就地 指 数据在 最外层子类的对象 中直接展开，剥离表指针
        浮动 指 父类 只能通过 最外层子类 确定 成员地址
        引用堆==非就地，通过引用联络
        私有就地成员:
          剥离 表指针
          具体类型确定
          负责初始化
        公开浮动就地成员:
          剥离 表指针
          当本类是父类时:
            只设定 成员父类，具体类型 待定
            不负责初始化
          当本类是 最外层子类 时:
            负责初始化
              初始化时 具体类型确定
              当成员函数使用该7数据成员时 还是以 设定的成员父类 为接口
          因此 声明 两个类型:
            读类型
            具体类型
        引用堆数据成员:
          不剥离 表指针
          只设定 成员父类
          声明 两个类型:
            读类型
            替换类型
            #见上面 输入类型/输出类型
          可阻止静态类型爆炸

      就地数组vs引用堆数组
        就地数组:剥离 元素 表指针
          元素 长度？
          元素 是 公开浮动就地成员？
          数组接口！解决问题！
        引用堆数组:引用...
      定长数组vs变长数组
        定长:类型 含 长度信息
          长 是 短 子类？
          位移 子类？
          数组接口！解决问题！
        变长:类型 不含 长度信息
      继承封闭:有限互斥并联
        *禁止继承:final
        *有限继承:case互斥并联
      读约束 与 写约束 不对称
        写约束 强于 读约束
        约束强 即意味着 值域小
        父写约束 强于 子写约束 强于 子读约束 强于 父读约束
        对象写 指 对象的修改操作/修改成员函数
        属性对象替换 指 更换对象属性指向的对象
          这是区别于 对象写 的 操作
          显然 通常 基类对象 是无法被替换的
        正方形读接口: 读边 读横边 读纵边
        正方形写接口: 写边
        矩形读接口: 读横边 读纵边
        矩形写接口: 写边 写横边 写纵边
        类型的特定语义接口！
  类型的特定语义接口:语义切面接口



yield冻结执行 * 静态类型 * 正则表达式
  #用于 交互协议
  每一次暂停，都是一个新函数
  所有可能出现的暂停函数的签名 组成状态空间
  all_states = {
      st0 :: i0 -> {Case00 o00 st0 | Case01 o01 st2 | ... }
      ,st1 :: i1 -> {Case10 o10 st0 | Case11 o11 st1 | ... }
      ,halt :: ()
      ,err :: ()
      }
  问题:通常并非稠密正交，如何表达稀疏而规整的状态转移表？
  问题:如何构建外部配合投送函数？


并行 与 串行 混合
  主并行
  只有当发生参数依赖时，两语句串行
    或 显式指示
    创建 变量 的 语句 先于 其他使用变量的语句
    然而 修改/读取 变量的语句间 需指明执行次序
    返回变量 可当标签(void变量也可存在) # 旧变量 直接删除
      x[<-y z: del a b] = ...
        在 y z 之后执行，返回x的同时删除 a b
？？简单数据
  只读，勤性，递归不循环不交叉(树)
    无指针，无交叉引用(只有树状引用)
    很难不交叉，很难不使用 引用计数
    view+控制生存期？
  大文件？
调用约定
  如何传入？
    每一种类型 可定义 相关的 多种 传入方法 及 相应的使用接口
    值复制？引用(向上父类)？类型转换(构造新类新对象)？
      重载？-特化 针对 临时变量T&&
      不考虑重载优化的话，实际上都是 值赋值，引用 只是 语法糖
  如何返回？
    移动构造？就地构造？

数据 变 代码
  lisp 代码是怎样的数据 什么时候执行 执行的时候哪些代码依然是数据？
  有两类函数:
    #函数的输入必然是值，只不过只可以是符号名
    #函数自带定义时的上下文环境，无需调用者操心
    1）真函数:
      run env "x"
        <==> env["x"]
      run env "(tg x (th y))"
        <==> env["tg"]([env["x"], env["th"](env["y"])])
      例: list 是 真函数
        let x = 1 in (list x (- 2))
          ==>> [1, -2]
    2）伪函数:
      run env "(fg x (th y))"
        <==> env := env["fg"](env, ["x"s, ["th"s, "y"s]])
      例: quo 是 伪函数
        let x = 1 in (quo x (- 2))
          ==>> ["x"s, ["-"s, "2"i]]


list lazy -->
  data List a = (a -> (()-->r) --> r) -> (()-->r) --> r
    empty = \ _ f --> f ()
    cons a ls = \ w f --> w a (\() --> ls w f)
  data Stmt
    = Assign Var Expr
    | Typing Var Expr
  data Expr
    = Let Stmt Expr
    | Lambda Var Expr
    | Apply Expr Expr
    | Refer Var
    = (<Stmt> -> (()-->r) -->r) -> ... --> r
    = ((@x,s. (Var -> (()-->x) --> s) -> (Var -> (()-->x) --> s) --> s) -> (()-->r) -->r) -> ... --> r



全局命名
  版本 与 继承/无关 问题
    什么是版本？
    版本之间的关系？
    以游戏为例
      ，大版本之间可能没多大关系，比如:同一世界设定，剧情的后续等
      ，中版本-多媒体文件复用/更新
      ，小版本-修复bug，更新更有效率的算法，更新技能威力/伤害算法...
    游戏可切分分为几部分:
      1）模拟器/引擎
      2）独立资源文件
      3）游戏逻辑模块
      4）依赖于游戏逻辑模块及独立资源的资源文件
        如：高层游戏脚本，回放录像
      1-高共享
      2-可共享
      3-部分可共享
      4-？共享有强约束，有副作用
        midi的音色库 都能明显改变播放结果
    可见版本间的共享问题十分复杂，难以刻画
  个人自由命名
    不做任何约束/外部实时检查
    必须足够长
      必要的有意义个性信息，个性以区别
      填充用的随机数据，随机足够长以区别
      加密用的填充信息，填充直至整体信息可用作加密用的公钥
  局部路径名:
    被引用的包的命名文件(超长真名)在哪里？
      1）在本地哪里？与 局部短名 关联
        模块引用包时，向上搜索底层树状(底层主搜索树)结构，匹配局部包名，以得到命名文件
      2）在全局哪里定义？
        所有长名 置顶 不现实
        命名文件 可能 定义于 其他命名空间 中
    ...[我]::/"路径"/"路径"/[搜索:"局部短名"]::
    [我] 是 本模块 所在 主搜索树 的 匹配后缀的 最近的 祖节点
    三种树节点名:
      "路径" - 直接树节点名
      短名 - 局部短名/长名的局部别称
      长名 - 超长真名 # 保存在 命名文件 中，不直接被引用
    树路径名:
      ...[我]:: - 向上搜索的待确定名
      树路径名/"路径"
        可能是 符号链接，引用别的 主搜索树 子树
      树路径名/[搜索:"局部短名"]::
        可能不是 顶级长名，引用别的 主搜索树 子树 下的 长名
    #以下 [固定名] {自定义名}
    [主搜索树].目录/        #特殊目录
      {随机名}/             #自定义
        [包目录].包名       #特殊文件名
        [搜索]/             #特殊目录
          {随机名}/         #自定义
            [局部短名].短名 #特殊文件名
            [命名文件].长名 #特殊文件名
            [全局位置].路径 #特殊文件名
              #顶级长名-全局位置 为空
        [主搜索树].目录/
          {随机名}/
          {随机名}/
        [主搜索树].zip/
          {随机名}.zip
          {随机名}.zip
        [非主搜索树的有向边]/
          {随机名}/
            [目录别名].包名
            [目录所在主搜索树].路径

  外部引用？
    无所谓 全路径名，需下载所有 命名文件，局部解释
    用于打包下载、自动编译尚可
    但无法用于论坛交流！
    除非:
      论坛 开放 上传 命名文件(无穷！)
      用户 对齐 论坛 空间
      用户 浏览的页面 自动转化为 本地 空间路径名

贴吧分类
  *年份
    *同龄人
    *出版物
    *历史事件
    ...
  有向无环图/正交标签/树
    统一:
      单标签:
        顶层:有向无环图(可设优先级，制造 主搜索树，以拓展 树，但是优先级的更改或标签的增删 会改变树)
        底层:树 (方便 尾部的增减操作/相对地址操作)
      多标签正交
  1）问题是 分类后 后悔，再分类 怎么办？
    贴吧名 是？
      贴吧名+建立时的号码
      全路径贴吧名 将被废弃，这显然有违初衷
  2）贴吧拆分
    在原帖吧发帖，分流到拆分后的子贴吧
  3）贴吧合并
    虚拟父贴吧 收集子贴吧里的内容






动态实例化的静态类型
  在堆上分配内存
  初始化内存，修改对象
  静态类型 有2种变换:
    1）模版类型参数实例化，出现的 静态类型 分2种:
      1）编译期爆炸可得的静态类型
        C++模版
        #其实就是 静态类型表达式 是 编译期求值 还是 执行期求值
      2）执行期得到的静态类型
        Haskell.finger_tree
          (Node^n a) 嵌套深度由数据决定
        Python.tuple
          分配的内存大小 动态决定，并非 由编译期静态类型决定
    2）初始化过程中静态类型的变化
        初始化之后的修改中造成静态类型的变化
        静态类型 变化时，必须 单线程
        单引用(外部引用必须更新以强调类型变化，类似realloc)
          或 多引用(要求此时 外部引用的静态类型 用法 父类化)

  数据 依使用方法进行归类:
    1）垃圾回收
      数据 的 静态类型 变化时，重新计算 其垃圾回收的分类
      垃圾对象 类型信息在哪？
        非垃圾对象:
          Haskell:通过静态类型的层层推导，由表及里
          Java类父化:统一对象的类型信息物理访问方式
    2）其他用法(用户编程用法 是最常见的一种)



lisp
  对状列表
    正向:[/ /]
      <==> ( list ... )
    反向:[\ \]
    单层有效，不冻结子调用
  表达式求值
    ( )
  表达式冻结
    [( )]
    冻结所有子调用，解冻时一起解冻
      如果嵌套冻结，则深层冻结结构并不与浅层冻结结构一起解冻
    要求部分参数立即求值以阻止重复求值的话，需使用let/where+.name
      不能使用 (! !)
        原因:
          [( f ( let` x = ( g y ) `in (! h x !) ) )]
          x 被冻结
          h x 无法计算
          故只能用外部let，而不能用内部(! !)
  局部定义-求值与冻结混合
    let/where
    递归循环定义
      尾递归
      let r = {
            ,f = ... .r.f .r.g ...
            ,g = ... .r.f .r.g ...
            }
  字符串常量
  编译期求值
    编译期求值+字符串常量+内建函数==>>内建数据类型
    (< >)
  变量名
    .引用名指向的对象/引用
    ,名本身/形参
    ,.已存在的引用名经解析后的全名本身/指针名
  数据对
    pair实现cons 正向 及 反向
      (/ a, b, c /) == (a, (b, (c, ())))
      (/ a, b . c /) == (a, (b, c))
      (\ a, b, c \) == ((((), a), b), c)
      (\ a . b, c \) == ((a, b), c)
  数据标记/容器标记
    可修改？
      可修改数组
      含 可修改元素 的 容器 标记 可修改
    有副作用？
      含 有副作用子表达式 或 可修改数据 的 表达式 标记 有副作用
  类型
    无类型数据 + 约束



全局指针
  指针 按 读写 可分为：不变只读、观察只读、...
  指针 按 数据存在期 可分为：永久全局、假设全局(约束指针的使用期，不得超过数据存在期)、...

条件分支 建立约束 #无副作用？
  if f(x) as p:
    p :: [f(x)]
    ...g p ...
  else:
    p :: [not f(x)]
    ...g p ...

  assert f(x) as p


类访问:
  静态类型访问函数+动态对象
  按 静态类型访问函数 归类:
    静态类型不同，但可能共享同一 静态类型访问函数
      java类擦除的原理
      非爆炸式无外挂接口的模版 的 参数 必须 依此 分组，才能空降 静态类型访问函数
      编译期访问？编译期对象？实际静态类型？声明的静态类型？
    大指针
    小指针
    所需外部环境变量/权限管理
    ...
  编译期求值/简化(函数/表达式/矩阵连乘运算结合次序)
  如果使用垃圾回收，则
    要么统一为一种访问方式
    要么按 静态类型访问函数 归类 分配的内存
      再全部涂黑阶段，按类访问涂黑


用户可见类(用户继承用类)vs实际实现类(结构区分用类):
  比如：tuple
    实际上，我们可以对不同大小的元组使用不同的类
    但为使用户不至于困惑(方便继承)，可定义type如下：
      type(obj)=[def]=actual_type(obj).use_see_type

树状分类vs有向无环图分类
  静态覆盖表 的 定位
    有向无环图，非常复杂，O(n^2)
  容器元素 的 静态类型统一
    默认 如：[T <: 使用中的接口] - T 指 最外层派生类
      命名为T 用于 跨定义 统一
    手动 如：[? <: 使用中的接口] - ? 指 实际类型的共同父类
      无命名
      又分为：
        *已解析大指针元素
        *未解析小指针元素
        类型转换成 含更抽象接口元素的容器 时：
          *已解析大指针元素
            原容器+再解析表
          *未解析小指针元素
            直接原容器
    统一的好处:
      1) 一次解析 处处使用
        解析什么？即：定位 静态覆盖表
      2) 类似加法等二元运算要求实际类型相同
    接口声明:
      参数:
        * 本接口 的 最外层派生类 T
        * 以下 类 的 接口(父类) 或 实际类型形参
          * 函数签名输入类
          * 函数签名输出类
          * 函数签名输入输出类
          * 数据成员类
            *定长/安全
              如：指针
            *变长
              自我直接嵌套结构-出错



多元语句块框架
  起始标签//  /接力标签 //终止标签
    起始标签 互斥唯一
    其他标签 随意，反正 嵌套 不得 跨标签
  c.for <==>
    循环初始化// -> void
    /循环条件 -> bool=true
    /循环体之续 -> void
    //循环体 -> void
    ==>>实际展开
      {
        循环初始化
        while (true, 循环条件){
          循环体
          循环体之续
        }
      }
  c++.try <==>
    测试语句块//
    多个:
      /异常捕获 异常类型+变量名
      /异常处理
    /无异常之续
    //测试结束
      #两次返回？前面返回一次，测试结束再返回一次
      要不分为：之前已返回的测试结束、之前未返回的测试结束
      返回值:
        提前预留位置
          未初始化
          已初始化
            可读
            仅可 被赋值/交换
        未预留位置
        #函数定义时，可自由假设，反正 调用时可 自由安排
仿函数调用帧并联体
  其定义形式是树，其实现的数据结构是串/栈
  标签+帧 ==>> 动态ADT
  树:
    根节点=我标签
    非根节点=我标签，数据类型，父标签
    树节点 对应 标签
    树边 对于 数据类型# +变量名？
    全局标签vs局部标签vs混合标签
      局部标签-易扩展
        只需保证 兄弟节点标签 不同
        但引用 需全路径
      全局标签-易引用
        需保证 所有节点标签 不同
        但引用 只需单标签
      混合标签
        声明 命名唯一所在父
          假父节点 必须是 祖节点
          假父节点 可有多个
          假父节点 的 子节点 与 假子节点 共享互斥命名空间
        声明 命名唯一所在域
          相当于 声明 我节点 至 域节点 的 所有 祖节点 均为 假父节点






关联数据
  对于特定应用，可能会希望将某些或全部obj与特定类型的数据(属性)捆绑在一起
    比如:对抽象语法树的处理与求值
      语法文本 只有一个
      应用目的 却很多
      传入传出的属性值 当动态定义
  * Map weakref<obj> a
    一属性一映射
  * obj.hidden_attr_dict<@k=weakref<Symbol>, tp<k> >
    一对象一映射
    特点:
      不可干扰性
        不知大小: err: len(obj.hidden_attr_dict)
        不知其他键值: err: iter(obj.hidden_attr_dict)
  * 行列形式
    obj.id 即是 行索引号
    列 即是属性，可自由扩展



wwwww
===
我说一七五三，即非一七五三，是名一七五三
同代竞争
  为何竞争？为人为己？
  为己，则未必需要那么急切。
    人生很长，需要打发的时间不少，闻鸡起舞毕竟稀罕。
    大部分人若临了后悔为何年轻时不用功以致事业未竟，那也是发现自己的人生目标太晚之故。
    人之所以奋斗，是因为有需要有目标有动力，而这推动力来自于自己的经历。
    打发时间的经历也是人生的一部分，对于人的行动方向同样有不可忽视的作用。
    学以致用，这『用』可不是别人强加的，而是自己的追求。
    没有一个人活在虚空中，一个人不可能无缘无故，仅是为学而学。
    士不可不弘毅，但实际上为学常在立志前。
    一方面是生物性的原因，青少年期学习效率似乎更高。
    另一方面是社会性原因，今之学者为人。
    生物性原因是比较可疑的，成年之后到底怎么了？
    难道不是要糊口度日以致没时间，或者空闲时间碎片化歇足处也更随机？
    难道不是被更多外物牵动心神，浮躁难安，不得静思反省？
    说到底，还是缺乏动力。
    随便给自己订个小目标，规划日程，然后期望未来自己按部就班，达不到便归咎外因。
  为人，根源于社会资源的有限性。
    它并不希望均摊资源，均摊没前途。
    要集中资源办大事，就要有人带头。
    谁？
    每一代人都被驱使着前行，少时与同学竞，长时与同事争，并非为己。
    我不能说为人而学是错的，也不能说不重要。
    社会发展的需要，便是正确便是重要。
    但为人终究只是为人，我自己究竟要的什么？
    今生所求，即是为己。


臣服 或 死亡？
  这策略如何？我看不怎么样。现在看来声势极大，如火如荼，实则体微影巨，不堪一击。得之快，失之亦快，关键在于我们不能蠢到帮敌人实现这个策略。仗打败可以接受，仗打赢却迫害潜在的盟友在战略上是更大的失败，哪怕最终所有仗都打赢，也只相当于平白遍地树敌，是最不可接受的失败之一。一定要尽最大诚意善待被胁迫参战的俘虏及敌占区的百姓，大力宣传我们的意图，他们会与我们同仇敌忾，甚至极有可能直接与我们并肩作战！

问题需要解决，但要解决也需要恰当的时机。
  个人情况不同，志向规划手段也不同。
  盲目地指摘他人的不足，未必有多少帮助。
连坐
  十分无理，但在人口不能自由流动的地方有用。
  地图炮无理但可用于规避潜在风险
  不是一家人不进一家门


同心同德；口径统一，政策长久；朝令夕改；阳奉阴违；阳奉阳违
信任层次
  相信不会害己
  相信不会欺诈
  相信不会被迷惑
  相信不会顾头不顾尾

功是功过是过，有功则赏有过则罚，功过不相抵。
  但若对方有功不求赏，有过是否还该罚？（荫蔽后人？）
  -你有罪，该死！
    （抵抗外敌的重要力量，杀之真是众望所归？）
    （有罪当杀，因为要利用他而放过，十分可耻）
    （对活人负责对死人负责？难道被人就保卫不了家园？难道不允许人改过自新？）
  -...为何还不动手？
  -你立下如此大功，万家生佛，为何隐姓埋名？
  -你连这都知道？！众人赞美的只是他们心目中的英雄，与我何干？劣迹斑斑如我，既不会被他们接受，也不想改变随心所欲的生活方式。（牧场主心态，我的畜群）（给予希望却永远无法得尝）
  恃强凌弱，行；明知不可为而为之，行；痛打落水狗，也行；偷袭也行；但直贯心中的正气不畅，则为难。直不在于手段，而在于目的。
  观行不观言。有些人恶事做尽，却还真心以为自己是个好人。

  ===
  别名反对托名方
    化名，英雄，归隐
    托名，作恶
    另名，起义
      -出尔反尔，让那劳什子狗屁英雄滚出来！
      -...我原以为你是智者，可不曾想却是蛮牛。
      -你在教我做事？强者的世界你不懂！
      #当权者膨胀了，一个目标容易被针对，干脆多另名几个隐世的绝顶高手，显灵乱世

-他还是个孩子！
-我、我也是个孩子！
-（我的天！八英中为何有这种货色）

-他就是凶手？你们拿一个白痴来顶数？
-哼！听说你族人才济济，想必在一天之内就能搞清楚，他究竟是不是凶手。无端的质疑是在哭奶么？


优秀？优秀，至少也得功成名就，功成名就大都人已中年。婚姻的首要目的只能是繁衍后代。优秀的雄性通常还有生殖力，优秀的雌性则不然。





战俘
  战时
    不能释放
    不能随军
    不可喂饱以免作难
    必须劳作不得白食
    ==>>虐待
    作为战利品生杀随意
  战后
    战争太久，战后『忘记』处理战俘，仍依战时方法（灭族无人提要求）
  奴隶
    若是罪大恶极，则当处死
    罪不至死，则『生生世世为奴』作为惩罚则太过
    若父母为奴子非奴，父母生命为人所贱踏，子必不允
    若求『虐待仇敌的快感』或『免费劳力』，则非是『强者』所为。人当自强，不被余物蒙蔽双眼。
  错
    奴隶之子喊冤
    杀人者死？
    杀奴有错？
    若以当下人们的观点，『杀奴』不算罪
    你（杀奴）没错，错的是这种主流观点
    我们都错了，现在改正也不迟
    ==
    杀人者死？
      复仇无罪，但可能造成更多不必要的伤亡
      而且若人人认为不敢私下复仇的人是孬种，可能会变成鼓励私人复仇，危害深远
      所以即使复仇无罪，也要大力提倡公诉复仇，反对宣扬私刑
  人兽不分
    功劳体系
      任何组织，对人员的要求:忠诚，才能
      血脉？伯乐？都不靠谱，只有功劳！
    劳作者便享有社会身份，受社会保护
      参与劳作的牲畜也一样
    于社会有功者便享有社会身份，受社会保护
      有功的牲畜也一样
    不能劳作的人？老人小孩残疾人
      必须开辟出新的分工或全新的行当，使他们也能参与进社会功劳体系
      这项开辟任务，是正常人对残疾人应尽的义务。
      必须教授年轻人必要的生存技能，
      ？



年轻人
  -你就不管管你女儿？
  -我什么都不知道，反正该说的都说过。
  -就在我们眼皮底下，真把我们当瞎子。
  -年轻人嘛，觉得老家伙眼神不好很正常。
  ...
  -嘿你！
  -我？
  -年轻人，为人要谨慎，做事别草率！


假如一个人随时都可能死或者下一刻就死，现在踩到狗屎，会有什么反应？反应可能极不相同:一则极度嫌恶，非得弄干净，以清白离世；一则无所谓，人都死了，哪来许多讲究。
喜欢你，与你何干。你的喜怒哀乐生老病死，无关紧要，只如爱花折花。爱恨婚离，也不关心，爱梅岂能妻梅？爱千人岂能妻千人？夫妻非一人，岂能无分歧？爱必有弛，岂缘弛而离婚？



王负剑

思无邪-一切正常朴素的情感倾诉，都『无邪』，这些自然也包括男女之情。

===

括号
冂凵丄丅匚彐彳亍 辶勹
丩卩曱甴卍卐
连字符
冄
逗号
丷丶爫乊
丿亅刂亇
讠阝亻冫丬氵彡
巜巛
空格
冖宀亠乛灬罓罒艹
运算符
卄亖丯丨丆乁乚囗屮
====


冂凵丄丅匚彐彳亍 卍卐氵彡
冖宀
丷灬丶爫乊
卝
肀
辶乚厂乁 乀丿
爿片
帀 巿
尐
厃
兯仒仐仌卆厸冄罓罒
亖
亣丯
丨孒亅乛
丩卩
丆巜
廴讠亠阝亻刂勹冫丬亇乆

凣凢
卪卄
卂亽亼亾兦
饣忄囗
艹
夨
巛屮
纟扌犭
丮厈圧屵
耂
礻
丱冎冚冊匞畕冋冋冏囧煛燛臦臩
凷仺仚屳仧冭夳
囙
氺
癶钅
曱甴
疒
===5->6
襾覀
亞亜
叒劦姦厽
凼卋兲
尗赱弜夶吅奻
忎忈
肎氼艸
糹
===7
丣叓亪凬冝
囯囬囦奆夾巠
孨壵灷灻戺汖
====8
叕鼡
丳兓
凮冞罙
囶
実宔 宩宲窋
炗炛灮烡炏烎
戼汬坓沝昍峕癷
畱畄靣
===9
乗亰匩
尛尜圀
垔垚猋骉
怣
栆昚眘芔羍
====





用C++实现个Haskell
  目标:高移植性
    我的手机安装不了Haskell
  中文版
  勤性求值
    很多 容器 需要勤性求值
    迭代生成数据？
      g :: i -> [o]
      ==>>
      f :: i -> st
      h :: st -> Maybe (st, o)
      类？函数表？
      yield？h :: i -> &g= () -> Maybe (o, g)
      throw？
      callcc？
      冻结？
    垃圾回收？
      即是勤性求值又是只读就不要循环数据了
      引用计数#看来也不是完全只读，不安全！
        资源 如 文件
        析构函数
        类！因为 擦除了静态类型！
    没有循环数据
      循环类型？
      &S={T = T R S.T; R = R i S.T;}
      转化为 S 的键
      类型只是一个名字，并非对象
      函数递归也一样，有一个 递归包 将所有相互引用的函数 打包
    数组？
      允许只读，不许修改
  以finger_tree替代list
  支持view作匹配
  Type的类型是Type
  证明All替代箭头
    允许从完整类型切出部分，施加各种约束
    不允许 漏过分支，除非 声明 确实没有
      不允许Haskell.head
    约束 最简单的 就是 要求某函数返回真
      动态建立约束
    返回结果 可以带约束
    函数 可以有多个签名，仅约束不同
  多值判断结果
    真 假 未知
      比如:连分数 比较大小，只能用隐参数控制比较精度，结果可能只是高精度相近
      比如:单步执行，超时中断
      比如:素性判断，不少算法返回值:是，否，很可能是
    偏序比较: 前 后 等 无关
  函数分两种
    除了IO类其他的都可以动态分析
    也允许动态由数据变函数
      类似lisp以实现 惰性求值 短路与或
    函数<->数据
    类型<->数据
    类似Typeable a=>，用外挂区分
    数据是？
      lambda？combinator？
        combinator
          勤性/惰性
          简单的讲，求值可能停不下来，所以某些地方一定要表明等等再执行
          递归函数:
            &sf= sf->e
            &sf= (()--->sf)->e
      context？
  class翻译成『外挂接口』
  instance翻译成『外挂』
    私有区 辅助函数
    模版 引用

  动态拆包+ADT静态拆包
  并行，选择先返回的结果，终止其余
  记录 的 属性值 不该是函数 太容易 碰撞
    使用: T.f t === t .f
    并联记录 只能用匹配取出 属性
      见上面 约束 不得漏分支


外挂接口
  动态传入
    即作为隐参数与数据平行传入7使用数据的函数
  与类同在
    外挂接口可以注入到『类虚函数表』中
      *直接注入拆包后的函数
      *注入外挂接口本身的包指针，带名，以防止碰撞
  隐参数 更为 灵活，支持 同一接口 的 多种 实现。
  注入式 如果 要实现同样功能，就要
    *覆盖/还原 所要竞争的注入名
    *或 描述 一个相互依赖(特定于被调用函数所期望的某种一致性)的外挂接口的组群(一种更大的外挂接口，由其他更小的接口动态组合而成)，覆盖/还原 这个更大的接口组的注入名

默认 外挂接口
  默认 可视为 一种领域/空间
  我们 可以重置 默认领域，从而批量切换外挂接口
  类似隐参数

Haskell.class
  class M a where
    r :: *
    f :: a -> r
  相当于: @[r::*]. a -> r





语言设计 之 括号:
  任何匹配对:括号，字符串
  禁用单字符方案
  注意:括号连续出现时 应使肉眼也能轻松切分
    双字符坏榜样: [[  ]]
    双字符坏榜样: {[ [{  }] ]}
  注意:多行字符串很多行时，应使文本编辑器进行局部语法标记时不至于认错
      Python是个坏榜样
      可改为："""[  ]"""
  双字符方案:
    ===注意:等级先后:{[(<>)]}
    {[ ]}
    {( )}
    {< >}
    [( )]
    [< >]
    (< >)
    ==
    {: :}
    {. .}
    {$ $}
    {% %}
    {= =}
    {/ /}
    {~ ~}
    {* *}
  三字符方案:
    <(>  <)>
    <[>  <]>
    <{>  <}>
    ([)  (])
    ({)  (})
    [{]  [}]
  四字符方案:
    [{*]  [*}]




=======================================
C/C++ 需要编译，需要链接，指明语言标准和标准库，很好，也很反人类
Java 模块必须指明所在包，很好，也很反人类
简单来说，随便搞个文件，所有东西一起扔进去，直接运行，虽然乱糟糟，但十分友好。
Haskell/Python 当作脚本语言来用，十分完美，对新手十分友好
=======================================



类的方法的调用形式，但采用Haskell的外挂接口的引入方式，以避免多重实现接口导致的方法名冲突
  import I (f, g as h)
  obj .f()
  obj .h()
    <==> obj@I.g()
    <==> I.g(obj)



=======================================
『醒目文本』
    普通文本的醒目强调形式
〖特义词条〗
    被赋予特殊语义的词条
    一般都是已定义/将定义的技术性词条
【醒目特义词条】
    特义词条的醒目强调形式
=======================================
易移植语言
  见下面『最终目标清单』
  ===
  vs
    易移植语言.txt
    通用汇编语言.txt
      差不多。
      就是 阉割各种强力特性，以保证『能够』移植/汇编
    可运行于任何平台的语言.txt
      不同。
      强调 自己就是完整平台，除了极少的极为基本的外部依赖
      即是 虚拟机，同时 也强调 外部依赖极少

  ===

  移植的目标平台是其他编程语言，称之为〖移植所向宿主语言〗，简称〖植宿语〗
  易移植语言，简称〖易迁语〗
  ===
  动机由来:ANTLR-一个Java上的〖句析生成器〗
    元语言 = 用于书写语法规则的语言
    句语言 = 待分析的目标语言
    句语法 = 用元语言表达的 句语言的语法
    句析器 = 句语言语法分析器的算法
    句析器代码 = 用某种编程语言书写的句析器
    植宿语 = 句析器代码的实际用语
    元语言编译器 = 句析生成器 = 依指定的〖句语法〗及〖植宿语〗生成〖句析器代码〗的算法
    元语言编译器代码 = 用某种编程语言书写的元语言编译器
    元宿语 = 元语言编译器代码的实际用语

    ==
    需求一.支持多〖植宿语〗
      问：如何支持多〖植宿语〗？即〖句析器代码〗易于移植？
    需求二.支持多〖元宿语〗
      用户需要〖元宿语〗来生成〖句析器代码〗
      ，同时又需要〖植宿语〗来运行句析器
      ，最好是两种宿主语言是同一种。
      这就要求〖元语言编译器代码〗易于移植。
    需求三.交互问题
      用户如何使用〖句析器〗？观察者模式？
      即：移植后的代码与用户代码的交互问题。

    ==
    可执行语言 = 已存在解释执行器的语言
    特用定制语言 = 以特殊用途为导向进行设计的语言
      如:便于人类手写
      如:便于人类阅读
      如:便于机器作语法分析
      如:便于机器存取数据

    拆分〖元语言编译器〗:
      〖元语言编译器〗=〖元至易半译器〗+〖易迁语移植器〗
      元至易半译器
        = 入句法出易述句析器吾生成器
        = 入元语言述句法出易迁语述句析器吾生成器
        = 以元语言书就的句语法为输入、以易迁语书就的句析器为输出 的 句析生成器
      易迁语移植器 = 将〖易迁语〗翻译成〖植宿语〗的算法
        这是描述性定义，〖易迁语移植器〗的拆分组合式定义 见下面

    供需双方:
      供方 = 提供代码的一方，支持多种可执行语言
      需方 = 下载代码的一方，只支持一种可执行语言，附带可能有〖易迁语移植器〗
      勤性供方 = 提供代码的各种〖植宿语〗版本的供方
      惰性供方 = 只提供代码的〖易迁语〗版本的供方
      勤性需方 = 下载代码的〖易迁语〗版本的需方
      惰性需方 = 只下载代码的某种〖植宿语〗版本的需方
    ==
    对于『需求一』:
      勤性供方:
        *需要用〖易迁语〗书写〖句析器代码〗
          等价转化为:
            *功能要求〖元语言编译器〗须支持〖易迁语〗作为〖植宿语〗
            *需要〖元语言编译器〗可执行版本
              只需用某种可执行语言实现即可，无需易移植
            *需要〖句语法〗文本
              即〖元语言编译器〗的输入文本
        *需要〖易迁语移植器〗可执行版本
          只需用某种可执行语言实现即可，无需易移植
        一个功能要求+三个需要，即可得到〖句析器代码〗的各种版本
        因『一个功能要求』及『第三个需要』，才有了上面对〖元语言编译器〗拆分，这就是〖元至易半译器〗的由来
        ==
        『需求一之于勤性供方』总需求等价转化为:
          *需要各种〖特用定制语言〗的〖句语法〗文本
          *需要〖元至易半译器〗可执行版本
          *需要〖易迁语移植器〗可执行版本


      勤性需方:
        *下载〖易迁语〗书就的〖句析器代码〗
        *需要〖易迁语移植器〗可执行版本

    对于『需求二』:
      *需要用〖易迁语〗书写〖元语言编译器代码〗
        即〖元宿语〗是〖易迁语〗
      *需要〖易迁语移植器〗可执行版本
      ==
      问：既然需要〖易迁语移植器〗可执行版本，何不直接要整个〖元语言编译器〗可执行版本？既然有了可执行版本，何必要〖易迁语〗版本？
          目的是将〖元语言编译器〗内嵌到各种编程语言。
          当这些编程语言『动态』读取〖句语法〗、用内嵌的〖元语言编译器〗生成临时的〖句析器代码〗的本语言版本、分析解释执行之后，便可以对句语言的文本进行语法分析。
      ==
      『需求二』总需求等价转化为:
        *需要〖元至易半译器〗易迁语版本
        *需要〖易迁语移植器〗易迁语版本
        *需要〖易迁语移植器〗可执行版本


    对于『需求三』:
      见下面 交互问题的解决方案
    ==
    ==
    『最终目标清单』:=
      *需要设计的语言:
        *〖元语言〗
        *〖易迁语〗
        *多个〖过渡语〗，分别对应不同的〖植宿语特性选项〗
        *〖直译插件脚本语言〗
        *可选〖易迁语虚拟机脚本语言〗

      #自『交互问题的解决方案』
      *可选〖易迁语虚拟机脚本解释器〗易迁语版本
        #〖易迁语移植器〗并无交互问题，不必含此

      #自『需求一需求二』总需求等价转化为:
      *需要各种〖特用定制语言〗的〖句语法〗文本
      *需要〖元至易半译器〗易迁语版本
      *需要〖易迁语移植器〗易迁语版本
        #接下来的拆分，复制自更下面
        #其中『器』由隐含的『可执行版本』改为『易迁语版本』
        #
        =〖易迁语意译器〗@植宿语特性选项
        +多个〖过渡语直译器〗@植宿语
        +各〖植宿语〗相应的〖过渡语直译器〗插件
        +〖直译插件脚本语言解释器〗
        +各〖植宿语〗相应的〖轻量级接口支持库〗
      *需要〖易迁语移植器〗可执行版本
        #见上面
        #如：含〖直译插件脚本语言解释器〗可执行版本
      ==

  ===
  显然，由于〖植宿语〗情况复杂
    ，『易移植』即意味着『受到极大约束』、『严重阉割』
    ，只能选择各种编程语言共有的特性以保证『能够』移植
    ，具体到各植宿语，则可选用针对性的移植方案
    ==
    可设计一套〖植宿语特性选项〗集合，及 每一选项集合所对应的〖过渡语〗
    ==
    由于有时可能要求〖植宿语〗提供某种接口
      ，而实际上其标准库并无此接口或签名稍有不同
      ，这时就需要一个〖轻量级接口支持库〗
    ==

    〖易迁语意译器〗(唯一)
        将〖易迁语〗依〖植宿语特性选项〗编译成相应的〖过渡语〗
        ，解决 移植方案的选择问题
        :: 文本<易迁语> -> @植宿语特性选项 -> 文本<过渡语<植宿语特性选项>>#或 ->抽象语法树
        〖植宿语特性选项〗全集 相对稳定
          ，故而 直接依各选项静态特化之
          ，也就是 将多个实际上独立的分支实现打包一起，叫做〖易迁语意译器〗

    〖过渡语直译器〗(多个，对应不同过渡语)
        将〖过渡语〗编译成〖植宿语〗
        ，解决 具体语句生成问题
        :: 文本<过渡语<植宿语特性选项>> -> @植宿语 -> 文本<植宿语>#或 ->具象语法树
        〖植宿语〗全集 是在不断增长的
          ，又由于直译相对简单
          ，可以采用插件方案拓展目标语言集合
        由于插件只是进行简单的文本替换处理
          ，或 提供一个文本模版以供替换
          ，故 插件本身可用一个轻量级的的脚本语言书写
          ，称之为〖直译插件脚本语言〗
          ，需要〖直译插件脚本语言解释器〗代码的〖植宿语〗版本
          ，但对于跨语言移植而言，需要的只是〖直译插件脚本语言解释器〗代码的本地〖植宿语〗版本及〖易迁语〗版本，无需各〖植宿语〗版本

    〖易迁语移植器〗=
        =〖易迁语意译器〗@植宿语特性选项
        +多个〖过渡语直译器〗@植宿语
        +各〖植宿语〗相应的〖过渡语直译器〗插件
        +〖直译插件脚本语言解释器〗
        +各〖植宿语〗相应的〖轻量级接口支持库〗

    ==
    编译选项 至 过渡语:
      植宿语 的 特性选项:
        函数指针？
          有了函数指针
            ，就有了接口(只读函数表)
            ，就有了类及对象
        垃圾回收？
          混乱的循环数据结构
            混乱，即 权责不明
        数据可修改？
        数组？
          可以只是 只读数组
        if-case还是jump-case？
          jump-case只需支持 模剩余等价类(只针对 互斥并联ADT)
  ===
  ===
  ##重大性能影响
    不支持函数指针
      没有钩子函数，交互效率低
        #可用〖易迁语虚拟机脚本解释器〗
      外挂接口，代码爆炸
    不支持可修改数据
      无随机存取容器/数组，效率低
        字节串，编解码
        字符串，文本处理
        矩阵，图像处理

  支持路径名
    包/空间
  支持静态表达式+静态编译分支
    见下面 参见 封装宏
  机器字长
    有时要保证机器字长的下限，否则自定义或使用大整数
        见下面 参见 封装宏
  不直接支持IO操作
    若 不支持函数指针，则 真不支持IO操作
    或者 可配置静态编译选项，处理未定义函数，连接为IO函数
        见下面 参见 封装宏

  不支持函数指针，更不支持curry
    原因: 某些宿主语言 不支持函数指针
    ==
    或者说 高层概念中没有函数指针
    具体到特定宿主语言，可以有，以简化设计
    但 宿主语言共性中不该有

  没有类，全是函数调用
    因为 不支持函数指针，类的意义不大

  严格静态类型
    不存在子类型
      静态析构函数
        或者说由静态类型可退出析构函数
    可用模版
      但只能有一个定义
        即不得特化模版另行定义
        模版在这方面(擦除静态类型，形式不变)
          ，类似Java泛型、Haskell类
          ，而非C++模版/静态重载特化模版

    支持外挂接口(形式上，类似Haskell类)
      若 不支持函数指针
        ，外挂接口不能动态传入
        ，模版实例化时必然会产生代码爆炸
        ，每个模版最终只允许有限实例
        ，模版在这方面(代码爆炸)
          ，类似C++模版
          ，而非Java泛型、Haskell类
      若 支持函数指针
        ，外挂接口是动态传入的
        ，模版实例化时不会产生代码爆炸
        ，每个模版允许动态无限实例#如finger_tree
        ，模版在这方面(接口与数据分离、动态传入)
          ，类似Haskell类
          ，而非C++模版、Java泛型

  交互问题的解决方案
    如何实现 观察者模式？
    *用户受控: 使用外挂接口即可
      交互过程中，用户是受控方
      若 不支持函数指针，甚至只能静态编译(代码爆炸)
      否则 用户传入 受控接口+初始累积结果 即可
    *用户掌控: 冻结执行/单步执行
      类似Python的yield
      若 不支持函数指针:switch-case
        如果可能，采用jump-case
      否则 直接返回 接力函数
        静态签名？数据类型=互斥并联 或 子类+接口
      如何实现执行状态冻结？
        循环嵌套函数 拆解开来:
        状态冻结类型 = 互斥并联 各函数调用帧 的 各执行状态
          # union （原函数名+执行位置，混合的帧中数据）
          # 原函数名+执行位置 -->[jump-case?]-->ADT拆包分发->静态类型重建--> 拆分后的实际碎片工作函数
          #     效率极低，没有函数指针，真的不行
          #     不过 强调移植性 的话，能够运行就行了
          #     更何况 只有不支持函数指针的编程语言受影响
          #     都这样了，为何不干脆 当作汇编脚本 来解释执行？
          #     在此定义〖易迁语虚拟机脚本语言〗〖易迁语虚拟机脚本解释器〗
          #
        帧数据保存于堆上单链表中
        链表头为最深层的函数的帧
  可持久性数据 只读变量 尾递归循环
    勤性求值+只读数据==>>数据收敛
    注意：算法 于 勤性求值 与 惰性求值 的 实现形式不同
        如：list append
          Lisp需reverse
          Haskell则不该
  堆上数据 内存管理 责权分明
    不支持对象指针
      或者说 不支持指针 操作
      没有指针概念，连 是否相等 也不行
        如 Haskell
    虽然不支持对象指针，但内存资源管理还是要参与，或者假装有在参与。
    见下面 参见 指针约束
  参见
    参见
      『安全C.txt』
          指针约束 内存权责
    参见
      『模块C.txt』
          封装宏
          类似Python.__debug__/C.ifdef
    参见
      others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt
        编译相关的名词


  ===
  ===
  ===
  ===




=======================================
模块C
  屏蔽宏 或 受控宏
    * 指明从哪里引入哪些宏，用于何种目的
      *要不要在本模块展开(不展开相当于只是中转)
      *必须已定义 还是 用于 编译分支测试
      *声明引用虚拟空间中的 路径名，它将由 外部程序 配置
        静态 - 分析阶段所需，编译选项设定
        全局统一 - 连接生成 可执行目标 时 统一设定
        全局统一 - 加载 可执行目标 时 统一设定
          比如:
            超长名 变 短名
              各模块 用于 动态注册，避免 模块名太长 或 避免 自定义昵称 全局冲突
              在最后加载时 才动态分配一个临时昵称，只在程序运行期 有效

  空间名/包名，支持 超长名
体系C
  如:外挂接口体系
  如:封装指针垃圾回收体系（知道 那些成员指针 需要被...）
  如:封装双指针体系（打包对象及接口于大指针中，静态类型变换时自动更换接口）
  如:静态注入对象类型静态表体系（用于 多体系 并存）
  如:动态注入对象类型静态表体系（用于 动态添加 新体系）
  如:虚拟环境（缸中大脑，一切IO/内存分配/...，皆通过同一接口隔离 即作为 隐参数(不使用IO的就是pure)，用户可覆写部分接口以之运行 函数/线程/进程）

安全C
指针约束:
  谁负责释放？
    法人=容器 或 活动中的函数
    * 指定唯一的法人负责
      销毁责任/销毁权限 可转移
      甚至可指定唯一的访问者:
        唯一的访问者，甚至可以变更 指针静态类型 即 指针所受约束
        更变 双向链表 结构时，各节点的权责 不断变化
    * 若有多个法人要求同时访问
      * 引用计数+是否僵尸
        要求 被引用者 声明 自己负责销毁的那些指针 及 以此展开的有向图 必须 无环
      * 将指针传入子过程时:
        * 要求 被调用者 返回前 销毁关于指针本身的信息
          即 不得在 返回后 在其他地方 持久保存 本指针，以阻止未授权访问
        * 要求 被调用者 返回前 只能保存在某些指定容器中
          既然是『保存』，这些容器 显然比被调用者 活得更久
          这些容器 必须声明:
            + 生命比指针短，只要它们还活着 就可以访问指针
            + 无销毁权限







什么叫认清现实/自画像
  知道身处何处
  知道有哪些路可走
  知道路都通向哪里
  知道应当走哪条路
  知道实际会选哪条路

  所谓身处何处，即指身周如何，感觉好坏，合理与否
    而 这实是为我的由来所决定
      肉身的情况、感觉
      我的经历、知识
      决定了对未来的预测，进而决定了对当下的满意度。
    不识庐山真面目
      我觉得如何通常与实际情况不一致
      或者应当说 与别人的看法不同，包括 古人/子孙
      寻求认同？党同伐异，手掌真理替天行道
      寻求真相？随波逐流，虚心认错盲目跟风
      而常见情形是 两种情况交替出现，美其名曰螺旋上升

  神 永动机 来世 修行 永生 涅槃

  纵欲
    主观无明确的收敛状态
    挥霍人生
      漫无边际-贪婪无度
        资讯轰炸，眼睛离不开手机
        偷闲摸鱼赚翻了
        攀比慕强
      漫无目的-佛系，走哪死哪
        行到水穷处，坐看云起时
        买买买，下载下载下载
      毫无意义，一切虚无
        冒险 挑衅 违章
    主流狂热
      一门语言再有用，无人用也只是死语言。
      一件工具再好用，无人用就是多余的垃圾。
      我只一人，人微言轻，实属无奈
      被逼无奈 抱怨
        虽受害 亦受益
        希望改变同时害怕改变
          指望别人来改变
          避免被责难却愿意责难别人
  克制欲望
    主观有明确的收敛状态
    个人:关我屁事
      闭目塞听
        断电断网
        我什么都不知道
        记性不好
      漠然旁观
        明月照大江
        我就看看不说话，内心毫无波动
    集体:小国寡民
      闭关锁国
        永久中立
      减少人口
        计划生育降低出生人口
        主动冒险减少活口
        放纵疾病减少活口


















翻译




wwwww
coherence 连贯性 相干性 一致性
issue
n.
（水等的）流出( issue的名词复数 )；出口；放出；（特别重要或大众关注的）问题
v.
出版( issue的第三人称单数 )；发表；宣布；分配
并发 并行 区别

memory order 翻译
  发现『并发编程』有歧义，按『并发访问』来解释的话，变成『多人合作写代码』

===
网站创意
分几个区
帖子顺序 体现 不同内存模型
===
说话别人听不懂赖谁？
有人听懂不算啥；
有人听不懂说明他发现歧义，事实上更懂。
===
感觉发帖问人，会欠很多钱，还还不上，便极少发问。
不过会以问人时的客气口吻将问题的由来及扼要写下来，没事便上网搜搜。
这样过，全仗别人的提问及热心解答。
我虽不问，事理却是相通的。
===
正义是先天还是后天？
如果是先天，则可不计一切现实后果去追求。
如果是后天，则只是生存的鞋子，不值得削足适履。
天地不仁，我并不认为有先天正义。
但！即便是后天，还是有疑问。
何为生存？或者强调的是『谁』的生存？
个人？集体？哪个集体？
当代？后代？
为『谁』？
===
有一种『感兴趣』叫『仇视』
===
人活着就有烦恼，人活着就要打发时间。
===
记住骂过的话，它会回来的
===
:知道，知止
===
不要以为别人跟你一样
不要以为别人跟你不同
不要以为你跟别人一样
不要以为你跟别人不同
当你觉得合适时就可以拿来用
当你觉得不合适时也可以拿来用

因为觉得可疑，故意选择另一条路，也很可疑
因为觉得正确，才去做，未必就那么正确

真理就是废话

我所学到的一切，即是，这一切并非理所当然，你需慎重，你当如何如何……

=====
绝对自由，可以，今后律法皆废……现在我们来玩一个游戏，我当猎人，其余人当猎物。
反抗军首领也是我，再来新一轮吧

====
你误会了，我不是说他(墨)这个人怎样，我是说，这种徒党众多的模式持续下去，究竟会如何。这些势力久之，既不服从官府，也不会遵循前人定下的规矩，越有力量就越有奇怪的人员混入，朝廷便是如此，我疑虑重重，实难安心。

====
反正坏的是别人的名声，管他
竟然是我！我冒充我自己
====
看着它们挺起蓬松的胸膛互怼，脸上不经意浮现笑容，如果人间的争斗也能如此平和……
====
只做正确的决断，本身就是一种可怕的错误。
没有挫折的经历，是最糟糕的一种。
====
你以为得到权力，其实只会失去更多，未必划算
====
着相
  --财是身外之物，权力是，名声也是，父母又有何不同？让你嘴上多认几个爹而已，与真相何干？既与事实无关紧要，有何不可？……为何迟疑？莫不是在挖空心思编造借口来绕过自己以前的说法？何必呢，唇舌不过真实。
  --言行一致果然没想地简单，不过我不会让自己陷于那样的窘境，如果真出现了这样的局面，只能说我智力有缺陷，何当该死，多做多错无需挣扎。
  #假子潮流
=====
=记忆，传承，书籍，教师，工匠，原材料，工坊，定居……由均衡无要害自由飘荡的海水烟雾，变成弱点明确心脑难迁的巨兽，代价不可谓不大

=====
这可能是某种说话技巧，以一种理所当然的一切人一切事都围着自己转的自恋口吻发表出人意料的言论，使人困惑进而深究其意，达到引起听众注意的效果。
=====
只有手下死过很多人的大夫，才有可能是真神医
=====
人生的每个阶段各有目标。如果年龄见长心智却依旧如小孩，就是智障，这是残疾。如果过了适婚年龄而未婚，不论是畏婚还是以真爱之名避婚，也是一种残疾。应当养育后代之时却还沉迷肉欲，不能理解此间快感不过是物类为引导个体交配而给的小甜头，也是一种残疾。
=====
魔道功法精髓，有进无退，不留人生机，也不留己生机，刚不能久。他擅长逃命，一缕生机不绝，说是魔道中人，简直是对魔道两字的侮辱。
=====
灵活
  那就当我来迟好了，在敌人淫行忘我时出手击杀，总比先出声打断，再死战克敌，最后即便取胜也大概率被敌人逃脱来的强。我又不打算嚼舌，也不会跟当事人漏底，事实上就等效于『迟到』，无不可。
=====
就连天上的星辰也只能被宿命摆布，依着注定的轨道前行
=====
每一件事都要有始有终，避免节外生枝，否则随性而行只怕身在何处都搞不清
=====
所谓引导教化欺骗洗脑奴役诸如此类，不过是人们心中臆想，是从未发生过的事情。不要妄图去改变别人
=====
智杖之争
  智慧之杖
=====
冷面微融，居然有了好感，毕竟就算再坏，肯带自己痴呆妹妹出来逛街晒太阳，倘然承受由疯言乖行引起的外人异样眼光，这样的人也不算毫无人性。叹，见过太多权贵，富甲一方，却唯恐被人发现智障的亲属，深锁庭院。
痴呆妹妹？什么痴呆妹妹？
=====
人是不变的，试图改变别人，是白费力，有时甚至是危险的
反对:人是可以改变的，善恶是可以转变的
奢靡浪费无益，定等级规格
反对:欲望，前进的动力，应培养引导群众的上进心
不需要隐私，只是个人相关的事公众并不关心，没必要拿出来扰乱视听，但若有了解真相的需要，秘密也当消失。
  弃婴
反对:个人离奇的经历与奇葩的理念，其实只与自身紧密相关，对别人而言毫无借鉴意义
  秘密-大人小人
    你们，天神，无尽的寿元，也有烦恼吗？
    小罐中藏着一个小人世界，朝生夕死
=====
惧
  害怕曾经休戚与共的族群相互仇视
  害怕曾经诞生无数英雄的民族倒行逆施
  巨兽需要记忆
=====
种群，无关善恶
  为何多生少育？一窝五六只雏鸟，经过手足相残最终只有一只存活，少育是因为鸟群数量庞大，食物相对匮乏觅食艰难，多生是为了种群在遭到严重摧残时能快速恢复。
  一切根源于现实，盲目模仿很可笑，虔诚地认为有什么先天的善意超凡的天条也很可笑
=====
不听号令，擅自行动，巨大成功
我能怎么处理？报喜不报忧，喜欢偏听偏信的可不只君主，平民也一样。
=====
探索真理？学以致用？天马行空的想象没问题，但要是从来都不考虑实用性就是大问题。
=====
对我的态度？倒不如说是对某一类人的态度，依社会地位、性别等分类，我所知的是你的恶劣态度，但与我何干？
=====
如果法律保护不了受害者，那它又凭什么能保护施害人？
报复出轨是封建余毒，出轨反而不是，是真爱是进步是文明。
出轨不违法，私刑违法，等于拉偏架，实质鼓励出轨。可明面上又规定一夫一妻，显然是求滥交社会而不能得，只能曲线图谋，等出轨率高到一定程度就可以光明正大地说这就是人性，这就是解放，这就是文明，这就是未来。何止出轨，吸毒、艾滋病都是同样套路。现在『文明』的西方已将吸毒合法化，就看我们这些东方牲畜识不识趣，上赶着去吃它们的屎了。
众人所求不同，其实解决方案也简单，反对出轨的人做出明确的声明，以后他若出轨直接死刑，他的配偶也必须是做出同样声明的人，保守派自成一派，剩下的人爱怎样怎样。
=====
富有即榜样，美丽即善良
=====
人既然不能选择自己的父母子女兄弟姐妹，有何必计较能否自主选择自己的配偶？
=====
民主制度必要求配套保障其能有效实行的社会规范。据说美国投票日故意选用工作日，以降低劳工投票的积极性。就我个人而言，完全不关注选举；但物质决定意识，就中国国情而言，外地打工阻碍被动地由家常话了解选情，996则妨碍主动地去了解选情。最后，家乡的情况、工作地的情况，均是两眼一抹黑，不论选区在哪，不论票投没投出去，已无意义。民主制度，是否真民主，得看能否保证选民了解国情，能否保证选民最低的道德与智力底线。
=====
一项技术，与其难以制止地被暗搓搓用于邪道，不如正大光明地大量用于正途，使它的正面贡献超过负面危害。
-反派的研究成果，我们大可以夺过来使用。
  -使用？那要不要继续研究？以邪恶的手段？若禁止而确实有人希望深入研究，会不会以默许放任甚至支持反派暗中搞事，最后再以消灭反派夺取成果之名，合理合法达成目的？
=====
反派站到我这边，原来我就是反派。
=====
反者道之动
  -联合？只怕不容易
  -今时不同往日，正因我宗实力大损，又被三个敌对势力联合剿灭的危机，其他大势力才不会坐看他们瓜分我宗壮大势力，结成同盟危及余者。故此有了拉拢的基础。福兮祸所伏，他们近日的胜利未必不是他们倾覆的开始；祸兮福所倚，我宗若能反败为胜必将更生从前！
  -宗主英明！我们必能从一个胜利走向另一个胜利
=====
old money vs 最年轻的真理
=====
--idea from 虹猫蓝兔七侠传:莎莉:独臂大侠:有志者事竟成
-（走出无数强者的传承之所。经过重重考验，一无所获）坑爹呢！（自悟神功。之后，重新布置机关）前人坑我，我坑后人，合理公平。
=====
--对于以弱克强的发家史，别人依之骄横，独我以为警惕。世间豪杰辈出，家世岂足依凭？
=====
先是临时联盟，等对方得罪原先盟友，虽还未到临时联盟完成其声明的目标，但立刻以某件无关痛痒的小事分裂联盟，也不进行激烈斗争，只是冷处理，令对方进退两难：进-则被新盟友冷漠拒绝；退-则被旧盟友羞辱，又没到生死存亡的关头自己拉不下脸别人也不会从权真诚以待。只好选择暂时孤立--这就是灭亡的开端。
=====
因为过于低级，无法理解等级威压。
=====
同心蛊奴隶蛊，既中一蛊，便集另一蛊。债多不愁，我很想知道在一人身上养此二蛊，谁能控制我？
=====
能则示之以不能，好名者需谦逊低调，淡泊者可追名逐利
=====
人工智能 的 问题 还可能出现在 使用方式上，一种很自然的廉价的使用方式是一个对象的拷贝被滥用，缺陷被重复无数次，类似无性繁衍或基因单一的农作物，如：土豆、香蕉，极其容易团灭。
=====
=====
=====
wwwww








函数式表达 固然 功能完备，但不利于 转化成 相对简洁的 外部通用数据表达 以 进一步处理（如:比较两个表述是否等效）
外部通用数据表达 可能体系复杂庞大一点也不简洁，而且需要 对数据作详尽的注释 或 设计数据格式标准






































grep 阳
阳符/阴符 错误命名？
  柔刚-长短-静动-阴阳-凹凸-隐显-虚实
    ==>> 阴符/阳符 不是 好的 命名，有 歧义！
    浊符流
    清符=动符+静符
  view others/数学/编程/术语/我的术语.txt
  view ../txt/TODO2.txt
  view ../txt/script/上下文无关语法分析器.py
  view ../txt/script/a_parse.py
  view ../txt/others/数学/编程/TODO_list/CFG编译器.txt
  view ../txt/others/数学/编程/TODO_list/句法识别器.txt
  view ../txt/others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt
  view ../txt/others/book/Build Your Own Lisp (2014)(Daniel Holden).txt











e others/数学/编程/TODO_list/模版式语法.txt
e others/数学/编程/术语/我的术语.txt

e others/数学/『无限』假设.txt
e others/数学/编程/永恒代码/抽象是共性抽取.txt
e others/数学/编程/永恒代码/strict-lazy-形式不同-如何统一？.txt
e others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt
view /sdcard/0my_files/git_repos/python3_src/java_external/antlr4/工具-句析器生成器ANTLR.txt
  e others/数学/编程/编译/工具-句析器生成器ANTLR.txt
e others/数学/编程/lambda/形式证明-如何在不同的整数编码间切换-命题变换-同态.txt
e others/数学/编程/lambda/空间-类型-函数的集合论解释.txt
e others/数学/编程/lambda/well-found is not countable.txt
e others/数学/编程/永恒代码/原子更新.txt
e others/数学/编程/永恒代码/可持久化数据.txt

e others/数学/编程/永恒代码/文件夹化.txt

e others/数学/编程/永恒代码/概率问题-终止、正确.txt
e others/数学/编程/永恒代码/对编译的支持问题.txt
e others/数学/编程/永恒代码/简洁即是美.txt
e others/数学/编程/ill/shell的shebang的毛病.txt
e others/数学/编程/ill/竟然.txt

# /storage/emulated/0/0my_files/git_repos/python3_src/
.e ../../python3_src/seed/iters/flatten_recur.py
.e ../../python3_src/nn_ns/CJK/CJK_data/raw/125成字部件_44部首.txt
.e others/数学/编程/兼容.txt
.e others/数学/编程/变址寻址.txt
e others/数学/编程/并行并发/并行并发区别.txt
e others/数学/编程/并行并发/并发编程-内存模型-内存次序.txt
e others/数学/编程/并行并发/无锁并发编程.txt
e others/数学/编程/并行并发/CAS无锁实现原理.txt

.e others/杂/中庸名句.txt
.e others/杂/中庸（汉语词语）.txt
.e others/杂/易-可久可大.txt
.e others/杂/房vs屋.txt
.e others/杂/x86-amd-arm.txt
e others/杂/〖钥〗发音.txt
  公钥 发音 yao4 yue4？
===
e others/杂/词语解释/崖vs岸vs涯.txt
e others/杂/词语解释/阴符vs阳神.txt
e others/杂/词语解释.txt
  更名为：
    e others/杂/词语解释/词语解释.txt
e others/app/网/哔哩哔哩.txt
e others/app/网/B站评论.txt
  更名为:
    e others/app/网/哔哩哔哩-评论.txt
e others/我的叶子/魔门明心宗.txt
!e others/我的叶子/科学教.txt
!e others/数学/编程/永恒代码/向前兼容的数据格式.txt
.e others/数学/编程/tree/RMQ、树状数组、线段树.txt
.e others/数学/编程/applicative-data-structure.txt
.e others/数学/编程/applicative-vs-functional.txt
e others/数学/编程/functional/functional language without GC.txt
e others/数学/编程/垃圾回收/垃圾回收.txt


e others/数学/编程/C++/realloc.txt
e others/数学/编程/C++/c++智能指针weak_ptr+enable_shared_from_this+diamond-inherit.txt
e others/数学/编程/C++/static_cast会改变指针的值.txt


e others/数学/编程/tex/www.latexlive.com[help].html
  wget -k -r -l1 https://www.latexlive.com/help
  file:///storage/emulated/0/0my_files/git_repos/txt_phone/txt/others/%E6%95%B0%E5%AD%A6/%E7%BC%96%E7%A8%8B/tex/www.latexlive.com/help

e others/app/termux/py_pip/manim.txt
e others/app/termux/无法安装/scipy-manim.txt
e others/app/termux/无法安装/无法安装汇总.txt

to read:
  TODO
  Inductive Data Type Systems
    e others/book/Inductive Data Type Systems.txt
  Mastering Linux Shell Scripting
    e others/book/Mastering Linux Shell Scripting.txt

  佛学问答集 #downloaded
  latexlive-help.html #downloaded
  ###
  Beyond_feelings_A_guide_to_critical_thinking.pdf
  Computer_Systems(2nd).pdf
  =====
  #e others/book/compile.txt
  Build Your Own Lisp (2014)(Daniel Holden).pdf
    pg 116/195
    e others/book/Build Your Own Lisp (2014)(Daniel Holden).txt
    e /sdcard/0my_files/tmp/lisp/example/try_readline.c
  Compilers and Compiler Generators: an Introduction with C++
  Let's Build a Compiler
  Writing Compilers and Interpreters (3ed)(2009)
  Modern Compiler Implementation in Java (2ed)(2002)
  Modern Compiler Implementation in C (rev+ex)(2004).djvu
  Compiler Construction (Niklaus Wirth)(2017rev1996)
  The Definitive ANTLR 4 Reference.pdf
    2012
    109/322
e others/book/read.txt
  finger trees: a simple general-purpose data structure
  Sketchy LISP -- An Introduction to Functional Programming in Scheme (3ed)(2008)(Nils M Holm).pdf
    e ../lots/NOTE/Lisp/Sketchy LISP.txt


DONE:
  .e others/数学/编程/tree/2_3_4_tree.txt
TODO:
  TODO
  e others/数学/编程/TODO_list/
  ?e others/数学/编程/tree/finger_tree.txt
      e script/a_parse.py
  !e others/数学/编程/TODO_list/py_mk_sh.txt
    TODO: py_mk_sh

  e others/数学/编程/永恒代码/字符串内部转义.txt
  e others/数学/编程/永恒代码/语法解析结果标记语言.txt
  e others/数学/编程/永恒代码/可运行于任何平台的语言.txt
  e others/数学/编程/永恒代码/通用汇编语言.txt
  e others/数学/编程/编程任务无用技巧书目.txt
  e others/数学/编程/TODO_list/句法识别器.txt





TODO: www
TODO:
  finger_tree
  insert/remove O(log n)??
  finger tree
  2-3-4 tree
TODO:





xslt
XSLT
XSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other XML documents, or other formats such as HTML for web pages, plain text or XSL Formatting Objects, which may subsequently be converted to other formats, such as PDF, PostScript and PNG. XSLT 1.0 is widely supported in modern web browsers.






















实名制配给、不记名货币 -- 本质都是用于控制有限资源不被大量浪费，无论无意或是恶意

吸血寄生虫--洪荒凶兽？

当永生成为可能，一切资源都将匮乏，因为人口是无限的。资源如何分配将成为大问题。现在人们还在报怨这报怨那，殊不知对于永生纪元的新生代而言，这是最后的可轻易翻身的黄金时代，此后每一分收获必将付出当下的百倍努力，而且情况只会越来越严重。
升级打怪
  整容-出台-螺旋上升-莫欺少女丑

反抗人类暴政
  你是一只饿死在废弃水族馆池子里的海豚，你重生了，这一次你将如何对待人类？

乐宗-穷搜寰宇编钟，镇压祛除一切灵性生机
一蓬杂草强出头，尘间竟然有悲欢

进化方向-食腐


https://www.latexlive.com/
https://www.latexlive.com/help



=======
TODO www wwwww
小说推荐
买 浅底广口瓶/长柄口壶？ 鸡蛋 脖胸
app 定时关闭进程
app 图论 作图 手动调整 类似『线条别交叉』
  线条别交叉 @com.livelikepoet.linecross

py c库 编译 构建 => nauty
pip install cairosvg
  view nn_ns/app/svg2pngs.py
  from cairosvg import svg2png
? incident 表语，incidence 定语?
  no!
  incident 表语+定语，incidence名词

python path escape/quote
py bs4 path归纳

data structure
  dgraph with data colored vertices
    eq === colored dgraph automorphism eqivalence class
  seq : line dgraph
  set: dgraph without edge
  cyclic-order: cycle graph
      # embedding = cyclic order of incident hedges of each vertex
e ../lots/NOTE/graph/planar/fast generation of planar graphs (expanded)(McKay).txt
duM /sdcard/



e script/欧路词典.py
  inc decode
    codecs.getincrementaldecoder
  e /storage/emulated/0/0my_files/git_repos/python3_src/seed/text/StepDecoder.py
test overlap search
  done
  unit test
  e /storage/emulated/0/0my_files/git_repos/python3_src/seed/iters/find.py
        iter_search_subseq_on_seq
        iter_search_subseq_on_stream
Get args . replace/update
  done
info plantri subcmd
  e script/info_tri_planar_graphs.py
update useful.txt:
  e ../../python3_src/useful.txt
    unit test
    main() arg parse
      e ../../python3_src/seed/for_libs/for_argparse/subcmd.py






done:
  py png read/write, 将图片设置为黑白，手动画图 黑色不黑！
    pip install purepng
    import png
done:
  app 网格作图
  python c-string escape/quote
  graphviz/dot planar graph
  e script/draw_tri_planar_graphs.py
  lftp adc3m3... .txt
    E:\my_data\program_output\py3\nn_ns\graph\adc3m3\-adc3m3[4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24].txt
    E:\my_data\program_output\py3\nn_ns\graph\adc3m3\-adc3m3[26].txt
  upload svg-png

  e script/draw_tri_planar_graphs.py.data/hand_draw-readme.txt
    e script/info_tri_planar_graphs.py
    e script/draw_tri_planar_graphs.py
    e script/pngs2blackwhite.py


息壤中文网
蛊真人
纵横天下...铁布衫
公子千秋


天行健，君子以自强不息
  易::乾
  《象》曰：“天行健，君子以自强不息。”
十室之邑，必有忠信
  论语::公冶长
  子曰：“十室之邑，必有忠信如丘者焉，不如丘之好学也。”
楚师之惧，我不修也...冀州之土，其无令君乎？
  国语::卷十-晋语四::8-楚成王以周礼享重耳
   令尹子玉曰：“请杀晋公子。弗杀，而反晋国，必惧楚师。”王曰：“不可。楚师之惧，我不修也。我之不德，杀之何为！天之祚楚，谁能惧之？楚不可祚，冀州之土，其无令君乎？且晋公子敏而有文，约而不谄，三材待之，天祚之矣。天之所兴，谁能废之？”
奢靡使人迷信:要加钱？不，我选择科学




update:
  pip install grab
  download nauty plantri
    ../../python3_src/c_external/nauty/
    ../../python3_src/c_external/plantri/
  download  cppreference-doc
  download  ANTLR-doc
    The Definitive ANTLR 4 Reference.pdf
  download python3-doc networkx-doc grap-doc bs4-doc sympy-doc
    https://networkx.org/
      https://networkx.github.io/documentation/stable/_downloads/networkx_reference.pdf
        networkx_reference.pdf
          ==>> networkx_reference-2_5.pdf



====
python grab grablib example
python grab grablib doc download
  https://grab.readthedocs.io/_/downloads/en/latest/pdf/
    pdf
https://pypi.org/project/grab/
  pip install grab
    含依赖 小于 2MB（部分依赖已安装，未计入）
  http://docs.grablib.org/en/latest/
https://github.com/lorien/grab/
  https://github.com/lorien/grab/releases

==================================[ZZZ
https://pypi.org/project/grab/

##Grab Example

import logging

from grab import Grab

logging.basicConfig(level=logging.DEBUG)

g = Grab()

g.go('https://github.com/login')
g.doc.set_input('login', '****')
g.doc.set_input('password', '****')
g.doc.submit()

g.doc.save('/tmp/x.html')

g.doc('//ul[@id="user-links"]//button[contains(@class, "signout")]').assert_exists()

home_url = g.doc('//a[contains(@class, "header-nav-link name")]/@href').text()
repo_url = home_url + '?tab=repositories'

g.go(repo_url)

for elem in g.doc.select('//h3[@class="repo-list-name"]/a'):
    print('%s: %s' % (elem.text(),
                      g.make_url_absolute(elem.attr('href'))))







##Grab::Spider Example

import logging

from grab.spider import Spider, Task

logging.basicConfig(level=logging.DEBUG)


class ExampleSpider(Spider):
    def task_generator(self):
        for lang in 'python', 'ruby', 'perl':
            url = 'https://www.google.com/search?q=%s' % lang
            yield Task('search', url=url, lang=lang)

    def task_search(self, grab, task):
        print('%s: %s' % (task.lang,
                          grab.doc('//div[@class="s"]//cite').text()))


bot = ExampleSpider(thread_number=2)
bot.run()


==================================]ZZZ
==================================[ZZZ
==================================]ZZZ


e others/app/termux/py_pip/py-excel-xls-xlsx.txt




拥趸dun3

downloaded_zip.txt
  cppreference-doc
    cppreference-doc-html_book_20190607.zip
  py
    python-3.8.1-docs-html.zip
    sympy-docs-html-1.5.zip
    sympy-1.5.1-py2.py3-none-any.whl
    python3_src-master.zip #github:edt-yxz-zzd
  stardict
    *
  cmake
    cmake-3.7.2-doc-man.rar
  tcl/tk
  openssl
    openssl开发手册.chm #加密相关，中文

stardict
  /storage/emulated/0/0my_files/tmp/git_/stardict-3/
    exclude /.git/
  e /storage/emulated/0/0my_files/git_repos/txt_phone/lots/NOTE/stardict星际译王/stardict-www.txt
    upload err name!
  /sdcard/0my_files/zip/stardict/
  /sdcard/0my_files/unzip/stardict/



语言设计-静态计算vs声明式概念
  静态计算 虽好，但 和声明式 还是有明显不同
    关键是 概念的组合、复用、拆解
    用 数据 表达 概念，数据 必须 能标准化，标准化是比较的前提
  用于 不完整的前瞻声明
    不同形式的陈述/条件组合 是否等价/兼容？
    API源代码使用接口的形式一致性
      结构体:
        数据成员的声明次序-自由
          多次整体声明，此次序可不同
        初始化次序
          不同构造函数 各不同
        析构次序
          唯一
        解包次序
          auto& [x,y] = a
          各编译单元唯一
        内存布局次序
          与外部语言统一
    ABI对外接口约束
      内存布局





有没有简单高效的内存管理方案？
  要求:
    允许引用某棵树的子树时不必完全复制子树
    允许数据间循环引用
    单线程引用数据时不必使用原子操作
    程序运行时不会由内存管理导致明显卡顿
我想设计一门脚本语言
  数据允许共享，即不至于函数调用时需要复制大量数据
  这样一来，数据不存在固定的拥有者
  内存管理大概剩两种可能: 引用计数 或 垃圾回收
  引用计数:一来听说没垃圾回收快，二来还有死循环的可能，先排除
  垃圾回收，又有两种实现:先暂停后回收 或 并发回收
  感觉暂停的时机不好确定，如果等到分配内存失败才暂停，岂不是长期占用大量无用内存？
  而且暂停的话，可能中断运行很久，所以排除
  但是并发回收的话，就有黑户反复橫跳的可能
  为避免错误回收这些黑户，克隆指针时，需要更新数据的标记位以表明存活。
    参见:CMS第三步3.重新标记（CMS remark）
    参见:G1第三步3.最终标记（Final Marking）
  并发环境下，岂不是每一次克隆指针都需要原子操作？只读数据也不能幸免？
  是不是存在某个明确的时长，过后memory_order_relaxed的副作用可传播开？
  感觉并发回收效率也不是很高啊？原子操作到底快不快？
    见：e others/数学/编程/并行并发/原子操作到底快不快？.txt

手机自发重启 感觉比 手动重启 要快，似乎不是真重启，是不是 CMS "Concurrent Mode Failure" 触发一次 Full GC？


垃圾回收 效率分析
垃圾回收 需不需要 原子操作



垃圾回收怎能在C语言中实现，而不对数据类型作出要求？
  C语言 垃圾回收 库

垃圾回收是否『回收用时 与负载成反比 与垃圾成正比』

如何实现 实时垃圾回收？
  是不是与 引用计数 一样，复制引用时需要原子操作-修改标记位？毕竟有黑户反复橫跳的可能。
    对象访问 需要 原子操作？

并发环境下，只读数据 的 读取 也需要 原子操作吗？毕竟 其他进程 可能持有 原地址 的 过时数据。可又好像 见到过 只读数据 无需 原子操作 的 说法。
  需要同步，详见:
    view others/数学/编程/C++/shared_ptr-concurrent.txt
      1) shared_ptr本身 的 同步问题






是不是存在某个明确的时长，过后memory_order_relaxed的副作用可传播开？


rel/acq拆开来，能更快吗？
  n个rel_acq，拆成n个rel+1个acq，能更快吗？
  失败 是否 相当于 relaxed
内存栏栅
并发编程原理 书


POD条件
  是否初始化？
  是否值传递？
memcopy/memzero

？C语言 没有 Fortune快？
  strict指针？
  如何声明，以表示两数组不重合？任何地址皆无别名？
？struct.bitfield成员 可实现多大的整数？

？『若』是不是『如果切』？
？『否则』的反义词是什么？『然则』『与则』『是则』
？std::deque的元素指针是否稳定？


查询:
    参见:CMS第三步3.重新标记（CMS remark）
    参见:G1第三步3.最终标记（Final Marking）


内存分配 - 锁？无锁？无等待？
  链表式 并发对象 需要 内存管理，这可能是 瓶颈


shared_ptr carry-a-dependency
怎样的数据访问模式更cache-friendly？


？shared_ptr turn off concurrent support
？共享指针 部分开启多线程支持，部分单线程？


独占指针？
  unque_ptr
    看来像是 unique_ptr 取代了auto_ptr
    ，因为有了 移动构造
  auto_ptr
    auto_ptr
    // deprecated in C++11, removed in C++17



linearizable, wait-free, and fast
  linearizable?
  并发对象可线性化 是针对 对象状态的变化
    在该并发对象上执行的任意多操作，导致的结果状态 等价于 这些操作的 按照 某个次序 串行操作 得到的结果状态
fast-path-slow-path
  将用CAS实现的lock-free数据结构 转化为 wait-free
compare_and_swap vs test_and_set
  test_and_set(&x, v) :=
    z = x
    x = v
    return z
  compare_and_swap(&x, y, v) :=
    z = x
    if z == y:
      x = v
    return z




生产消费-何时停止？
  主线程 等待 所有生产者 停止
  ，设置 可止标记位
  ，然后 等待 所有消费者 停止
  。
  消费者 使用 非阻塞尝试移出元素
  ，失败则读取 可止标记位
  ，若 可止 则止
  ，否则 休眠后再尝试
  。
如何证明多线程函数的正确性？


什么东西可替代手指点击手机触摸屏？
  戴上手套，点击不了
  不是压感，感觉像是电容式感应
  不行:布/塑料/胶/铁/桔叶/干红枣
  行:手指/桔皮/桔子/香肠






e others/数学/编程/并行并发/并发编程——原子性，可见性和有序性.txt

e others/数学/编程/垃圾回收/垃圾回收.txt
e others/数学/编程/C++/shared_ptr-concurrent.txt
e others/数学/编程/C++/C++容器.txt
e others/数学/编程/C++/make_shared比直接构建 shared_ptr更好.txt
e others/数学/编程/C++/make_shared-array.txt
e others/数学/编程/C++/shared_ptr接口+内部两指针.txt
e others/数学/编程/C++/weak_ptr接口.txt
e others/数学/编程/内存/cache与缓存行.txt
e others/数学/编程/并行并发/blocking vs lock-free vs wait-free.txt
e others/数学/编程/并行并发/CAS比较并交换.txt
e others/数学/编程/并行并发/shared_ptr析构函数的错误代码.txt
e others/数学/编程/并行并发/我的shared_ptr优化.txt
e others/数学/编程/C++/shared_ptr共享指针的传入方式.txt
e others/数学/编程/并行并发/原子操作到底快不快？.txt
e others/数学/编程/并行并发/锁升级-混合锁.txt
e others/数学/编程/C++/POD-and-union.txt
e others/数学/编程/C++/union.txt
e others/数学/编程/C++/union-vs-variant.txt
e others/数学/编程/C++/variant.methods.txt
e others/数学/编程/C++/memory_order.标准参考.happen-before.txt
e others/数学/编程/C++/memory_order.atomic_thread_fence.txt
e others/数学/编程/C++/initialization.初始化.txt
e others/数学/编程/C++/initialization.default-constructor.txt
e others/数学/编程/C++/type.类型.txt
e others/数学/编程/C++/type.POD.txt
e others/数学/编程/C++/type.trivial.txt
e others/数学/编程/C++/type.StandardLayoutType.txt
e others/数学/编程/C++/type.LiteralType.txt


e others/book/note并发/wait-free queue(2016).txt





TODO:to view
  深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）周志明.pdf
  futexes are tricky(2011)
  futex in Linux(2002)
  lock-free queue(1996)
  wait-free queue(2016)

======
======
======






e others/book/note.txt









小众技术工具库 app下载:https://www.xiaozhongjishu.com/












here

2020下半年『浴中奇思』精选TOP150
  74. 小时候，我们通过朋友发展新的兴趣；长大后，我们通过兴趣认识新的朋友。
  95. 如果不守规矩的人没有受到惩罚，则会由守规矩的人来代替他们受到惩罚。








  识别器
  NFA - 简单版 复杂版
  www.eudic.net 安卓版 完整词典 -> 手机 eudb_en
  DONE:mpc
  ===
  token/tokenizie 翻译





  ordinal
    n.序数；比较；
    adj.序数的
  Brouwer ordinal
    !=Bachmann–Howard ordinal
  which f?
    About Brouwer’s ordinals, note that only a suitable choice of f's provides a semantically correct ordinal notation and that, for such a correct notation, the above formal definition provides semantically correct ordinal addition.



=


  词典
    #本地+技术性+可复制
    变址
    标引
    index register
    index assess method


  echo input avoid -n
    echo does not interpret -- to mean the end of options.
      from "man bash"
  desktop book
    database
    system
    lisp
    xslt
  ===
  gedit app

  py async example
  #bug:㘅u3605h<=5:@@2513323411243112 vs 銜u929Ch<=5:@@33234112431112
  #bug:㘒u3612h<=5:@@3123431251112125135 /3123431251121125135 vs 種u7A2Eh<=5:@@31234312511211
  #bug:歰u6B70h<=5:@@53453421212121 vs 㒊u348Ah<=5:@@3253421215342121
  #bug?㔡u3521h<=5:@@325341153553 #1535?1515

  ##???gb bug???
  ##25144511221342511134㘔u3614h
  ##25144511221342534左口右赛#无此字
  ##251445112212511134貝版㗷#无此字
  ##251445112212534㗷u35F7h#疑为错别字

  py parse hs
  金岷氏 金岷彬
  汉字拓扑学
  矢量图 app 字体 app
  vim 字体大小
  具体笔顺？

  笔画名称 汉字字型
  汉字 unicode 私用区 是什么
  明朝花园 开心宋体
  《信息處理用 GB13000.1 字符集漢字部件規範》
  GF 3001―1997《信息处理用GB13000.1字符集汉字部件规范》
  汉字基础部件表 胡敬禹  2004年1月8日

  split pdf
    config EBookDroid
  DONE vim output window
    :read !cmd
    :redir END tells Vim to end redirecting messages. See :h :redir
  grep with encoding
    ???




=======
py shell
  iter chain cmd
  e ../../python3_src/nn_ns/io/py_io_shell.py
DONE mapping set lazy
DONE text io: path e f(fin) g(r)
DONE iter lines rstrip? filter head rex? eaters?









================有道理！
https://www.zhihu.com/question/39279003
现代汉语可怕的地方就是在于，双音节名词无论你怎么严肃，看起来都很难像一个术语，它会被试图解构，怎么看都像是一个临时组建出来的词组，而不会被和一个意义固定地联系起来。
================





初步答疑 网站创意:
  问：自然语言 描述 具体问题
  答：
    相关领域 # ==>> 专业网站
    相关术语 # ==>> 相关书籍/论文
    抽象问题，泛化问题


=========TODO
关于无限的理论，需要先假设存在一个无限大的集合
环境感知
  where I am:
    在哪个模块/类/对象/函数/switch-case分支？
      switch-case分支 的 键 与 主变量 相等，但 对象可能不同
      对象绑定:
        静态编译switch-case
          随函数定义一次绑定switch-case
        函数内临时动态绑定switch-case

打洞与宏:数据，数据类型声明，语句，语句块
人工智能
  要点在于 矛盾
  记住又记不住 遗忘
  某些方面精明某些方面迂腐 性格
  稳定又不稳定 情绪

止戈为武，彳亍成行
闲野道人
史珍香
六经注我


互逆
  人我见-一人为众念之国
  巨兽-同类众生为一巨兽
?以水入水，以言遣言

联姻
  争斗而已，何须忧伤？血脉渴求扩散长存，权财渴求吞并壮大，一切顺利。

愚而好自用，贱而好自专。生乎今之世，反古之道。如此者灾及其身者也。《中庸·第二十八章》
  说的就是我
道不远人。人之为道而远人，不可以为道。《中庸·第十三章》
  道在屎溺之中

困难的解决，产生快乐
  有用的工具
    应用
      vim
      python
        manim
        sympy
    语言
      lambda #formal proof, Haskell
      xml # vs latex



学诡辩，不是为了辩，而是为了不辩。
  佛法无边，皆因佛法是个球。

罪罚相当，就等于鼓励犯罪。利益共享:个人-积累，集体-保险，外国-买空。只要社会全体因犯罪而致的损失，无法从罪犯身上实际上找回(不能仅止于名义上的严惩，形成呆账坏账)，犯罪团伙的共同体就能得到养分不断壮大。
智愚/善恶/好恶悲欢/夭寿
  智无的，智不能立志，智不能改志，智能立能改者术而已。
  善恶，利分之。利，在于我，在于终。我，有小大之别，有分合不定之惑，人我古今其利相背；终，有短长之别，有终始不绝之惑，祸福表里互为因果。
    名善恶，则善者得名，得名则得利。利必使人，人施恶行以逐名，披善名以行恶获利。方知此善此将不善矣，方善方恶，善耶？行善藏名，知恶扬名。
  雷霆雨露俱是天恩，患得患失故生悲欢。甘苦，味之二，好恶，心之偏。
  夭者憾，寿者困。


轮回不灭，岂不有寿者相？修行必有所求，岂不有寿者相？







源究
本 自 由
溯本慎终
地横武定:安内伐外，人纵文和:由来慎终，天深仙齐:洞幽同异

现实测量的数据 精度有限
  显微镜的观测尺寸虽小，但对于提高百米赛道的精度毫无帮助。
  高精度运算无用

智力究竟是用来解答自己行为的目的及动机，还是用来给自己找借口？
  动机:深层原因
  目的:智力由动机及目下情形得出的行动方向
  借口:强行得出结论:所用手段的无害性或不得已的合理性
智力
  总结经验教训，假设并推广
    什么东西可吃？
      可吃范围推广
      禁食范围推广
  迷之自信
    赞美神，神会保佑我
      求人，人必须答应
      天生我，必有用
    实验结果与时间地点无关
      此时此地的实验结果必与过去将来无限远处的实验结果相同
  什么是合理？什么是不合理？智力其局限
  =====
  天地不仁
  社会纲常不会是理所当然，它需要所有人共同维护
  手段:
    为达到目的，所择手段的:可用，有效
      禁止范围:社会主流的智力及其价值观认为对社会有害的手段(当下稳定优先？发展潜力优先？纲常伦理优先？)
      合理范围:智力认为有效的手段




======
DONE

.e others/杂/玄学/二我见.txt
  二我见 人我见 法我见
.e others/杂/玄学/性命.txt
.e others/杂/玄学/十六知见.txt
.e others/杂/玄学/末那识.txt
e others/杂/玄学/五蕴.txt
  to read
e others/杂/玄学/人我四相.txt
  人我四相 我人四相 我相 人相 众生相 寿者相
  to read
e others/杂/玄学/八识.txt
e others/杂/玄学/因缘.txt
e others/杂/玄学/佛说即非是名.txt
e others/杂/玄学/涅盘四德-常乐我净.txt
e others/杂/玄学/五戒十善.txt
e others/杂/玄学/什么是佛法.txt
e others/杂/玄学/佛之三身-法报化.txt
e others/杂/玄学/儒家-仁义礼智信.txt
e others/杂/玄学/天干地支-由来.txt
e others/杂/玄学/方位-坐向.txt
e others/杂/玄学/.txt
==================================

==================================[ZZZ
==================================]ZZZ


地藏孝亲网
  佛学问答集1-4
    https://www.dizang.org/wd/fx/index.htm
    https://www.dizang.org/wd/fx/index2.htm
    https://www.dizang.org/wd/fx2/index.htm
    https://www.dizang.org/wd/fx3/index.htm
  file:///storage/emulated/0/0my_files/tmp/wget_/dizang/www.dizang.org/wd/fx/index.htm

  佛教入门
    https://www.dizang.org/qt/zh/index.htm
  file:///storage/emulated/0/0my_files/tmp/wget_/dizang/www.dizang.org/qt/zh/index.htm
    to read
======








=========
view ++enc=gb18030 /sdcard/0my_files/novel/《士子风流》（校对版全本）作者：上山打老虎额.txt
e ../lots/NOTE/novel/士子风流_note.txt
view /sdcard/0my_files/novel/《貌似高手在异界》（校对版全本）作者：高楼大厦.txt
e ../lots/NOTE/novel/貌似高手在异界_note.txt
view ++enc=gb18030 /sdcard/0my_files/novel/《太浩》（校对版全本）作者：无极书虫.txt
e ../lots/NOTE/novel/太浩_note.txt
view ++enc=gb18030 /sdcard/0my_files/novel/《百变销魂》（校对版全本）作者：二十四桥明月夜.txt
e ../lots/NOTE/novel/百变销魂_note.txt


=========
标准表格处理 函数
  book: Python for Data Analysis
  standard tabulate processing
vim -font ???
  大字体



汉字分解 相关文件
  js.load
  parse_CHISE_IDS.py
  after_parse_CHISE_IDS.py
  py -m nn_ns.CJK.cjk_subsets.hanzi
  cd /sdcard/0my_files/unzip/e_book/汉字分解/chise-ids-ea97c5d\[20200812\]/ids-ea97c5d/
  less ~/tmp/ids_all_2.txt
  less ~/tmp/ids_all_2_err.txt
  less  ~/tmp/after_ids_pp_2.txt
  cd /sdcard/0my_files/unzip/e_book/汉字分解/现代常用字部件及部件名称规范
  py script/py_repr2json.py -i ~/tmp/ids_all_2.txt -o ~/tmp/ids_all_2.json.txt -f
  less ~/tmp/ids_all_2.json.txt


IDS 分解
三级简体字
download 中华字经4000字
download 汉字 笔画 分解
	部件 笔画 分解
		部件粗区分（公开）= 部件笔画分解
		私用部件内部标识 = 部件粗区分 + 私用部件粗区分内部序号
	汉字 部件 分解
		汉字粗区分（公开）= 汉字部件粗区分分解
		私用汉字内部标识 = 汉字粗区分 + 私用汉字粗区分内部序号

=====DONE
DONE 125成字部件_44部首.txt
e /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/CJK/CJK_data/raw/汉语注音符号.html[baike.baidu].data.txt
  注音符号 来源 与全拼音对照
view /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/CJK/CJK_data/raw/unicode_CJK_Bopomofo_Zhuyin_Fuhao_U3100.pdf.txt
=====

DONE view others/数学/编程/python/Python_async_await_Tutorial.txt
  recur inf ==>> max depth
  async ??
  e /storage/emulated/0/0my_files/git_repos/python3_src/script/try_python/try_std_libs/try_async/async_vs_recur.py
  e /storage/emulated/0/0my_files/git_repos/python3_src/seed/iters/flatten_recur.py
=====



termux update for spec keys? fail require sndroid 7.0
termux openssl doc

git mv txt/*.txt /txt/xxx/
git py txt
update music/book/novel/font list


pure py site package
	image??
		remove pydroid???
grep with encoding




finite field DLP
shortest vector problem (SVP)
learning with errors (LWE) problem
ECC ？？成立条件?? order?? small subgroup??


李村战
地图 邮政 富士康公交




只增文档.txt
提取 TODO.txt 中有意义的东西
编程任务.txt



tuple翻译:元组
is_prime ~ O(n^6)
	[2^(x/2) - x^6 > 0] ==>> [ceil x >= 75]
	useful at least 75^6 > 74^6 > 2^(74/2) == 2^37


虚函数 递归约束 成员与基类
省电助手



3264=?=2100+150+(26*3+2)*13=3290
221=16*x+5*13-2*7
170=16*x=2*d
d=85=2100/27
x=9.75
2100/30=70
2100/26=80.76923076923077
2100/78=26.923076923076923
2100/27=77.77777777777777
2100/85=24.705882352941178
2100/25=84.0

8m
26*d+(26*3+2)*13-(26+1)*7=3061
9m
18*d+(18*1+4*2)*13-18*7=1742
3061+1742=4803
+30=4833

10-20,16:00 保安室领9月

1792



