TODO2


view others/数学/编程/术语/我的术语.txt
?TODO
.DONE
!WORKING

@All
?Some
&Recur
\Abstract
$Let
[proposition]
->
::
<:

『醒目文本』
    普通文本的醒目强调形式
〖特义词条〗
    被赋予特殊语义的词条
    一般都是已定义/将定义的技术性词条
【醒目特义词条】
    特义词条的醒目强调形式

==================================[ZZZ
==================================]ZZZ


注意:编译、+x脚本 均不得在storage即/sdcard/中进行，用户权限问题
tar -xzf rebol.tar.gz
  The result will be a new directory containing the files.
  -x extract
  -z gz
  -f fname

view others/app/termux/apt_pkg.txt
view /storage/emulated/0/0my_files/git_repos/txt_phone/txt/others/app/termux/lftp.txt
view others/app/termux/wget/wget.txt
  wget -k -r -l1 https://www.latexlive.com/help
view ../lots/NOTE/internet/download/curl/cmd.txt
      curl --continue-at - -L --retry 99 -O https://github.com/scipy/scipy/releases/download/v1.5.4/scipy-1.5.4.tar.xz

/storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/CJK/CJK_data/raw/
=======
DONE py module & id for ctrl+p
  view /storage/emulated/0/0my_files/git_repos/python3_src/自己的相关数据/py_modules.txt
  view /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/app/app_output/count_identifiers.py.out/py_doc_381_words.txt
  view ../../python3_src/useful.txt
教程 见others/app/网/哔哩哔哩.txt
  unity3d教程
  manim 教程




133*1651*1058

$ find . -name .ef0b4ddacc046d054f437ba0af966623 -delete
pi cf count by bit_len; [3]++[...]
规范 98MB ...
	"[20200713]zip_selected__e_book_数据_content.txt"中的"简繁对比"缺"通用规范汉字表 2013 pdf 99MB"

upload_book.txt
IRawFile
	multi_files
FrozenRangeSet

py.lzma + head+f[?:]+f[:?] + split


刷牙 洗澡 刮胡子 手机值 工

血：xue4 书面语〖一针见血 除外〗 xie3 口语〖单独成词〗 ????


10.1 看 增城招工 租房 搬家费



紫外灯
吃蛋壳 yes
夹腰 束腰
手表在卖为何不关电
为何米袋故意打洞？
鸡蛋 4.8元/斤 5个2.9元
  ==>> 6毛/个 8个/斤 63克/个
咸蛋腌制:料酒、醋、保鲜膜、盐
为何白醋可用塑料瓶装或用塑料瓶盖？
料酒、酒、醋 区别
腊肠 肠衣 可不可以吃？
20200929 腊肠 32元/kg, 鸡蛋 8元/kg
here
DONE 注音符号 来源 与全拼音对照




?TODO
.DONE
!WORKING
?汉字部首?
.一两笔的汉字
!纯汉字标识内部编程


e ../../python3_src/README\[汉字处理相关数据及脚本].txt
e ../../python3_src/nn_ns/CJK/CJK_data/raw/我的汉字分解原则.txt
e hz/TODO-笔顺码分解.txt
e hz/TODO-汉字部件清单_潘德孚_20030617.txt
e hz/TODO-汉字粗拆分working.txt
e hz/TODO-纵横字体.txt
e hz/TODO-汉字拆分设计.txt



䏮u43EEh#U3400pg74 䏮 JA4-753E

####################
######g肉 vs g月
##  肦胊胐脁脧膧+䏓䑃
##  肦u80A6h胊u80CAh胐u80D0h脁u8101h脧u8127h膧u81A7h䏓u43D3h䑃u4443h
##
##  朌朐朏朓朘朣+朊朦
##  朌u670Ch朐u6710h朏u670Fh朓u6713h朘u6718h朣u6723h朊u670Ah朦u6726h
####################


####################
如果『字底艹万』是『力』，『字头艹负』是『刀』，则笔顺码都该是53
  㗗u35D7h㗗 T5-3E3D#U3400pg10 另 字底艹万
  色字头上一把刀
  刀版色:=㔃，T3_457D，上部的右部，上刀下巴/t源的：㔃u3503h㔢u3522h
####################





e others/数学/编程/ill/竟然.txt
竟然
pip 竟然不是 断点续传！
echo 竟然不支持 "--"
  echo "$REPLY"
    what if "-n"
shell的shebang的毛病:
  .sh的shebang示例:『#! /bin/bash』
    毛病:强行指定执行器的硬路径



六经注我








index
  索引
    下标/附标
    指针
  检索/查找
  变址
  标引
  示[食]指 (=index finger)










yield
  i -> o
  i -> (mo, mi->o)
  $ArrYield o mo mi = Return o | Send mo (ArrGenerator mi o mo mi)
  $ArrGenerator i o mo mi = i -> ArrYield o mo mi

  i -> m o
  i -> m (mo, mi-> m o)
  $MonadYield m o mo mi = Return o | Send mo (MonadGenerator m mi o mo mi)
  $MonadGenerator m i o mo mi = i -> m (MonadYield m o mo mi)






e others/数学/编程/co归纳inductive.txt
  coinductive
data Co :: Type
data Co =
  | NotRecursive
  | Inductive
  | Coinductive
data T :: Co -> Co -> Type -> Type
data T x y a b =
  | TC1 (co_set x a) b
  | TC2 (co_set (not y) b)
  | TC3 (co_set (co_get (T x y a b)) b)
  | TC4 (T (not x) Coinductive a b))
  | TC4 (co_set (not $ co_get (T x y a b)) (T y x a b))
  | ...
keyword:
  co_set :: Co -> Type -> Type
  co_set Coinductive t = coinductive<t>
  co_set Inductive t = inductive<t>
  co_set NotRecursive t = t

  co_get :: Type -> Co



let !a = co_set Inductive a
let $a = co_set Coinductive a
cofunc:
  $i 0.. -> 1 $o
  !i 0.. -> 0..1 !o
  result cmp is unsafe
    结果可能是 $o
    除非相等比较的另一边是 !o，且使用惰性求值 #half_unsafe
func:
  $i 0.. -> 1 $o
  !i 0.. -> 1 !o

mapping: i 0.. -> 1 o
injection: i 0..1 -> 1 o
bijection: i 1 -> 1 o
surjection: i 1.. -> 1 o











new version
  new syntax construct / suger
    #normally new parser know old version
    old abstract syntax tree construction + convert ==>> new ast
      Haskell [| |]
  new std lib API
    new primitive
    more primitive
      old primitive become sugar API
    sugar API


















实现NFA=简单版+复杂版.txt

我来翻译NFA:有限并行状态机

有限状态自动机
  极小化

Nondeterministic Finite Automata (NFA)
非确定型有限状态自动机
形式语言 formal language


NFA - 简单版 复杂版
简单版#对应最基本的regex
  约束:
    一起一止
    起=/=止
    起无入，止无出
  两个基本NFA:
    起-[]->止
    起-[符]->止
  三种结构:
    注意:旧止取消结束标记
    注:『指向』即插入 无符转移有向边
    并联union
      #两个NFA起止分别合并
      新起指向两旧起，两旧止指向新止
    串联concatation
      #一NFA的止与另一NFA的起合并
      一NFA止指向另一NFA起
    闭包closure
      #NFA起止合并
      新起旧止皆指向旧起新止

复杂版#难用regex表达
  先独立建点，再画有向边
    有符线/无符线/诞影线
    简称:实线/虚线/影线
    节点有色
      终点颜色 是个有用的输出，用于 词法分析 中，对结果进行粗归类/粗标记。
      颜色 亦用于 灭影断言 中。
      为简单起见，要求 终点的颜色 与 非终点的颜色 不同
      影线 需标上 颜色集，当作影行者的终点色
    影行者 即是 原行者的约束
      目的是实现『前瞻后顾断言』
      当原行者抵达终点后，影行者仍可前行抵达它自己的终点
      当原行者抵达终点后，分几种情况处理:
        *要求 无有影行者 或 影行者 已灭
        *要求 影行者 也抵达它自己的终点
        *要求 影行者 不在抵达它自己的终点
        *影行者仍可前行抵达它自己的终点
            由于 需要 句外信息，这显然不是 句法/语法。
            假设 搜索最短前缀，还行
            假设 搜索最长前缀，则要求影行者记忆之前的可能终点，？不太行？
                ？但是，可将？？搜索最长 转化为 搜索最短？？
    灭影节点:
      甲类是 原行者 行至时，触发
      乙类是 影行者 行至时，触发
      断言若失败则原行者死
      原行者死，则影行者死
      ===
      断言相遇
      断言不相遇
      甲类断言影行者抵达带指定颜色之一的节点
      乙类断言原行者抵达带指定颜色之一的节点
      乙类断言『真』即直接灭影
      如果
  如何融合？与或非
  影行者 针对 其原行者（可能也是影行者）
    行者 即行于 节点网络 中，亦行于 输入符流 中。
      网络节点-简称『点』『节点』『地点』(适用于各种变形: 出生地)
      输入符流的索引-简称『指』『符指』『位指』
    要求一:影行者 从分身起 便走入 独立网络
      需求动机:
        不可能 参与 原网络 的 循环，避免 无限分身
        由于 影行者 的 并行数 受限于 节点数，影行者 的 影行者 的 层数 受限于 要求一，故而 必然是 有限状态。
    『要求一』泛化:
      从 生成影行者的无符有向边 出发，无法回到它的源端
      命名:〖影行者不得重返出生地〗
        *〖诞影线不重入〗
        *〖诞影线重入之前已灭影〗
          比如:『与』型影，将期望在指定节点与原行者复合(灭影)

  状态:
    原状态=原行者+所在节点+相应的所有的影状态
    如果 影状态 不同，则 原行者 即使 在 同一节点 也不得合并。
    ===注意:影行者 本来就会对应多个 原行者，因为 原行者 会进行 实体分身！
    逻辑上 如果 原行者所在节点不同，则 影行者 即使 在 影状态 相同的情况下 也不得合并。
        但 这只是概念上的，实际实现时，为了节省空间，可 允许 状态相同的影行者合并。
        如果 允许 影状态 合并，则 一影状态将有多个原行者，当说的『原行者』时，便是指合并前的复数个原行者。
        一切 操作 需与 不合并的情形 操作结果相同

  前瞻后顾断言:
    指定异端
      当 影行者 踩点时，触发断言
    指定异端边界
      当 原行者 踩点时，？触发断言
    异端自由
      当有 正行者 抵达 止点，？分情况，可能影行者还要前行


regex的语法:
  采用 多字符转义
  字符转义
    [[uXXXXh]]:
      unicode转义
      如:
        [[u0h]]
    [[/转义负载/]]
      如:
        [[/全文起点/]]
        [[/换行/]]
        [[/循环*/]]
        [[/循环+/]]
        [[/循环?/]]
    [[[协议/转义负载/]]]
    [[([协议/)转义负载(/])]]
      如:
        [[([生肉/)直接字符串(/])]]
  字符集描述:
    阳性字符集:[[+字符列+]]
    阴性字符集:[[-字符列-]]
  字符 可能是 阳符#语法中的终止符
    必然涉及 长名引用
    阳符集并补表达式:
      并集:
        +阳符集名+阳符集名
      补集:
        +阳符集名-阳符集名
        -阳符集名
    阳符句串联表达式:
      #允许 空
      ,阳符集并补表达式,阳符集并补表达式
    阳符句并联表达式:
      #允许 空
      ;阳符句串联表达式;阳符句串联表达式
    多个阳符集引用:
      #单阳符 可视为 单元素集合
      [[:阳符集名:]]
      [[:阳符集并补表达式:]]
        如:
          [[:+阳符集名+阳符集名-阳符集名:]]
          [[:-阳符集名+阳符集名-阳符集名:]]
    阳符集 的 串联/并联:
      [[.阳符句串联表达式.]]
      [[|阳符句并联表达式|]]







他空行
  可用于 跳过 空白/注释


语法
  ^优先并联输出名:@可选标记名
    /路径规则名 = 引用名@可选标记名
    /中间名/.../规则名 = 引用名@名...@标记名

  |互斥并联输出名:@可选标记名
    /路径规则名 = 引用名@可选标记名
    /中间名/.../规则名 = 引用名@名...@标记名

  ,串联输出名:@可选标记名
    .路径属性名 = 引用名@可选标记名
    .中间名.....属性名 = 引用名@名...@标记名
    !!!         #用于 优先并联，是我 提前锁定

  &自新输出名 = 引用名@可选标记名

  ====勤性
  $循环输出名 = 引用名*@可选标记名
  $循环输出名 = 引用名+@可选标记名
  $循环输出名 = 引用名?@可选标记名
  ====惰性
  $?循环输出名 = 引用名*? 引用名
    $?ysz = y*? z
    ==>>
    ^ys0:
      /ys1 = ys1
      /y0 = pass
    ,ys1
      .hd = y
      .tl = ys0
    ^ysz:
      /z = z
      /yysz = yysz
    ,yysz:
      .y = y
      .ysz = ysz


  『优先并联』于『勤性/惰性』的区分实现是必须的
  『自新输出名』-假如不支持循环，手写的话，显然需要对结果进行合并，即由链表变成数组，这时就需要一个真正的引用名
  『引用名』是『输出名』/『输入名』
    ！！！对于『优先并联』而言，分支名 亦可被引用，含义为自此以降，可用于 优先级不同的多个 二元运算符 构成的表达式 自我引用中
  『并联』情形，由于『引用名』必然不同，故『规则名』，也可以是『并联输出名@引用名』，但『路径规则名』可能更达意
  『规则名』=『并联输出名@引用名』/『并联输出名/路径规则名...』/『其他输出名』
      用于『语法树的规则节点』
      并非『引用名』
    『路径规则名』『可选标记名』主要用于『数据变换』
    『可选标记名』-数量任意，无序集合












注释
  注释出现的位置太随意了
  很难融入到CFG语法中，也难以从语法树中复原
    #考虑下，Python不遵守缩进规则的注释
  基本只能当作噪声去掉
  为了能统一处理/复原注释，我们需要将注释纳入语法体系，空白字符也一样
  具象语法vs抽象语法
    只需对〖具象语法〗中的『引用名』作标记和归类，便可定义 不同 程度的〖抽象语法〗






勤性求值/惰性求值/重复求值
  ？重复求值，值永远是表达式，每次匹配从新求值
    无法想象

已知 有向无环图 的 节点数 及 出度上限，入度不限，各点颜色不同，问：有几个图？
  假设 节点数n，出度上限o
  假设 节点的深度 指 节点到源的最长距离
  按 深度 分层，设 层数m
  m>=1，每层至少一个节点，除了源，其他节点 必在 上层某一节点 有边
  分层的组合数:
    层非空，所以对某一排列的节点 进行染色
惰性求值 与 引用计数
  假设 数据只读
  数据完全展开就是一个有向图
  强连通分量视为一个大点，则是有向无环图
    此时，引用计数便有用武之地
    引用计数 与 强连通分量 一一对应
  ====乙区
  甲区 说反了
  1. 虽然 数据 从用户角度看 结果是只读的，但 既然有从 表达式 到 值 的变化，显然实际上 不是只读的。
  2. 由于一开始 惰性表达式 代表数据而存在，如果把表达式看成一个点(实际上是有向图)，那么这个点将会分裂成(或被取代)多个点，关键是这些新点整体上指向外部的边 是『不增反减』的(将指向同一外点的边当作一条)

  ====甲区
  但是由于是惰性求值，有些节点和边并未出现
    好消息是，由于数据只读，强连通分量不减。
    (比只读更弱的要求:只要引用的对象的集合不变就行，甚至只要保持强连通分量不减就行)
    坏消息是，在新点新边加入后，检测循环并不容易
      ，与C++判断是否子类是同样难度
      给出 有向无环图 中的两个点，判断它们是否相通
      有向无环图 的 数量？编码？信息论 比较信息比特位
      注意:数据循环是受类型循环控制的
      所以 可认为 出度 有上限
      我们将类型相同的放在一起(析构函数可省)，再将互相引用的类型放在一起，这里说的类型 是 不含 参数变量 的
      因此 有向图 的 节点数 可知
      已知 有向无环图 的 节点数 及 出度上限，入度不限，各点颜色不同，问：有几个图？
  受控的环境:
    新点 由表达式而来，新边 由赋值而来
    a = f b
    a 将去哪里？多个地点
    b 将去哪里？
    f 的上下文？自由变量
    ===
    循环函数(相互引用的函数)
    ===
    数据循环 是怎么被引入的？
    必然是由于允许:
      *1
        x = f x
        x = f [1,x] # 返回值x 是 输入列表 后代
        x = f (g x)
      *2
        x = f y
        y = g x
        打包:
        c.x = f c.y
        c.y = g c.x
        ==>> c = fg c
    标记: 函数的本次调用，返回值是某个输入的后代(含 自身)
      当 函数是构造器时，形成循环
      注意:数据循环是受类型循环控制的
        所以 需要 标记的输入只有？
    其实 可以这样:
      x = f weakref(y)
      y = f weakref(x)
      但 外部 拆开 x，指向中间节点怎么办？
        还是需要 合并 强连通分量
        x = 2:3: if g i then [] else x
      正常<x> = f 强引用但拆包要标记<x>
        正常<x> 不论 拆包 还是 直接 被构造器捕获，都正常
        强引用但拆包要标记<x>
          #注意:多变量情形，则x换成 变量包
          *拆包:
            同循环类子节点 也要作 相同标记
            并且 记录 父节点，即保存唯一的向上路径
            ！行！
          *直接 被构造器捕获:
            试图 向上 合并，但父节点是动态增加的
              外部的拆包 在此之前！！
              但外部 看到的 都是正常节点！！
            好在调用路径只有一条，沿着 自顶向下 的 赋值=(但？尾递归优化-深度变浅！) 与 构造器(但？有多个分支！) 可得到一条路径
              ！错！
            更正:见上面 拆包，保存 唯一的向上路径，可行！
    ===
    综上，重述
    第一，只读假设，可得:之后定义的变量可以引用之前定义的变量，反之则不可
    第二，因此，实际上，一次只有一个变量被定义，称之为〖根变量〗
      相互引用？letrec？
      被定义的其实是一个变量包，相互引用的乃是它的属性，或者更广泛地讲，是它的后代
    第三，后代定义过程中引用的〖根变量〗只能是被标记的，称之为〖代理根变量〗
      后代被赋值时的右侧表达式中，最外层函数的该次调用，将绑定唯一的〖根变量〗
        后代本身或亲戚相互引用时，仍旧绑定原来的〖根变量〗。
    第四，〖代理根变量〗拆包时，其所有后代均被标记，称之为〖代理变量〗
      注意:变量包定义之外，对它及其后代的引用，都是正常的，无标记的，未被代理。
      〖代理变量〗直指〖代理根变量〗
      〖根变量〗及其后代及它们的代理，均共享同一个〖引用计数〗
    第五，构造器最后一次调用，在生成新后代时，如果发现本次调用











关联数据
  对于特定应用，可能会希望将某些或全部obj与特定类型的数据(属性)捆绑在一起
    比如:对抽象语法树的处理与求值
      语法文本 只有一个
      应用目的 却很多
      传入传出的属性值 当动态定义
  * Map weakref<obj> a
    一属性一映射
  * obj.hidden_attr_dict<@k=weakref<Symbol>, tp<k> >
    一对象一映射
    特点:
      不可干扰性
        不知大小: err: len(obj.hidden_attr_dict)
        不知其他键值: err: iter(obj.hidden_attr_dict)
  * 行列形式
    obj.id 即是 行索引号
    列 即是属性，可自由扩展



wwwww
===
我说一七五三，即非一七五三，是名一七五三
同代竞争
  为何竞争？为人为己？
  为己，则未必需要那么急切。
    人生很长，需要打发的时间不少，闻鸡起舞毕竟稀罕。
    大部分人若临了后悔为何年轻时不用功以致事业未竟，那也是发现自己的人生目标太晚之故。
    人之所以奋斗，是因为有需要有目标有动力，而这推动力来自于自己的经历。
    打发时间的经历也是人生的一部分，对于人的行动方向同样有不可忽视的作用。
    学以致用，这『用』可不是别人强加的，而是自己的追求。
    没有一个人活在虚空中，一个人不可能无缘无故，仅是为学而学。
    士不可不弘毅，但实际上为学常在立志前。
    一方面是生物性的原因，青少年期学习效率似乎更高。
    另一方面是社会性原因，今之学者为人。
    生物性原因是比较可疑的，成年之后到底怎么了？
    难道不是要糊口度日以致没时间，或者空闲时间碎片化歇足处也更随机？
    难道不是被更多外物牵动心神，浮躁难安，不得静思反省？
    说到底，还是缺乏动力。
    随便给自己订个小目标，规划日程，然后期望未来自己按部就班，达不到便归咎外因。
  为人，根源于社会资源的有限性。
    它并不希望均摊资源，均摊没前途。
    要集中资源办大事，就要有人带头。
    谁？
    每一代人都被驱使着前行，少时与同学竞，长时与同事争，并非为己。
    我不能说为人而学是错的，也不能说不重要。
    社会发展的需要，便是正确便是重要。
    但为人终究只是为人，我自己究竟要的什么？
    今生所求，即是为己。


===

括号
冂凵丄丅匚彐彳亍 辶勹
丩卩曱甴卍卐
连字符
冄
逗号
丷丶爫乊
丿亅刂亇
讠阝亻冫丬氵彡
巜巛
空格
冖宀亠乛灬罓罒艹
运算符
卄亖丯丨丆乁乚囗屮
====


冂凵丄丅匚彐彳亍 卍卐氵彡
冖宀
丷灬丶爫乊
卝
肀
辶乚厂乁 乀丿
爿片
帀 巿
尐
厃
兯仒仐仌卆厸冄罓罒
亖
亣丯
丨孒亅乛
丩卩
丆巜
廴讠亠阝亻刂勹冫丬亇乆

凣凢
卪卄
卂亽亼亾兦
饣忄囗
艹
夨
巛屮
纟扌犭
丮厈圧屵
耂
礻
丱冎冚冊匞畕冋冋冏囧煛燛臦臩
凷仺仚屳仧冭夳
囙
氺
癶钅
曱甴
疒
===5->6
襾覀
亞亜
叒劦姦厽
凼卋兲
尗赱弜夶吅奻
忎忈
肎氼艸
糹
===7
丣叓亪凬冝
囯囬囦奆夾巠
孨壵灷灻戺汖
====8
叕鼡
丳兓
凮冞罙
囶
実宔 宩宲窋
炗炛灮烡炏烎
戼汬坓沝昍峕癷
畱畄靣
===9
乗亰匩
尛尜圀
垔垚猋骉
怣
栆昚眘芔羍
====





用C++实现个Haskell
  目标:高移植性
    我的手机安装不了Haskell
  中文版
  勤性求值
    很多 容器 需要勤性求值
    迭代生成数据？
      g :: i -> [o]
      ==>>
      f :: i -> st
      h :: st -> Maybe (st, o)
      类？函数表？
      yield？h :: i -> &g= () -> Maybe (o, g)
      throw？
      callcc？
      冻结？
    垃圾回收？
      即是勤性求值又是只读就不要循环数据了
      引用计数#看来也不是完全只读，不安全！
        资源 如 文件
        析构函数
        类！因为 擦除了静态类型！
    没有循环数据
      循环类型？
      &S={T = T R S.T; R = R i S.T;}
      转化为 S 的键
      类型只是一个名字，并非对象
      函数递归也一样，有一个 递归包 将所有相互引用的函数 打包
    数组？
      允许只读，不许修改
  以finger_tree替代list
  支持view作匹配
  Type的类型是Type
  证明All替代箭头
    允许从完整类型切出部分，施加各种约束
    不允许 漏过分支，除非 声明 确实没有
      不允许Haskell.head
    约束 最简单的 就是 要求某函数返回真
      动态建立约束
    返回结果 可以带约束
    函数 可以有多个签名，仅约束不同
  多值判断结果
    真 假 未知
      比如:连分数 比较大小，只能用隐参数控制比较精度，结果可能只是高精度相近
      比如:单步执行，超时中断
      比如:素性判断，不少算法返回值:是，否，很可能是
    偏序比较: 前 后 等 无关
  函数分两种
    除了IO类其他的都可以动态分析
    也允许动态由数据变函数
      类似lisp以实现 惰性求值 短路与或
    函数<->数据
    类型<->数据
    类似Typeable a=>，用外挂区分
    数据是？
      lambda？combinator？
        combinator
          勤性/惰性
          简单的讲，求值可能停不下来，所以某些地方一定要表明等等再执行
          递归函数:
            &sf= sf->e
            &sf= (()--->sf)->e
      context？
  class翻译成『外挂接口』
  instance翻译成『外挂』
    私有区 辅助函数
    模版 引用

  动态拆包+ADT静态拆包
  并行，选择先返回的结果，终止其余
  记录 的 属性值 不该是函数 太容易 碰撞
    使用: T.f t === t .f
    并联记录 只能用匹配取出 属性
      见上面 约束 不得漏分支


外挂接口
  动态传入
    即作为隐参数与数据平行传入7使用数据的函数
  与类同在
    外挂接口可以注入到『类虚函数表』中
      *直接注入拆包后的函数
      *注入外挂接口本身的包指针，带名，以防止碰撞
  隐参数 更为 灵活，支持 同一接口 的 多种 实现。
  注入式 如果 要实现同样功能，就要
    *覆盖/还原 所要竞争的注入名
    *或 描述 一个相互依赖(特定于被调用函数所期望的某种一致性)的外挂接口的组群(一种更大的外挂接口，由其他更小的接口动态组合而成)，覆盖/还原 这个更大的接口组的注入名

默认 外挂接口
  默认 可视为 一种领域/空间
  我们 可以重置 默认领域，从而批量切换外挂接口
  类似隐参数

Haskell.class
  class M a where
    r :: *
    f :: a -> r
  相当于: @[r::*]. a -> r





语言设计 之 括号:
  任何匹配对:括号，字符串
  禁用单字符方案
  注意:括号连续出现时 应使肉眼也能轻松切分
    双字符坏榜样: [[  ]]
    双字符坏榜样: {[ [{  }] ]}
  注意:多行字符串很多行时，应使文本编辑器进行局部语法标记时不至于认错
      Python是个坏榜样
      可改为："""[  ]"""
  双字符方案:
    ===注意:等级先后:{[(<>)]}
    {[ ]}
    {( )}
    {< >}
    [( )]
    [< >]
    (< >)
    ==
    {: :}
    {. .}
    {$ $}
    {% %}
    {= =}
    {/ /}
    {~ ~}
    {* *}
  三字符方案:
    <(>  <)>
    <[>  <]>
    <{>  <}>
    ([)  (])
    ({)  (})
    [{]  [}]
  四字符方案:
    [{*]  [*}]




=======================================
C/C++ 需要编译，需要链接，指明语言标准和标准库，很好，也很反人类
Java 模块必须指明所在包，很好，也很反人类
简单来说，随便搞个文件，所有东西一起扔进去，直接运行，虽然乱糟糟，但十分友好。
Haskell/Python 当作脚本语言来用，十分完美，对新手十分友好
=======================================



类的方法的调用形式，但采用Haskell的外挂接口的引入方式，以避免多重实现接口导致的方法名冲突
  import I (f, g as h)
  obj .f()
  obj .h()
    <==> obj@I.g()
    <==> I.g(obj)



=======================================
『醒目文本』
    普通文本的醒目强调形式
〖特义词条〗
    被赋予特殊语义的词条
    一般都是已定义/将定义的技术性词条
【醒目特义词条】
    特义词条的醒目强调形式
=======================================
易移植语言
  见下面『最终目标清单』
  ===
  vs
    易移植语言.txt
    通用汇编语言.txt
      差不多。
      就是 阉割各种强力特性，以保证『能够』移植/汇编
    可运行于任何平台的语言.txt
      不同。
      强调 自己就是完整平台，除了极少的极为基本的外部依赖
      即是 虚拟机，同时 也强调 外部依赖极少

  ===

  移植的目标平台是其他编程语言，称之为〖移植所向宿主语言〗，简称〖植宿语〗
  易移植语言，简称〖易迁语〗
  ===
  动机由来:ANTLR-一个Java上的〖句析生成器〗
    元语言 = 用于书写语法规则的语言
    句语言 = 待分析的目标语言
    句语法 = 用元语言表达的 句语言的语法
    句析器 = 句语言语法分析器的算法
    句析器代码 = 用某种编程语言书写的句析器
    植宿语 = 句析器代码的实际用语
    元语言编译器 = 句析生成器 = 依指定的〖句语法〗及〖植宿语〗生成〖句析器代码〗的算法
    元语言编译器代码 = 用某种编程语言书写的元语言编译器
    元宿语 = 元语言编译器代码的实际用语

    ==
    需求一.支持多〖植宿语〗
      问：如何支持多〖植宿语〗？即〖句析器代码〗易于移植？
    需求二.支持多〖元宿语〗
      用户需要〖元宿语〗来生成〖句析器代码〗
      ，同时又需要〖植宿语〗来运行句析器
      ，最好是两种宿主语言是同一种。
      这就要求〖元语言编译器代码〗易于移植。
    需求三.交互问题
      用户如何使用〖句析器〗？观察者模式？
      即：移植后的代码与用户代码的交互问题。

    ==
    可执行语言 = 已存在解释执行器的语言
    特用定制语言 = 以特殊用途为导向进行设计的语言
      如:便于人类手写
      如:便于人类阅读
      如:便于机器作语法分析
      如:便于机器存取数据

    拆分〖元语言编译器〗:
      〖元语言编译器〗=〖元至易半译器〗+〖易迁语移植器〗
      元至易半译器
        = 入句法出易述句析器吾生成器
        = 入元语言述句法出易迁语述句析器吾生成器
        = 以元语言书就的句语法为输入、以易迁语书就的句析器为输出 的 句析生成器
      易迁语移植器 = 将〖易迁语〗翻译成〖植宿语〗的算法
        这是描述性定义，〖易迁语移植器〗的拆分组合式定义 见下面

    供需双方:
      供方 = 提供代码的一方，支持多种可执行语言
      需方 = 下载代码的一方，只支持一种可执行语言，附带可能有〖易迁语移植器〗
      勤性供方 = 提供代码的各种〖植宿语〗版本的供方
      惰性供方 = 只提供代码的〖易迁语〗版本的供方
      勤性需方 = 下载代码的〖易迁语〗版本的需方
      惰性需方 = 只下载代码的某种〖植宿语〗版本的需方
    ==
    对于『需求一』:
      勤性供方:
        *需要用〖易迁语〗书写〖句析器代码〗
          等价转化为:
            *功能要求〖元语言编译器〗须支持〖易迁语〗作为〖植宿语〗
            *需要〖元语言编译器〗可执行版本
              只需用某种可执行语言实现即可，无需易移植
            *需要〖句语法〗文本
              即〖元语言编译器〗的输入文本
        *需要〖易迁语移植器〗可执行版本
          只需用某种可执行语言实现即可，无需易移植
        一个功能要求+三个需要，即可得到〖句析器代码〗的各种版本
        因『一个功能要求』及『第三个需要』，才有了上面对〖元语言编译器〗拆分，这就是〖元至易半译器〗的由来
        ==
        『需求一之于勤性供方』总需求等价转化为:
          *需要各种〖特用定制语言〗的〖句语法〗文本
          *需要〖元至易半译器〗可执行版本
          *需要〖易迁语移植器〗可执行版本


      勤性需方:
        *下载〖易迁语〗书就的〖句析器代码〗
        *需要〖易迁语移植器〗可执行版本

    对于『需求二』:
      *需要用〖易迁语〗书写〖元语言编译器代码〗
        即〖元宿语〗是〖易迁语〗
      *需要〖易迁语移植器〗可执行版本
      ==
      问：既然需要〖易迁语移植器〗可执行版本，何不直接要整个〖元语言编译器〗可执行版本？既然有了可执行版本，何必要〖易迁语〗版本？
          目的是将〖元语言编译器〗内嵌到各种编程语言。
          当这些编程语言『动态』读取〖句语法〗、用内嵌的〖元语言编译器〗生成临时的〖句析器代码〗的本语言版本、分析解释执行之后，便可以对句语言的文本进行语法分析。
      ==
      『需求二』总需求等价转化为:
        *需要〖元至易半译器〗易迁语版本
        *需要〖易迁语移植器〗易迁语版本
        *需要〖易迁语移植器〗可执行版本


    对于『需求三』:
      见下面 交互问题的解决方案
    ==
    ==
    『最终目标清单』:=
      *需要设计的语言:
        *〖元语言〗
        *〖易迁语〗
        *多个〖过渡语〗，分别对应不同的〖植宿语特性选项〗
        *〖直译插件脚本语言〗
        *可选〖易迁语虚拟机脚本语言〗

      #自『交互问题的解决方案』
      *可选〖易迁语虚拟机脚本解释器〗易迁语版本
        #〖易迁语移植器〗并无交互问题，不必含此

      #自『需求一需求二』总需求等价转化为:
      *需要各种〖特用定制语言〗的〖句语法〗文本
      *需要〖元至易半译器〗易迁语版本
      *需要〖易迁语移植器〗易迁语版本
        #接下来的拆分，复制自更下面
        #其中『器』由隐含的『可执行版本』改为『易迁语版本』
        #
        =〖易迁语意译器〗@植宿语特性选项
        +多个〖过渡语直译器〗@植宿语
        +各〖植宿语〗相应的〖过渡语直译器〗插件
        +〖直译插件脚本语言解释器〗
        +各〖植宿语〗相应的〖轻量级接口支持库〗
      *需要〖易迁语移植器〗可执行版本
        #见上面
        #如：含〖直译插件脚本语言解释器〗可执行版本
      ==

  ===
  显然，由于〖植宿语〗情况复杂
    ，『易移植』即意味着『受到极大约束』、『严重阉割』
    ，只能选择各种编程语言共有的特性以保证『能够』移植
    ，具体到各植宿语，则可选用针对性的移植方案
    ==
    可设计一套〖植宿语特性选项〗集合，及 每一选项集合所对应的〖过渡语〗
    ==
    由于有时可能要求〖植宿语〗提供某种接口
      ，而实际上其标准库并无此接口或签名稍有不同
      ，这时就需要一个〖轻量级接口支持库〗
    ==

    〖易迁语意译器〗(唯一)
        将〖易迁语〗依〖植宿语特性选项〗编译成相应的〖过渡语〗
        ，解决 移植方案的选择问题
        :: 文本<易迁语> -> @植宿语特性选项 -> 文本<过渡语<植宿语特性选项>>#或 ->抽象语法树
        〖植宿语特性选项〗全集 相对稳定
          ，故而 直接依各选项静态特化之
          ，也就是 将多个实际上独立的分支实现打包一起，叫做〖易迁语意译器〗

    〖过渡语直译器〗(多个，对应不同过渡语)
        将〖过渡语〗编译成〖植宿语〗
        ，解决 具体语句生成问题
        :: 文本<过渡语<植宿语特性选项>> -> @植宿语 -> 文本<植宿语>#或 ->具象语法树
        〖植宿语〗全集 是在不断增长的
          ，又由于直译相对简单
          ，可以采用插件方案拓展目标语言集合
        由于插件只是进行简单的文本替换处理
          ，或 提供一个文本模版以供替换
          ，故 插件本身可用一个轻量级的的脚本语言书写
          ，称之为〖直译插件脚本语言〗
          ，需要〖直译插件脚本语言解释器〗代码的〖植宿语〗版本
          ，但对于跨语言移植而言，需要的只是〖直译插件脚本语言解释器〗代码的本地〖植宿语〗版本及〖易迁语〗版本，无需各〖植宿语〗版本

    〖易迁语移植器〗=
        =〖易迁语意译器〗@植宿语特性选项
        +多个〖过渡语直译器〗@植宿语
        +各〖植宿语〗相应的〖过渡语直译器〗插件
        +〖直译插件脚本语言解释器〗
        +各〖植宿语〗相应的〖轻量级接口支持库〗

    ==
    编译选项 至 过渡语:
      植宿语 的 特性选项:
        函数指针？
          有了函数指针
            ，就有了接口(只读函数表)
            ，就有了类及对象
        垃圾回收？
          混乱的循环数据结构
            混乱，即 权责不明
        数据可修改？
        数组？
          可以只是 只读数组
        if-case还是jump-case？
          jump-case只需支持 模剩余等价类(只针对 互斥并联ADT)
  ===
  ===
  ##重大性能影响
    不支持函数指针
      没有钩子函数，交互效率低
        #可用〖易迁语虚拟机脚本解释器〗
      外挂接口，代码爆炸
    不支持可修改数据
      无随机存取容器/数组，效率低
        字节串，编解码
        字符串，文本处理
        矩阵，图像处理

  支持路径名
    包/空间
  支持静态表达式+静态编译分支
    见下面 参见 封装宏
  机器字长
    有时要保证机器字长的下限，否则自定义或使用大整数
        见下面 参见 封装宏
  不直接支持IO操作
    若 不支持函数指针，则 真不支持IO操作
    或者 可配置静态编译选项，处理未定义函数，连接为IO函数
        见下面 参见 封装宏

  不支持函数指针，更不支持curry
    原因: 某些宿主语言 不支持函数指针
    ==
    或者说 高层概念中没有函数指针
    具体到特定宿主语言，可以有，以简化设计
    但 宿主语言共性中不该有

  没有类，全是函数调用
    因为 不支持函数指针，类的意义不大

  严格静态类型
    不存在子类型
      静态析构函数
        或者说由静态类型可退出析构函数
    可用模版
      但只能有一个定义
        即不得特化模版另行定义
        模版在这方面(擦除静态类型，形式不变)
          ，类似Java泛型、Haskell类
          ，而非C++模版/静态重载特化模版

    支持外挂接口(形式上，类似Haskell类)
      若 不支持函数指针
        ，外挂接口不能动态传入
        ，模版实例化时必然会产生代码爆炸
        ，每个模版最终只允许有限实例
        ，模版在这方面(代码爆炸)
          ，类似C++模版
          ，而非Java泛型、Haskell类
      若 支持函数指针
        ，外挂接口是动态传入的
        ，模版实例化时不会产生代码爆炸
        ，每个模版允许动态无限实例#如finger_tree
        ，模版在这方面(接口与数据分离、动态传入)
          ，类似Haskell类
          ，而非C++模版、Java泛型

  交互问题的解决方案
    如何实现 观察者模式？
    *用户受控: 使用外挂接口即可
      交互过程中，用户是受控方
      若 不支持函数指针，甚至只能静态编译(代码爆炸)
      否则 用户传入 受控接口+初始累积结果 即可
    *用户掌控: 冻结执行/单步执行
      类似Python的yield
      若 不支持函数指针:switch-case
        如果可能，采用jump-case
      否则 直接返回 接力函数
        静态签名？数据类型=互斥并联 或 子类+接口
      如何实现执行状态冻结？
        循环嵌套函数 拆解开来:
        状态冻结类型 = 互斥并联 各函数调用帧 的 各执行状态
          # union （原函数名+执行位置，混合的帧中数据）
          # 原函数名+执行位置 -->[jump-case?]-->ADT拆包分发->静态类型重建--> 拆分后的实际碎片工作函数
          #     效率极低，没有函数指针，真的不行
          #     不过 强调移植性 的话，能够运行就行了
          #     更何况 只有不支持函数指针的编程语言受影响
          #     都这样了，为何不干脆 当作汇编脚本 来解释执行？
          #     在此定义〖易迁语虚拟机脚本语言〗〖易迁语虚拟机脚本解释器〗
          #
        帧数据保存于堆上单链表中
        链表头为最深层的函数的帧
  可持久性数据 只读变量 尾递归循环
    勤性求值+只读数据==>>数据收敛
    注意：算法 于 勤性求值 与 惰性求值 的 实现形式不同
        如：list append
          Lisp需reverse
          Haskell则不该
  堆上数据 内存管理 责权分明
    不支持对象指针
      或者说 不支持指针 操作
      没有指针概念，连 是否相等 也不行
        如 Haskell
    虽然不支持对象指针，但内存资源管理还是要参与，或者假装有在参与。
    见下面 参见 指针约束
  参见
    参见
      『安全C.txt』
          指针约束 内存权责
    参见
      『模块C.txt』
          封装宏
          类似Python.__debug__/C.ifdef
    参见
      others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt
        编译相关的名词


  ===
  ===
  ===
  ===




=======================================
模块C
  屏蔽宏 或 受控宏
    * 指明从哪里引入哪些宏，用于何种目的
      *要不要在本模块展开(不展开相当于只是中转)
      *必须已定义 还是 用于 编译分支测试
      *声明引用虚拟空间中的 路径名，它将由 外部程序 配置
        静态 - 分析阶段所需，编译选项设定
        全局统一 - 连接生成 可执行目标 时 统一设定
        全局统一 - 加载 可执行目标 时 统一设定
          比如:
            超长名 变 短名
              各模块 用于 动态注册，避免 模块名太长 或 避免 自定义昵称 全局冲突
              在最后加载时 才动态分配一个临时昵称，只在程序运行期 有效

  空间名/包名，支持 超长名
体系C
  如:外挂接口体系
  如:封装指针垃圾回收体系（知道 那些成员指针 需要被...）
  如:封装双指针体系（打包对象及接口于大指针中，静态类型变换时自动更换接口）
  如:静态注入对象类型静态表体系（用于 多体系 并存）
  如:动态注入对象类型静态表体系（用于 动态添加 新体系）
  如:虚拟环境（缸中大脑，一切IO/内存分配/...，皆通过同一接口隔离 即作为 隐参数(不使用IO的就是pure)，用户可覆写部分接口以之运行 函数/线程/进程）

安全C
指针约束:
  谁负责释放？
    法人=容器 或 活动中的函数
    * 指定唯一的法人负责
      销毁责任/销毁权限 可转移
      甚至可指定唯一的访问者:
        唯一的访问者，甚至可以变更 指针静态类型 即 指针所受约束
        更变 双向链表 结构时，各节点的权责 不断变化
    * 若有多个法人要求同时访问
      * 引用计数+是否僵尸
        要求 被引用者 声明 自己负责销毁的那些指针 及 以此展开的有向图 必须 无环
      * 将指针传入子过程时:
        * 要求 被调用者 返回前 销毁关于指针本身的信息
          即 不得在 返回后 在其他地方 持久保存 本指针，以阻止未授权访问
        * 要求 被调用者 返回前 只能保存在某些指定容器中
          既然是『保存』，这些容器 显然比被调用者 活得更久
          这些容器 必须声明:
            + 生命比指针短，只要它们还活着 就可以访问指针
            + 无销毁权限







什么叫认清现实/自画像
  知道身处何处
  知道有哪些路可走
  知道路都通向哪里
  知道应当走哪条路
  知道实际会选哪条路

  所谓身处何处，即指身周如何，感觉好坏，合理与否
    而 这实是为我的由来所决定
      肉身的情况、感觉
      我的经历、知识
      决定了对未来的预测，进而决定了对当下的满意度。
    不识庐山真面目
      我觉得如何通常与实际情况不一致
      或者应当说 与别人的看法不同，包括 古人/子孙
      寻求认同？党同伐异，手掌真理替天行道
      寻求真相？随波逐流，虚心认错盲目跟风
      而常见情形是 两种情况交替出现，美其名曰螺旋上升

  神 永动机 来世 修行 永生 涅槃

  纵欲
    主观无明确的收敛状态
    挥霍人生
      漫无边际-贪婪无度
        资讯轰炸，眼睛离不开手机
        偷闲摸鱼赚翻了
        攀比慕强
      漫无目的-佛系，走哪死哪
        行到水穷处，坐看云起时
        买买买，下载下载下载
      毫无意义，一切虚无
        冒险 挑衅 违章
    主流狂热
      一门语言再有用，无人用也只是死语言。
      一件工具再好用，无人用就是多余的垃圾。
      我只一人，人微言轻，实属无奈
      被逼无奈 抱怨
        虽受害 亦受益
        希望改变同时害怕改变
          指望别人来改变
          避免被责难却愿意责难别人
  克制欲望
    主观有明确的收敛状态
    个人:关我屁事
      闭目塞听
        断电断网
        我什么都不知道
        记性不好
      漠然旁观
        明月照大江
        我就看看不说话，内心毫无波动
    集体:小国寡民
      闭关锁国
        永久中立
      减少人口
        计划生育降低出生人口
        主动冒险减少活口
        放纵疾病减少活口


















翻译




wwwww
coherence 连贯性 相干性 一致性
issue
n.
（水等的）流出( issue的名词复数 )；出口；放出；（特别重要或大众关注的）问题
v.
出版( issue的第三人称单数 )；发表；宣布；分配
并发 并行 区别

memory order 翻译
  发现『并发编程』有歧义，按『并发访问』来解释的话，变成『多人合作写代码』

===
网站创意
分几个区
帖子顺序 体现 不同内存模型
===
说话别人听不懂赖谁？
有人听懂不算啥；
有人听不懂说明他发现歧义，事实上更懂。
===
感觉发帖问人，会欠很多钱，还还不上，便极少发问。
不过会以问人时的客气口吻将问题的由来及扼要写下来，没事便上网搜搜。
这样过，全仗别人的提问及热心解答。
我虽不问，事理却是相通的。
===
正义是先天还是后天？
如果是先天，则可不计一切现实后果去追求。
如果是后天，则只是生存的鞋子，不值得削足适履。
天地不仁，我并不认为有先天正义。
但！即便是后天，还是有疑问。
何为生存？或者强调的是『谁』的生存？
个人？集体？哪个集体？
当代？后代？
为『谁』？
===
有一种『感兴趣』叫『仇视』
===
人活着就有烦恼，人活着就要打发时间。
===
记住骂过的话，它会回来的
===
:知道，知止
===
不要以为别人跟你一样
不要以为别人跟你不同
不要以为你跟别人一样
不要以为你跟别人不同
当你觉得合适时就可以拿来用
当你觉得不合适时也可以拿来用

因为觉得可疑，故意选择另一条路，也很可疑
因为觉得正确，才去做，未必就那么正确

真理就是废话

我所学到的一切，即是，这一切并非理所当然，你需慎重，你当如何如何……

=====
绝对自由，可以，今后律法皆废……现在我们来玩一个游戏，我当猎人，其余人当猎物。
反抗军首领也是我，再来新一轮吧

====
你误会了，我不是说他(墨)这个人怎样，我是说，这种徒党众多的模式持续下去，究竟会如何。这些势力久之，既不服从官府，也不会遵循前人定下的规矩，越有力量就越有奇怪的人员混入，朝廷便是如此，我疑虑重重，实难安心。

====
反正坏的是别人的名声，管他
竟然是我！我冒充我自己
====
看着它们挺起蓬松的胸膛互怼，脸上不经意浮现笑容，如果人间的争斗也能如此平和……
====
只做正确的决断，本身就是一种可怕的错误。
没有挫折的经历，是最糟糕的一种。
====
你以为得到权力，其实只会失去更多，未必划算
====
着相
  --财是身外之物，权力是，名声也是，父母又有何不同？让你嘴上多认几个爹而已，与真相何干？既与事实无关紧要，有何不可？……为何迟疑？莫不是在挖空心思编造借口来绕过自己以前的说法？何必呢，唇舌不过真实。
  --言行一致果然没想地简单，不过我不会让自己陷于那样的窘境，如果真出现了这样的局面，只能说我智力有缺陷，何当该死，多做多错无需挣扎。
  #假子潮流
=====
=记忆，传承，书籍，教师，工匠，原材料，工坊，定居……由均衡无要害自由飘荡的海水烟雾，变成弱点明确心脑难迁的巨兽，代价不可谓不大

=====
这可能是某种说话技巧，以一种理所当然的一切人一切事都围着自己转的自恋口吻发表出人意料的言论，使人困惑进而深究其意，达到引起听众注意的效果。
=====
只有手下死过很多人的大夫，才有可能是真神医
=====
人生的每个阶段各有目标。如果年龄见长心智却依旧如小孩，就是智障，这是残疾。如果过了适婚年龄而未婚，不论是畏婚还是以真爱之名避婚，也是一种残疾。应当养育后代之时却还沉迷肉欲，不能理解此间快感不过是物类为引导个体交配而给的小甜头，也是一种残疾。
=====
魔道功法精髓，有进无退，不留人生机，也不留己生机，刚不能久。他擅长逃命，一缕生机不绝，说是魔道中人，简直是对魔道两字的侮辱。
=====
灵活
  那就当我来迟好了，在敌人淫行忘我时出手击杀，总比先出声打断，再死战克敌，最后即便取胜也大概率被敌人逃脱来的强。我又不打算嚼舌，也不会跟当事人漏底，事实上就等效于『迟到』，无不可。
=====
就连天上的星辰也只能被宿命摆布，依着注定的轨道前行
=====
每一件事都要有始有终，避免节外生枝，否则随性而行只怕身在何处都搞不清
=====
所谓引导教化欺骗洗脑奴役诸如此类，不过是人们心中臆想，是从未发生过的事情。不要妄图去改变别人
=====
智杖之争
  智慧之杖
=====
冷面微融，居然有了好感，毕竟就算再坏，肯带自己痴呆妹妹出来逛街晒太阳，倘然承受由疯言乖行引起的外人异样眼光，这样的人也不算毫无人性。叹，见过太多权贵，富甲一方，却唯恐被人发现智障的亲属，深锁庭院。
痴呆妹妹？什么痴呆妹妹？
=====
人是不变的，试图改变别人，是白费力，有时甚至是危险的
反对:人是可以改变的，善恶是可以转变的
奢靡浪费无益，定等级规格
反对:欲望，前进的动力，应培养引导群众的上进心
不需要隐私，只是个人相关的事公众并不关心，没必要拿出来扰乱视听，但若有了解真相的需要，秘密也当消失。
  弃婴
反对:个人离奇的经历与奇葩的理念，其实只与自身紧密相关，对别人而言毫无借鉴意义
  秘密-大人小人
    你们，天神，无尽的寿元，也有烦恼吗？
    小罐中藏着一个小人世界，朝生夕死
=====
惧
  害怕曾经休戚与共的族群相互仇视
  害怕曾经诞生无数英雄的民族倒行逆施
  巨兽需要记忆
=====
种群，无关善恶
  为何多生少育？一窝五六只雏鸟，经过手足相残最终只有一只存活，少育是因为鸟群数量庞大，食物相对匮乏觅食艰难，多生是为了种群在遭到严重摧残时能快速恢复。
  一切根源于现实，盲目模仿很可笑，虔诚地认为有什么先天的善意超凡的天条也很可笑
=====
不听号令，擅自行动，巨大成功
我能怎么处理？报喜不报忧，喜欢偏听偏信的可不只君主，平民也一样。
=====
探索真理？学以致用？天马行空的想象没问题，但要是从来都不考虑实用性就是大问题。
=====
对我的态度？倒不如说是对某一类人的态度，依社会地位、性别等分类，我所知的是你的恶劣态度，但与我何干？
=====
如果法律保护不了受害者，那它又凭什么能保护施害人？
报复出轨是封建余毒，出轨反而不是，是真爱是进步是文明。
出轨不违法，私刑违法，等于拉偏架，实质鼓励出轨。可明面上又规定一夫一妻，显然是求滥交社会而不能得，只能曲线图谋，等出轨率高到一定程度就可以光明正大地说这就是人性，这就是解放，这就是文明，这就是未来。何止出轨，吸毒、艾滋病都是同样套路。现在『文明』的西方已将吸毒合法化，就看我们这些东方牲畜识不识趣，上赶着去吃它们的屎了。
众人所求不同，其实解决方案也简单，反对出轨的人做出明确的声明，以后他若出轨直接死刑，他的配偶也必须是做出同样声明的人，保守派自成一派，剩下的人爱怎样怎样。















































grep 阳
阳符/阴符 错误命名？
  view others/数学/编程/术语/我的术语.txt
  view ../txt/TODO2.txt
  view ../txt/script/上下文无关语法分析器.py
  view ../txt/script/a_parse.py
  view ../txt/others/数学/编程/TODO_list/CFG编译器.txt
  view ../txt/others/数学/编程/TODO_list/句法识别器.txt
  view ../txt/others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt
  view ../txt/others/book/Build Your Own Lisp (2014)(Daniel Holden).txt











e others/数学/编程/术语/我的术语.txt

e others/数学/『无限』假设.txt
e others/数学/编程/永恒代码/抽象是共性抽取.txt
e others/数学/编程/永恒代码/strict-lazy-形式不同-如何统一？.txt
e others/数学/编程/编译/tokenize翻译-ast对比cst-降噪.txt
view /sdcard/0my_files/git_repos/python3_src/java_external/antlr4/工具-句析器生成器ANTLR.txt
  e others/数学/编程/编译/工具-句析器生成器ANTLR.txt
e others/数学/编程/lambda/形式证明-如何在不同的整数编码间切换-命题变换-同态.txt
e others/数学/编程/lambda/空间-类型-函数的集合论解释.txt
e others/数学/编程/lambda/well-found is not countable.txt
e others/数学/编程/永恒代码/原子更新.txt
e others/数学/编程/永恒代码/可持久化数据.txt

e others/数学/编程/永恒代码/文件夹化.txt

e others/数学/编程/永恒代码/概率问题-终止、正确.txt
e others/数学/编程/永恒代码/对编译的支持问题.txt
e others/数学/编程/永恒代码/简洁即是美.txt
e others/数学/编程/ill/shell的shebang的毛病.txt
e others/数学/编程/ill/竟然.txt

# /storage/emulated/0/0my_files/git_repos/python3_src/
.e ../../python3_src/seed/iters/flatten_recur.py
.e ../../python3_src/nn_ns/CJK/CJK_data/raw/125成字部件_44部首.txt
.e others/数学/编程/兼容.txt
.e others/数学/编程/变址寻址.txt
e others/数学/编程/并行并发/并行并发区别.txt
e others/数学/编程/并行并发/并发编程-内存模型-内存次序.txt
e others/数学/编程/并行并发/无锁并发编程.txt
e others/数学/编程/并行并发/CAS无锁实现原理.txt

.e others/杂/中庸名句.txt
.e others/杂/中庸（汉语词语）.txt
.e others/杂/易-可久可大.txt
.e others/杂/房vs屋.txt
.e others/杂/x86-amd-arm.txt
===
e others/杂/词语解释.txt
e others/app/网/哔哩哔哩.txt
e others/app/网/B站评论.txt
e others/我的叶子/魔门明心宗.txt
!e others/我的叶子/科学教.txt
!e others/数学/编程/永恒代码/向前兼容的数据格式.txt
.e others/数学/编程/tree/RMQ、树状数组、线段树.txt
.e others/数学/编程/applicative-data-structure.txt
.e others/数学/编程/applicative-vs-functional.txt
e others/数学/编程/functional/functional language without GC.txt

e others/数学/编程/tex/www.latexlive.com[help].html
  wget -k -r -l1 https://www.latexlive.com/help
  file:///storage/emulated/0/0my_files/git_repos/txt_phone/txt/others/%E6%95%B0%E5%AD%A6/%E7%BC%96%E7%A8%8B/tex/www.latexlive.com/help

e others/app/termux/py_pip/manim.txt
e others/app/termux/无法安装/scipy-manim.txt
e others/app/termux/无法安装/无法安装汇总.txt

to read:
  TODO
  Inductive Data Type Systems
  Mastering Linux Shell Scripting
    e others/book/Mastering Linux Shell Scripting.txt

  佛学问答集 #downloaded
  latexlive-help.html #downloaded
  ###
  Beyond_feelings_A_guide_to_critical_thinking.pdf
  Computer_Systems(2nd).pdf
  =====
  #e others/book/compile.txt
  Build Your Own Lisp (2014)(Daniel Holden).pdf
    e others/book/Build Your Own Lisp (2014)(Daniel Holden).txt
  Compilers and Compiler Generators: an Introduction with C++
  Let's Build a Compiler
  Writing Compilers and Interpreters (3ed)(2009)
  Modern Compiler Implementation in Java (2ed)(2002)
  Modern Compiler Implementation in C (rev+ex)(2004).djvu
  Compiler Construction (Niklaus Wirth)(2017rev1996)
  The Definitive ANTLR 4 Reference.pdf
    2012
    109/322
e others/book/read.txt
  finger trees: a simple general-purpose data structure
  Sketchy LISP -- An Introduction to Functional Programming in Scheme (3ed)(2008)(Nils M Holm).pdf
    e ../lots/NOTE/Lisp/Sketchy LISP.txt


DONE:
  .e others/数学/编程/tree/2_3_4_tree.txt
TODO:
  TODO
  e others/数学/编程/TODO_list/
  ?e others/数学/编程/tree/finger_tree.txt
      e script/a_parse.py
  !e others/数学/编程/TODO_list/py_mk_sh.txt
    TODO: py_mk_sh

  e others/数学/编程/永恒代码/字符串内部转义.txt
  e others/数学/编程/永恒代码/语法解析结果标记语言.txt
  e others/数学/编程/永恒代码/可运行于任何平台的语言.txt
  e others/数学/编程/永恒代码/通用汇编语言.txt
  e others/数学/编程/编程任务无用技巧书目.txt
  e others/数学/编程/TODO_list/句法识别器.txt





TODO: www
TODO:
  finger_tree
  insert/remove O(log n)??
  finger tree
  2-3-4 tree
TODO:





xslt
XSLT
XSLT (Extensible Stylesheet Language Transformations) is a language for transforming XML documents into other XML documents, or other formats such as HTML for web pages, plain text or XSL Formatting Objects, which may subsequently be converted to other formats, such as PDF, PostScript and PNG. XSLT 1.0 is widely supported in modern web browsers.























当永生成为可能，一切资源都将匮乏，因为人口是无限的。资源如何分配将成为大问题。现在人们还在报怨这报怨那，殊不知对于永生纪元的新生代而言，这是最后的可轻易翻身的黄金时代，此后每一分收获必将付出当下的百倍努力，而且情况只会越来越严重。
升级打怪
  整容-出台-螺旋上升-莫欺少女丑

反抗人类暴政
  你是一只饿死在废弃水族馆池子里的海豚，你重生了，这一次你将如何对待人类？


https://b-ok.global/
https://b-ok.lat/
https://www.latexlive.com/
https://www.latexlive.com/help
=======
TODO www wwwww
多吉搜索DogeDoge网址www.dogedoge.com
新闻 https://m.chinanews.com/
手游 https://www.taptap.com/
小说推荐

编译 右边界 其实只有一种，即：读取禁止界限
  勤性/惰性 循环 - 其实并无本质区别
    x* = ?=y x x*
    x* = ?!y
  如果 读取禁止界限 与 匹配许可上限 不一致，当下面的句子匹配x*就会失败/出现矛盾:
    x x $ y $$
      $ - 匹配许可上限
      $$ - 读取禁止界限
    这种失败是确实需要的吗？





1、EDX 链接：edx.org
2、学堂在线 链接：next.xuetangx.com
3、迅捷PDF转换器 链接：app.xunjiepdf.com
4、coursera 链接：coursera.org
5、稿定设计 链接：s.dancf.com/4d5B
6、游达学城 链接：cn.udacity.com
7、慕课网 链接：imooc.com

C++国产小项目-自学向
1.https://github.com/qinguoyi/TinyWebServer
2.https://gitee.com/huiwei13/Ncnn_FaceTrack
3.https://gitee.com/liuxinouc/plunder_the_xuanyuan_sword
4.https://github.com/miloyip/json-tutorial
5.https://gitee.com/Barryda/QtScrcpy



#c语言技术网

#中国长安网
BV18K4y1f727
  澳剧《乌托邦Utopia》片段
  保护中澳航线不受中国威胁

#冷科普
BV1AA41147FL
层流
BV11K4y1j7sP
沙:沙漠沙细且咸，河沙宜建筑已濒危，海沙淡化去氯，机制沙上线
BV1Hf4y1q7e1
都江堰:分水分沙
BV1Za4y1L7DN
混沌摆:多摆级，初值敏感


BV1t7411R7mS
AI象棋-弃子攻杀

BV1sA411j7Nb
兰芳共和国

BV1qi4y1V79u
包商银行破产

#太阳星sunstar
  BV11y4y1r7iY
  军事骗局


BV1CZ4y157Yv
东汉开国:昆阳大战#叶散Era

BV1rA411x7m9
乌合麒麟画作:致莫里森-你要的道歉#国防时报TV


BV1bA411x7J5
毛洪涛事件#舆情探长


表情丰富的up:
  #太阳星sunstar
  #波士顿圆脸



垃圾回收是否『回收用时 与负载成反比 与垃圾成正比』


  识别器
  NFA - 简单版 复杂版
  www.eudic.net 安卓版 完整词典 -> 手机 eudb_en
  DONE:mpc
  ===
  token/tokenizie 翻译





  ordinal
    n.序数；比较；
    adj.序数的
  Brouwer ordinal
    !=Bachmann–Howard ordinal
  which f?
    About Brouwer’s ordinals, note that only a suitable choice of f's provides a semantically correct ordinal notation and that, for such a correct notation, the above formal definition provides semantically correct ordinal addition.



=


  词典
    #本地+技术性+可复制
    变址
    标引
    index register
    index assess method


  echo input avoid -n
    echo does not interpret -- to mean the end of options.
      from "man bash"
  desktop book
    database
    system
    lisp
    xslt
  ===
  gedit app

  py async example
  #bug:㘅u3605h<=5:@@2513323411243112 vs 銜u929Ch<=5:@@33234112431112
  #bug:㘒u3612h<=5:@@3123431251112125135 /3123431251121125135 vs 種u7A2Eh<=5:@@31234312511211
  #bug:歰u6B70h<=5:@@53453421212121 vs 㒊u348Ah<=5:@@3253421215342121
  #bug?㔡u3521h<=5:@@325341153553 #1535?1515

  ##???gb bug???
  ##25144511221342511134㘔u3614h
  ##25144511221342534左口右赛#无此字
  ##251445112212511134貝版㗷#无此字
  ##251445112212534㗷u35F7h#疑为错别字

  py parse hs
  金岷氏 金岷彬
  汉字拓扑学
  矢量图 app 字体 app
  vim 字体大小
  具体笔顺？

  笔画名称 汉字字型
  汉字 unicode 私用区 是什么
  明朝花园 开心宋体
  《信息處理用 GB13000.1 字符集漢字部件規範》
  GF 3001―1997《信息处理用GB13000.1字符集汉字部件规范》
  汉字基础部件表 胡敬禹  2004年1月8日

  split pdf
    config EBookDroid
  DONE vim output window
    :read !cmd
    :redir END tells Vim to end redirecting messages. See :h :redir
  grep with encoding
    ???




=======
py shell
  iter chain cmd
  e ../../python3_src/nn_ns/io/py_io_shell.py
DONE mapping set lazy
DONE text io: path e f(fin) g(r)
DONE iter lines rstrip? filter head rex? eaters?









================有道理！
https://www.zhihu.com/question/39279003
现代汉语可怕的地方就是在于，双音节名词无论你怎么严肃，看起来都很难像一个术语，它会被试图解构，怎么看都像是一个临时组建出来的词组，而不会被和一个意义固定地联系起来。
================





初步答疑 网站创意:
  问：自然语言 描述 具体问题
  答：
    相关领域 # ==>> 专业网站
    相关术语 # ==>> 相关书籍/论文
    抽象问题，泛化问题


=========TODO
关于无限的理论，需要先假设存在一个无限大的集合
环境感知
  where I am:
    在哪个模块/类/对象/函数/switch-case分支？
      switch-case分支 的 键 与 主变量 相等，但 对象可能不同
      对象绑定:
        静态编译switch-case
          随函数定义一次绑定switch-case
        函数内临时动态绑定switch-case

打洞与宏:数据，数据类型声明，语句，语句块
人工智能
  要点在于 矛盾
  记住又记不住 遗忘
  某些方面精明某些方面迂腐 性格
  稳定又不稳定 情绪

止戈为武，彳亍成行
闲野道人
史珍香
六经注我


互逆
  人我见-一人为众念之国
  巨兽-同类众生为一巨兽
?以水入水，以言遣言

联姻
  争斗而已，何须忧伤？血脉渴求扩散长存，权财渴求吞并壮大，一切顺利。

愚而好自用，贱而好自专。生乎今之世，反古之道。如此者灾及其身者也。《中庸·第二十八章》
  说的就是我
道不远人。人之为道而远人，不可以为道。《中庸·第十三章》
  道在屎溺之中

困难的解决，产生快乐
  有用的工具
    应用
      vim
      python
        manim
        sympy
    语言
      lambda #formal proof, Haskell
      xml # vs latex



学诡辩，不是为了辩，而是为了不辩。
  佛法无边，皆因佛法是个球。

罪罚相当，就等于鼓励犯罪。利益共享:个人-积累，集体-保险，外国-买空。只要社会全体因犯罪而致的损失，无法从罪犯身上实际上找回(不能仅止于名义上的严惩，形成呆账坏账)，犯罪团伙的共同体就能得到养分不断壮大。
智愚/善恶/好恶悲欢/夭寿
  智无的，智不能立志，智不能改志，智能立能改者术而已。
  善恶，利分之。利，在于我，在于终。我，有小大之别，有分合不定之惑，人我古今其利相背；终，有短长之别，有终始不绝之惑，祸福表里互为因果。
    名善恶，则善者得名，得名则得利。利必使人，人施恶行以逐名，披善名以行恶获利。方知此善此将不善矣，方善方恶，善耶？行善藏名，知恶扬名。
  雷霆雨露俱是天恩，患得患失故生悲欢。甘苦，味之二，好恶，心之偏。
  夭者憾，寿者困。


轮回不灭，岂不有寿者相？修行必有所求，岂不有寿者相？







源究
本 自 由
溯本慎终
地横武定:安内伐外，人纵文和:由来慎终，天深仙齐:洞幽同异

现实测量的数据 精度有限
  显微镜的观测尺寸虽小，但对于提高百米赛道的精度毫无帮助。
  高精度运算无用

智力究竟是用来解答自己行为的目的及动机，还是用来给自己找借口？
  动机:深层原因
  目的:智力由动机及目下情形得出的行动方向
  借口:强行得出结论:所用手段的无害性或不得已的合理性
智力
  总结经验教训，假设并推广
    什么东西可吃？
      可吃范围推广
      禁食范围推广
  迷之自信
    赞美神，神会保佑我
      求人，人必须答应
      天生我，必有用
    实验结果与时间地点无关
      此时此地的实验结果必与过去将来无限远处的实验结果相同
  什么是合理？什么是不合理？智力其局限
  =====
  天地不仁
  社会纲常不会是理所当然，它需要所有人共同维护
  手段:
    为达到目的，所择手段的:可用，有效
      禁止范围:社会主流的智力及其价值观认为对社会有害的手段(当下稳定优先？发展潜力优先？纲常伦理优先？)
      合理范围:智力认为有效的手段




======
DONE

.e others/杂/玄学/二我见.txt
  二我见 人我见 法我见
.e others/杂/玄学/性命.txt
.e others/杂/玄学/十六知见.txt
.e others/杂/玄学/末那识.txt
e others/杂/玄学/五蕴.txt
  to read
e others/杂/玄学/人我四相.txt
  人我四相 我人四相 我相 人相 众生相 寿者相
  to read
e others/杂/玄学/八识.txt
e others/杂/玄学/因缘.txt
e others/杂/玄学/佛说即非是名.txt
e others/杂/玄学/涅盘四德-常乐我净.txt
e others/杂/玄学/五戒十善.txt
e others/杂/玄学/什么是佛法.txt
e others/杂/玄学/佛之三身-法报化.txt
e others/杂/玄学/儒家-仁义礼智信.txt
e others/杂/玄学/天干地支-由来.txt
e others/杂/玄学/方位-坐向.txt
e others/杂/玄学/.txt
==================================

==================================[ZZZ
==================================]ZZZ


地藏孝亲网
  佛学问答集1-4
    https://www.dizang.org/wd/fx/index.htm
    https://www.dizang.org/wd/fx/index2.htm
    https://www.dizang.org/wd/fx2/index.htm
    https://www.dizang.org/wd/fx3/index.htm
  file:///storage/emulated/0/0my_files/tmp/wget_/dizang/www.dizang.org/wd/fx/index.htm

  佛教入门
    https://www.dizang.org/qt/zh/index.htm
  file:///storage/emulated/0/0my_files/tmp/wget_/dizang/www.dizang.org/qt/zh/index.htm
    to read
======








=========
view ++enc=gb18030 /sdcard/0my_files/novel/《士子风流》（校对版全本）作者：上山打老虎额.txt
e ../lots/NOTE/novel/士子风流_note.txt
view /sdcard/0my_files/novel/《貌似高手在异界》（校对版全本）作者：高楼大厦.txt
e ../lots/NOTE/novel/貌似高手在异界_note.txt
view ++enc=gb18030 /sdcard/0my_files/novel/《太浩》（校对版全本）作者：无极书虫.txt
e ../lots/NOTE/novel/太浩_note.txt
view ++enc=gb18030 /sdcard/0my_files/novel/《百变销魂》（校对版全本）作者：二十四桥明月夜.txt
e ../lots/NOTE/novel/百变销魂_note.txt


=========
标准表格处理 函数
  book: Python for Data Analysis
  standard tabulate processing
vim -font ???
  大字体



汉字分解 相关文件
  js.load
  parse_CHISE_IDS.py
  after_parse_CHISE_IDS.py
  py -m nn_ns.CJK.cjk_subsets.hanzi
  cd /sdcard/0my_files/unzip/e_book/汉字分解/chise-ids-ea97c5d\[20200812\]/ids-ea97c5d/
  less ~/tmp/ids_all_2.txt
  less ~/tmp/ids_all_2_err.txt
  less  ~/tmp/after_ids_pp_2.txt
  cd /sdcard/0my_files/unzip/e_book/汉字分解/现代常用字部件及部件名称规范
  py script/py_repr2json.py -i ~/tmp/ids_all_2.txt -o ~/tmp/ids_all_2.json.txt -f
  less ~/tmp/ids_all_2.json.txt


IDS 分解
三级简体字
download 中华字经4000字
download 汉字 笔画 分解
	部件 笔画 分解
		部件粗区分（公开）= 部件笔画分解
		私用部件内部标识 = 部件粗区分 + 私用部件粗区分内部序号
	汉字 部件 分解
		汉字粗区分（公开）= 汉字部件粗区分分解
		私用汉字内部标识 = 汉字粗区分 + 私用汉字粗区分内部序号

=====DONE
DONE 125成字部件_44部首.txt
e /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/CJK/CJK_data/raw/汉语注音符号.html[baike.baidu].data.txt
  注音符号 来源 与全拼音对照
view /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/CJK/CJK_data/raw/unicode_CJK_Bopomofo_Zhuyin_Fuhao_U3100.pdf.txt
=====

DONE view others/数学/编程/python/Python_async_await_Tutorial.txt
  recur inf ==>> max depth
  async ??
  e /storage/emulated/0/0my_files/git_repos/python3_src/script/try_python/try_std_libs/try_async/async_vs_recur.py
  e /storage/emulated/0/0my_files/git_repos/python3_src/seed/iters/flatten_recur.py
=====



termux update for spec keys? fail require sndroid 7.0
termux openssl doc

git mv txt/*.txt /txt/xxx/
git py txt
update music/book/novel/font list


pure py site package
	image??
		remove pydroid???
grep with encoding




finite field DLP
shortest vector problem (SVP)
learning with errors (LWE) problem
ECC ？？成立条件?? order?? small subgroup??


李村战
地图 邮政 富士康公交




只增文档.txt
提取 TODO.txt 中有意义的东西
编程任务.txt



tuple翻译:元组
is_prime ~ O(n^6)
	[2^(x/2) - x^6 > 0] ==>> [ceil x >= 75]
	useful at least 75^6 > 74^6 > 2^(74/2) == 2^37


虚函数 递归约束 成员与基类
省电助手



3264=?=2100+150+(26*3+2)*13=3290
221=16*x+5*13-2*7
170=16*x=2*d
d=85=2100/27
x=9.75
2100/30=70
2100/26=80.76923076923077
2100/78=26.923076923076923
2100/27=77.77777777777777
2100/85=24.705882352941178
2100/25=84.0

8m
26*d+(26*3+2)*13-(26+1)*7=3061
9m
18*d+(18*1+4*2)*13-18*7=1742
3061+1742=4803
+30=4833

10-20,16:00 保安室领9月

1792



