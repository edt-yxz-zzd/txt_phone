is_group(G) and <size(G)=7> 在群的公理系统中不可判定，any G
演算规则
    通常的逻辑演算规则加上下面几条。
    良构串真理性与可证明性等价，任何良构串可判定，即完全性。（定义即是一切，不可证明的性质是谎言，当然非良构串除外。要么谈的不是同一个定义，包括'定义'这个词本身）any G, 'well_form(G) && ~provable(G)'|-> 'ill_form(~G) or provable(~G)'
    本公理系统有且只有一个分类（参见下面对象空间中的分类说法，于是结果是0或1，我相信是1），即一致性。'any G, well_form(G) && provable(G) |-> 1=size(classify(this_system))'（this_system是个谓词）
    映射自由定义公理：可以自由地对新映射进行定义，只要'&&(any a,in_domain_of(a,F)) exist b F(a)=b' = M一致，那么any 。即局域性。
    子系统良构串定义。any F, any f, pred(F) && get_form(f,F) |-> pred(f) && 'any G, F(G) |-> f(G)'
    哥德尔句是说，在与本系统同构的子系统中的某个句子（刚好对应于本句）不可在有限步内证明。
    可证明性涉及有限性，有限性依赖于自然数，如果哥德尔的攻击出现，那也只说明自然数的精确概念无法在形式系统中表现。
命题空间由良构串组成。
    谓词的生成空间，是指将自由变量用any量化后的闭公式的可证明命题的集合。
    演算规则的生成空间称为真理集。
    一个谓词代表了一个公理系统，即{any a 'F(a)|->P'}与真理集的交集
对象空间由原子组成（原子是未定义的），
    谓词是过滤器（比如is_group；过滤是指any a any b 'F1(a) && F2(a) && F3((a,b)|->P')），
    筛选出一个原子集合（原子可以是(N,+)，S_3），
    而根据谓词可以构造一个该原子集合的划分（群的同构），
    这个划分代表了对谓词所表达的数学对象的分类（群的分类）。


某一数学对象的分类数量：
    0，对象不存在 等价于 谓词不一致， 'any P F(x) |-> P' 为真
    1，精确定义
    





试着在TNT命题前加上'any N'怎么样？


信仰决定一切
=>人不可能做得比形式系统更好
==>如果看到更多真理，那必是用了更多假设。
=>一致性是必然的，无法产生不一致性。
=>所有良构串真理，必可推出。所有假理不可推出。
==>类TNT系统是完全的，一致的
=>802
类TNT系统
++定义了超良构串（这里就用TNT的良构串定义吧）
++给出一个谓词F(x)，使得any x, F(x)是个超良构串
++针对F，定义了一个数学对象C：
++++B={A in ?|F(A)}
++++根据F构造同构判定T(x,y)，依此划分B。
++++（T类似于当F中出现any/exist时，x,y在此处所指的集合存在同构）
++++BB={ {x in B|T(x,A)} | A in B}
++++C={choose_one(x)| x in BB}
++定义了良构串：
++++如果G是一个超良构串，
++++那么对于G中任何自由变量x，我们在G前面冠上'any x'，
++++在G中的任何量词'any x'或'exist x'的后面加上'in D'
++++最后，冠上'any D in C'
++++注意，'exist D'、'~any D'、'~exist D'非良构。
++唯一的公理是 any D in C, F(D)
++++G ---- any D, G
++++~G ---- any D, ~G // 不是~any D, G或exist D, ~G
++++所以弯号不代表非！
++++TNT系统设计时犯了一个错，以为|C| = 1，'any D'、'exist D'一样，可有可无。
++++德摩根规则不适用：~x and ~y  不等价但蕴含 ~(x and y) 
++++思维陀螺规则不适用：x or y 不等价但蕴含 ~x -> y


