
e ../lots/NOTE/Haskell/API-freq.txt
view ../lots/NOTE/Haskell/API-modules.txt

ls /data/data/com.termux/files/usr/lib/ghc-9.2.5/
find /data/data/com.termux/files/usr/lib/ghc-9.2.5/ -iname '*Solo*'
grep Solo -r /data/data/com.termux/files/usr/lib/ghc-9.2.5/ -l
  ##Solo 似乎是 GHC.Base 定义的 私用类型




ghci>
  import <mod>
  :info <typ>
  :browse <mod>
    # tab - to show all complete names/possibilities, even unimported modules

GHCi, version 9.2.5: https://www.haskell.org/ghc/  :? for help

[[
Functor
Foldable
Traversable
Applicative
Monad
Monoid
Semigroup
===
ghci
===
ghci> :info Bool
type Bool :: *
data Bool = False | True
        -- Defined in ‘GHC.Types’
instance Eq Bool -- Defined in ‘GHC.Classes’
instance Ord Bool -- Defined in ‘GHC.Classes’
instance Enum Bool -- Defined in ‘GHC.Enum’
instance Show Bool -- Defined in ‘GHC.Show’
instance Read Bool -- Defined in ‘GHC.Read’
instance Bounded Bool -- Defined in ‘GHC.Enum’
===
ghci> :info Functor
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
        -- Defined in ‘GHC.Base’
instance Functor (Either a) -- Defined in ‘Data.Either’
instance Functor [] -- Defined in ‘GHC.Base’
instance Functor Solo -- Defined in ‘GHC.Base’
instance Functor Maybe -- Defined in ‘GHC.Base’
instance Functor IO -- Defined in ‘GHC.Base’
instance Functor ((->) r) -- Defined in ‘GHC.Base’
instance Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance Functor ((,) a) -- Defined in ‘GHC.Base’
===
ghci> :info Foldable
type Foldable :: (* -> *) -> Constraint
class Foldable t where
  Data.Foldable.fold :: Monoid m => t m -> m
  foldMap :: Monoid m => (a -> m) -> t a -> m
  Data.Foldable.foldMap' :: Monoid m => (a -> m) -> t a -> m
  foldr :: (a -> b -> b) -> b -> t a -> b
  Data.Foldable.foldr' :: (a -> b -> b) -> b -> t a -> b
  foldl :: (b -> a -> b) -> b -> t a -> b
  Data.Foldable.foldl' :: (b -> a -> b) -> b -> t a -> b
  foldr1 :: (a -> a -> a) -> t a -> a
  foldl1 :: (a -> a -> a) -> t a -> a
  Data.Foldable.toList :: t a -> [a]
  null :: t a -> Bool
  length :: t a -> Int
  elem :: Eq a => a -> t a -> Bool
  maximum :: Ord a => t a -> a
  minimum :: Ord a => t a -> a
  sum :: Num a => t a -> a
  product :: Num a => t a -> a
  {-# MINIMAL foldMap | foldr #-}
        -- Defined in ‘Data.Foldable’
instance Foldable [] -- Defined in ‘Data.Foldable’
instance Foldable Solo -- Defined in ‘Data.Foldable’
instance Foldable Maybe -- Defined in ‘Data.Foldable’
instance Foldable (Either a) -- Defined in ‘Data.Foldable’
instance Foldable ((,) a) -- Defined in ‘Data.Foldable’
===
ghci> :info Traversable
type Traversable :: (* -> *) -> Constraint
class (Functor t, Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  sequenceA :: Applicative f => t (f a) -> f (t a)
  mapM :: Monad m => (a -> m b) -> t a -> m (t b)
  sequence :: Monad m => t (m a) -> m (t a)
  {-# MINIMAL traverse | sequenceA #-}
        -- Defined in ‘Data.Traversable’
instance Traversable [] -- Defined in ‘Data.Traversable’
instance Traversable Solo -- Defined in ‘Data.Traversable’
instance Traversable Maybe -- Defined in ‘Data.Traversable’
instance Traversable (Either a) -- Defined in ‘Data.Traversable’
instance Traversable ((,) a) -- Defined in ‘Data.Traversable’
===
ghci> :info Monoid
type Monoid :: * -> Constraint
class Semigroup a => Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
  {-# MINIMAL mempty #-}
        -- Defined in ‘GHC.Base’
instance Monoid [a] -- Defined in ‘GHC.Base’
instance Monoid a => Monoid (Solo a) -- Defined in ‘GHC.Base’
instance Monoid Ordering -- Defined in ‘GHC.Base’
instance Semigroup a => Monoid (Maybe a) -- Defined in ‘GHC.Base’
instance Monoid a => Monoid (IO a) -- Defined in ‘GHC.Base’
instance Monoid b => Monoid (a -> b) -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c, Monoid d, Monoid e) =>
         Monoid (a, b, c, d, e)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c, Monoid d) =>
         Monoid (a, b, c, d)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c) => Monoid (a, b, c)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b) => Monoid (a, b)
  -- Defined in ‘GHC.Base’
instance Monoid () -- Defined in ‘GHC.Base’
===
ghci> :info Monad
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  {-# MINIMAL (>>=) #-}
        -- Defined in ‘GHC.Base’
instance Monad (Either e) -- Defined in ‘Data.Either’
instance Monad [] -- Defined in ‘GHC.Base’
instance Monad Solo -- Defined in ‘GHC.Base’
instance Monad Maybe -- Defined in ‘GHC.Base’
instance Monad IO -- Defined in ‘GHC.Base’
instance Monad ((->) r) -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c) => Monad ((,,,) a b c)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b) => Monad ((,,) a b)
  -- Defined in ‘GHC.Base’
instance Monoid a => Monad ((,) a) -- Defined in ‘GHC.Base’
===
ghci> :info Applicative
type Applicative :: (* -> *) -> Constraint
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  GHC.Base.liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  (*>) :: f a -> f b -> f b
  (<*) :: f a -> f b -> f a
  {-# MINIMAL pure, ((<*>) | liftA2) #-}
        -- Defined in ‘GHC.Base’
instance Applicative (Either e) -- Defined in ‘Data.Either’
instance Applicative [] -- Defined in ‘GHC.Base’
instance Applicative Solo -- Defined in ‘GHC.Base’
instance Applicative Maybe -- Defined in ‘GHC.Base’
instance Applicative IO -- Defined in ‘GHC.Base’
instance Applicative ((->) r) -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b, Monoid c) =>
         Applicative ((,,,) a b c)
  -- Defined in ‘GHC.Base’
instance (Monoid a, Monoid b) => Applicative ((,,) a b)
  -- Defined in ‘GHC.Base’
instance Monoid a => Applicative ((,) a) -- Defined in ‘GHC.Base’
===
ghci> :info Semigroup
type Semigroup :: * -> Constraint
class Semigroup a where
  (<>) :: a -> a -> a
  GHC.Base.sconcat :: GHC.Base.NonEmpty a -> a
  GHC.Base.stimes :: Integral b => b -> a -> a
  {-# MINIMAL (<>) #-}
        -- Defined in ‘GHC.Base’
instance Semigroup (Either a b) -- Defined in ‘Data.Either’
instance Semigroup [a] -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (Solo a) -- Defined in ‘GHC.Base’
instance Semigroup Ordering -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (Maybe a)
  -- Defined in ‘GHC.Base’
instance Semigroup a => Semigroup (IO a) -- Defined in ‘GHC.Base’
instance Semigroup b => Semigroup (a -> b) -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b, Semigroup c, Semigroup d,
          Semigroup e) =>
         Semigroup (a, b, c, d, e)
  -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b, Semigroup c, Semigroup d) =>
         Semigroup (a, b, c, d)
  -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b, Semigroup c) =>
         Semigroup (a, b, c)
  -- Defined in ‘GHC.Base’
instance (Semigroup a, Semigroup b) => Semigroup (a, b)
  -- Defined in ‘GHC.Base’
instance Semigroup () -- Defined in ‘GHC.Base’
===
ghci>
]]
[[
===
ghci> :browse Prelude
(!!) :: [a] -> Int -> a
($) :: (a -> b) -> a -> b
($!) :: (a -> b) -> a -> b
(&&) :: Bool -> Bool -> Bool
(++) :: [a] -> [a] -> [a]
(.) :: (b -> c) -> (a -> b) -> a -> c
(<$>) :: Functor f => (a -> b) -> f a -> f b
(=<<) :: Monad m => (a -> m b) -> m a -> m b
type Applicative :: (* -> *) -> Constraint
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
  liftA2 :: (a -> b -> c) -> f a -> f b -> f c
  (*>) :: f a -> f b -> f b
  (<*) :: f a -> f b -> f a
  {-# MINIMAL pure, ((<*>) | liftA2) #-}
type Bool :: *
data Bool = False | True
type Bounded :: * -> Constraint
class Bounded a where
  minBound :: a
  maxBound :: a
  {-# MINIMAL minBound, maxBound #-}
type Char :: *
data Char = C# Char#
type Double :: *
data Double = D# Double#
type Either :: * -> * -> *
data Either a b = Left a | Right b
type Enum :: * -> Constraint
class Enum a where
  succ :: a -> a
  pred :: a -> a
  toEnum :: Int -> a
  fromEnum :: a -> Int
  enumFrom :: a -> [a]
  enumFromThen :: a -> a -> [a]
  enumFromTo :: a -> a -> [a]
  enumFromThenTo :: a -> a -> a -> [a]
  {-# MINIMAL toEnum, fromEnum #-}
type Eq :: * -> Constraint
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  {-# MINIMAL (==) | (/=) #-}
type FilePath :: *
type FilePath = String
type Float :: *
data Float = F# Float#
type Floating :: * -> Constraint
class Fractional a => Floating a where
  pi :: a
  exp :: a -> a
  log :: a -> a
  sqrt :: a -> a
  (**) :: a -> a -> a
  logBase :: a -> a -> a
  sin :: a -> a
  cos :: a -> a
  tan :: a -> a
  asin :: a -> a
  acos :: a -> a
  atan :: a -> a
  sinh :: a -> a
  cosh :: a -> a
  tanh :: a -> a
  asinh :: a -> a
  acosh :: a -> a
  atanh :: a -> a
  GHC.Float.log1p :: a -> a
  GHC.Float.expm1 :: a -> a
  GHC.Float.log1pexp :: a -> a
  GHC.Float.log1mexp :: a -> a
  {-# MINIMAL pi, exp, log, sin, cos, asin, acos, atan, sinh, cosh,
              asinh, acosh, atanh #-}
type Foldable :: (* -> *) -> Constraint
class Foldable t where
  Data.Foldable.fold :: Monoid m => t m -> m
  foldMap :: Monoid m => (a -> m) -> t a -> m
  Data.Foldable.foldMap' :: Monoid m => (a -> m) -> t a -> m
  Prelude.foldr :: (a -> b -> b) -> b -> t a -> b
  Data.Foldable.foldr' :: (a -> b -> b) -> b -> t a -> b
  foldl :: (b -> a -> b) -> b -> t a -> b
  Data.Foldable.foldl' :: (b -> a -> b) -> b -> t a -> b
  foldr1 :: (a -> a -> a) -> t a -> a
  foldl1 :: (a -> a -> a) -> t a -> a
  Data.Foldable.toList :: t a -> [a]
  null :: t a -> Bool
  length :: t a -> Int
  elem :: Eq a => a -> t a -> Bool
  maximum :: Ord a => t a -> a
  minimum :: Ord a => t a -> a
  sum :: Num a => t a -> a
  product :: Num a => t a -> a
  {-# MINIMAL foldMap | foldr #-}
type Fractional :: * -> Constraint
class Num a => Fractional a where
  (/) :: a -> a -> a
  recip :: a -> a
  fromRational :: Rational -> a
  {-# MINIMAL fromRational, (recip | (/)) #-}
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b
  (<$) :: a -> f b -> f a
  {-# MINIMAL fmap #-}
type IO :: * -> *
newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
type IOError :: *
type IOError = GHC.IO.Exception.IOException
type Int :: *
data Int = I# Int#
type Integer :: *
data Integer
  = GHC.Num.Integer.IS Int#
  | GHC.Num.Integer.IP ByteArray#
  | GHC.Num.Integer.IN ByteArray#
type Integral :: * -> Constraint
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a
  rem :: a -> a -> a
  div :: a -> a -> a
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer
  {-# MINIMAL quotRem, toInteger #-}
type Maybe :: * -> *
data Maybe a = Nothing | Just a
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  {-# MINIMAL (>>=) #-}
type MonadFail :: (* -> *) -> Constraint
class Monad m => MonadFail m where
  fail :: String -> m a
  {-# MINIMAL fail #-}
type Monoid :: * -> Constraint
class Semigroup a => Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
  {-# MINIMAL mempty #-}
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
type Ord :: * -> Constraint
class Eq a => Ord a where
  compare :: a -> a -> Ordering
  (<) :: a -> a -> Bool
  (<=) :: a -> a -> Bool
  (>) :: a -> a -> Bool
  (>=) :: a -> a -> Bool
  max :: a -> a -> a
  min :: a -> a -> a
  {-# MINIMAL compare | (<=) #-}
type Ordering :: *
data Ordering = LT | EQ | GT
type Rational :: *
type Rational = GHC.Real.Ratio Integer
type Read :: * -> Constraint
class Read a where
  readsPrec :: Int -> ReadS a
  readList :: ReadS [a]
  GHC.Read.readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
  GHC.Read.readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec
                             [a]
  {-# MINIMAL readsPrec | readPrec #-}
type ReadS :: * -> *
type ReadS a = String -> [(a, String)]
type Real :: * -> Constraint
class (Num a, Ord a) => Real a where
  toRational :: a -> Rational
  {-# MINIMAL toRational #-}
type RealFloat :: * -> Constraint
class (RealFrac a, Floating a) => RealFloat a where
  floatRadix :: a -> Integer
  floatDigits :: a -> Int
  floatRange :: a -> (Int, Int)
  decodeFloat :: a -> (Integer, Int)
  encodeFloat :: Integer -> Int -> a
  exponent :: a -> Int
  significand :: a -> a
  scaleFloat :: Int -> a -> a
  isNaN :: a -> Bool
  isInfinite :: a -> Bool
  isDenormalized :: a -> Bool
  isNegativeZero :: a -> Bool
  isIEEE :: a -> Bool
  atan2 :: a -> a -> a
  {-# MINIMAL floatRadix, floatDigits, floatRange, decodeFloat,
              encodeFloat, isNaN, isInfinite, isDenormalized, isNegativeZero,
              isIEEE #-}
type RealFrac :: * -> Constraint
class (Real a, Fractional a) => RealFrac a where
  properFraction :: Integral b => a -> (b, a)
  truncate :: Integral b => a -> b
  round :: Integral b => a -> b
  ceiling :: Integral b => a -> b
  floor :: Integral b => a -> b
  {-# MINIMAL properFraction #-}
type Semigroup :: * -> Constraint
class Semigroup a where
  (<>) :: a -> a -> a
  sconcat :: NonEmpty a -> a
  stimes :: Integral b => b -> a -> a
  {-# MINIMAL (<>) #-}
type Show :: * -> Constraint
class Show a where
  showsPrec :: Int -> a -> ShowS
  show :: a -> String
  showList :: [a] -> ShowS
  {-# MINIMAL showsPrec | show #-}
type ShowS :: *
type ShowS = String -> String
type String :: *
type String = [Char]
type Traversable :: (* -> *) -> Constraint
class (Functor t, Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
  sequenceA :: Applicative f => t (f a) -> f (t a)
  Prelude.mapM :: Monad m => (a -> m b) -> t a -> m (t b)
  Prelude.sequence :: Monad m => t (m a) -> m (t a)
  {-# MINIMAL traverse | sequenceA #-}
type Word :: *
data Word = W# Word#
(^) :: (Num a, Integral b) => a -> b -> a
(^^) :: (Fractional a, Integral b) => a -> b -> a
all :: Foldable t => (a -> Bool) -> t a -> Bool
and :: Foldable t => t Bool -> Bool
any :: Foldable t => (a -> Bool) -> t a -> Bool
appendFile :: FilePath -> String -> IO ()
asTypeOf :: a -> a -> a
break :: (a -> Bool) -> [a] -> ([a], [a])
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
const :: a -> b -> a
curry :: ((a, b) -> c) -> a -> b -> c
cycle :: [a] -> [a]
drop :: Int -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
either :: (a -> c) -> (b -> c) -> Either a b -> c
error :: GHC.Stack.Types.HasCallStack => [Char] -> a
errorWithoutStackTrace :: [Char] -> a
even :: Integral a => a -> Bool
filter :: (a -> Bool) -> [a] -> [a]
flip :: (a -> b -> c) -> b -> a -> c
fromIntegral :: (Integral a, Num b) => a -> b
fst :: (a, b) -> a
gcd :: Integral a => a -> a -> a
getChar :: IO Char
getContents :: IO String
getLine :: IO String
head :: [a] -> a
id :: a -> a
init :: [a] -> [a]
interact :: (String -> String) -> IO ()
ioError :: IOError -> IO a
iterate :: (a -> a) -> a -> [a]
last :: [a] -> a
lcm :: Integral a => a -> a -> a
lex :: ReadS String
lines :: String -> [String]
lookup :: Eq a => a -> [(a, b)] -> Maybe b
map :: (a -> b) -> [a] -> [b]
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
maybe :: b -> (a -> b) -> Maybe a -> b
not :: Bool -> Bool
notElem :: (Foldable t, Eq a) => a -> t a -> Bool
odd :: Integral a => a -> Bool
or :: Foldable t => t Bool -> Bool
otherwise :: Bool
print :: Show a => a -> IO ()
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
read :: Read a => String -> a
readFile :: FilePath -> IO String
readIO :: Read a => String -> IO a
readLn :: Read a => IO a
readParen :: Bool -> ReadS a -> ReadS a
reads :: Read a => ReadS a
realToFrac :: (Real a, Fractional b) => a -> b
repeat :: a -> [a]
replicate :: Int -> a -> [a]
reverse :: [a] -> [a]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
seq :: a -> b -> b
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
showChar :: Char -> ShowS
showParen :: Bool -> ShowS -> ShowS
showString :: String -> ShowS
shows :: Show a => a -> ShowS
snd :: (a, b) -> b
span :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])
subtract :: Num a => a -> a -> a
tail :: [a] -> [a]
take :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
uncurry :: (a -> b -> c) -> (a, b) -> c
undefined :: GHC.Stack.Types.HasCallStack => a
unlines :: [String] -> String
until :: (a -> Bool) -> (a -> a) -> a -> a
unwords :: [String] -> String
unzip :: [(a, b)] -> ([a], [b])
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
userError :: String -> IOError
words :: String -> [String]
writeFile :: FilePath -> String -> IO ()
zip :: [a] -> [b] -> [(a, b)]
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
(||) :: Bool -> Bool -> Bool
ghci>
===
]]
[[
===
ghci> :browse GHC.Types
type GHC.Types.Any :: forall k. k
type family GHC.Types.Any where
type Bool :: *
data Bool = False | True
type Char :: *
data Char = GHC.Types.C# GHC.Prim.Char#
type role Coercible representational representational
type Coercible :: forall k. k -> k -> Constraint
class Coercible a b => Coercible a b
type Constraint :: *
data Constraint
type Double :: *
data Double = GHC.Types.D# GHC.Prim.Double#
type Float :: *
data Float = GHC.Types.F# GHC.Prim.Float#
type IO :: * -> *
newtype IO a
  = GHC.Types.IO (GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
type Int :: *
data Int = GHC.Types.I# GHC.Prim.Int#
type GHC.Types.KindBndr :: *
type GHC.Types.KindBndr = Int
type GHC.Types.KindRep :: *
data GHC.Types.KindRep
  = GHC.Types.KindRepTyConApp GHC.Types.TyCon [GHC.Types.KindRep]
  | GHC.Types.KindRepVar {-# UNPACK #-}GHC.Types.KindBndr
  | GHC.Types.KindRepApp GHC.Types.KindRep GHC.Types.KindRep
  | GHC.Types.KindRepFun GHC.Types.KindRep GHC.Types.KindRep
  | GHC.Types.KindRepTYPE !GHC.Types.RuntimeRep
  | GHC.Types.KindRepTypeLitS GHC.Types.TypeLitSort GHC.Prim.Addr#
  | GHC.Types.KindRepTypeLitD GHC.Types.TypeLitSort [Char]
type GHC.Types.Levity :: *
data GHC.Types.Levity = GHC.Types.Lifted | GHC.Types.Unlifted
type GHC.Types.LiftedRep :: GHC.Types.RuntimeRep
type GHC.Types.LiftedRep =
  'GHC.Types.BoxedRep 'GHC.Types.Lifted :: GHC.Types.RuntimeRep
type GHC.Types.Module :: *
data GHC.Types.Module
  = GHC.Types.Module GHC.Types.TrName GHC.Types.TrName
type GHC.Types.MultMul :: GHC.Types.Multiplicity
                          -> GHC.Types.Multiplicity -> GHC.Types.Multiplicity
type family GHC.Types.MultMul a b where
    GHC.Types.MultMul 'One x = x
    GHC.Types.MultMul x 'One = x
    GHC.Types.MultMul 'Many x = 'Many
    GHC.Types.MultMul x 'Many = 'Many
type GHC.Types.Multiplicity :: *
data GHC.Types.Multiplicity = GHC.Types.One | GHC.Types.Many
type Ordering :: *
data Ordering = LT | EQ | GT
type GHC.Types.RuntimeRep :: *
data GHC.Types.RuntimeRep
  = GHC.Types.VecRep GHC.Types.VecCount GHC.Types.VecElem
  | GHC.Types.TupleRep [GHC.Types.RuntimeRep]
  | GHC.Types.SumRep [GHC.Types.RuntimeRep]
  | GHC.Types.BoxedRep GHC.Types.Levity
  | GHC.Types.IntRep
  | GHC.Types.Int8Rep
  | GHC.Types.Int16Rep
  | GHC.Types.Int32Rep
  | GHC.Types.Int64Rep
  | GHC.Types.WordRep
  | GHC.Types.Word8Rep
  | GHC.Types.Word16Rep
  | GHC.Types.Word32Rep
  | GHC.Types.Word64Rep
  | GHC.Types.AddrRep
  | GHC.Types.FloatRep
  | GHC.Types.DoubleRep
type GHC.Types.SPEC :: *
data GHC.Types.SPEC = GHC.Types.SPEC | GHC.Types.SPEC2
type GHC.Types.Symbol :: *
data GHC.Types.Symbol
type GHC.Types.TrName :: *
data GHC.Types.TrName
  = GHC.Types.TrNameS GHC.Prim.Addr# | GHC.Types.TrNameD [Char]
type GHC.Types.TyCon :: *
data GHC.Types.TyCon
  = GHC.Types.TyCon GHC.Prim.Word#
                    GHC.Prim.Word#
                    GHC.Types.Module
                    GHC.Types.TrName
                    GHC.Prim.Int#
                    GHC.Types.KindRep
type GHC.Types.Type :: *
type GHC.Types.Type = TYPE GHC.Types.LiftedRep
type GHC.Types.TypeLitSort :: *
data GHC.Types.TypeLitSort
  = GHC.Types.TypeLitSymbol
  | GHC.Types.TypeLitNat
  | GHC.Types.TypeLitChar
type GHC.Types.UnliftedRep :: GHC.Types.RuntimeRep
type GHC.Types.UnliftedRep =
  'GHC.Types.BoxedRep 'GHC.Types.Unlifted :: GHC.Types.RuntimeRep
type GHC.Types.UnliftedType :: *
type GHC.Types.UnliftedType = TYPE GHC.Types.UnliftedRep
type GHC.Types.VecCount :: *
data GHC.Types.VecCount
  = GHC.Types.Vec2
  | GHC.Types.Vec4
  | GHC.Types.Vec8
  | GHC.Types.Vec16
  | GHC.Types.Vec32
  | GHC.Types.Vec64
type GHC.Types.VecElem :: *
data GHC.Types.VecElem
  = GHC.Types.Int8ElemRep
  | GHC.Types.Int16ElemRep
  | GHC.Types.Int32ElemRep
  | GHC.Types.Int64ElemRep
  | GHC.Types.Word8ElemRep
  | GHC.Types.Word16ElemRep
  | GHC.Types.Word32ElemRep
  | GHC.Types.Word64ElemRep
  | GHC.Types.FloatElemRep
  | GHC.Types.DoubleElemRep
type GHC.Types.Void# :: TYPE ('GHC.Types.TupleRep '[])
type GHC.Types.Void# = (# #) :: TYPE ('GHC.Types.TupleRep '[])
type Word :: *
data Word = GHC.Types.W# GHC.Prim.Word#
GHC.Types.isTrue# :: GHC.Prim.Int# -> Bool
type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
class (a ~~ b) => (~~) a b
type role TYPE nominal
type TYPE :: GHC.Types.RuntimeRep -> *
data TYPE a
ghci>
===
]]
[[
===

===
]]
[[
===

===
]]
[[
===

===
]]
[[
===

===
]]
[[
===

===
]]
[[
===

===
]]
[[
===

===
]]

