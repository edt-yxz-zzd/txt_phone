CHAPTER 8 Versioning

8.1.1 Version Number Significance
    standard MAJOR.MINOR.PATCH numbering scheme
        Linux kernel currently uses an even/odd numbering scheme to differentiate between stable releases (even) and development releases (odd). 
            Linux 2.4 and 2.6 are stable releases,
            whereas 2.3 and 2.5 are development releases.
    1. Major version.
        start from 1
        signal to your users to expect significant API changes.
            the backward compatible addition of substantial new features 
            or backward compatibility has been broken.
    2. Minor version.
        start from 0
        whenever smaller features or significant bug fixes have been added.
        Users should expect to be able to upgrade to a new minor release without making any changes to their own software. 
        However, some new features may be added to the API, which, if used, would mean that users could not revert to an earlier minor version without changing their code.
    3. Patch version. (optional)
        start from 0
        whenever important bug or security fixes are released.
            patch version changes should be backward and forward compatible.
    
    Software is often provided to users before the final release in order to get feedback and valuable field testing. 
        In these cases, it is common to add a symbol to the version string to indicate the phase of the development process that the software relates to. 
        1.0.0a might refer to an alpha release, 
        1.0.0b might refer to a beta release, 
        1.0.0rc might refer to a release candidate. 
    However, you should note that once you start deviating from a purely numeric identification system, doing comparisons of version numbers starts to become more complicated 
    (see Python PEP 0386 at http://www.python.org/dev/peps/pep-0386/for an example of this complexity).

TIP
    It is good practice to include your API¡¯s major version number in your library names, particularly if you have made non-backward compatible changes, for example,libFoo.so, libFoo2.so, and libFoo3.so.



TIP
    Provide version information for your API.

    // version .h
    #include<string>
    
    #define API MAJOR 1
    #define API MINOR 2
    #define API PATCH 0
    
    class Version
    {
    public:
        static int GetMajor();
        static int GetMinor();
        static int GetPatch();
        static std::string GetVersion();
        static bool IsAtLeast(int major, int minor, int patch);
        static bool HasFeature(const std::string &name);
    };


    // .cpp
    if (Version::HasFeature("THREADSAFE"))
    {
    ...
    }

    The use of feature tags is particularly useful if you have an open source project where clients may fork your source code or an open specification project where vendors can produce different implementations of your specification.

    In these cases, there could be multiple versions of your API that offer different feature sets in releases with the same version number. 
    This concept is employed by the OpenGL API, where the same version of the OpenGL API may be implemented by different vendors but with different extensions available. 
        OpenGL API provides the glGetStringi(GL_EXTENSION, n) call to return the name of the nth extension.




8.2 SOFTWARE BRANCHING STRATEGIES
    different source control management (SCM) products make certain branching strategies easier than others.

TIP
    Branch only when necessary and branch late. Prefer branching to freezing a code line. Merge between branches early and often. (From the Perforce High Level Best Practices white paper.)

TIP
    When creating Basic vs Advanced versions of the same APIs, accompany the version number with a Basic or Advanced string in any generated files. 
    Don't try to use the version number solely to glean whether the file was generated by the Basic or Advanced API.

TIP
    After release, you can evolve an API but not change it.



8.4 LEVELS OF COMPATIBILITY
    backward compatibility
        the newer API is a superset of the older API. 
            It can add new functionality, 
            but it cannot incompatibly change functionality that is already defined by the older API.
            
        1) API backward compatibility
            1. Functional compatibility
                the run-time behavior of an implementation.
                an API will hardly ever be 100% backward compatible in this respect. 
                    Even a release that only fixes bugs in implementation code will have changed the behavior of the API, behavior that some clients may actually be depending on.
                Most API updates will intentionally break functional compatibility.
                a case where functional compatibility is useful, consider a new version of an API that focused solely on performance.
            2. Source compatibility == API compatibility
                It basically states that users can recompile their programs using a newer version of the API without making any change to their code. 
                This says nothing about the behavior of the resulting program, only that it can be successfully compiled and linked.
            3. Binary compatibility == Application Binary Interface (ABI) compatibility
                clients only need to relink their programs with a newer version of a static library or simply drop a new shared library into the install directory of their end-user application.
                The binary representation of all API elements must remain the same, including the type, size, and alignment of structures and the signatures of all functions. 
                    Most changes made to an interface in C++ will cause changes to its binary representation.
                    The binary representation of an API can also change if you use different compile flags. 
                    It tends to be compiler specific, too. 
                        One reason for this is because the C++ standards committee decided not to dictate the specifics of name mangling.
                >> Binary-Incompatible API Changes:
                    ? Removing a class, method, or function.
                    ? Adding, removing, or reordering member variables for a class.
                    ? Adding or removing base classes from a class.
                    ? Changing the type of any member variable.
                    ? Changing the signature of an existing method in any way.
                    ? Adding, removing, or reordering template arguments.
                    ? Changing a non-inlined method to be inlined.
                    ? Changing a non-virtual method to be virtual, and vice versa.
                    ? Changing the order of virtual methods.
                    ? Adding a virtual method to a class with no existing virtual methods.
                    ? Adding new virtual methods (some compilers may preserve binary compatibility if you only add new virtual methods after existing ones).
                    ? Overriding an existing virtual method (thismay be possible in some cases, but is best avoided).
                >> Binary-Compatible API Changes:
                    ? Adding new classes, non-virtual methods, or free functions.
                    ? Adding new static variables to a class.
                    ? Removing private static variables (if they are never referenced from an inline method).
                    ? Removing non-virtual private methods (if they are never called from an inline method).
                    ? Changing the implementation of an inline method (however, this requires recompilation to pick up the new implementation).
                    ? Changing an inline method to be non-inline (however, this requires recompilation if the implementation is also changed).
                    ? Changing the default arguments of a method (however, this requires recompilation to actually use the new default argument).
                    ? Adding or removing friend declarations from a class.
                    ? Adding a new enum to a class.
                    ? Appending new enumerations to an existing enum.
                    ? Using unclaimed remaining bits of a bit field.
                1) Instead of adding parameters to an existing method, you can define a new overloaded version of the method.
                    (Note that this technique may impact source compatibility if the method is not already overloaded because client code can no longer reference the function pointer &func without an explicit cast.)
                2) The pimpl idom can be used to help preserve binary compatibility of your interfaces
                3) Adopting a flat C style API can make it much easier to attain binary compatibility simply
                    you may decide to develop your API using an object-oriented C++style and then provide a flat C style wrapping of the C++ API.
                4) If you do need to make a binary-incompatible change, then you might consider naming the new library differently so that you don¡¯t break existing applications.
        2) data-oriented backward-compatibility
            1. Client/server compatibility
                 if your API involves communication over a network ==>> client/server protocol
                a client using an older release of the API will still be able to communicate with a newer version of the server. 
                a client using a newer release of the API will still be able to communicate with an older version of the server (Rooney, 2005).
            2. File format compatibility
                if your API stores data in a file or database ==>> file format or database schema
                
    forward compatibility
    functional compatibility
    source (or API) compatibility
    binary (or ABI) compatibility

8.5 HOW TO MAINTAIN BACKWARD COMPATIBILITY
8.5.1 Adding Functionality
In terms of source compatibility, adding new functionality to an API is generally a safe thing to do.
TIP
    Do not add new pure virtual member functions to an abstract base class after the initial release of your API.


8.5.3 Deprecating Functionality
    // deprecated.h
    #ifdef __GNUC
    #define DEPRECATED __attribute__((deprecated))
    #elif defined(_MSC_VER)
    #define DEPRECATED __declspec(deprecated)
    #else
    #define DEPRECATED
    #pragma message("DEPRECATED is not defined for this compiler")
    #endif

    // MyClass.hpp
    #include "deprecated.h"
    #include<string>
    class MyClass
    {
    public:
        DEPRECATED std::string GetName();
        std::string GetFullName();
    };

TIP
    Introduce an API review process to check all changes before releasing a new version of the API.



