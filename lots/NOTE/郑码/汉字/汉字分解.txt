
大致有以下信息:
    由哪些组件构成？
    多少种大组件分法？
    笔划顺序？
    组件相对位置？

按不同目的的拆分:
	麻烦：
	   变形：
	       或捺点：“木”捺换成点
	       或点撇捺：“心”第一笔
	       或撇竖：“用”第一笔
	       弯可省略：“西”－“要”
	       钩可省略：“冂”－“口”，“丁”－“B”；不行“无天”“木”的捺换成竖弯
	       或横提撇：“七”－“屯”，“戋?”将中间的横换成撇；不行“夭天”
	       一笔多笔：“艹”－“?”，“水”－“臁
	       时接时断：“同”－“丨司”，“日”横，“工”竖；不行：“己已巳”“人八”
	       时交时接：“在”第2、3笔；不行：“天夫”
	       时接时连时断：“自”第1、2笔
	       反转：“小”－“?”
	       
	       “一灬火”
	       
	       
    知形索码: 知道字形或部分字形, 查找字的编码(如unicode)
        不知笔顺（“惯”）
        不知怎样算一笔（一笔可能被拆成多笔，多笔可能算一笔，“”，“l”－“三人”还是“f八”？）
        抹去笔顺笔划等信息，只保留纯图形
        保留端点、触点与交点，不留拐点（撇捺弯折拐钩）
        触点问题：
            “l”的捺与谁相交？“大”字的触点是否是交点？
            “日曰”中间的横有没有接触两边？
            列出所有可能，用下面“知道部分组件查编码”给出的约束生成所有组合
        平面图，自环（口古），重边（中日），非连通（因）
        
    知道部分组件查编码：如找所有含“口十”的字，将包括：古田由束……
        // 注意：“束”中“口”与“木”交叠
        
        需要知道怎样算一笔
        多种拆分，不预设标准
            查找程序不是输入法，统一的风格以减少记忆错误，故不设拆分标准及笔顺。
            “束”－“一口小”或“一中八”或“木口”或“十只”或“c一”
            实际上n笔字将有n种极大拆分（只拆出一笔）；共2**n个碎片
        字先分成不连通（不相交、不相触）的组件集。
            如“估”－“亻古”而非“亻十口”
            如“小”－“丿|丶”而非“|八”（注意“八”这种不连通的组件）
            如“同”－“冂一口”
            如“黑”－“[口土]丶4丿2”
        现在只考虑连通组件
            暂不考虑非连通关联（“黑”中的点之间的关系、上下、包围）
            ？？？有难度，不如直接拆成笔划
        直接拆成笔划，通过点描述笔划间的关系
            // 只考虑非圈的边，或将首尾相连的边当成圈
            区域（用以约束向量）
                本点
                开线（正北、正东北）
                开域
                    东偏东南=(0,-pi/8)
                    东偏南=(0,-pi/4)
                    东南=(0,-pi/2)=东偏南+正东南+南偏东
                    东=(pi/4,-pi/4)=东偏南+正东+东偏北
                    狭东=(pi/8,-pi/8)
                    泛东=(pi/2,-pi/2)=东南+正东+东北
            笔顺
                两边书写次序
                未指定则任意
                虽由不同小组件的笔划混杂，但单拣一组件，其中笔划次序与该组件相应的独立字的相同
            笔向：
                +1与有向边的方向相同，-1相反，或未定向
            抽象字、表现字、约束字
                同一抽象字有诸多表现字（构成不同）
                同一表现字允有不同约束字（实边+点集+约束）
                约束字实际上一个书写字（实边+点集+坐标）集合
                约束字A,B，若存在书写字a in A, b in B，存在b的实点集到a的实点集的一子集的映射，s.t. 实边对实边，坐标不变
                    就说：B是A的一个组件
                若A,B互为组件，则为同一表现字
                但同一表现字可以不互为组件的约束字
                我们希望一个约束字的约束够宽松（即其所对应的书写字集合较大），
                    使得一般用户正常输入的约束字与之互为组件，或书写字满足其约束。
                    又希望约束够紧，不会有不合理的组件出现，
                        当用户搜索其它字的组件时，不找到该字。
                    为了简化计算，只使用线性约束
                        比较已知方向的直线上两点的先后
                        比较已知向量与未知向量的方向
                        ==>> 表示某点在直线上时，直线方向必须是已知的
                        ==>> 求两直线交点时，要求两直线的方向已知
                        ==>> 所有笔划的方向已知 ==>> 只使用8个方向
                    当用户输入书写字时，可用更宽松、更复杂的约束（点与线、线与线、min，max……）
                        因为只是检查坐标（某种排列）是否合适
                        “幽”－对“幺”约束为：在一个多边形中。该多边形是由底横、左右竖（可能是斜的）、左右竖顶点至顶横及顶横构成，顶横的水平位置由“山”最高点决定。
            实边即是通常意义上的边，由多个实点及中间直线段组成
                ？？只有8种直线段（8个方向）不含圈
                    为了不混淆撇与竖，每个方向45度（=360/8）。
                撇只有竖撇
                竖撇如何变成撇？“春”
                    其中竖（非正常竖）是竖或撇
                竖撇如何变成竖？“月杏弥堋
                    其中撇的长度可为0，即可省略
            虚边是实边的无限延伸（射线）
            有向边－虚实边+方向 // 不一定是书写方向，比如“七”，我不是很清楚是横、提、撇
            4条假想边（有向）：竖向南, 横向东, 捺向东南, 撇向西南
            点=(x,y, s(t), t) # edge[k] = s(t)
                实点
                    端点－实边的两端
                    拐点－实边的中间点
                        主要是为了应对方向改变
                        有时用以兼容可省略段，如丨【|】，“春”中撇或竖撇
                        可省略拐点：
                            前后方向未改变
                            或是前实点或是后实点（所在线段长度为0）
                虚点
                    联点(x,y)－边与边的重叠点（实线段及其延伸边）
                        重叠点不是交点，点是动点，含时间，不可能交
                        只是位置相同，是位置上的交点
                        导出点
                        当提到它，必须提到当前所在边
                    投影点－非投影点在假想边上的投影
                        以区分“日曰”
                            “S”在假想撇上的投射，可用于辨别长短
                    辅助点－凭空出现，以助布局，在约束中常以投影点出现
                        如：左右型字，可加一辅助点在中间，左组件实点在假想横上投影全在辅助点投影的左边
                        模块化，“幽”“S”字都有“山”字，可在“山”字中加上两小方框，各4个辅助点
                        所有字均加一大方框以包含所有实点
                        但模块也有缺陷：
                            “写”并非模块化意义下的上下型，更不是上包围
                            “什”只需“十”在“丨”的东，在“丿”的东南
                        布局感知：
                            “冖”在“竖直”布局中只考虑“一”
                            “亻”在“水平”布局中只考虑“丨”
            点与边的关系：
                点{所在有向边：与边关系（前+首+中+尾+后，可选相邻的几项）}
                不出现的边即为无关边
                前后－不在实边上
                首尾－实边的两个端点
                中－实边上除首尾外任一点
            每边的首尾皆单独成点
            
            点与点的关系：
                当两点有共同的所在边时：
                    两点在有向边上的前后关系： 前+同+后，可选相邻的几项
                        三个全选==无关
                        包括假想边，这时点指的是它在假想边上的投影
                        包括中间直线段的延伸边
        
        “曰日”
        有向边:
        1->2: a<=1<b<2<=d ; 1:实点, a:联点, 1->2:有向实边, 比较的是出现顺序(以有向边的方向)
            ; 此边上在其他边上有约束的非实点, 即使在此边上无约束, 也需列出
        3->4->5: a<=3<4<c<5<=e ; 4->5:单独拿出来可用于引用其延伸边
        6->7: b<=6<7<=c
        8->9: d<=8<9<=e
        
        ; 假想撇: a<e  ; a:a在假想边上的投影 ; a<e 是"日", e<a 是"曰"
        向量方向:
        横: 3->4, 6->7, 8->9 ; 3->4:有向实直线段(实向量)
        竖: 1->2, 4->5
        南偏东: a~>e ; a~>e:虚向量 ; 南偏东 是"日", 东偏南 是"曰"


        人入V八R
        有向边:
        1->2: 1<=a<2 ; a<=1<2 ; 1<a<2 ; a<1<2 ; 1<2<=a
        3->4: a<=3<4 ; 3<a<4  ; 3<a<4 ; a<3<4 ; 3<4<=a
        向量方向:
        撇: 1->2
        捺: 3->4
        
        工土士干于
        束





大部件 = 布局 “（” 布局组件 “）”
布局组件 = 小部件选择区{2,} // 按小部件第一笔笔顺排列
小部件选择区 = (小部件 跳转表)
小部件选择区 = “{”(小部件 跳转表)+ “}”
跳转表 = （（数“.”）*数 “：” 数）* // [本小部件第几笔转至第几个小部件兄弟]
跳转表 = （（数“.”）+ “：” 数）* // [本小部件第几部完成后转至第几个小部件兄弟]

大部件选择区 = “{”大部件+ “}”
大部件选择区 = 大部件
小部件 = 大部件选择区
小部件 = 笔划
小部件 = 引用
引用 = “[” 引用名 “]”

布局 笔划 引用名 数
“（” “）”“{”“}”“[”“]”
“：” “.”


布局 = 行 列 交 包 包－南，包－北，包－东，包－东北，包－东南，包－西南




