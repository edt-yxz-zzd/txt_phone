
目标：设计一门外星语，准确的讲，是外星文字（可视化）
要求：
    抗噪声
    可平面化（三维的话其实更像外星文字，只是毕竟是给人看的）（最好可以画在网格上，方便电脑显示）
    无方向（主要是区别于地球上线性书写的文字）
    一体化（浑然一体，字与字之间不至于毫无联系）
    无色（白底黑字）
    较高编码效率

待考察对象：
    拓朴
    图graph
    结knot

拓朴：
    可平面化==>>平面拓朴
        连通：带洞的点
        不连通：带洞的点在洞中（球面）
    一体化==>>连通==>>以洞的数目编码整数==>>编码效率低
    画在纸上抗噪差，褪色出现新洞
结：
    可计算性有问题
图：
    可平面化==>>平面图？？？
    一体化==>>二连通(比如：树看起来就很脆，不圆滑)
        二连通为句，三连通为字。#SPQR tree
    抗噪声？
        二连通图比单连通图抗噪强，可发现断线。
            degree>=2
        degree!=2，否则点必须明显比边粗，抗噪差
            degree>=3
        出度degree太大的话，一个点可能被当成多个点。
            可网格化==>> 3<=degree<=4
            为了增强纠错能力，degree当是固定值。
            为了方便画在网格上，如十字交叉当成跨过而非点，degree!=4。
                如此一来，甚至不必是平面图。
                但平面图的相关算法比较简单（如图同构）。
        因为不是平面拓朴，所以不能容忍过分的变形。边的长宽有一定要求。
            "工" --[竖太短]--> "X" --[竖太短太粗]--> "H"

====================================================
选用“二连通三度平面图”来实现外星文，称之为“平面网格二三语”
====================================================
证明：三连通图连接任意两不同边后仍是三连通。（新图点数多2，边数多3）
    设G->H
    #证H删任意两点后仍为连通图
    1. "二" -> "工"
        a-e-b
          |
        c-f-d
        若H删除的两点不含ef，则相当于G先删这两点（仍连通）再添加ef，ef必与abcd其中（至少）之2相连，结果必连通。
        H删ea <==> G删a，添f
        H删ec <==> G删点c与边a~b，添f，必连通
        H删ef <==> G删边a~b与边c~d，必连通
    2. "/\" -> "A"
           a
          / \
         d---e
        /     \
       b       c
        若H删除的两点不含de，则相当于G先删这两点（仍连通）再添加de，de必与abc其中（至少）之1相连，结果必连通。
        H删ea <==> G删a，添d
        H删ec <==> G删c，添d
        H删eb <==> G删点b与边a~c，添d
        H删ed <==> G删边a~b与边a~c，必连通


====================================================
编码整数：
    “蚕”：
              --------------------
            /   |   |       |   |  \
        ----    |   | ...   |   |   ----
       |    \   |   |       |   |  /    |
       |      --------------------      |
       |                                |
       ----------------------------------

    1. 往蚕里面的方格添加隔板
        ---------------
            |   |
            |---|
        ... |---| ...
            |---|
            |   |
        ---------------
        保留首尾两个三角形，也就是首尾两个方格不加隔板
        为了区分首尾及上下，可破坏第一个三角形和第一个方格：
              ----------------------
            /   |   |       |    |   \
        ----  4 |>=5| ...   |>=4 | 3  ----
       |    \   |   |       |    |   /    |
       |      -/-\------------------      |
       |           face>=6                |
       ------------------------------------
                   face>=5

        有且只有两个三角形
        若"..."不存在，即其左右竖板是同一边，则有不平凡自同构，作为0无需识别首尾上下
            10点：
                a   b   c
            d               e
                f
               g h  i   j

            15边：
             da  ab  bc  ce
               af  bi  cj
            dg fg fh    ej
              gh hi  ij
                 de
            同构?? h->e,g->j,f->c
                abcdefghij
                bafihcjedg
        否则，若两个三角形均与唯一的四边形相邻：
            三角形中与该四边形相对的顶点的出边，与另一三角形的距离为1（尾）或>=2（首）
        否则，与四边形相邻的三角形为首。
        －－－－－－－－－－－－－－－－－－－－－－
        编码：
            假设上图中"..."部分的方格数为m(m>=0)，
                各方格隔板数为n[i](n[i]>=0,1<=i<=m)
            各竖上的新添加点数为：
                n[0], n[0]+n[1], n[1]+n[2], ..., n[m-1]+n[m], n[m]
                组合数为：C(n[0]+n[1],n[1])*C(n[1]+n[2],n[2])*...*C(n[m-1]+n[m],n[m])
                    = II: C(n[i-1]+n[i],n[i]) {1<=i<=m}
            新添加点总数 = 2*m + 2*sum n[i] {1<=i<=m}
                #error = 2*新添加边总数
                = 2*新添加(竖与横隔板)总数
            －－－－－－－－
            给定尚未添加的横竖隔板总数n与前一方格中的隔板数u递归计算组合数：
                f :: Integer -> Integer -> UInt
                f n u | n < 0 || u < 0 = 0
                f 0 u = 1
                # i - 当前方格隔板数
                f n u = sum: C (u+i) i * f (n-1-i) i {i}
                #[u==0] ==>> [1, 1, 2, 4, 9, 22, 57, 154, 430, 1234]
                #http://oeis.org/A287709

    2. 往蚕里面添加隔板（无需竖板）
        类似上图，但"..."的两竖必须是不同边。"..."里可以随意添加隔板，但最终不得有三角形。
              ----------------------
            /   |   |       |    |   \
        ----  4 |>=5| ...   |>=4 | 3  ----
       |    \   |   |       |    |   /    |
       |      -/-\------------------      |
       |           face>=7                |
       ------------------------------------
                   face>=6

        给定一个多边形，边数为o(o>=3)，已嵌入平面，有一指定的起始点，往其中添加n个隔板，最终内部无三角形，原第一边必须被隔s，组合数为：
                # 原第一边 必须被隔则s=True，可隔可不隔则s=False
                g n o s | n<0 = 0
                g n o s | o<3 = 0
                g n o s | n==0 = [o>3][not s]
                # i - 最终包含起始点的内部多边形在去掉其他隔板后的边数
                g n o s = sum: g (n-1) (o-i+4) (i==3) * (1 if s else i-2) {3<=i<=o+1}
                #[o==4][s==False] ==>> [1, 2, 6, 25, 114, 532, 2516, 12044, 58303, 285076]

    3. 简化
    以上2种编码本质上划出一块平面作为编码区，并且定义该面的起始点与方向。
    核心块 包含 三角形 作为 地标，编码区 所有子块边数须>=4
    若 含2个三角形:
      若 相邻: 只有一个图
      若 不相邻: ？待研究
    若 只含1个三角形:
      若 其邻面边数分别为:
        * 4,4,4: 只有一个图
        * 4,4,5: 不存在
        * 4,5,5: 只有一个图
        * 4,5,>=6: nv >= 10
          核心块=(plantri.exe -adc3m3 => 全局4th，局部10点0th)
          共2个三角形，等价，选择任一三角形作为 编码区，但为了避免三角形子块，第一次须新增4点（丫叉），nv=14
          并不比第2种方法nv>=12更少节点
    直接考察 核心块<-(plantri.exe -adc3m3)
      最简单候选为12点3个:
        *核心块=(plantri.exe -adc3m3 => 全局9th，局部12点0th)
          '[0000009]12 bcd,aef,afg,ahi,bjf,bec,cjk,dki,dhl,elg,glh,ikj'
          *甲：即 第2种方法
            核心块 边数 [>=7]-(3,4,>=6,3,...)
          *乙：编码区 右移一格
            核心块 边数 3-(4,5,>=7)
        *核心块=(plantri.exe -adc3m3 => 全局10th，局部12点1th)
          '[0000010]12 bcd,aef,afd,acg,bhi,bjc,djk,ekl,elj,fig,glh,hki'
          共2四边形，等价，选一作为编码区
          核心块 边数 3-(4,5,>=7)
        *核心块=(plantri.exe -adc3m3 => 全局11th，局部12点2th)
          '[0000011]12 bcd,aef,agh,aij,bkl,blg,cfl,cki,dhj,dik,ejh,egf'
          共2四边形，等价，选一作为编码区
          核心块 边数 3-(4,5,>=6)

编码字符：
    若直接编码uniode，则可用上面编码整数的方法：
    (0x11_0000==1114112)
    蚕方法1：
        16 [1, 1, 2, 4, 9, 22, 57, 154, 430, 1234, 3625, 10865, 33136, 102598, 321913, 1021963, 3278543]
        最多需10+2*16 = 42点
    蚕方法2：
        10 [1, 2, 6, 25, 114, 532, 2516, 12044, 58303, 285076, 1406253]
        最多需12+2*10 = 32点



树关系：一对多
    被修饰：
        子节点-[修饰]->父节点
        父节点-[被修饰]->无序{子节点}
        名词、形容词
        形容词、副词
        名词、副词
    作用于：
        父节点-[作用于]->有序有限制[子节点]tuple
        谓词、（主语、宾语）
    下降嵌套：
        #可读性<==>线性<==>无“递归嵌套”#允许无限制重复（象正则表达式）
        父节点-[下降嵌套]->有序无限制[子节点]list
        存在ord：
            ord :: 节点 -> UInt
            ord(父节点) > ord(子节点)
        章、节
    递归嵌套：
        父节点-[递归嵌套]->有序无限制[子节点]list
        无需ord




