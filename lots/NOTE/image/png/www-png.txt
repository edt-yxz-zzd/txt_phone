
e ../lots/NOTE/image/png/www-png.txt

[[
view /sdcard/0my_files/unzip/png_specification/www.w3.org/TR/png-3/index.html
view /sdcard/0my_files/unzip/png_specification/www.libpng.org/pub/png/spec/1.2/PNG-Contents.html

view others/app/termux/web_server.txt

html2text -i /sdcard/0my_files/unzip/png_specification/www.w3.org/TR/png-3/index.html -o $my_tmp/out4py/html2text/w3_org-png_3-index.html.txt
view /sdcard/0my_files/tmp/out4py/html2text/w3_org-png_3-index.html.txt
]]
<<==:
[[
@20251022
png specification
  https://www.w3.org/TR/png-3/
  http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html
  http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html
  ==>>:
cd $my_tmp/wget_/
wget_web_under https://www.w3.org/TR/png-3/
  1.2M    www.w3.org/
wget_web_under http://www.libpng.org/pub/png/spec/1.2/PNG-Contents.html
  338K    www.libpng.org/

==>>:
cd $my_tmp/wget_/

ls www.w3.org/TR/png-3/ -1
  figures
  index.html

ls www.libpng.org/pub/png/spec/1.2/ -1
  PNG-CRCAppendix.html
  PNG-Chunks.html
  PNG-ColorAppendix.html
  PNG-Compression.html
  PNG-Contents.html
  PNG-Credits.html
  PNG-DataRep.html
  PNG-Decoders.html
  PNG-Encoders.html
  PNG-Filters.html
  PNG-GammaAppendix.html
  PNG-Glossary.html
  PNG-History.html
  PNG-Introduction.html
  PNG-Misc.html
  PNG-Ordering.html
  PNG-Rationale.html
  PNG-References.html
  PNG-Resources.html
  PNG-Structure.html

du -h www.libpng.org/
  320K    www.libpng.org/pub/png/spec/1.2
  323K    www.libpng.org/pub/png/spec
  327K    www.libpng.org/pub/png
  330K    www.libpng.org/pub
  338K    www.libpng.org/

du -h www.w3.org/
  164K    www.w3.org/Daemon/User/Config
  167K    www.w3.org/Daemon/User
  171K    www.w3.org/Daemon
  16K     www.w3.org/Icons/WWW
  12K     www.w3.org/Icons/32x32
  31K     www.w3.org/Icons
  184K    www.w3.org/TR/png-3/figures
  851K    www.w3.org/TR/png-3
  855K    www.w3.org/TR
  68K     www.w3.org/StyleSheets/TR/2021/logos
  119K    www.w3.org/StyleSheets/TR/2021
  123K    www.w3.org/StyleSheets/TR
  126K    www.w3.org/StyleSheets
  1.2M    www.w3.org/

==>>:
cd $my_tmp/wget_/
tar -cJvf png_3-w3_org-20251022.txz www.w3.org/
tar -tvf png_3-w3_org-20251022.txz
du -h png_3-w3_org-20251022.txz
  164K

mkdir /sdcard/0my_files/unzip/png_specification/
mkdir /sdcard/0my_files/unzip/png_specification/tmp
cd /sdcard/0my_files/unzip/png_specification/tmp
tar -xvf $my_tmp/wget_/png_3-w3_org-20251022.txz -C /sdcard/0my_files/unzip/png_specification/

==>>:
cd $my_tmp/wget_/
tar -cJvf png_1_2-libpng_org-20251022.txz www.libpng.org/
tar -tvf png_1_2-libpng_org-20251022.txz
du -h png_1_2-libpng_org-20251022.txz
  68K

tar -xvf png_1_2-libpng_org-20251022.txz -C /sdcard/0my_files/unzip/png_specification/

==>>:
cd $my_txt
mkdir /sdcard/0my_files/zip/png_specification/
cp -iv -t /sdcard/0my_files/zip/png_specification/   $my_tmp/wget_/png_3-w3_org-20251022.txz $my_tmp/wget_/png_1_2-libpng_org-20251022.txz

du -h /sdcard/0my_files/zip/png_specification/
  236K

cp -iv -t ../lots/NOTE/image/png/  -r /sdcard/0my_files/zip/png_specification/

ls ../lots/NOTE/image/png/  -1
  png_specification
  www-png.txt

ls ../lots/NOTE/image/png/png_specification/  -1
  png_1_2-libpng_org-20251022.txz
  png_3-w3_org-20251022.txz








===源自py源代码，似乎已过气:
png格式
  ls ~/../usr/lib/python3.10/site-packages/PIL/PngImagePlugin.py
  view /sdcard/0my_files/tmp/out4py/py_src/site-packages/PIL/PngImagePlugin.py
    # See "PNG (Portable Network Graphics) Specification, version 1.0;
    # W3C Recommendation", 1996-10-01, Thomas Boutell (ed.).
  purepng:
    view /sdcard/0my_files/tmp/out4py/py_src/site-packages/png/png.py
      http://www.w3.org/TR/2003/REC-PNG-20031110/
      http://www.w3.org/TR/PNG
  cd $my_tmp/wget_/
  #wget_web_under http://www.w3.org/TR/2003/REC-PNG-20031110/
  #wget_web_under http://www.w3.org/TR/PNG


]]

[[

[png_file == (png_file_signature, chunks/[chunk])]

[png_file_signature == b'\x89PNG\r\n\x1a\n']
    #bytes([137,80,78,71,13,10,26,10])

[chunks[0].chunk_type == 'IHDR']
[chunks[-1].chunk_type == 'IEND']

[chunk == (len4data, chunk_type, data, crc4typ_dat)]

[data :: bytes{len==len4data}]
[len4data :: bytes{len==4}{big_endian_32bit_uint}{uint%2**31}]
    32bit但最高爻元置零
[crc4typ_dat :: bytes{len==4}{big_endian_32bit_uint}]
[chunk_type :: bytes{len==4}]
    每一字节的(1<<5)爻元 是 超类型:
      + 欤补助/欤非紧要
      + 欤私用
      + <保留{当下置零}>欤扩展
      + 欤安全复制/欤不依赖其他类型块/欤独列类型
    大写字母:A-Z:0x41..0x5A
    小写字母:a-z:0x61..0x7A
    两者:同:
        第七爻元:0#最高爻元
        第六爻元:1#次高爻元
    两者:异:
        第五爻元:0#大写字母
        第五爻元:1#小写字母
    >>> bin(ord('Z'))
    '0b1011010'
    >>> bin(ord('A'))
    '0b1000001'
    >>> bin(ord('z'))
    '0b1111010'
    >>> bin(ord('a'))
    '0b1100001'
    ...6543210

#from:w3_org-png_3:
PNG four-byte unsigned integer
  a four-byte unsigned integer limited to the range 0 to 2^31-1.
    Note:The restriction is imposed in order to accommodate languages that have difficulty with unsigned four-byte values.
]]
<<==:
[[
@20251022
http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html
===
PNG (Portable Network Graphics) Specification, Version 1.2
Previous page
Next page
Table of contents
3. File Structure
A PNG file consists of a PNG signature followed by a series of chunks. This chapter defines the signature and the basic properties of chunks. Individual chunk types are discussed in the next chapter.

3.1. PNG file signature
The first eight bytes of a PNG file always contain the following (decimal) values:

   137 80 78 71 13 10 26 10
      ## b'\x89PNG\r\n\x1a\n'
This signature indicates that the remainder of the file contains a single PNG image, consisting of a series of chunks beginning with an IHDR chunk and ending with an IEND chunk.

See Rationale: PNG file signature.

3.2. Chunk layout
Each chunk consists of four parts:

Length
A 4-byte unsigned integer giving the number of bytes in the chunk's data field. The length counts only the data field, not itself, the chunk type code, or the CRC. Zero is a valid length. Although encoders and decoders should treat the length as unsigned, its value must not exceed 2^31 bytes.
Chunk Type
A 4-byte chunk type code. For convenience in description and in examining PNG files, type codes are restricted to consist of uppercase and lowercase ASCII letters (A-Z and a-z, or 65-90 and 97-122 decimal). However, encoders and decoders must treat the codes as fixed binary values, not character strings. For example, it would not be correct to represent the type code IDAT by the EBCDIC equivalents of those letters. Additional naming conventions for chunk types are discussed in the next section.
Chunk Data
The data bytes appropriate to the chunk type, if any. This field can be of zero length.
CRC
A 4-byte CRC (Cyclic Redundancy Check) calculated on the preceding bytes in the chunk, including the chunk type code and chunk data fields, but not including the length field. The CRC is always present, even for chunks containing no data. See CRC algorithm.
The chunk data length can be any number of bytes up to the maximum; therefore, implementors cannot assume that chunks are aligned on any boundaries larger than bytes.

Chunks can appear in any order, subject to the restrictions placed on each chunk type. (One notable restriction is that IHDR must appear first and IEND must appear last; thus the IEND chunk serves as an end-of-file marker.) Multiple chunks of the same type can appear, but only if specifically permitted for that type.

See Rationale: Chunk layout.

3.3. Chunk naming conventions
Chunk type codes are assigned so that a decoder can determine some properties of a chunk even when it does not recognize the type code. These rules are intended to allow safe, flexible extension of the PNG format, by allowing a decoder to decide what to do when it encounters an unknown chunk. The naming rules are not normally of interest when the decoder does recognize the chunk's type.

Four bits of the type code, namely bit 5 (value 32) of each byte, are used to convey chunk properties. This choice means that a human can read off the assigned properties according to whether each letter of the type code is uppercase (bit 5 is 0) or lowercase (bit 5 is 1). However, decoders should test the properties of an unknown chunk by numerically testing the specified bits; testing whether a character is uppercase or lowercase is inefficient, and even incorrect if a locale-specific case definition is used.

It is worth noting that the property bits are an inherent part of the chunk name, and hence are fixed for any chunk type. Thus, BLOB and bLOb would be unrelated chunk type codes, not the same chunk with different properties. Decoders must recognize type codes by a simple four-byte literal comparison; it is incorrect to perform case conversion on type codes.

The semantics of the property bits are:

Ancillary bit: bit 5 of first byte
0 (uppercase) = critical, 1 (lowercase) = ancillary.
Chunks that are not strictly necessary in order to meaningfully display the contents of the file are known as "ancillary" chunks. A decoder encountering an unknown chunk in which the ancillary bit is 1 can safely ignore the chunk and proceed to display the image. The time chunk (tIME) is an example of an ancillary chunk.

Chunks that are necessary for successful display of the file's contents are called "critical" chunks. A decoder encountering an unknown chunk in which the ancillary bit is 0 must indicate to the user that the image contains information it cannot safely interpret. The image header chunk (IHDR) is an example of a critical chunk.

Private bit: bit 5 of second byte
0 (uppercase) = public, 1 (lowercase) = private.
A public chunk is one that is part of the PNG specification or is registered in the list of PNG special-purpose public chunk types. Applications can also define private (unregistered) chunks for their own purposes. The names of private chunks must have a lowercase second letter, while public chunks will always be assigned names with uppercase second letters. Note that decoders do not need to test the private-chunk property bit, since it has no functional significance; it is simply an administrative convenience to ensure that public and private chunk names will not conflict. See Additional chunk types, and Recommendations for Encoders: Use of private chunks.

Reserved bit: bit 5 of third byte
Must be 0 (uppercase) in files conforming to this version of PNG.
The significance of the case of the third letter of the chunk name is reserved for possible future expansion. At the present time all chunk names must have uppercase third letters. (Decoders should not complain about a lowercase third letter, however, as some future version of the PNG specification could define a meaning for this bit. It is sufficient to treat a chunk with a lowercase third letter in the same way as any other unknown chunk type.)

Safe-to-copy bit: bit 5 of fourth byte
0 (uppercase) = unsafe to copy, 1 (lowercase) = safe to copy.
This property bit is not of interest to pure decoders, but it is needed by PNG editors (programs that modify PNG files). This bit defines the proper handling of unrecognized chunks in a file that is being modified.

If a chunk's safe-to-copy bit is 1, the chunk may be copied to a modified PNG file whether or not the software recognizes the chunk type, and regardless of the extent of the file modifications.

If a chunk's safe-to-copy bit is 0, it indicates that the chunk depends on the image data. If the program has made any changes to critical chunks, including addition, modification, deletion, or reordering of critical chunks, then unrecognized unsafe chunks must not be copied to the output PNG file. (Of course, if the program does recognize the chunk, it can choose to output an appropriately modified version.)

A PNG editor is always allowed to copy all unrecognized chunks if it has only added, deleted, modified, or reordered ancillary chunks. This implies that it is not permissible for ancillary chunks to depend on other ancillary chunks.

PNG editors that do not recognize a critical chunk must report an error and refuse to process that PNG file at all. The safe/unsafe mechanism is intended for use with ancillary chunks. The safe-to-copy bit will always be 0 for critical chunks.

Rules for PNG editors are discussed further in Chunk Ordering Rules.

For example, the hypothetical chunk type name bLOb has the property bits:

   bLOb  <-- 32 bit chunk type code represented in text form
   ||||
   |||+- Safe-to-copy bit is 1 (lowercase letter; bit 5 is 1)
   ||+-- Reserved bit is 0     (uppercase letter; bit 5 is 0)
   |+--- Private bit is 0      (uppercase letter; bit 5 is 0)
   +---- Ancillary bit is 1    (lowercase letter; bit 5 is 1)
Therefore, this name represents an ancillary, public, safe-to-copy chunk.

See Rationale: Chunk naming conventions.

3.4. CRC algorithm
Chunk CRCs are calculated using standard CRC methods with pre and post conditioning, as defined by ISO 3309 [ISO-3309] or ITU-T V.42 [ITU-T-V42]. The CRC polynomial employed is

   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1
The 32-bit CRC register is initialized to all 1's, and then the data from each byte is processed from the least significant bit (1) to the most significant bit (128). After all the data bytes are processed, the CRC register is inverted (its ones complement is taken). This value is transmitted (stored in the file) MSB first. For the purpose of separating into bytes and ordering, the least significant bit of the 32-bit CRC is defined to be the coefficient of the x31 term.

Practical calculation of the CRC always employs a precalculated table to greatly accelerate the computation. See Sample CRC Code.

Previous page
Next page
Table of contents
]]
