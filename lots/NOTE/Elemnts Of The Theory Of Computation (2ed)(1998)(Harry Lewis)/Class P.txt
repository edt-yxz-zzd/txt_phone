[page 278-279] 6.2 PROBLEMS, PROBLEMS...
    How well does the class P capture the intuitive notion of "satisfactorily solvable problem?" How widely accepted is the thesis that polynomial algorithms are precisely the empirically feasible ones? It is fair to say that, while it is the only serious proposal in this arena, it can be challenged on various grounds. For example, it can be argued that an algorithm with time requirements n^100, or even 10^100*n^2, is not at all "practically feasible," even though it is a polynomial-time one. Also, an algorithm with time requirements n^loglogn may be considered perfectly feasible in practice, despite the fact that its growth is not bounded by any polynomial. The empirical argument in defense of our thesis is that such extreme time bounds, though theoretically possible, rarely come up in practice: Polynomial algorithms that arise in computational practice usually have small exponents and palatable constant coefficients, while nonpolynomial algorithms are usually hopelessly exponential, and are therefore of quite limited use in practice.
    <comment> But even the Church-Turing thesis was challenged extensively during its time, and in fact from both sides: There were mathematicians who thought that Turing decidability is too restricted a notion, while others opined that it is too liberal. In fact, complexity theory, the subject of this and the next chapter, can be seen as the latest and most serious challenge of the latter type. 

    A further criticism of our thesis is that it categorizes an algorithm based only on its worst-case performance (the largest running time over all inputs of length n). Arguably, an average-case approach -- for example, insisting that the time requirements of a Turing machine, when averaged over all possible inputs of length n, be bounded by p(n) -- would be a better predictor of the practical utility of the algorithm. Although average-case analysis seems a very reasonable alternative, it is in fact itself open to even more devastating challenges. For example, which distribution on the inputs should we adopt in our average-case analysis? There seems to be no satisfactory answer.
    Despite these reservations, however, polynomially bounded computation is an appealing and productive concept, and it leads to an elegant and useful theory. By focusing on the gray areas on its boundary, one often forgets what a useful classification tool it is, that it includes mostly practically feasible algorithms, and excludes mostly impractical ones. But the best way to get acquainted with polynomial-time computation, its true scope, and its limitations, is to introduce a variety of interesting computational problems that are known to belong in P. It is also instructive to contrast such problems with certain examples of stubborn problems that do not seem to be in P. Often the difficult and the easy problems look very similar. 

[page 280]
    Languages encode problems. But of course also any language L |<=| S* can be thought of as a problem:
        THE DECISION PROBLEM FOR L: Given a string x |<-| S*, is x |<-| L?
    It is productive to think of a problem and the associated language interchangeably. Languages are more appropriate in connection to Turing machines, while problems are more clear statements of practical computational tasks of interest, for which we must develop algorithms. In the following pages we shall introduce and discuss extensively many interesting problems; we shall treat a problem and the corresponding language as two different aspects of the same thing. For example, we shall next point out that REACHABILITY is in P. By this we mean that the corresponding language R, defined above, is in P.

[page 282]
    Despite the superficial similarity between the two problems EULER CYCLE and HAMILTON CYCLE, there appears to be a world of difference between them. After one and a half centuries of scrutiny by many talented mathematicians, no one has discovered a polynomial algorithm for HAMILTON CYCLE. 

[page 283] Optimization Problems // minimization|maximization problems // cost function // budget B // goal K
    There is a serious obstacle for studying the traveling salesman problem within our framework of problems and languages: Unlike all other problems we have seen in this chapter, the traveling salesman problem is not the kind of problem that requires a "yes" or "no" answer and can therefore be studied in terms of a language. It is an optimization problem, in that it requires us to find the best (according to some cost function) among many possible solutions.
    There is a useful general method for turning optimization problems into languages, so that we can study their complexity: Supply each input with a bound on the cost function. In this case, consider the following problem:
        TRAVELING SALESMAN PROBLEM: Given an integer n > 2, an n * n distance matrix dij, and an integer B > 0 (intuitively, the budget of the traveling salesman) find a permutation pi of {1,2,... ,n} such that c(pi) < B.
    If we could solve the original optimization problem in polynomial time, that is, if we had an algorithm for computing the cheapest tour, then obviously we would be able to solve this "budget" version in polynomial time as well: Just compute the cost of the cheapest tour and compare it with B. Thus, any negative result about the complexity of the TRAVELING SALESMAN PROBLEM as denned just now will reflect negatively on our prospects for solving the original, optimization version of the problem.
    We shall use this maneuver to bring many interesting optimization problems within our language framework. In the case of maximization problems we do not supply a budget B but instead a goal K. For example, the following is an important maximization problem transformed this way:
        INDEPENDENT SET: Given an undirected graph G and an integer K > 2, is there a subset C of V with |C| >= K such that for all Vi, Vj |<-| C, there is no edge between Vi and Vj?
    INDEPENDENT SET is yet another natural and simply stated problem for which, despite prolonged and intense interest by researchers, no polynomial-time algorithm has been found.

[page 286] binary v.s. unary
    This pair of problems, PARTITION and UNARY PARTITION, with their contrasting complexity, illustrates the following important fact about input representations: The precise representation of mathematical objects such as graphs, automata, Turing machines, and so on, as inputs to problems makes little difference in the membership of the corresponding language in P, because the lengths of all reasonable representations of the same object are related by a polynomial. The only encoding convention whose violation leads to misleading results, is that integers should be encoded in binary and not in unary.
    <comment> Or in decimal, hexadecimal, or in any other radix system; all such representations of the same integer have lengths that are constant multiples of each other. 




