
file:
1) descript this file in which subformat
    encoding/style/tokenizer/parser/standard...
2) descript what this file needed
    external processor
        e.g. what Monad(method supported?)
             DOM
             compiler_features)
    dependants
3) what the output type?
    the output AST (like DTD)


file in file
    file itself can be a filesystem/database
gateway
    rename
    filter : whitelist/blacklist
    regex: "[0abcde]*" - "0*"
    sum product exclude
    tree:
        external <-> parent <-> children

class New u => Unit u
type family Mul u v
mul :: Num a, Unit u, Unit v, Unit (Mul u v) => u a -> v a -> Mul u v a


define keyword... // no comment needed!
    since we define DSL or Templates
        readers are likely not able to figure out what happens.
        we write comment: "Here defines data XXX, instance Eq XXX"
        but, comment are only for humans
        they are useless for processor
        they can not impose constraints to verify what they declare
        to document, comment with syntax error may silently absent in result document.
        we define keyword like : will_define ...
        the ability to define keyword+parser+constraints
        we never need a comment!
define attributes
    like XML/HTML, we desript what the entity is
    qsort :: ...
        {class = algo.sort, stable = False, ...}
auto-generated-code-sense
    take care that code may generated by program
    1) free-style enable, no constraints like max line length
        (python has no free-style like haskell)
    2) text substitute
        scope handle:
            which identity is not visible to outside?
            which identity is from outside?
            which identity is define inside and export to outside?
                in restrict way?
                    e.g. inject into outside's namespace
                         or outside should import them use alias
            merge splited scope
                framework...
                private implict parameter passed to same layers...
    3) sub-ast substitute
    4) sub-parsers available
        outer sense
        so that DSL parser can customize/generate target format for outer
        e.g.
            OutText ~ OutParser
                DSL ~ InParser OutParser



