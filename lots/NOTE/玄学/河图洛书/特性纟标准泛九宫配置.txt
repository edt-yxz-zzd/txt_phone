
e ../lots/NOTE/玄学/河图洛书/特性纟标准泛九宫配置.txt

[[[[[[[[[
@20251018
copy from:
    view script/九宫泛化.py
===
[[[[[
公式:考虑(%)后情形，或者说，晶格胞周期延拓
    [d := (i-j)%n]
    各对角线最大值位置是:
        {(2j+1,j) | [j::int]}
        {((2j+1)%,j%n) | [j::int]}
    各对角线最小值位置是:
        {(2j+1+1,j+1) | [j::int]}
        {(2j,j) | [j::int]}
                [d = i-j = (2j-j) = j]
        {(2j%n,j%n) | [j::int]}
                [d = j%n]
        {(2d%n,d%n) | [d::uint%n]}
    各对角线最小值是:
        {1+(d+h)*n | [d::uint%n]}
        {((d+h)*n)%nn +1 | [d::uint%n]}
        {(d+h)%n *n +1 | [d::uint%n]}
    (i,j)~(j+d,j)
        最小值所在:(2d%n,d%n)
        最小值为:((d+h)%n *n +1)
        偏移量:(j-d)%n
        值为:((d+h)%n *n +1) +(j-d)%n
    [mx[i,j] == ((d+h)%n *n +1 +(j-d)%n)]

特性纟标准泛九宫配置:
[[h:<-[0..]] -> [n:=2*h+1] -> [[i,j::int] -> [d:=i-j] -> [mx[i,j] =[def]= ((d+h)%n *n +1 +(j-d)%n)]] -> [
    [[i::int] -> [sum{mx[i,j] | [j:<-[0..<n]]} == (2hh+2h+1)*n]]
        #行和
    [[j::int] -> [sum{mx[i,j] | [i:<-[0..<n]]} == (2hh+2h+1)*n]]
        #列和
    [sum{mx[k,k] | [k:<-[0..<n]]} == (2hh+2h+1)*n]
        #对角线和
    [sum{mx[k,n-1-k] | [k:<-[0..<n]]} == (2hh+2h+1)*n]
        #反对角线和
    [[i,j::int] -> [mx[i,j]+mx[n-1-i,n-1-j] == nn+1]]
        #互补对称性
    [[a,b,i,j::int] -> [mx[a,b] == mx[i,j]] -> [[a%n==i%n][b%n==j%n]]]
        #周期内唯一性
    [[i,j::int] -> [1 <= mx[i,j] <= nn]]
        #取值范围
]]
证明:特性纟标准泛九宫配置
    #########
    #行和:
    [sum{mx[i,j] | [j:<-[0..<n]]}
    == sum{((d+h)%n *n +1 +(j-d)%n) | [j:<-[0..<n]]}
    !! [d==i-j]
    == sum{((i-j+h)%n *n +1 +(2*j-i)%n) | [j:<-[0..<n]]}
    !! [n%2==1]
    => [sum{(2*j-i)%n | [j:<-[0..<n]]} == sum{k%n | [k:<-[0..<n]]}]
    == sum{(k%n *n +1 +k%n) | [k:<-[0..<n]]}
    == n + sum{k | [k:<-[0..<n]]}*(n+1)
    == n + (n-1)*n///2 *(n+1)
    == n + 2h*n///2 *(2h+2)
    == n + 2h*n*(h+1)
    == n*(1 + 2h*(h+1))
    == (2hh+2h+1)*n
    ]
    [sum{mx[i,j] | [j:<-[0..<n]]} == (2hh+2h+1)*n]
        #行和
    #########
    #列和:
    [sum{mx[i,j] | [i:<-[0..<n]]}
    == sum{((d+h)%n *n +1 +(j-d)%n) | [i:<-[0..<n]]}
    !! [d==i-j]
    == sum{((i-j+h)%n *n +1 +(2*j-i)%n) | [i:<-[0..<n]]}
    == sum{(k%n *n +1 +k%n) | [k:<-[0..<n]]}
    !! 同上:
    == (2hh+2h+1)*n
    ]
    [sum{mx[i,j] | [i:<-[0..<n]]} == (2hh+2h+1)*n]
        #列和
    #########
    #对角线和:
    [sum{mx[k,k] | [k:<-[0..<n]]}
    == sum{((d+h)%n *n +1 +(k-d)%n) | [k:<-[0..<n]]}
    !! [d==i-j==k-k==0]
    == sum{((0+h)%n *n +1 +(k-0)%n) | [k:<-[0..<n]]}
    == sum{(h*n +1 +k%n) | [k:<-[0..<n]]}
    == (h*n +1)*n +sum{k | [k:<-[0..<n]]}
    == (2hh +h +1)*n +(n-1)*n///2
    == (2hh +h +1)*n +2h*n///2
    == (2hh+2h+1)*n
    ]
    [sum{mx[k,k] | [k:<-[0..<n]]} == (2hh+2h+1)*n]
        #对角线和
    #########
    #反对角线和:
    [sum{mx[k,n-1-k] | [k:<-[0..<n]]}
    == sum{((d+h)%n *n +1 +((n-1-k)-d)%n) | [k:<-[0..<n]]}
    !! [d==i-j==k-(n-1-k)==(2k-2h)]
    == sum{(((2k-2h)+h)%n *n +1 +((2h-k)-(2k-2h))%n) | [k:<-[0..<n]]}
    == sum{((2k-h)%n *n +1 +(4h-3k)%n) | [k:<-[0..<n]]}
    !! [n%2==1]
    == sum{(t*n +1 +(-2-3t)%n) | [t:<-[0..<n]]}
    == (n-1)*n///2 *n +n +sum{(-2-3t)%n | [t:<-[0..<n]]}
    == (2hh+h+1)*n +sum{(-2-3t)%n | [t:<-[0..<n]]}
    == (2hh+h+1)*n +[n%3=!=0]sum{(-2-3t)%n | [t:<-[0..<n]]} +[n%3==0]sum{(-2-3t)%n | [t:<-[0..<n]]}
    == (2hh+h+1)*n +[n%3=!=0]sum{u | [u:<-[0..<n]]} +[n%3==0]3*sum{(-2-3v)%n | [v:<-[0..<n///3]]}
    == (2hh+h+1)*n +[n%3=!=0]h*n +[n%3==0][s:=(n-3)///6]3*sum{(-2-3v)%n | [v:<-[0..=2s]]}
    !! [2h+1==n==(6s+3)][h==3s+1]
    == (2hh+h+1)*n +[n%3=!=0]h*n +[n%3==0]3*sum[1,4,..=n-2]
    == (2hh+h+1)*n +[n%3=!=0]h*n +[n%3==0]3* n///3 *(n-1) ///2
    == (2hh+h+1)*n +[n%3=!=0]h*n +[n%3==0]n*h
    == (2hh+h+1)*n +h*n
    == (2hh+2h+1)*n
    ]
    [sum{mx[k,n-1-k] | [k:<-[0..<n]]} == (2hh+2h+1)*n]
        #反对角线和
    #########
    #互补对称性:
    [mx[i,j]+mx[n-1-i,n-1-j]
    == mx[i,j]+mx[n-1-i,n-1-j]
    !! [_d:=(n-1-i)-(n-1-j)==j-i==-d]
    == ((d+h)%n *n +1 +(j-d)%n) +((-d+h)%n *n +1 +((n-1-j)- -d)%n)
    == ((d+h)%n +(-d+h)%n) *n +2 +((j-d)%n +((n-1-j)- -d)%n)
    == ((d+h)%n +(2h-(d+h))%n) *n +2 +((j-d)%n +(2h-(j-d))%n)
    == 2h *n +2 +2h
    == 2h *(n+1) +2
    == (n-1)*(n+1) +2
    == nn+1
    ]
    [mx[i,j]+mx[n-1-i,n-1-j] == nn+1]
        #互补对称性
    #########
    #周期内唯一性:
    [[mx[a,b] == mx[i,j]] -> [[a%n==i%n][b%n==j%n]]]
    [mx[a,b] == mx[i,j]]:
        [d:=i-j]
        [_d:=a-b]
        [((d+h)%n *n +1 +(j-d)%n) == ((_d+h)%n *n +1 +(b-_d)%n)]

        [((d+h)%n *n +(j-d)%n) == ((_d+h)%n *n +(b-_d)%n)]

        [(d+h)%n == (_d+h)%n][(j-d)%n == (b-_d)%n]
        [d%n == _d%n][(j-d)%n == (b-_d)%n]
        [d%n == _d%n][j%n == b%n]
        [(i-j)%n == (a-b)%n][j%n == b%n]
        [i%n == a%n][j%n == b%n]
    [[mx[a,b] == mx[i,j]] -> [[a%n==i%n][b%n==j%n]]]
        #周期内唯一性
    #########
    #取值范围:
    [mx[i,j]
    == ((d+h)%n *n +1 +(j-d)%n)
    <= ((n-1) *n +1 +(n-1))
    == nn
    ]
    [mx[i,j]
    == ((d+h)%n *n +1 +(j-d)%n)
    >= (0 +1 +0)
    == 1
    ]
    [1 <= mx[i,j] <= nn]
        #取值范围
    #########
]]]]]
<<==:
[[
公式:
    [h:=(n-1)///2]
        #1
    [n==2h+1]
        #3
    中心: [c:=(n**2+1)///2]
        # [c == (2hh+2h+1)]
        # [2*c == (4hh+4h+2)]
        #5
    对角线: [c-h..=c+h]
        [(n**2-n+2)///2..=(n+1)*n///2]
        [(n-1)*n///2+1..=(n+1)*n///2]
        [(2hh+h+1)..=(2hh+3h+1)]
        #[4..=6]
    下一对角线、相应跳线/右上角: [c-h-1]++[c-h-n..=c-h-3]、[c-h-2]
        [(2hh+h)]++[(2hh-h)..=(2hh+h-2)]、[(2hh+h-1)]
        #[3]++[1..=1]，[2]
    上一对角线、相应跳线/左下角:[c+h+3..=c+h+n]++[c+h+1]、[c+h+2]
        [(2hh+3h+4)..=(2hh+5h+2)]++[(2hh+3h+2)]、[(2hh+3h+3)]
        #[9..=9]++[7]，[8]
    左一列:[c-h]++[c-h-1,c-h-1-(n+1)..c-h-1-(n+1)*(h-1)]++[c+h+2+(n+1)*(h-1)..c+h+2+(n+1),c+h+2]
        [(2hh+h+1)]++[(2hh+h),(2hh-h-2)..(3h+4),(h+2)]++[nn-h==(4hh+3h+1)..(2hh+5h+5),(2hh+3h+3)]
        #[4]++[3,{#-1..7#},3]++[8..{#12#},8]
    顶一行:[c-h,c-h+(n+2)..=c-h+(n+2)h]++[2,2+(n+2)..=2+(n+2)*(h-1)]
        [(2hh+h+1),(2hh+3h+4)..=(4hh+4h+1)==nn]++[2,(2h+5)..=2hh+h-1]
        #[4,9..=9]++[2,{#7#}..=2]
    互补对称性:[mx[i,j]+mx[n-1-i,n-1-j] == 2*c]
    底一行:[2*c-2-(n+2)*(h-1)..2*c-2-(n+2),2*c-2]++[1,1+(n+2)..=1+(n+2)h]
        [(2hh+3h+3)..(4hh+2h-3),(4hh+4h)==nn-1]++[1,(2h+4)..=(2hh+3h+1)]
        #[8..{#3#},8]++[1,6..=6]
    下三角的偏对角线上的最大值位置是:
        {(1,0),(3,1),(5,2),...,(2h-1,h-1)}
        {(2j+1,j) | [j:<-[0..<h]]}
    mx[i,j]
        | i==j = j+  (2hh+h+1)
        | i<j = (nn+1) -mx[j,i]
        | i>j =
            #下三角
            #{除去开头}左一列:[(2hh+h+1)]++[(2hh+h),(2hh-h-2)..(3h+4),(h+2)]++[nn-h==(4hh+3h+1)..(2hh+5h+5),(2hh+3h+3)]
            #{除去结尾}底一行:[(2hh+3h+3)..(4hh+2h-3),(4hh+4h)==nn-1]++[1,(2h+4)..=(2hh+3h+1)]
            let [d:=i-j]
            | h+1 <= d <= 2*h = j+  (nn-h)-(d-h-1)*(n+1)
                or = (i-2h)+  (nn-1)-(d-h-1)*(n+2)
                #左一列下半:...++[nn-h==(4hh+3h+1)..(2hh+5h+5),(2hh+3h+3)]
                #底一行前半:[(2hh+3h+3)..(4hh+2h-3),(4hh+4h)==nn-1]++...
            | 1 <= d <= h =
                | j < h && i >= 2j+1 = j+  (h+2) +(h-d)*(n+1)
                    #左一列上半:...++[(2hh+h),(2hh-h-2)..(3h+4),(h+2)]++...
                | i < 2j+1 = (i-2h)+  1+(h-d)*(n+2)
                    #底一行后半:...++[1,(2h+4)..=(2hh+3h+1)]{除去结尾}
]]
<<==:
[[
py_adhoc_call   script.九宫泛化   ,枚举冫标准泛九宫灬扌 +to_chain ='[3,5,7,9,11]'
[4, 9, 2]
[3, 5, 7]
[8, 1, 6]
[11, 18, 25, 2, 9]
[10, 12, 19, 21, 3]
[4, 6, 13, 20, 22]
[23, 5, 7, 14, 16]
[17, 24, 1, 8, 15]
[22, 31, 40, 49, 2, 11, 20]
[21, 23, 32, 41, 43, 3, 12]
[13, 15, 24, 33, 42, 44, 4]
[5, 14, 16, 25, 34, 36, 45]
[46, 6, 8, 17, 26, 35, 37]
[38, 47, 7, 9, 18, 27, 29]
[30, 39, 48, 1, 10, 19, 28]
[37, 48, 59, 70, 81, 2, 13, 24, 35]
[36, 38, 49, 60, 71, 73, 3, 14, 25]
[26, 28, 39, 50, 61, 72, 74, 4, 15]
[16, 27, 29, 40, 51, 62, 64, 75, 5]
[6, 17, 19, 30, 41, 52, 63, 65, 76]
[77, 7, 18, 20, 31, 42, 53, 55, 66]
[67, 78, 8, 10, 21, 32, 43, 54, 56]
[57, 68, 79, 9, 11, 22, 33, 44, 46]
[47, 58, 69, 80, 1, 12, 23, 34, 45]
[56, 69, 82, 95, 108, 121, 2, 15, 28, 41, 54]
[55, 57, 70, 83, 96, 109, 111, 3, 16, 29, 42]
[43, 45, 58, 71, 84, 97, 110, 112, 4, 17, 30]
[31, 44, 46, 59, 72, 85, 98, 100, 113, 5, 18]
[19, 32, 34, 47, 60, 73, 86, 99, 101, 114, 6]
[7, 20, 33, 35, 48, 61, 74, 87, 89, 102, 115]
[116, 8, 21, 23, 36, 49, 62, 75, 88, 90, 103]
[104, 117, 9, 22, 24, 37, 50, 63, 76, 78, 91]
[92, 105, 118, 10, 12, 25, 38, 51, 64, 77, 79]
[80, 93, 106, 119, 11, 13, 26, 39, 52, 65, 67]
[68, 81, 94, 107, 120, 1, 14, 27, 40, 53, 66]


]]
<<==:
[[
九宫-->二十五宫/五五宫
4 9 2
3 5 7
8 1 6

4 . .
. 5 .
. . 6

. . 2
3 . .
. 1 .

. 9 .
. . 7
8 . .

11 .. .. .. ..
.. 12 .. .. ..
.. .. 13 .. ..
.. .. .. 14 ..
.. .. .. .. 15


11 .. .. 02 ..
.. 12 .. .. 03
04 .. 13 .. ..
.. 05 .. 14 ..
.. .. 01 .. 15

11 .. 25 02 ..
.. 12 .. 21 03
04 .. 13 .. 22
23 05 .. 14 ..
.. 24 01 .. 15

11 .. 25 02 09
10 12 .. 21 03
04 06 13 .. 22
23 05 07 14 ..
.. 24 01 08 15

11 18 25 02 09
10 12 19 21 03
04 06 13 20 22
23 05 07 14 16
17 24 01 08 15

]]
===
[[
__all__ = r'''
枚举冫标准泛九宫灬扌
构造冫标准泛九宫扌
    枚举冫顺次位置纟标准泛九宫扌
        求冫起始位置纟标准泛九宫扌
        求冫欤跃迁辻下一位置纟标准泛九宫扌
    校验冫泛九宫扌
        求冫格值巛位置牜标准泛九宫扌
        求冫格值巛位置牜标准泛九宫牜周期延拓版扌
'''.split()#'''
__all__
from itertools import chain
from seed.tiny_.check import check_type_is, check_int_ge, check_int_ge_lt


def 求冫起始位置纟标准泛九宫扌(n, /):
    '-> coordinate'
    check_int_ge(0, n)
    if not n&1:raise ValueError(n)
    return (n-1, n>>1)
def 求冫欤跃迁辻下一位置纟标准泛九宫扌(n, coordinate8fst6this_diagonal, coordinate8prev, /):
    '-> (b_jmp/欤跃迁,coordinate)'
    i, j = coordinate8prev
    _i, _j = i+1, j+1
    _i %= n
    _j %= n
    coordinate8succ = (_i, _j)
    if not coordinate8succ == coordinate8fst6this_diagonal:
        return (False, coordinate8succ)
    _i, _j = i-1, j
    _i %= n
    coordinate8succ = (_i, _j)
    return (True, coordinate8succ)


def 枚举冫顺次位置纟标准泛九宫扌(n, /):
    'n/uint{odd} -> Iter coordinate/(uint%n, uint%n)'
    #-> coordinates
    ct00 = 求冫起始位置纟标准泛九宫扌(n)
    ct = ct0 = ct00
    while 1:
        yield ct
        (b_jmp, _ct) = 求冫欤跃迁辻下一位置纟标准泛九宫扌(n, ct0, ct)
        ct = _ct
        if b_jmp:
            ct0 = ct
            if ct0 == ct00:
                break


def 枚举冫标准泛九宫灬扌(ns, /, *, to_chain=False):
    it = map(构造冫标准泛九宫扌, ns)
    if to_chain:
        it = chain.from_iterable(it)
    return it

def 构造冫标准泛九宫扌(n, /):
    coordinates = 枚举冫顺次位置纟标准泛九宫扌(n)
    square = [[None]*n for i in range(n)]
    k = 0
    for k, (i,j) in enumerate(coordinates, 1):
        square[i][j] = k
    assert k == n**2
    校验冫泛九宫扌(n, square)
    return square
def 校验冫泛九宫扌(n, square, /):
    assert len(square) == n
    assert all(len(square[i]) == n for i in range(n))
    assert sorted(u for us in square for u in us) == [*range(1, 1+n**2)]
    SUM = (n**2+1)*n//2
    # [SUM == (n**2+1)*n**2/2/n]
    assert all(sum(square[i]) == SUM for i in range(n))
    assert all(sum(square[i][j] for i in range(n)) == SUM for j in range(n))
    assert sum(square[i][i] for i in range(n)) == SUM
    assert sum(square[i][n-1-i] for i in range(n)) == SUM
    #if 0b00001: _check_via_formula(n, square)
    assert all(square[i][j] == 求冫格值巛位置牜标准泛九宫扌(n, i, j) for i in range(n) for j in range(n))
def _check_via_formula(n, square, /):
    for i in range(n):
        for j in range(n):
            assert square[i][j] == (__:=求冫格值巛位置牜标准泛九宫扌(n, i, j)), (n, (i, j), (square[i][j], __))
    for i in range(n):
        for j in range(n):
            assert square[i][j] == (__:=求冫格值巛位置牜标准泛九宫牜周期延拓版扌(n, i, j)), (n, (i, j), (square[i][j], __))

def _check_nij(n, i, j, /):
    check_int_ge(0, n)
    if not n&1:raise ValueError(n)
    check_int_ge_lt(0, n, i)
    check_int_ge_lt(0, n, j)
def 求冫格值巛位置牜标准泛九宫扌(n, i, j, /):
    _check_nij(n, i, j)
    h = n >> 1
    hh = h**2
    nn = n**2
    if i == j:
        return j+  (2*hh+h+1)
    if i < j:
        #上三角
        # !! 互补对称性:[mx[i,j]+mx[n-1-i,n-1-j] == 2*c]
        return (nn+1) -求冫格值巛位置牜标准泛九宫扌(n, n-1-i, n-1-j)
    assert i > j
    #下三角
    d = i-j
    if d > h:
        assert h+1 <= d <= 2*h
        # !! 左一列下半:...++[nn-h==(4hh+3h+1)..(2hh+5h+5),(2hh+3h+3)]
        return j+  (nn-h)-(d-h-1)*(n+1)
        # !! 底一行前半:[(2hh+3h+3)..(4hh+2h-3),(4hh+4h)==nn-1]++...
        return (i-2*h)+  (nn-1)-(d-h-1)*(n+2)
    assert 1 <= d <= h
    # !! 下三角的偏对角线上的最大值位置是: {(2j+1,j) | [j:<-[0..<h]]}
    if j < h and i >= 2*j+1:
        # !! 左一列上半:...++[(2hh+h),(2hh-h-2)..(3h+4),(h+2)]++...
        return j+  (h+2) +(h-d)*(n+1)
    else:
        assert i < 2*j+1
        # !! 底一行后半:...++[1,(2h+4)..=(2hh+3h+1)]{除去结尾}
        return (i-2*h)+  1+(h-d)*(n+2)

def 求冫格值巛位置牜标准泛九宫牜周期延拓版扌(n, i, j, /):
    _check_nij(n, i, j)
    h = n >> 1
    d = i-j
    # !! 值为:((d+h)%n *n +1) +(j-d)%n
    return ((d+h)%n *n +1) +(j-d)%n

__all__
from script.九宫泛化 import 构造冫标准泛九宫扌
]]

]]]]]]]]]

