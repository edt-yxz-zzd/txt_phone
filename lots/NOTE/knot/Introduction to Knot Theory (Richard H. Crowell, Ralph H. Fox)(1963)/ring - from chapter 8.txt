
GJ[R, G] ::= {sum r[i]*g[i] {i=1..L} | L in NN, r: NN->R, g: NN->G}
    G - group
    R - ring (with identity??)
    NOTE: finite sum
    
    
    J[G] ::= group ring = GJ[ZZ, G]
    // G <= GJ[R,G], R <= GJ[R,G]
    I :: G -> GJ[R, G]
    I g = e[R] * g
    K :: R -> GJ[R, G]
    K r = r * e[G]


    

F[X] ::= free group generated by X
AB[G] ::= abelianed G = G/[G,G]
FA[X] ::= free abelian group generated by X = AB[F[X]]
JA[X] ::= J[FA[X]] = GJ[ZZ, FA[X]] = GJA[ZZ, X]
    // [group ring of free abelian group]
    // [abelianized group of group of link with card(X)-component]
GJA[R, X] ::= GJ[R, FA[X]]
    // ring of L-polynomials in variables X with coefficients in ring R
    // "L-" The letter "L" is suggested by the Laurent power series with negative exponents which arises in the theory of complex variables.
    
    GJA[R, X|Y] = GJA[GJA[R, X], Y\X]
    
    make_product :: (X->ZZ)->FA[X]
    make_product f = II x^f(x) {x in X}
    
    make_rproduct :: (X->ZZ|{+oo}) -> GJA[R,X]
    make_rproduct f = II 0[GJA[R,X]] if f(x)=+oo else I[x^-f(x)] {x in X}
    ==>> make_rproduct f * make_rproduct g = make_rproduct (\x: f x + g x)
    
    coeff :: (X->ZZ) -> GJA[R, X] -> R
    coeff x2exp gsum = coefficient of term (make_product x2exp) in gsum
    
     
    min_exps :: GJA[R, X] -> (X->ZZ|{+oo}) 
    min_exps s u // min exp of u in terms with nonzero coeff of sum s
        = mi sum coeff(f, s) * make_product f {f:X->ZZ} u
        = min default=+oo: f(u) {f:X->ZZ | if coeff(f, s) /= 0[R]}
    
    ==>> min_exps (s*t) u = min_exps s u + min_exps t u
         min_exps (s*t) = \u: min_exps s u + min_exps t u


P[R, X] ::= ring of polynomials in variables X with coefficients in ring R
    - polynomial is a "finite" sum without x^-1
    - [ring R]
    
    [I[x^-1] not in P[R, X]] ==>> P[R, X] < GJA[R, X]
    P[R, X|Y] = P[P[R, X], Y\X]
    
    
    to_polynomial :: GJA[R, X] -> P[R, X]
    to_polynomial s = s * make_rproduct (min_exps s)

    [s = 0[GJA[R, X]]] ==>> make_rproduct (min_exps s) = 0[GJA[R, X]]
    [s /= 0[GJA[R, X]]] ==>> make_rproduct (min_exps s) = I[?], i.e. a trivial unit
    ==>> [s ~ to_polynomial s]
    ==>> make_rproduct f * s = s * make_rproduct f

    to_polynomial s * to_polynomial t 
        = s * make_rproduct (min_exps s) * t * make_rproduct (min_exps t)
        // make_rproduct f * s = s * make_rproduct f
        = s * t * make_rproduct (min_exps s) * make_rproduct (min_exps t)
        // make_rproduct f * make_rproduct g = make_rproduct (\x: f x + g x)
        = s * t * make_rproduct (\x: min_exps s x + min_exps t x)
        // min_exps (s*t) = \u: min_exps s u + min_exps t u
        = s * t * make_rproduct (min_exps (s*t))
        = to_polynomial (s*t)
    // [s ~ to_polynomial s] and to_polynomial (s*t) = to_polynomial s * to_polynomial t
    ==>> GJA[R, X] is associate to P[R, X] // see below
    

[ring divisibility]
    [ring with multiplicative identity] // ?? e[R] /= 0[R] ??
        ::= exists e[R] for a in R, e[R]*a = a = a*e[R]
        
        [unit] // element having an inverse
            unit u of R with e[R] ::= exist w, v in R, s.t. w*u = e[R] = u*v
            
            ==>> w = w*(u*v) = (w*u)*v = v
            ?? a*b = e[R] ==>> b*a = e[R] ==>> [unit a] ?? no!!
                a*e[R] = e[R]*a = (a*b)*a = a*(b*a)
                a*(e[R]-b*a) = 0[R]
                // but not an integral domain
                // fail
            
            [units of R is a multiplicative group]
            [trivial units of J[G]] ::= trivial_units[J[G]] = I[G] | -I[G] = {I[g], -I[g] | g in G}

    [commutative ring]
        ::= for a,b in R, a*b=b*a
        [divides]
            a, b in commutative ring R
            [a | b] ::= [a divides b] = exists c in R, s.t. a*c = b
                a*0 = 0 ==>> [a|0] for any a in R
                0*c = 0 ==>> [0|b] <--> b=0
                [a|b][b|c] ==>> [a|c]
                    exists a*s=b, b*t=c ==>> a*(s*t)=c
            [associates]
                [a, b are associates] ::= [a|b][b|a]
                [0, b are associates] ==>> [0|b] ==>> b=0
    
        [greatest common divisor of a finite set of ring elements]
            gcd_set(R, S) ::= {d | [d|s] for s in S; [a|d] for a in R if all [a|s] for s in S}
                where finite set S <= set[R]
            gcd(R, S) ::= an arbitrary element in gcd_set(R, S)
                but gcd_set(R, S) may be empty
    [commutative ring with identity]
        ["associates" is an equivalence relation]
            a*e[R] = a = e[R]*a // identity used here
                ==>> [a|a] 
                ==>> a ~ a
            a ~ b ::= [a|b][b|a]
                ==>> b ~ a = [b|a][a|b] = a ~ b
            a ~ b, b ~ c
                ==>> [a|b][b|a] [b|c][c|b]
                ==>> [a|b][b|c] [c|b][b|a]
                ==>> [a|c] [c|a]
                ==>> a ~ c
        [ideal generated by subset]
            ideal<R, S> = {sum s*f(s) {s in S} | any f:S->R}}
                        = the smallest ideal containing S
                where S <= set[R]
        [principal ideal] ::= principal_ideal(r) = ideal<R, {r}>
        [a, b are associates] <==> [ideal<R, {a}> = ideal<R, {b}>]
        if [finite S]:
            [d in gcd_set(R, S)] <==> [principal_ideal(d) = intersect principal_ideal(r) {r in R | S <= principal_ideal(r)}]
        
        
    [integral domain] <= [commutative ring]
        ::= for a,b in R, a*b=b*a, [a/=0][b/=0]-->>[a*b/=0]
        [a*b=a*c] ==>> [a*(b-c)=0[R]] ==>> [a=0[R]]||[b=c]
        
    [integral domain with identity]
        a*b = e[R] ==>> b*a = e[R] ==>> [unit a] // see [unit] above
        
        [prime p] ::= [not unit p][p=a*b -->> [unit a] or [unit b] for a, b in R]
        
        
        [a, b are associates] <==> exists unit u, s.t. a*u = b
            ==>>
                ==>> [a|b][b|a] 
                ==>> exists c, d, s.t. a*c=b, b*d=a
                ==>> a*(c*d) = a = a * e[R]
                ==>> a*(c*d - e[R]) = 0[R]
                ==>> a = 0[R] or c*d = e[R]
                ==>> (b = 0[R], u=e[R]) or (u=c)
            <<==
                ==>> exists v, u*v = e[R]
                ==>> a*u*v = b*v
                ==>> a = b*v
                ==>> [a|b][b|a]

    [commutative ring that is associate to a subring]
        subring Q <= commutative ring R
        exists mapping f: R->Q (not ring homomorphism??), s.t.
            for a in R, a ~ f(a)
            for a, b in R, f(a*b)=f(a)*f(b)
            
            [f(a) = 0[R]] <==> [a ~ 0[R] ~ f(a)] <==> [a = 0[R]]
            f(0[R]) * f(a) = f(0[R] * a) = 0[R] = f(0[R])
            ==>> 0[Q] = f(0[R]) = 0[R]
            
            if [exists e[Q] /= 0[Q]]:
                e[Q] /~ 0[Q] ==>> f(e[Q]) /= 0[Q]
                f(e[Q])*e[Q] = f(e[Q]) = f(e[Q]*e[Q]) = f(e[Q])*f(e[Q])

                if [integral domain Q]:
                    e[Q] = f(e[Q])
                    ==>> [integral domain R]
                    a in R
                    b = a * e[Q]
                    b * e[Q] = a * e[Q] * e[Q] = a * (e[Q] * e[Q]) = b = a * e[Q]
                    [e[Q] /= 0[R]] [integral domain R]
                    ==>> b = a
                    ==>> exists e[R], e[R]=e[Q]
                    ==>> exists unit[R], unit[Q] <= unit[R]
                    
        [integral domain Q] ==>> [integral domain R]
        [gcd domain Q] ==>> [gcd domain R] // see below [gcd domain]
        ?? [unique factorization domain Q] ==>> [unique factorization domain R] ?? yes!!
            ==>> [integral domain R][exists e[Q]]
            ==>> exists e[R]
            ==>> [gcd domain R with identity]
            ==>> exists unit[R]
            ==>> a ~ f(a) <==> exists u in unit[R], a = u*f(a)
            ==>> a = u*f(a) = u*u'*II prime[Q][i] {i}
            
            ?? prime[Q] <= prime[R] ?? yes
                p in prime[Q]
                s, t in R \ {0[R]} \ unit[R]
                if [p = s*t]:
                    p = u*f(p) = u*f(s)*f(t)
                    where u in unit[Q]
                          f(s), f(t) in Q \ {0[Q]} \ unit[Q]
                    ==>> p not in prime[Q]
            ==>> right
                
                

    [gcd domain] <= integral domain
        ::= for a,b in R, a*b=b*a, [a/=0][b/=0]-->>[a*b/=0]
            and gcd is well-defined
    
    [unique factorization domain] <= [integral domain with identity]
        ::= an [integral domain with identity], s.t.
            for a in R, [a=0[R]] or [unit a] or [a has an essentially unique factorization into primes]
            [factorization into primes is essentially unique] ::= u * II p {prime p} where [unit u]
.       ==>> [unique factorization domain] <= [gcd domain]

        
    [integral domain R] ==>> [integral domain P[R, {x}]]
        ==>> [integral domain P[R, X]]
    (2.5)(by Gauss): [unique factorization domain R] ==>> [unique factorization domain P[R, {x}]]
        ==>> [unique factorization domain P[R, X]]


    [unique factorization domain JA[X]]
        [JA[X] = GJA[ZZ, X]]
        
        [unique factorization domain ZZ]
            ==>> [commutative ring ZZ] 
            ==>> [commutative ring GJA[ZZ, X]]
        [unique factorization domain ZZ] 
            ==>> [unique factorization domain P[ZZ, X]]
        [GJA[R, X] is associate to P[R, X]]
            ==>> [GJA[ZZ, X] is associate to P[ZZ, X]]

        [[commutative ring R that is associate to a subring Q][unique factorization domain Q] -->> [unique factorization domain R]]
            ==>> [unique factorization domain GJA[ZZ, X]]
        ==>> [unique factorization domain JA[X]]

    [unit[JA[X]] = trivial_units[JA[X]]]
        to_polynomial :: JA[X] -> P[ZZ, X]
        unit[P[ZZ, X]] = {K[+1], K[-1]}
        u in unit[JA[X]] ==>> to_polynomial u in unit[P[ZZ, X]]
            ==>> to_polynomial u = u * make_rproduct (min_exps u) = K[+-1]
            ==>> u = make_rproduct (min_exps u)^-1 * K[+-1]
            ==>> u in trivial_units[JA[X]]
