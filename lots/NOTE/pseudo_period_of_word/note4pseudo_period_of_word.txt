
[[[[[[[[[
e ../lots/NOTE/pseudo_period_of_word/note4pseudo_period_of_word.txt



~/.../Download/wget_ $ ls -1hs /sdcard/0my_files/book/math/pseudo_period_of_word/
total 7.0M
4.3M 'Combinatorial Algorithms on Words(1985)(Guibas).djvu'
264K 'Combinatorics of periods in strings(2003)(Eric Rivals)(Sven Rahmann).pdf'
1.2M 'Periods in strings(1981)(Leo J Guibas)(Andrew M Odlyzko).pdf'
1.4M 'String overlaps, pattern matching, and nontransitive games(1981)(L.J Guibas)(A.M Odlyzko).pdf'



[[[
[[
1.2M 'Periods in strings(1981)(Leo J Guibas)(Andrew M Odlyzko).pdf'
=====
自相关函数 定义
[autocorrelation :: Eq a => [a] -> [Bool]]
[autocorrelation(s) =[def]= [s[i:] == s[:len(s)-i] for i in range(len(s))]]
互相关函数 定义
[correlation :: Eq a => [a] -> [a] -> [Bool]]
[correlation(s,t) =[def]= [s[i:i+L] == t[:L] for i in range(len(s))] for L in [min(len(s)-i, len(t))]]
    #不可交换
[autocorrelation(s) === correlation(s,s)]

[@M <- [2..]]:
  [is_period_of :: uint -> [uint%M] -> Bool]
  [is_period_of p w =[def]= [0 <= p < len w][w[:p] === w[len w -p:]]]
  [period_set_of :: [uint%M] -> {uint}]
  [period_set_of w =[def]= {p <- [0..<len w] | [w[:p] === w[len w -p:]]}]

  #basic_period is not period
  #pi(w)
  [basic_period_of :: [uint%M]{len=S} -> uint/({1..<S}\-/{S})]
    [S>=1]==>>[basic_period_of :: [uint%M]{len=S} -> {1..=S}]
  [basic_period_of w = basic_period5period_set_ (len w) (period_set_of w)]
    #basic_period may be (len w) which is not period
    #basic_period may be 0 which == (len w)
  [basic_period5period_set_ S ps = min((ps \-\{0}) \-/{S})]

#see:all_period_sets_at, all_irreducible_period_sets_at



等价描述:
[characterization of autocorrelations]
  [@[v :: [Bool]] -> [
    [?[w :: [Bool]] -> [v==autocorrelation(w)]]
    <==> [@M <- [2..] -> ?[w :: [uint%M]] -> [v==autocorrelation(w)]]
    <==> [[len v >= 1] -> [[v[0]==1][forward_propagation_rule(v)][backward_propagation_rule(v)]]]
    <==> [recursive_predicate4autocorrelation(v)]
    ]]
@[v :: [Bool]]:#大前提
  #无需[len v >= 1]
  # 无需[v==autocorrelation(w)]
  # 试图建立 判断任意比特向量是否是字串自相关比特向量的条件
  #
  #FPR:前向传播约束
  [forward_propagation_rule(v) =[def]= @[p,q <- [0..<len v]] -> [p < q] -> [v[p]==1==v[q]] -> @[i <- [2..(len v -p)//(q-p)]] -> [v[p+i*(q-p)]==1]]
  #BPR:后向传播约束
  [backward_propagation_rule(v) =[def]= @[p,q <- [0..<len v]] -> [p < q < 2*p] -> [v[p]==1==v[q]] -> [v[2*p-q]==0] -> @[i <- [2..=min(p, len v -p)//(q-p)]] -> [v[p-i*(q-p)]==0]]
  #公约数约束
  [GCD_rule(v) =[def]= [[v[0]==1][forward_propagation_rule(v)][backward_propagation_rule(v)]] -> @[p,q <- [0..<len v]] -> [let g := gcd(p,q)] -> [v[p]==1==v[q]] -> [p+q<=len v +g] -> [v[g]==1]]
    #下面『反GCD_rule』 =[def]= 『不满足GCD_rule的前置条件[p+q<=len v +g]』
  #O(len v) 线性递归断言囗自相关比特向量
  [recursive_predicate4autocorrelation(v) =[def]= [len v >= 1] -> [let p := basic_period_of v] -> [[v[0]==1][
    #v is not empty
    #0 < p <= len v
    [[len v >= 2*p] -> [let r := len v %p +p] -> [let tail := v[len v -r:]] -> [
      #[0 < len tail == r <- [p..<2*p]]
      [@[i<-[1..<len v -r]] -> [v[i] == [i%p==0]]]
      [[r =!= p] -> [tail[p]==1]]
        #turn on if not at end of v
      [[basic_period_of tail < p] -> [p+basic_period_of tail > r+gcd(p, basic_period_of tail)]]
        #avoid GCD_rule
      [recursive_predicate4autocorrelation(tail)]
        #recur, tail is not empty
      ]]
    [[len v < 2*p] -> [let r := len v-p] -> [let tail := v[p:]] -> [
      #[0 <= len tail == r <- [0..<p]]
      [@[i<-[1..<p]] -> [v[i] == 0]]
      [recursive_predicate4autocorrelation(tail)]
        #recur, tail may be empty
      ]]
  ]]]



#number of distinct correlations of length n
[num_period_sets_at :: @[S <- [1..]] -> uint]
[num_period_sets_at S =[def]= len (all_period_sets_at S)]

[n足够大之后[n ~~> +oo] ==>> 1/(2*ln(2)) +o(1) <= ln (num_period_sets_at S) / (ln S)**2 <= 1/(2*ln(3/2)) +o(1)]


#primitive period
#primitive_period
@[M <- [2..]]:
  [is_primitive_period_of :: uint -> [uint%M] -> Bool]
  [is_primitive_period_of p w =[def]= [is_period_of p w][@d <- [1..<p] -> [p%d==0] -> [not$ is_period_of d w]]]
  [[is_primitive_period_of p w] === [is_period_of p w][let bp := basic_period_of w][[p<-{0,bp}]or[p%bp =!=0]]]
    #反GCD_rule ==>> [除了 basic_period以及它的倍数，其他拟周期 > 句长/2]
    #primitive_period <==> 不是其他拟周期的倍数的拟周期/允0 <==> 不是basic_period的真倍数的拟周期
[is_autocorrelation_bit_vector v]: #大前提
  [period_set5autocorrelation v =[def]= {p <- [0..<len v] | [v[p]==1]}]
  [basic_period_of__5autocorrelation v =[def]= basic_period5period_set_ (len v) $ period_set5autocorrelation v]
  [is_period_of__5autocorrelation p v =[def]= [0 <= p <= len v][[p=!=len v] -> [v[p]==1]]]
  [is_primitive_period_of__5autocorrelation p v =[def]= [is_period_of__5autocorrelation p v][let bp := basic_period_of__5autocorrelation v][[p<-{0,bp}]or[p%bp =!=0]]]

[@M <- [2..]][@tail :: [Bool]][is_autocorrelation_bit_vector tail][let T := len tail]: #大前提
  #M - 字母表规模
  #S - 整句句长
  # [T >= 0] # tail允空
  #
  [允负双缀自由度 :: (M?, tail?) => Integer -> uint]
  [允负双缀自由度 M tail 允负双缀长度 =[def]=
      #假设 句长S
      #假设 k,T 都是 整句 的 双缀长度
      #假设 S > k >= T == len tail
      #假设 [k>T][k 与 T 之间 没有其他 双缀长度]or[k==T][S 与 T 之间 没有其他 双缀长度]
      # 允负双缀长度 := 2*k -S
      #
      if 允负双缀长度 > len tail then 0 else
        # <==> [2*k -S > T]
        # <==> [S < 2*k-T]
        # !![k < S]
        # !![2*k-S < k]
        # [T < 2*k-S < k]
        # [(2*k-S) 也是 双缀长度/正整数]
        # !![k>T][k 与 T 之间 没有其他 双缀长度]
        # ==>> 不存在
        #
      if 1 <= 允负双缀长度 <= len tail then tail[len tail-允负双缀长度] else
        # <==> [1 <= 2*k -S <= T]
        # <==> [2*k-T <= S < 2*k]
        # 允负双缀长度@(2*k-S) 是 整句[:T]的 一个 双缀长度
        # <==> T - (2*T-S) 是 整句[:T]的 一个 拟周期
        # <==> [tail[len tail-允负双缀长度] == 1]
        # ==>> 不存在 或 唯一
        #
      if 允负双缀长度 <= 0 then M**(-允负双缀长度)
        # <==> [2*k -S <= 0]
        # <==> [2*k <= S]
        # <==> S = k +(S-2*k) + k
        # <==> 中间 长度为(S-2*k)的 字串 可任选
        # <==> 总数为M**(S-2*k)
        #
      else _L #不可能的分支
  ]
  [is_simplex_autocorrelation_endswith tail v =[def]= [is_autocorrelation_bit_vector(v)][let len_prefix := (len v - len tail)][v[len_prefix:] == tail][@[i <- [0..<len_prefix]] -> [v[i]==[i==0]]]]
    # [[v == tail]or[v==[1,0,0..][:S-T]++tail]]
  [is_simplex_autocorrelation_endswith tail v == [
      [let len_prefix := (len v - len tail)]
      [len_prefix >= 0]
      [v[len_prefix:] == tail]
      [@[i <- [0..<len_prefix]] -> [v[i]==[i==0]]]
        # tail or 10..0 ++ tail
      [[is_period_of__5autocorrelation len_prefix tail] -> [is_primitive_period_of__5autocorrelation len_prefix tail]]
        #满足 BPR/backward_propagation_rule
        #   #自动满足 FPR/forward_propagation_rule
    ]]

  [len tail <= S]: #大前提
    [pseudo_mk_simplex_autocorrelation_endswith tail S =[def]= if T==S then tail else [1]++[0]*(S-T-1)++tail]

  [is_good_args4mk_simplex_autocorrelation_endswith tail S =[def]= [is_autocorrelation_bit_vector tail][len tail <= S][is_simplex_autocorrelation_endswith$ pseudo_mk_simplex_autocorrelation_endswith tail S]]

  [is_good_args4mk_simplex_autocorrelation_endswith tail S]: 大前提
    [mk_simplex_autocorrelation_endswith tail S =[def]= pseudo_mk_simplex_autocorrelation_endswith tail S]

  #允许[not$ is_autocorrelation_bit_vector tail]
  [population_size_of_simplex_endswith__ M tail S =[def]=
    let v := pseudo_mk_simplex_autocorrelation_endswith tail S
    in  if is_simplex_autocorrelation_endswith v
        then population_size_of__ M S $ period_set5autocorrelation v
        else 0
    ]

  #允许[not$ is_autocorrelation_bit_vector tail]
  [population_size_of_complex_endswith__ M tail S =[def]= sum~ population_size_of__ M S $ period_set5autocorrelation $ init++tail ~{init :: [Bool]{len=S-T} | [is_autocorrelation_bit_vector (init++tail)]}]

  #basic_population_recurrence
  #   see:equation_about_num_free_characters_and_population_size
  [[
    [let population_simplex_ := population_size_of_simplex_endswith__ M tail]
    [let 允负双缀自由度囗 := 允负双缀自由度 M tail]
    [let population_complex__ S k := 允负双缀自由度囗(2*k-S)*population_simplex_(k)]
    [let is_good_arg_ := is_good_args4mk_simplex_autocorrelation_endswith tail]
    ][@S::uint] -> [
      [[S>=T] -> [is_good_arg_ S] -> [
        population_simplex_(S)
        == 2*(population_complex__ S T) - sum~ (population_complex__ S k) ~{k <- [T..=(S+T)//2] | [is_good_arg_ k]}
        == (population_complex__ S T) - sum~ (population_complex__ S k) ~{k <- [T+1..=(S+T)//2] | [is_good_arg_ k]}
        ]]
        #{k <- [T+0/+1..=(S+T)//2] \-\ let bp := basic_period_of__5autocorrelation tail in [T+2*bp, T+3*bp, ..]}
      [[S>=T] -> [not$ is_good_arg_ S]  -> [population_simplex_(S) == 0]]
      [[S<T]  -> [population_simplex_(S) == 0]]
  ]]
    #
    # why ???[k <- [T..=(S+T)//2]]???
    #   [k < T]:
    #       [population_simplex_(k) ==0]
    #   [2*k-S > T]:
    #       [允负双缀自由度囗(2*k-S) ==0]
    #   [2*k-S > T] <==> [k > (S+T)/2]
    #   ==>> 只有[k <- [T..=(S+T)//2]] 『和项』才有可能非零
    #
    #
    #
    #
  [[proof:
    [T <= S][@k <- [T..=(S+T)//2]][is_good_args4mk_simplex_autocorrelation_endswith tail k]:
      #conclusion: [population_simplex_(S) == (population_complex__ S T) - sum~ (population_complex__ S k) ~{k <- [T+1..=(S+T)//2] | [is_good_arg_ k]}]
      #

      # (population_complex__ S k) == ?
      #
      !![T <= S]
      [(S+T)//2 <= S]
      [k <= S]

      !![T <= k <= (S+T)//2]
      [2*T <= 2*k <= S+T]
      [2*k-T <= S]
      #分支:[2*k-T <= S < 2*k]or[2*k <= S]
        #除去 [S < 2*k-T]


      #与 population_simplex_ 只是简单别名 不同，需要 证明 population_complex__ 的 命名 的 合理性！
      !![is_good_args4mk_simplex_autocorrelation_endswith tail k]
      [let extended_tail := (mk_simplex_autocorrelation_endswith tail k)]
      * [2*k <= S]:
        ##[T <= k <= S//2]
        [(population_complex__ S k)
        = 允负双缀自由度囗(2*k-S)*population_simplex_(k)
          # [(2*k-S) <= 0]
        = M**(S-2*k)*population_simplex_(k)
            #整句{len=S} == 双缀{len=k} ++ 中间{len=(S-2*k)} ++ 双缀{len=k}
        = population_size_of_complex_endswith__ M extended_tail S
          #注意:双缀长度是k不是T。做了简单延展
        ]
      * [2*k-T <= S < 2*k]:
        ##[T <= k <= min-or-max{(S+T)//2, 2*k-T} <= S < 2*k]
        #   [T=2][k=3][S=4..5][3==(S+T)//2 < 2*k-T==4]
        #   [T=4][k=4][S=4..7][4..5==(S+T)//2 >= 2*k-T==4]
        #
        [(population_complex__ S k)
        = 允负双缀自由度囗(2*k-S)*population_simplex_(k)
          # [1 <= (2*k-S) <= T]
        = tail[T-(2*k-S)]*population_simplex_(k)
        = tail[S+T-2*k]*population_simplex_(k)
          #不满足backward_propagation_rule的k，一早被is_good_args4mk_simplex_autocorrelation_endswith排除
          #因为同时满足FPR/BPR，是合格的 字串自相关比特向量
        = [is_good_arg_ k]*tail[S+T-2*k]*population_simplex_(k)
        = population_size_of_complex_endswith__ M extended_tail S
        ]
      #
      [population_complex__ S k === population_size_of_complex_endswith__ M extended_tail S]
        # vs: [let population_simplex_ := population_size_of_simplex_endswith__ M tail]
        # diff: extended_tail<k,tail> vs tail

    #[k==T]:is_good_arg_
    !![is_good_args4mk_simplex_autocorrelation_endswith tail T]
    [population_complex__ S T === population_size_of_complex_endswith__ M (mk_simplex_autocorrelation_endswith tail T) S]


    [let lhs := population_simplex_(S)]
      # population_simplex_(S) == 满足 自相关比特向量 (10...0++tail 总长S) 的所有word的总数
    [let rhs := (population_complex__ S T) - sum~ (population_complex__ S k) ~{k <- [T+1..=(S+T)//2] | [is_good_arg_ k]}]
      # (population_complex__ S k) == 满足 自相关比特向量 (1x..z ++ (10...0++tail 总长k) 总长S) 的所有word的总数
    显然 [lhs==rhs]
  ]]#end-proof





]]
[[
264K 'Combinatorics of periods in strings(2003)(Eric Rivals)(Sven Rahmann).pdf'
=====
@[v :: [Bool]]:#大前提
  [is_autocorrelation_bit_vector(v) =[def]= [?[w :: [Bool]] -> [v==autocorrelation(w)]]]


[@[v :: [Bool]] -> [is_autocorrelation_bit_vector v] -> @[i,j :: uint] -> [0 <= i < j <= len v] -> [v[i]==1] -> [is_autocorrelation_bit_vector v[i:j]]]


#see:forward_propagation_rule
[forward_closure_ :: @[S::uint] -> @[ips::{uint%S}] -> ?[ps::{uint%S}] -> [ps === /-\~ {ps <- 2**{0..<S} | [ips |<=| ps][forward_propagation_rule(ps)]}]]
#FC
[forward_closure :: @[S::uint] -> {uint%S} -> {uint%S}]
[forward_closure S ips =[def]= fst $ forward_closure_ S ips]
[forward_closure S ips === let [ps := forward_closure_step S ips] in if ps == ips then ips else forward_closure S ps]
[forward_closure_step :: @[S::uint] -> {uint%S} -> {uint%S}]
[forward_closure_step S ips =[def]= ips \-/ {p+i*(q-p) | @[p,q <- ips], [p < q], [v[p]==1==v[q]], @[i <- [2..(S-p)//(q-p)]]}]


#IPS:不可约伪周期集合
#irreducible_period_set_of <== period_set_of
[@M <- [2..]][@S <- [1..]]: #大前提
  [all_irreducible_period_sets_of :: [uint%M]{len=S} -> {{uint%S}}]
  [all_irreducible_period_sets_of w =[def]= {ips <- 2**(period_set_of w) | [forward_closure S ips == w][@[ph,pi,pj <- ips] -> [ph < pi < pj] -> [(pj-pi)%(pi-ph) =!= 0]]}]
  ######
  # ips = irreducible_period_set
  # ps = period_set
  #
  #IPS :: word -> ips
  #R() :: ps -> ips
  #
  #IPS
  [irreducible_period_set_of :: [uint%M]{len=S} -> {uint%S}]
  [irreducible_period_set_of w =[def]= /-\~ {ips <- 2**(period_set_of w) | [forward_closure S ips == w]}]

  ######
  @[w :: [uint%M]{len=S}][irreducible_period_set_of w <- all_irreducible_period_sets_of w]
    #proof:???all_irreducible_period_sets_of不为空???

    ==> [bijective irreducible_period_set_of]

  #IPS :: word -> ips
  #R() :: ps -> ips
  #
  #R()
  [reduce__period_set :: sorted[uint%S] -> sorted[uint%S]]
  [reduce__period_set ps =[def]=
    let reversed_ips_ := ps[:1]
        idx4ps = 1 # skip 0
        ##useless: idx4ips = 1 # skip 0
        delta_period := S # ps[0] - 0
        excluded_period_set :: {uint%S}
        excluded_period_set := Set.empty
    in  reverse_list $ recur_ reversed_ips_ idx4ps delta_period excluded_period_set
    where
      recur_ reversed_ips_ idx4ps delta_period excluded_period_set =
        if (idx4ps == len ps) || (delta_period==1)
        then reversed_ips_ else
        let _delta_period := ps[idx4ps] - ps[idx4ps-1]
            len_pre_tail := S - ps[idx4ps-1]
            (times, r) := len_pre_tail /% _delta_period
              ##times >= 1
            (_reversed_ips_, _excluded_period_set, _idx4ps) := if ps[idx4ps] <- excluded_period_set
                then (reversed_ips_, excluded_period_set, idx4ps) else
                let excluded_period := ps[idx4ps-1] + times*_delta_period
                in  (ps[idx4ps]:reversed_ips_, excluded_period_set\-/if ps[idx4ps] < excluded_period < S then {excluded_period} else {}, idx4ps+max(0, times-2))
                  #原论文bug:mul==2时有避免n, 而mul>2时则无 #(mul~times, n~S)
        in  recur_ _reversed_ips_ (1+_idx4ps) _delta_period _excluded_period_set

  ]
  [inv reduce__period_set === forward_closure S]
  [bijective reduce__period_set]
  [bijective irreducible_period_set_of]
  [TIME(reduce__period_set ps) = O(let L := len (reduce__period_set ps) in L*log(L))]


[all_period_sets_at :: @[S <- [1..]] -> {{uint%S}}]
[all_period_sets_at S =[def]= {period_set_of w | [@w :: [Bool]][len w == S]}]

[all_irreducible_period_sets_at :: @[S <- [1..]] -> {{uint%S}}]
[all_irreducible_period_sets_at S =[def]= {reduce__period_set ps | [ps <- all_period_sets_at S]}]

#注意:[S >= 1]
@[S <- [1..]] -> @[ps <- all_period_sets_at S] -> [len (reduce__period_set ps) <= 1+floor_log<3/2>(S)]
  #[len (reduce__period_set ps) = O(log(S))]

[@S <- [1..]]: #大前提
  [is_lattice (all_period_sets_at S, (Set.|<=|))]
  [@[a,b <- all_period_sets_at S] -> [a /-\ b <- all_period_sets_at S]]
  [null_element__lattice (all_period_sets_at S, (Set.|<=|)) == {0}]
    #bottom?
  [universal_element__lattice (all_period_sets_at S, (Set.|<=|)) == {0..<S}]
    #top?
  [@a,b <- all_period_sets_at S]: #大前提
    [a /\ b === meet__lattice a b =[def]= a /-\ b]
    [a \/ b === join__lattice a b =[def]= /-\~ {c <- all_period_sets_at S | [(a \-/ b) |<=| c]}]
      #proof: ?the join exist&unique?

  [datatype Lattice a = [?xs :: Set a] -> Partially_CMP<xs>]
  [lattice4period_set_at S =[def]= (all_period_sets_at S, (Set.|<=|))]

[all_period_sets_at__with_basic_period_eq :: @[S <- [1..]] -> @[p <- [1..=S]] -> {{uint%S}}]
[all_period_sets_at__with_basic_period_eq S p =[def]= {ps | [@ps <- all_period_sets_at S][basic_period5period_set_ S ps == p]}]
[@S <- [1..]]: #大前提
  [sublattice4period_set_at__with_basic_period_eq S p =[def]= (all_period_sets_at__with_basic_period_eq S p, (Set.|<=|))]


[[[
https://encyclopediaofmath.org/wiki/Jordan-Dedekind_lattice

Jordan-Dedekind lattice
A lattice satisfying the following condition, known as the Jordan–Dedekind chain condition: All maximal chains have the same length.

The condition arose in connection with the Jordan–Hölder theorems for groups (cf. Jordan–Hölder theorem), and is equivalent to the condition of supersolvability in the lattice of all subgroups of a finite group (cf Supersolvable group).

A general reference is [a1]. See also Partially ordered set; Chain.

References
[a1] M. Hall, Jr., "The theory of groups" , Macmillan (1968)
]]]
[
偏序集
Partially ordered set

A non-empty set on which some order relation is given.

poset === (set<a>, partially_cmp<a>)
]
[
偏序集里的全序子集
https://encyclopediaofmath.org/wiki/Chain
Chain

In ordered sets
The same as a totally ordered set: in a general partially ordered set, a subset which is totally ordered with respect to the induced order. The rank of a partially ordered set is the maximal cardinality of a chain.

In algebraic topology
A formal linear combination of simplices (of a triangulation, of a simplicial set and, in particular, of singular simplices of a topological space) or of cells. In the most general sense it is an element of the group of chains of an arbitrary (as a rule, free) chain complex. A chain with coefficients in a group $G$ is an element of the tensor product of a chain complex by the group $G$.

References
[1] N.E. Steenrod, S. Eilenberg, "Foundations of algebraic topology" , Princeton Univ. Press (1966)
[2] P.J. Hilton, S. Wylie, "Homology theory. An introduction to algebraic topology" , Cambridge Univ. Press (1960)

]


[len4chain_in_poset chain =[def]= num_elements_of chain -1]
[satisfy_Jordan_Dedekind_condition poset =[def]= [is_poset poset][@[a,b <- poset] -> [a ~<~ b] -> [1==len {len chain | [@chain <- all_maximal_chains_between<poset>(a,b)]}]]]

[@S <- [1..]]: #大前提
  #The Jordan–Dedekind condition requires that all maximal chains between the same elements have the same length.
  [is_Jordan_Dedekind_lattice lattice =[def]= [is_lattice lattice][satisfy_Jordan_Dedekind_condition]]

  [is_chain_in :: Lattice a -> [a] -> Bool]
  [is_maximal_chain_in :: Lattice a -> [a] -> Bool]

  [[S >= 2] -> [let p := floor_half(S)+1][let lattice := lattice4period_set_at S][let ls := [{0..<S}]++[{0}\-/{i..<S} | [@i <- [p..=S]]]][is_maximal_chain_in<lattice> ls][len__chain ls == len ls -1 == (1 + S-p+1) -1 == S-p+1 == S-floor_half(S) == ceil_half(S)]]
    # 原论文 没有 [S >= 2]
    # [S >= 2] ==>> [p >= 2] ==>> [i >= 2] 确保 (1)与(S-p+1)不相交 即 (len ls) 正确
  精简:
    [[S >= 2] -> [let ls := [{0..<S}]++[{0}\-/{i..<S} | [@i <- [floor_half(S)+1..=S]]]][is_maximal_chain_in<lattice4period_set_at S> ls][len4chain_in_poset ls == ceil_half(S)]]
[@S <- [2..]]: #大前提
  [maximal_chain_in_lattice4period_set_at__via_half S =[def]= [{0..<S}]++[{0}\-/{i..<S} | [@i <- [floor_half(S)+1..=S]]]]

  #注意:[S >= 2]
  [@[p <- [floor_half(S)+1..<S]] -> [all_period_sets_at__with_basic_period_eq S p == {{0}\-/{p+tail_p | [@tail_p <- ps]} | [@ps <- all_period_sets_at (S-p)]}]]
    #   lifted
    #
    #当p足够大时，all_period_sets_at__with_basic_period_eq S p 与 all_period_sets_at (S-p) 的 关系
    #==>>当p足够大时，sublattice4period_set_at__with_basic_period_eq S p 与 lattice4period_set_at (S-p) 的 关系


  ########
  [let p := floor_half(S)+1]:
    lattice4period_set_at S
      maximal_chain_in_lattice4period_set_at__via_half S
      ---
      sublattice4period_set_at__with_basic_period_eq S p
      ===>
        lattice4period_set_at (S-p)
            maximal_chain_in_lattice4period_set_at__via_half (S-p)
            要求 [S-p >= 2]
              <==> [S-floor_half(S) >= 3]
              <==> [ceil_half(S) >= 3]
              <==> [S >= 6]
      <===
        lifted_maximal_chain_in_sublattice4period_set_at__via_half S := [{0..<S}]++(lift$ maximal_chain_in_lattice4period_set_at__via_half (S-p))++[{0}]
          #首段: ({0..<S}, {0}\-/{p..<S})
          #     === (maximal_chain_in_lattice4period_set_at__via_half S)[:2]
          #末段: ({0, p}, {0})
          #     不可插值，即 最大/maximal
          #注意: [p =!= 0]

        [[S>=6] -> [len (lifted_maximal_chain_in_sublattice4period_set_at__via_half S) == 2+ len (maximal_chain_in_lattice4period_set_at__via_half (S-p)) == 2+ ceil_half (S-p) == 2+ ceil_half (ceil_half S -1) == ceil_half (ceil_half S +3) == ceil_half$ ceil_half$ S+6 == ceil ((S+6)/4) == (S+9)//4]]
        精简:
          [[S>=6] -> [len (lifted_maximal_chain_in_sublattice4period_set_at__via_half S) == (S+9)//4]]
        !![[S>=2] -> [len (maximal_chain_in_lattice4period_set_at__via_half S) == ceil_half S == (S+1)//2 == 2*(S+1) //4]]
        [[S>=6] -> [[len (maximal_chain_in_lattice4period_set_at__via_half S) =!= len (lifted_maximal_chain_in_sublattice4period_set_at__via_half S)] <--> [(S+9)//4 =!= 2*(S+1)//4]]]
        [(S+9)//4 === 2*(S+1)//4]:
          [-1 < 2*(S+1)/4 - (S+9)/4 < 1]
          [-4 < 2*(S+1) - (S+9) < 4]
          [-4 < S - 7 < 4]
          [3 < S < 11]
        # hand inspection [S <- [4..=10]]
        [(S+9)//4 === 2*(S+1)//4] <==> [S <- [5,6,7,8]]
        [[S>=6] -> [[len (maximal_chain_in_lattice4period_set_at__via_half S) =!= len (lifted_maximal_chain_in_sublattice4period_set_at__via_half S)] <--> [(S+9)//4 =!= 2*(S+1)//4]] <--> [S <- [9..]]]
        ######
        也就是说，[S >= 9] 则 (maximal_chain_in_lattice4period_set_at__via_half S) 与 (lifted_maximal_chain_in_sublattice4period_set_at__via_half S) 给出2条长度不同的maximal_chain 连接 元素 universal_element__lattice/{0..<S} 与 null_element__lattice/{0}，故而 对于大多数S，(lattice4period_set_at S) 不满足 the_Jordan_Dedekind_condition
  [[S >= 9] -> [not$ is_Jordan_Dedekind_lattice (lattice4period_set_at S)]]

  [[S >= 7] -> [not$ is_Jordan_Dedekind_lattice (lattice4period_set_at S)]]
    #hand_inspection S<-[7,8] #原论文如此断言，我未核实



[@S <- [1..]]: #大前提
  [is_poset (all_irreducible_period_sets_at S, (Set.|<=|))]
  [poset4irreducible_period_set_at S =[def]= (all_irreducible_period_sets_at S, (Set.|<=|))]
  [[S >= 3] -> [not$ is_lattice (poset4irreducible_period_set_at S)]]
    # 元素/irreducible_period_set {0,1} 与 {0,2} 的 join__lattice 不存在，==>> 没有 universal_element__lattice ==>> 不是 格构
  [@[ips <- poset4irreducible_period_set_at S] -> @[ips_ <- 2**{0..<S}] -> [{0} |<=| ips_ |<=| ips] -> [ips_ <- poset4irreducible_period_set_at S]]
    # irreducible_period_set 的 任何 含0 子集 仍是 合法irreducible_period_set
    # 故而 [任意 maximal_chain长度 == 元素数量 -1]
    # ==>>: the_Jordan_Dedekind_condition
  [satisfy_Jordan_Dedekind_condition (poset4irreducible_period_set_at S)]



#[[[
# enumeration of all autocorrelations of length n
#
# to calc (all_period_sets_at__with_basic_period_eq S p) from (all_period_sets_at__with_basic_period_eq m q) for [[S >= 3][2<= p <= S-1][1 <= q <= m < 2*S/3][[all_period_sets_at__with_basic_period_eq S 1 = {{0..<S}}][all_period_sets_at__with_basic_period_eq S S = {{0}}] | [S <- [1..]]]]

def iter_all_period_sets_at__with_basic_period_eq():
  '-> Iter (len_of_word, basic_period, all_period_sets_at__with_basic_period_eq len_of_word basic_period)'
  sz2basic_period2all_period_sets = [{0:{}}, {1:{{0}}}, {2:{{0}}, 1:{{0,1}}}]
  for S, basic_period2all_period_sets in enumerate(sz2basic_period2all_period_sets):
    for p, pss in sorted(basic_period2all_period_sets.items()):
      yield S, p, pss

  def shift__up(S, S_, ps_):
      offset = S - S_
      common = range(0, offset, p)
      return ({*common}|{offset+p_ for p_ in ps_})

  for S in count(len(sz2basic_period2all_period_sets)):
    basic_period2all_period_sets = {}
    sz2basic_period2all_period_sets.append(basic_period2all_period_sets)
    if 1:
      p = 1
      pss = {{0..<S}}
      basic_period2all_period_sets[p] = pss
      yield S, p, pss

    for p in range(2, S//2+1):
      S_ = p+ (S%p)
      assert 2 <= p <= S_ < 2*p <= S
      assert p <= S-S_
      q2pss_ = sz2basic_period2all_period_sets[S_]
        #这里 f(S) <-- f(S_) where S_ < 2*S/3 # 比例最大化 于 [S==3*p-1][S_==2*p-1]
        # 可以 缩小S_ 为 S_smaller
        # f(S) <-- f(S_)
        # f(S_) <-- f(S_smaller)
        # ==>> f(S) <-- f(S_smaller) # f(S_) 临时动态计算出
        # 反GCD_rule ==>> [p+q > S_]
        # [S_smaller <= S_-q < p <= S//2]
        # 再加上for p in range(S//2+1, S): [S_ <= S//2]
        # ==>> 仅需 缓存至 S//2 而非 (2*S-1)//3

      #qs :=
      if S_ == p:
        qs = {q for q in range(2, p) if not p%q == 0}
      else:
        qs  = {p}
                # [q==p]
            | {q for q in range(S_-p+2, p) if S_ + gcd(p,q) < p + q}
                # [q<p] 并且 反GCD_rule
      qs
      pss = {shift__up(S, S_, ps_) for q in qs for ps_ in q2pss_[q] if S_ == p or p in ps_}
      basic_period2all_period_sets[p] = pss
      yield S, p, pss

    for p in range(S//2+1, S):
      S_ = S - p
      assert 1 <= S_ <= S//2 < p < S
      q2pss_ = sz2basic_period2all_period_sets[S_]

      pss = {shift__up(S, S_, ps_) for pss_ in q2pss_.values() for ps_ in pss_}
      basic_period2all_period_sets[p] = pss
      yield S, p, pss

    if 1:
      p = S
      pss = {{0}}
      basic_period2all_period_sets[p] = pss
      yield S, p, pss
#end-def iter_all_period_sets_at__with_basic_period_eq():
#]]]




nfc = (number of free characters)
# The nfc of a correlation v is the maximum number of positions in a string U with P(U) = v that are not determined by the periods.

#NFC
[num_free_characters_of_ :: @[S <- [1..]] -> @[ps <- all_period_sets_at S] -> uint]
[num_free_characters_of_ S ps =[def]=
  let p := basic_period5period_set_ S ps
  in  if p <- [S,1] then p else
      if p > n//2 then let S_ := S-p in 2*p-S + num_free_characters_of_ S_ shift__down(S_, S, ps) else
       let S_ := p+(S%p) in num_free_characters_of_ S_ shift__down(S_, S, ps)
where
  def shift__down(S_, S, ps):
      offset = S - S_
      return {p-offset for p in ps if p >= offset}
      common = range(0, offset, p)
      return {p-offset for p in ps\-\{*common}}
]


[population_size_of__ :: @[M <- [2..]] -> @[S <- [1..]] -> @[ps <- all_period_sets_at S] -> uint]
[population_size_of__ M S ps =[def]= len {word :: [uint%M]{len=S} | [period_set_of word == ps]}]


#equation_about_num_free_characters_and_population_size
#   see:basic_population_recurrence
[@M <- [2..]][@S <- [1..]]: #大前提
  #word :: [uint%M]{len=S}
  #   M-ary string of length S
  [@[ps <- all_period_sets_at S] -> [M**(num_free_characters_of_ S ps) == sum~ (population_size_of__ M S ps_ex) ~{ps_ex <- all_period_sets_at S | [ps |<=| ps_ex]}]]



]]
[[
1.4M 'String overlaps, pattern matching, and nontransitive games(1981)(L.J Guibas)(A.M Odlyzko).pdf'
=====
correlation
[polynomial5Ring :: Ring a => a -> Symbol -> Polynomial a Symbol]
[polynomial5Integer :: Integer -> Symbol -> Polynomial Integer Symbol]

[polynomial5bits :: [Bool] -> Symbol -> Polynomial Integer Symbol]
[polynomial5bits bits z =[def]= recur (polynomial5Integer 0 z) bits
  where
    #recur poly_high bits_low
    recur poly_high [] = poly_high
    recur poly_high (h:bits_low) = recur (poly_high*z + polynomial5Integer h z) bits_low
  ]

[generating_function :: Ring a => (uint -> a) -> Symbol -> GeneratingFunction Symbol a]
  # GeneratingFunction Symbol a === infinite:Polynomial a (1/Symbol)
  # generating_function f z = sum~ f(i)*z**(-i) ~{i :: uint}

#reduced_set_of_patterns
[@M <- [2..]]:
  [is_reduced_set_of_patterns :: {[uint%M]} -> Bool]
  [is_reduced_set_of_patterns patterns =[def]= [@[a,b <- patterns] -> [a =!= b] -> [not$ a in b]]]
  [reduced_set_of_patterns :: {[uint%M]} -> {[uint%M]}]
  [reduced_set_of_patterns patterns =[def]= patterns \-\ {a | [[@a,b <- patterns][a =!= b][a in b]]}]

[all_reduced_set_of_patterns_ :: @[M <- [2..]] -> {{[uint%M]}}]
[all_reduced_set_of_patterns_ M =[def]= {patterns :: {[uint%M]} | [is_reduced_set_of_patterns patterns]}]


[@M <- [2..]]:
    [mk_correlation_polynomial :: [uint%M] -> [uint%M] -> Symbol -> Polynomial Integer Symbol]
    [mk_correlation_polynomial prev_end_pattern next_end_pattern =[def]= polynomial5bits $ correlation prev_end_pattern next_end_pattern]
    [mk_correlation_polynomial 空串 _ _ === 0]

[all_words_ :: @[M <- [2..]] -> {[uint%M]}]
[all_words_ M =[def]= {word :: [uint%M]}]

[all_sized_words_ :: @[M <- [2..]] -> @[S <- [0..]] -> {[uint%M]{len=S}}]
[all_sized_words_ M S =[def]= {word :: [uint%M]{len=S}}]

[all_words_exclude_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> {[uint%M]}]
[all_words_exclude_ M patterns =[def]= {word :: [uint%M] | [@[pattern <- patterns] -> [pattern not in word]]}]


[all_sized_words_exclude_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[S <- [0..]] -> {[uint%M]{len=S}}]
[all_sized_words_exclude_ M patterns S =[def]= all_sized_words_ M S /-\ all_words_exclude_ M patterns]

[all_words_exclude_except_endby_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[end_pattern <- patterns] -> {[uint%M]}]
[all_words_exclude_except_endby_ M patterns end_pattern =[def]= {word :: [uint%M] | [[let S := len word][S >= len end_pattern][word.find(end_pattern) == S-len end_pattern][@[pattern <- patterns] -> [pattern =!= end_pattern] -> [pattern not in word]]]}]

[all_sized_words_exclude_except_endby_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[end_pattern <- patterns] -> @[S <- [0..]] -> {[uint%M]{len=S}}]
[all_sized_words_exclude_except_endby_ M patterns end_pattern S =[def]= all_sized_words_ M S /-\ all_words_exclude_except_endby_ M patterns end_pattern]






[population_size_exclude__ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[S <- [0..]] -> uint]
[population_size_exclude__ M patterns S =[def]= len (all_sized_words_exclude_ M patterns S)]

[population_size_exclude_except_endby__ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[end_pattern <- patterns] -> @[S <- [0..]] -> uint]
[population_size_exclude_except_endby__ M patterns end_pattern S =[def]= len (all_sized_words_exclude_except_endby_ M patterns end_pattern S)]

#system of linear equations about generating functions
#system_of_linear_equations_about_generating_functions
[@[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> [
    [let GF_exclude := generating_function (population_size_exclude__ M patterns)]
    [let GF_exclude_endby_ := \ [end_pattern <- patterns] -> generating_function (population_size_exclude_except_endby__ M patterns end_pattern)]
    ##[let mk_correlation_polynomial := \ [prev_end_pattern <- patterns] -> \ [next_end_pattern <- patterns] -> polynomial5bits $ correlation prev_end_pattern next_end_pattern]
    ] -> @[z :: Symbol] -> [
    [(z-M)*(GF_exclude z) + sum~ z*(GF_exclude_endby_ end_pattern z) ~{end_pattern <- patterns} === z]
      # 等式数量:1
      #
      # [M*(GF_exclude z)/z === (-1 + GF_exclude z + sum~ (GF_exclude_endby_ end_pattern z) ~{end_pattern <- patterns})]
      # [空串 <- patterns] <==> [patterns=={空串}]
      #   [not$ 空串 <- patterns]: 求和{((长度(S-1)的排除patterns的所有字串) 再加上 任意字符 的 字串总数)*z**(-S) | [S>=1]} = lhs===rhs = [排除patterns的非空字串总数+以某个end_pattern结尾的字串总数]
      #   [空串 <- patterns]: M*0/z = 0 = lhs===rhs = (-1 + 0 + sum {1+z*0,})
      #
    [[@next_end_pattern <- patterns] -> [(GF_exclude z) + sum~ -z*(mk_correlation_polynomial prev_end_pattern next_end_pattern z)* (GF_exclude_endby_ prev_end_pattern z) ~{prev_end_pattern <- patterns} === 0]]
      # 等式数量:len patterns
      #
      # [(GF_exclude z) === sum~ (z*mk_correlation_polynomial prev_end_pattern next_end_pattern z)* (GF_exclude_endby_ prev_end_pattern z) ~{prev_end_pattern <- patterns}]
      #
      # [lhs = 求和{(长度S的排除patterns的字串)的总数*z**(-S) | [S>=0]}
      # === 求和{((长度S的排除patterns的字串)++next_end_pattern)的总数*z**(-(S+len next_end_pattern)) *z**(-S +(S+len next_end_pattern)) | [S>=0]}
      # === 求和{(长度(S-back_gap)的排除patterns的但以prev_end_pattern结尾的字串)的总数*z**(-(S-back_gap)) *z**(-S +(S-back_gap)) | [将((长度S的排除patterns的字串)++next_end_pattern)按照最早找到的prev_end_pattern及位置为i分类][let back_gap := S - i - len prev_end_pattern]}
      # === 求和{(population_size_exclude_except_endby__ M patterns prev_end_pattern (S-back_gap)) *z**back_gap | [@prev_end_pattern <- patterns][@back_gap <- 非空左后缀右前缀共同长度(prev_end_pattern,next_end_pattern)]}
      # = rhs]
      #
    #共计: 1+len patterns 个 等式
    #共计: 1+len patterns 个 生成函数
    #证明: reduced_set_of_patterns ==>> 每一列 最高次数的多项式 出现在 对角线 ==>> 线性无关/即 矩阵可逆 ==>> 等式组中所有生成函数 都是 有理分式(rational function of z)
    #
  ]]

#consistent reduced_set_of_patterns
[is_reduced_set_of_patterns]
[@M <- [2..]]:
  [is_consistent_reduced_set_of_patterns :: {[uint%M]} -> Bool]
  [is_consistent_reduced_set_of_patterns patterns =[def]= [[is_reduced_set_of_patterns patterns][@[S :: uint] -> [population_size_exclude__ M patterns S]]]]
    #consistent无限多 vs inconsistent有限多
  #判定算法: 通过求出(GF_exclude z)的 分式，[GF_exclude z === 有限个(n/z**e)之和] <==> [inconsistent]。










[all_words_startby_ :: @[M <- [2..]] -> @[begin_pattern :: [uint%M]] -> {[uint%M]}]
[all_words_startby_ M begin_pattern =[def]= {word :: [uint%M] | [word.find(begin_pattern) == 0]}]

[all_words_exclude_startby_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[begin_pattern <- all_words_exclude_ M patterns] -> {[uint%M]}]
[all_words_exclude_startby_ M patterns begin_pattern =[def]= all_words_startby_ M begin_pattern /-\ all_words_exclude_ M patterns]


[all_sized_words_exclude_startby_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[begin_pattern <- all_words_exclude_ M patterns] -> @[S <- [0..]] -> {[uint%M]{len=S}}]
[all_sized_words_exclude_startby_ M patterns begin_pattern S =[def]= all_words_exclude_startby_ M patterns begin_pattern /-\ all_sized_words_exclude_ M patterns S]

[all_sized_words_exclude_except_endby__startby_ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[end_pattern <- patterns] -> @[begin_pattern <- all_words_exclude_ M patterns] -> @[S <- [0..]] -> {[uint%M]{len=S}}]
[all_sized_words_exclude_except_endby__startby_ M patterns end_pattern begin_pattern S =[def]= all_words_exclude_startby_ M patterns begin_pattern /-\ all_sized_words_exclude_except_endby_ M patterns end_pattern S]




[population_size_exclude_startby___ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[begin_pattern <- all_words_exclude_ M patterns] -> @[S <- [0..]] -> uint]
[population_size_exclude_startby___ M patterns begin_pattern S =[def]= len (all_sized_words_exclude_startby_ M patterns begin_pattern S)]

[population_size_exclude_except_endby__startby___ :: @[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[end_pattern <- patterns] -> @[begin_pattern <- all_words_exclude_ M patterns] -> @[S <- [0..]] -> uint]
[population_size_exclude_except_endby__startby___ M patterns end_pattern begin_pattern S =[def]= len (all_sized_words_exclude_except_endby__startby_ M patterns end_pattern begin_pattern S)]

#generalization of system_of_linear_equations_about_generating_functions
#   半泛化:要求 [patterns =!= {空串}]
[@[M <- [2..]] -> @[patterns <- all_reduced_set_of_patterns_ M] -> @[begin_pattern <- all_words_exclude_ M patterns] -> [
    [let GF_exclude := generating_function (population_size_exclude_startby___ M patterns begin_pattern)]
    [let GF_exclude_endby_ := \ [end_pattern <- patterns] -> generating_function (population_size_exclude_except_endby__startby___ M patterns end_pattern begin_pattern)]
    ] -> @[z :: Symbol] -> [
    [(z-M)*(GF_exclude z) + sum~ z*(GF_exclude_endby_ end_pattern z) ~{end_pattern <- patterns} === z**(1-len begin_pattern)]
      # 等式数量:1
      #
      # [M*(GF_exclude z)/z === (-1/z**(len begin_pattern) + GF_exclude z + sum~ (GF_exclude_endby_ end_pattern z) ~{end_pattern <- patterns})]
      # [not$ 空串 <- patterns]
      # [patterns =!= {空串}]
      #   [not$ 空串 <- patterns]: 求和{((长度(S-1)的以begin_pattern开头的排除patterns的所有字串) 再加上 任意字符 的 字串总数)*z**(-S) | [S>=1+len begin_pattern]} = lhs===rhs = [以begin_pattern开头的排除patterns的非begin_pattern的字串总数+以begin_pattern开头的以某个end_pattern结尾的字串总数]
      #
    [[@next_end_pattern <- patterns] -> [(GF_exclude z) + sum~ -z*(mk_correlation_polynomial prev_end_pattern next_end_pattern z)* (GF_exclude_endby_ prev_end_pattern z) ~{prev_end_pattern <- patterns} === z**(1-len begin_pattern) *(mk_correlation_polynomial begin_pattern next_end_pattern z)]]
      # 原论文bug: 不知哪来的H，于 等号右侧 z**(1-|H|)，应该更正为 z**(1-|X|) # |X|==len begin_pattern
      #
      # 等式数量:len patterns
      #
      # [lhs_part1 := (GF_exclude z)]
      # [lhs_part2 := (z*mk_correlation_polynomial begin_pattern next_end_pattern z)*(-1/z**(len begin_pattern))]
      # [rhs_sum := sum~ (z*mk_correlation_polynomial prev_end_pattern next_end_pattern z)* (GF_exclude_endby_ prev_end_pattern z) ~{prev_end_pattern <- patterns}]
      # [lhs_part1 + lhs_part2 === rhs_sum]
      #
      # [系数囗 S z f =[def]= f中z**(-S)的系数]
      # [0 <= S < len begin_pattern] ==>> [(系数囗 S z lhs_part1) == 0]
      #     !!不含begin_pattern
      #
      # [所有次数(z*mk_correlation_polynomial word _ z) |<=| {1..=len word}] ==>> [所有次数(lhs_part2) |<=| {1-len begin_pattern..=0}]
      # [len begin_pattern <= S] ==>> [(系数囗 S z lhs_part2) == 0]
      #
      # 分支:[0 <= S < len begin_pattern]or[len begin_pattern <= S]
      #
      # [@[S :: uint] -> [(系数囗 S z lhs_part1) === [len begin_pattern <= S](系数囗 S z rhs_sum)]]
      #
      # [@[S :: uint] -> [(系数囗 S z lhs_part2) === [0 <= S < len begin_pattern](系数囗 S z rhs_sum)]]
      #
      #
      # [len 虚构字串 == S + len next_end_pattern]
      #
      # 分支一:[len begin_pattern <= S]
      # [len 虚构字串 == S + len next_end_pattern >= len begin_pattern + len next_end_pattern]
      #
      # 长度S的以begin_pattern开头的排除patterns字串++next_end_pattern，找出最先出现的prev_end_pattern以及与next_end_pattern的交叠子串长度L #L > 0
      # 将 population_size<prev_end_pattern, S+L> 通过(* z**L) 归入 population_size<null, S>
      # sum z**L {有效L} == z*mk_correlation_polynomial prev_end_pattern next_end_pattern z
      #
      # 分支二:[0 <= S < len begin_pattern]
      #[len 虚构字串 == S + len next_end_pattern < len begin_pattern + len next_end_pattern]
      #[len 虚构字串 >= S]
      #[len 虚构字串 >= len next_end_pattern]
      #
      # [虚构字串.endswith(next_end_pattern)]
      # [虚构字串.startswith(begin_pattern)]
      #[len 虚构字串 >= len begin_pattern]
      #
      [prev_end_pattern in 虚构字串]
      #[len 虚构字串 >= len prev_end_pattern]
      #
      # [let K := len begin_pattern + len next_end_pattern - len 虚构字串]
      # [K >= 1]
      # [K == len begin_pattern - S]
      # @[S <- [0..<len begin_pattern]] -> [最多只有一个有效 虚构字串]
      #     [begin_pattern[S:] == next_end_pattern[:K]] <==> 虚构字串 存在
      #     对应于 lhs_part2
      #
    #共计: 1+len patterns 个 等式
    #共计: 1+len patterns 个 生成函数
    #
  ]]





#WORST CASE BEHAVIOR OF PATTERN-MATCHING ALGORITHMS
#检查包含pattern与否的最小计算量
[[@M <- [2..]][@pattern ::[uint%M]][pattern=!=空串][@S :: uint][?T <- [0..S]][?does_contain :: @[word :: [uint%M]{len=S}] -> ?[r::Bool] -> [r == [pattern in word]]][does_contain 只需 读取word中最多 T 个字符]]:
  [[[
  # 固定M,pattern, S
  # T<M,pattern,S>
  # does_contain<M,pattern,S>
  #
  任选一个word
  若does_contain读取word中的字符的索引集为:ks
  则保持ks位置上的字符不变，其他字符的变动 不影响 does_contain读取字符的索引ks，不影响输出结果。
  ==>> [population_size_exclude__ M {pattern} S % M**(S-len ks) == 0]
  [[T<S] -> [population_size_exclude__ M {pattern} S % M == 0]]
  [[population_size_exclude__ M {pattern} S % M =!= 0] -> [T==S]]

  !!system_of_linear_equations_about_generating_functions
    [(z-M)*(GF_exclude z) + z*(GF_exclude_endby_ pattern z) === z]
    [(GF_exclude z) + -z*(mk_correlation_polynomial pattern pattern z)* (GF_exclude_endby_ pattern z) === 0]
    <==>
    [(GF_exclude z) === z*(mk_correlation_polynomial pattern pattern z)* (GF_exclude_endby_ pattern z)]
    [(z-M)*z*(mk_correlation_polynomial pattern pattern z)* (GF_exclude_endby_ pattern z) + z*(GF_exclude_endby_ pattern z) === z]
    <==>
    [(GF_exclude_endby_ pattern z) === 1/((z-M)*(mk_correlation_polynomial pattern pattern z)  + 1)]
    [(GF_exclude z) === z*(mk_correlation_polynomial pattern pattern z) / ((z-M)*(mk_correlation_polynomial pattern pattern z)  + 1)]
      #[pattern == 空串]:
      #     !![mk_correlation_polynomial 空串 _ _ === 0]
      #     分子=0，分母=1
      #     [(GF_exclude z) === 0]
      #
      #[pattern =!= 空串]:
      #     分子首项=分母首项=1*z**(len pattern)
      #     [(系数囗 0 z (GF_exclude z)) == 1]
      #
      #     view others/数学/递推/一元有理分式-转化为-递推公式.txt
      #     ##let poly(ns,z)/poly(ds,z) := (分子-分母)/分母
      #     ##[@[S>=0] -> [(系数囗 S z (GF_exclude z)) == xs[S]]]
      #     #
      #     let poly(ns,z)/poly(ds,z) := (分子/z)/分母
      #     [@[S>=0] -> [(系数囗 S z (GF_exclude z)) == xs[S+1]]]
      #     [xs[:2] == [0,1]]
      #
      #     ns = [..., 0]
      #     ds = [..., 1]
      #     !![pattern =!= 空串]
      #     [D = len pattern >= 1]
      #     (v, xs[1:1+D]) := 一元有理分式到递推参数 ns ds
      #     [v := [-ds[i]/ds[D] | [i <- [0..<D]]]]
      #     [v == -1 .* ds[:-1]]
      #     [[n >= 1] -> [xs[n+D] := v .*. xs[n:n+D]]]
      #
      #
      #     [ds[0] <- {1-M,1}]
      #     !![M >= 2]
      #     [ds[0] =!= 0]
      #         #允许反推！
      #         #若[M<-{0,1}]，都不需要读取，[T==0]
      #     [[n >= 1] -> [xs[n] := (xs[n+D] - v[1:] .*. xs[n+1:n+D])/-ds[0]]]
      #         # 刚好只需反推至[xs[1] == (系数囗 0 z (GF_exclude z)) == 1]
      #     若出现连续D个x/存在m.xs[m:m+D] 均整除M，则 反推得[xs[1]%M==0]，不可能。
      #     [不存在m，使得 xs[m:m+D] 均整除M]
      #     !![[population_size_exclude__ M {pattern} S % M =!= 0] -> [T==S]]
      #     [不存在m，使得 [@[S > m] -> [T<S]]]
      #     [S - T < D == len pattern]
      #
      #
      必须排除边缘条件:[M<2]or[pattern==空串]


  ]]]



# CLASS OF IRREDUCIBLE POLYNOMIALS
[@[z :: Symbol] -> @[ks :: {Integer}{len>=1}] -> [is_irreducible_polynomial z (II~ (z-k) ~{k <- ks} + [+-]1)]]
  # distinct integers
[@[z :: Symbol] -> @[bits :: [Bool]] -> @[k <- [3..]] -> [is_irreducible_polynomial z ((z-k)*polynomial5bits bits + 1)]]


???没认真看:
  [@[M <- [2..]] -> @[pattern0, pattern1 ::[uint%M]] -> [mk_correlation_polynomial pattern0 pattern0 M < mk_correlation_polynomial pattern1 pattern1 M] -> @[S :: uint] -> [population_size_exclude__ M {pattern0} S <= population_size_exclude__ M {pattern1} S]]
  #真奇怪，不含pattern0=abb...b的字串，竟然 不多于 不含 pattern1=aa...a的等长字串
  #hand_inspection: [[M==2][pattern0=ab][pattern1==aa]] 确实有 [S+1 <= sum~ choose(k+ (S-k)//2, k) ~{k <- [0..=S]}]
      # lhs 字串 模式=bb...b++aa...a 共计 S+1个
      # rhs 字串 模式= k个b 与 (S-k)//2个ab 自由组合，以(S-k)%2个a结尾
  #==>> 含pattern0=abb...b的字串，不少于 含 pattern1=aa...a的等长字串

]]
[[
4.3M 'Combinatorial Algorithms on Words(1985)(Guibas).djvu'
=====
]]
[[
=====
]]
]]]

]]]]]]]]]



