
e ../lots/NOTE/unicode/字符串规范化.txt

统合码的编码点 不一定是 字符/抽象字符
抽象字符 不一定 只有一个 统合码的编码点/统合码的编码点序列
  兼容？变体？...
  序列？
the abstract character
  "LATIN CAPITAL LETTER C WITH CEDILLA"
  can be represented as a single
    *precomposed character* at code position U+00C7
  , or as a sequence of
    a *base character* at code position U+0043 (LATIN CAPITAL LETTER C), followed by
    a *combining character* at code position U+0327 (COMBINING CEDILLA).


[[[
"unicodedata.normalize()"
===
Python 3.11.9
>>> help('OPERATORS')
Operator precedence
...
-[ Footnotes ]-
...

view /sdcard/0my_files/unzip/py_doc/python-3.12.4-docs-text/reference/expressions.txt
-[ Footnotes ]-
[3] The Unicode standard distinguishes between *code points* (e.g.
    U+0041) and *abstract characters* (e.g. "LATIN CAPITAL LETTER A").
    While most abstract characters in Unicode are only represented
    using one code point, there is a number of abstract characters
    that can in addition be represented using a sequence of more than
    one code point.  For example, the abstract character "LATIN
    CAPITAL LETTER C WITH CEDILLA" can be represented as a single
    *precomposed character* at code position U+00C7, or as a sequence
    of a *base character* at code position U+0043 (LATIN CAPITAL
    LETTER C), followed by a *combining character* at code position
    U+0327 (COMBINING CEDILLA).

    The comparison operators on strings compare at the level of
    Unicode code points. This may be counter-intuitive to humans.  For
    example, ""\u00C7" == "\u0043\u0327"" is "False", even though both
    strings represent the same abstract character "LATIN CAPITAL
    LETTER C WITH CEDILLA".

    To compare strings at the level of abstract characters (that is,
    in a way intuitive to humans), use "unicodedata.normalize()".
]]]




