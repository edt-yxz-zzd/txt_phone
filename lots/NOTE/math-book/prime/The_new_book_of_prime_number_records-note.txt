
e ../lots/NOTE/math-book/prime/The_new_book_of_prime_number_records-note.txt
/sdcard/0my_files/book/math/factorint/snd/The new book of prime number records(3ed)(1996)(Ribenboim).djvu
view others/数学/术语/费马大定理/费马大定理之第一子类.txt

[[
素模本原根的范围:here
'/sdcard/0my_files/book/math/factorint/snd/The new book of prime number records(3ed)(1996)(Ribenboim).djvu'
chaper2. How to Recognize Whether a Natural Number Is a Prime
page24

[欤素数扌(p)][欤最小素模本原根扌(p;g[p])]
[g[p] =[def]= the_smallest_positive_primitive_root_modulo_(p)]
[?[C > 0] -> [+oo == len{p | @[p>0][is_prime(p)][the_smallest_positive_primitive_root_modulo_(p) > C*ln(p)]}]]
  其上限增长快>=线性纟对数
  更弱版:[?[C > 0] -> [+oo == len{p | @[p>0][is_prime(p)][the_smallest_positive_primitive_root_modulo_(p) > C*lnln(p)]}]]
    其上限增长快>=线性纟对数对数
  更更弱版:[@[cc > 0] -> [+oo == len{p | @[p>0][is_prime(p)][p-cc > the_smallest_positive_primitive_root_modulo_(p) > cc]}]]
    其上限增长快>=任意常量#??基础知识证明
[@[err>0] -> ?[C,P > 0] -> @[p>P] -> [is_prime(p)] -> [the_smallest_positive_primitive_root_modulo_(p) < C*p**(err+1/4)]]
  其上限增长不太快<=四次方根
[@[p>e**e**24] -> [is_prime(p)] -> [the_smallest_positive_primitive_root_modulo_(p) < p**0.499]]
  其上限增长不太快<=平方根
  相比上面，消除了未知常量:[lnln(p)>24]

]]


[[
move some to:
  view others/数学/primality_test/proof_primality_via_Nmm_test.txt
素性检测:here
]]


因为书中公式错太多，转移到:
  view others/数学/primality_test/proof_primality_via_GFsqN_test.txt
[[
Lucas sequence

polynomial: (x**2-P*x+Q)
discriminant: D:=(P**2-4*Q)
roots:
  a := (P+sqrtD)/2
  b := (P-sqrtD)/2

[P, Q :: int][D := (P**2-4*Q)][D =!= 0][a := (P+sqrtD)/2][b := (P-sqrtD)/2]:
  # [D =!= 0] due to (...)/(a-b) #but it can be erased by factor polynomial!!!
  !! [P**2 %4 <- {0,1}]
  [D%4 <- {0,1}]
  [a+b == P]
  [a*b == Q]
  [D == (a-b)**2]
  [n :: int]:
    # negative n ok
    #   实际上，任意复数都行...
    #Lucas sequences associated to the pair (P, Q): U()&V()
    #companion Lucas sequence:V()
    [U(P,Q;n) =[def]= (a**n-b**n)/(a-b)]
    [V(P,Q;n) =[def]= (a**n+b**n)]
    #
    or:
    [U(a+b,a*b;n) =[def]= (a**n-b**n)/(a-b)]
    [V(a+b,a*b;n) =[def]= (a**n+b**n)]
    这可以看作:二元对称二项式的次数提升过程
      给定一个『二元对称多项式』，如何将它用『一次二元对称二项式』表达出来？
      1. 用『任意高次二元对称二项式』表达
      2. 再将『任意高次二元对称二项式』用『一次二元对称二项式』表达
        这里就用到 Lucas...
      ？可否推广到三元？
          V:n -> (n,m)
          (a**n*b**m+b**n*c**m+c**n*a**m)
          #???-1 -> w # [w**3==1]
  ... ...
  [U(P,Q;-2) == -P/Q**2]
  [U(P,Q;-1) == -1/Q]
  [U(P,Q;0) == 0]
  [U(P,Q;1) == 1]
  [U(P,Q;2) == P]
  [U(P,Q;3) == P**2-Q]
  ... ...
  ... ...
  [V(P,Q;-2) == (P**2-2*Q)/Q**2]
  [V(P,Q;-1) == P/Q]
  [V(P,Q;0) == 2]
  [V(P,Q;1) == P]
  [V(P,Q;2) == P**2-2*Q]
  [V(P,Q;3) == P**3-3*P*Q]
  ... ...
  这起始双值...，从矩阵的角度看，起始双值分别取[1,0],[0,1]更好

  [U(P,Q;-n) == -U(P,Q;n)/Q**n]
  [V(P,Q;-n) == +V(P,Q;n)/Q**n]
===
单步关系牜自反:
[U(P,Q;n) == P*U(P,Q;n-1) - Q*U(P,Q;n-2)]
[V(P,Q;n) == P*V(P,Q;n-1) - Q*V(P,Q;n-2)]
单步关系牜交叉:
[U(P,Q;n) == (P*V(P,Q;n) - 2*Q*V(P,Q;n-1))/D]
[V(P,Q;n) == P*U(P,Q;n) - 2*Q*U(P,Q;n-1)]
正负关系牜自反:
[U(P,Q;-n) == -U(P,Q;n)/Q**n]
[V(P,Q;-n) == +V(P,Q;n)/Q**n]
<<==:
===
(x**2-P*x+Q)
递推关系:       [f(n) == P*f(n-1) -Q*f(n-2)]
递推函数通解:   [f(n) == A*a**n + B*b**n]
由于 U(),V() 匹配该通解形式，故:
[U(P,Q;n) == P*U(P,Q;n-1) - Q*U(P,Q;n-2)]
[V(P,Q;n) == P*V(P,Q;n-1) - Q*V(P,Q;n-2)]
  启发自:/sdcard/0my_files/book/math/factorint/202308/Prime numbers-A Computational Perspective(2ed)(2005)(Pomerance)/Prime numbers-A Computational Perspective(2ed)(2005)(Pomerance).pdf
===
对比:上面(递推函数通解)vs下面(我的推导)
=> [V(P,Q;n-1) + Q*U(P,Q;n-2) == P*U(P,Q;n-1) - Q*U(P,Q;n-2)]
=> [V(P,Q;n-1) == P*U(P,Q;n-1) - 2*Q*U(P,Q;n-2)]
=> [V(P,Q;n) == P*U(P,Q;n) - 2*Q*U(P,Q;n-1)]
  经证明此关系正确
对称待定系数，得:
  [U(P,Q;n) == (P*V(P,Q;n) - 2*Q*V(P,Q;n-1))/D]
===
递推关系牜单步:
[U(P,Q;n) ==   V(P,Q;n-1) + Q*U(P,Q;n-2)]
[V(P,Q;n) == P*V(P,Q;n-1) - Q*V(P,Q;n-2)]
let UUVV(n) := transpose[[U(P,Q;n),U(P,Q;n-1),V(P,Q;n),V(P,Q;n-1)]]
  [T == (T1|T2)]
    因为 T2 可分解为对角线上两个相同的方阵
    T1相当于从T2复制信息
[UUVV(n) == T*UUVV(n-1)]
[T1 :=
  [[0, Q, 1, 0]
  ,[1, 0, 0, 0]
  ,[0, 0, P, -Q]
  ,[0, 0, 1, 0]
  ]
]
根据相同递归式:
[T2 :=
  [[P, -Q, 0, 0]
  ,[1, 0, 0, 0]
  ,[0, 0, P, -Q]
  ,[0, 0, 1, 0]
  ]
  == I *< [P,-Q;1,0;]
]
<<==:
推导冫递推关系牜单步巛定义:我的推导
  [U(P,Q;n) == (a**n-b**n)/(a-b)
  * [n >= 0]:
    == sum [a**i * b**j | [i,j>=0][i+j==n-1]]
    * [n >= 2]:
      == sum [a**i * b**j | [i,j>=1][i+j==n-1]] + (a**(n-1) + b**(n-1))
      == sum [a**i * b**j | [i,j>=1][i+j==n-1]] + V(P,Q;n-1)
      * [n >= 3]:
        == (a*b)*sum [a**i * b**j | [i,j>=0][i+j==n-3]] + V(P,Q;n-1)
        == Q*sum [a**i * b**j | [i,j>=0][i+j==n-3]] + V(P,Q;n-1)
        == Q*U(P,Q;n-2) + V(P,Q;n-1)
        == V(P,Q;n-1) + Q*U(P,Q;n-2)
  ]
  [U(P,Q;n) == V(P,Q;n-1) + Q*U(P,Q;n-2)]
  [V(P,Q;n) == (a**n+b**n)
  == (a**n+b**n) - (a+b)*(a**(n-1)+b**(n-1)) + P*V(P,Q;n-1)
  == -(b*a**(n-1)+a*b**(n-1)) + P*V(P,Q;n-1)
  == -(a*b)*(a**(n-2)+b**(n-2)) + P*V(P,Q;n-1)
  == -Q*V(P,Q;n-2) + P*V(P,Q;n-1)
  == P*V(P,Q;n-1) -Q*V(P,Q;n-2)
  ]
  [V(P,Q;n) == P*V(P,Q;n-1) - Q*V(P,Q;n-2)]
  ##发现新关系，再推导:
  [U(P,Q;n)*(a-b) == (a**n-b**n)
  == (a**n-b**n) -(a+b)*(a**(n-1)-b**n**(n-1)) +P*U(P,Q;n-1)*(a-b)
  == -(b*a**(n-1)-a*b**n**(n-1)) +P*U(P,Q;n-1)*(a-b)
  == -(a*b)*(a**(n-2)-b**n**(n-2)) +P*U(P,Q;n-1)*(a-b)
  == -Q*U(P,Q;n-2)*(a-b) +P*U(P,Q;n-1)*(a-b)
  == +P*U(P,Q;n-1)*(a-b) -Q*U(P,Q;n-2)*(a-b)
  ]
  [U(P,Q;n)*(a-b) == P*U(P,Q;n-1)*(a-b) - Q*U(P,Q;n-2)*(a-b)]
  [U(P,Q;n) == P*U(P,Q;n-1) - Q*U(P,Q;n-2)]
  差量推导:[V(P,Q;n) == P*U(P,Q;n) - 2*Q*U(P,Q;n-1)]
  由于满足相同递推关系，归纳法自动满足，只差检查任意相邻2值:
  [V(P,Q;1) == P == P*1 -2*Q*0 == P*U(P,Q;1) - 2*Q*U(P,Q;0)]
  [V(P,Q;2) == P**2-2*Q == P*P -2*Q*1 == P*U(P,Q;2) - 2*Q*U(P,Q;1)]
    <<==:
      [U(P,Q;0) == 0]
      [U(P,Q;1) == 1]
      [U(P,Q;2) == P]
      [V(P,Q;0) == 2]
      [V(P,Q;1) == P]
      [V(P,Q;2) == P**2-2*Q]
  [(P*U(P,Q;n) - 2*Q*U(P,Q;n-1))*(a-b)
  == (a+b)*(a**n-b**n) -2*(a*b)*(a**(n-1)-b**(n-1))
  == (a**(n+1)-b**(n+1))+(b*a**n-a*b**n) -2*(b*a**n-a*b**n)
  == (a**(n+1)-b**(n+1)) -(b*a**n-a*b**n)
  == (a-b)*(a**n+b**n)
  == (a-b)*V(P,Q;n)
  ]
  [V(P,Q;n) == P*U(P,Q;n) - 2*Q*U(P,Q;n-1)]
  ##对称待定系数:
  [U(P,Q;n)*(a-b) == (a**n-b**n)
  == AA*V(P,Q;n) + BB*Q*V(P,Q;n-1)
  == AA*(a**n+b**n) + BB*(b*a**n+a*b**n)
  == (AA+BB*b)*a**n + (AA+BB*a)*b**n
  ]
  [(AA+BB*b) == 1][(AA+BB*a) == -1]
  [BB*(a-b) == -2][2*AA+BB*(a+b)==0]
  [BB == -2/(a-b)][AA==-BB*P/2==P/(a-b)]
  [U(P,Q;n)
  == (AA*V(P,Q;n) + BB*Q*V(P,Q;n-1))/(a-b)
  == (P*V(P,Q;n) + -2*Q*V(P,Q;n-1))/(a-b)**2
  == (P*V(P,Q;n) + -2*Q*V(P,Q;n-1))/D
  ]
  [U(P,Q;n) == (P*V(P,Q;n) - 2*Q*V(P,Q;n-1))/D]
  实例验证:
  [U(P,Q;1) == 1 == (P*P - 2*Q*2)/D == (P*V(P,Q;1) - 2*Q*V(P,Q;0))/D]
  [U(P,Q;2) == P == (P*(P**2-2*Q) - 2*Q*P)/D == (P*V(P,Q;2) - 2*Q*V(P,Q;1))/D]
    <<==:
      [U(P,Q;0) == 0]
      [U(P,Q;1) == 1]
      [U(P,Q;2) == P]
      [V(P,Q;0) == 2]
      [V(P,Q;1) == P]
      [V(P,Q;2) == P**2-2*Q]
===
[Un   := U(P,Q;n)]
[Unpp := U(P,Q;n+1)]
[Unmm := U(P,Q;n-1)]

[Vn   := V(P,Q;n)]
[Vnpp := V(P,Q;n+1)]
[Vnmm := V(P,Q;n-1)]

(IV. 1) Quadratic relations:
[Vn**2 - D*Un**2 == 4*Q**n]
[Un**2 -Unmm*Unpp == Q**(n-1)]

(IV.2) Conversion formulas:
???[D*Un == Vnpp - Q*Vnmm] #bug?!
[  Vn == Unpp - Q*Unmm]
<==>:
???[Vnpp == D*Un - Q*Vnmm]
[Unpp ==   Vn - Q*Unmm]

???[D*Un == P*Vn]???
  见上面:递推关系牜单步#我的推导
  对比上式就有了:[D*Un == P*Vn]
  [(P**2-4*Q)*Un == P*Vn]
  [(P**2-4*Q)*(a**n-b**n)/(a-b) == P*(a**n+b**n)]
  !! [D == (a-b)**2]
  [(a-b)*(a**n-b**n) == (a+b)*(a**n+b**n)]
  不太行

(IV.3) Addition of indices:
[U(m+n) == Um*Un - Q**n*U(m-n)]#bug?!
  => [Q**n*U(m-n) == Q**m*U(n-m)]
  => [U(m-n) == Q**(m-n)*U(n-m)]
  !! [U(P,Q;-n) == -U(P,Q;n)/Q**n]
  _L
瞎改:[U(m+n) == Um*Un - (-Q)**n*U(m-n)]
[V(m+n) == Vm*Vn - Q*V(m-n) == D*Um*Un - Q**n*V(m-n)]#bug?!
[V(m+n) == Vm*Vn - Q*V(m-n)]#bug?!
  => [V(m-n) == V(n-m)]
  !! [V(P,Q;-n) == +V(P,Q;n)/Q**n]
  _L
瞎改:[V(m+n) == Vm*Vn - Q**n*V(m-n)]
  => [Q**n*V(m-n) == Q**m*V(n-m)]
  => [V(m-n) == Q**(m-n)*V(n-m)]
  !! [V(P,Q;-n) == +V(P,Q;n)/Q**n]
  改对了!
[V(m+n) == Vm*Vn - Q**n*V(m-n)]
  特例:[V(2*n) == Vn**2 - Q**n*2]
  特例:[V(2*n+1) == Vnpp*Vn - Q**n*P]
  特例:[V(2*(n+1)) == Vnpp**2 - Q**(n+1)*2]
  (n,n+1) --> (2*n,2*n+1)
  (n,n+1) --> (2*n+1,2*n+2)
  最好是[Q==+/-1]
===
===
]]







[[[
/sdcard/0my_files/book/math/factorint/snd/The new book of prime number records(3ed)(1996)(Ribenboim).djvu
估值冫素数上限巛素数位次
估值冫素数数量巛素数上限
制表冫素数序列
制表冫最小因子序列
===
  II. The nth Prime and Gaps
  page249[274/567]
  [n :<- [1..]]:
    [PRIMES_S1[n] =[def]= PRIMES[n-1]]
      @page3[28/567]
  [PRIMES_S1[1] == PRIMES[0] == 2]

  [[sufficiently large n] => [PRIMES_S1[n] == n*ln(n) + n*(lnln(n)-1) + o(n*lnln(n)/ln(n))]]
  [[n>=2] -> [n*ln(n) + n*(lnln(n)-10) < PRIMES_S1[n] < n*ln(n) + n*(lnln(n)+8)]]
    # [[n>=2] -> [-10 < (PRIMES_S1[n]/n -ln(n) -lnln(n)) < 8]]
    # [[n>=2] -> [abs(PRIMES_S1[n]/n -ln(n) -lnln(n) +1) < 9]]
  [[n>=1] -> [PRIMES_S1[n] > n*ln(n)]]
  [[n>=2] -> [n*ln(n) + n*(lnln(n)-1.0072629) <= PRIMES_S1[n]]]
  [[n>=2] -> [PRIMES_S1[n] <= 10**11] -> [n*ln(n) + n*(lnln(n)-1) <= PRIMES_S1[n]]]
  [[n>=7022] -> [PRIMES_S1[n] <= n*ln(n) + n*(lnln(n) -0.9385)]]
  [PRIMES_S1[7022] == PRIMES[7021] == 70919]
  view ../../python3_src/nn_ns/math_nn/numbers/_patch_prime_..b001918.b002233.out.txt
    0 2 1 1
    1 3 2 2
    2 5 2 2
    ... ...
    7021 70919 7 7
    7022 70921 13 13
    7023 70937 3 3
    ... ...
  The above inequalities required strenuous calculations to be established. If one is less ambitious, it is possible to obtain weaker estimates with elementary methods. Thus, for example, I quote an early result of Sierpinski 1964):
  [[n>=1] -> [1/4*n*ln(n) < PRIMES_S1[n] < 36*n*ln(n)]]
    # [[n>=1] -> [1/4 < PRIMES_S1[n]/(n*ln(n)) < 36]]
    # [[n>=1] -> [1/12 < 1/3*PRIMES_S1[n]/(n*ln(n)) < 12]]
    # [[n>=1] -> [abs(ln(1/3*PRIMES_S1[n]/(n*ln(n)))) < ln(12)]]
  More recently, Feigner 1990) obtained without much pain:
    [[n>=1] -> [0.91*n*ln(n) < PRIMES_S1[n] < 1.7*n*ln(n)]]

  [[n>=2] -> [PRIMES_S1[n]+PRIMES_S1[n+1] > PRIMES_S1[n+2]]]
  [[m,n>=1] -> [PRIMES_S1[m]*PRIMES_S1[n] > PRIMES_S1[m+n]]]
  [+oo == len{n | [[n:<-[1..]][@[i:<-[1..<n]] -> [PRIMES_S1[n]**2 > PRIMES_S1[n-i]*PRIMES_S1[n+i]]]]}]
    大于:几何平均
  [+oo == len{n | [[n:<-[1..]][@[i:<-[1..<n]] -> [PRIMES_S1[n]*2 < PRIMES_S1[n-i]+PRIMES_S1[n+i]]]]}]
    小于:算术平均

  [x::real]:
    [min_prime_ge_(x) =[def]= min{p | [[p :: prime][p >= x]]}]
    [min_prime_gt_(x) =[def]= min{p | [[p :: prime][p > x]]}]
    [max_prime_lt_(x) =[def]= min{p | [[p :: prime][p < x]]}]
    [max_prime_le_(x) =[def]= min{p | [[p :: prime][p <= x]]}]
  [x::real]:
    [num_primes_le(x) =[def]= len{p | [[p :: prime][p < x]]}]
  [x::real]:
    # Li(x):the function logarithmic integral of x # ver1
    [Li(x) =[def]= SS{1/ln(t) | [t :<~ 2 ~> x]}]
  [num_primes_le(x) /~/ Li(x) /~/ x/ln(x)]
    #Li更佳:
    #??? [(abs(Li(x) -num_primes_le(x))) = o(abs(x/ln(x) -num_primes_le(x)))]
    # The approximation of PI(x) by x/ln(x) is only reasonably good, while it is much better using the logarithmic integral,
    #
  [num_primes_le(PRIMES_S1[n]) == n]
  [PRIMES_S1[1+num_primes_le(x)] == min_prime_gt_(x)]
  [PRIMES_S1[num_primes_le(x)] == max_prime_le_(x)]

  [n>=1]:
    [gap4prime_(n) =[def]= min_prime_gt_(n) -n -1]
  [n>=1]:
    [gap_PRIMES_S1[n] =[def]= PRIMES_S1[n+1] -PRIMES_S1[n] -1]
    [diff_PRIMES_S1[n] =[def]= PRIMES_S1[n+1] -PRIMES_S1[n]]
  [diff_PRIMES_S1[n] == 1+gap_PRIMES_S1[n]]
  [diff_PRIMES_S1[n] == PRIMES_S1[n+1] -PRIMES_S1[n] == PRIMES[n] -PRIMES[n-1]]
  [low_gap>=1]:
    [min_prime4gap_ge_(low_gap) =[def]= min{PRIMES_S1[n] | [[n :<- [1..]][gap_PRIMES_S1[n] >= low_gap]]}]

  [素数间距猜想冫正偶数是无穷相邻素数对的间距:conjecture_Polignac_1849:[[k:<-[1..]] -> [len{n | [[n:<-[1..]][diff_PRIMES_S1[n]==2*k]]} == +oo]]]
    猜想特例:欤孪生素数对无穷多
    猜想泛化:[即使是未必相邻的素数间距同样不清楚]

  [猜想:ln(min_prime4gap_ge_(low_gap)) /~/ sqrt(low_gap)]
  [猜想:ln(min_prime4gap_ge_(low_gap)) /~/ sqrt(1.165746*low_gap)]
  [gap4prime_(6505941701960039) == 863]
    => [min_prime4gap_ge_(863) <= 6505941701960039]
  [gap4prime_(2500107922440823) == 783]
    => [min_prime4gap_ge_(783) <= 2500107922440823]
    [min_prime4gap_ge_(777) <= 42842283925351]
  [lim sup diff_PRIMES_S1[n] == +oo]
  [未知:lim inf diff_PRIMES_S1[n] < +oo]
  [[n>=1] -> [diff_PRIMES_S1[n] < PRIMES_S1[n]]]
    # [[n>=1] -> [PRIMES_S1[n+1] < 2*PRIMES_S1[n]]]
  [[(err,n0) :<- [(1/5,10),(1/13,118),(1/16597,2010760)]] -> [n>=n0] -> [diff_PRIMES_S1[n] < err*PRIMES_S1[n]]]
  [limit{diff_PRIMES_S1[n]/PRIMES_S1[n]| [n-->+oo]} == 0]



  [素数间距猜想冫素数间距估计约不超过对数平方:conjecture_Cramer_1937:diff_PRIMES_S1[n] == O(ln(PRIMES_S1[n])**2)]
  [[Riemann_hypothesis] => [diff_PRIMES_S1[n] == O(sqrt(PRIMES_S1[n])*ln(PRIMES_S1[n]))]]
  [[only the weaker density hypothesis on the nontrivial zeros of zeta(z)#Riemann_hypothesis] => @[err>0] -> [diff_PRIMES_S1[n] == O(PRIMES_S1[n]**(1/2+err))]]
  [@[e0 :<- [5/8,3/5,7/12,13/23,11/20,1/2+1/21~=0.5476...,11/20-1/384~=0.5473958...,6/11~=0.5454...,7/13~=0.53845...]] -> @[err>0] -> [diff_PRIMES_S1[n] == O(PRIMES_S1[n]**(e0+err))]]
  [lim inf (diff_PRIMES_S1[n]/ln(PRIMES_S1[n])) < 0.248]
  [lim sup (diff_PRIMES_S1[n]/ln(PRIMES_S1[n])) == +oo]

  #算术平均
  [[err>0] -> [+oo == len{n | [[n:<-[2..]][2*PRIMES_S1[n]**err > (PRIMES_S1[n-1]**err + PRIMES_S1[n+1]**err)]]}]]
    => [+oo == len{n | [[n:<-[2..]][diff_PRIMES_S1[n-1] > diff_PRIMES_S1[n]]]}]
  [[err>0] -> [+oo == len{n | [[n:<-[2..]][2*PRIMES_S1[n]**err < (PRIMES_S1[n-1]**err + PRIMES_S1[n+1]**err)]]}]]
    => [+oo == len{n | [[n:<-[2..]][diff_PRIMES_S1[n-1] < diff_PRIMES_S1[n]]]}]
  #几何平均
  [+oo == len{n | [[n:<-[2..]][PRIMES_S1[n]**2 > (PRIMES_S1[n-1] * PRIMES_S1[n+1])]]}]
  [+oo == len{n | [[n:<-[2..]][PRIMES_S1[n]**2 < (PRIMES_S1[n-1] * PRIMES_S1[n+1])]]}]

  [lim sup (min{diff_PRIMES_S1[n],diff_PRIMES_S1[n+1]}/ln(PRIMES_S1[n])) == +oo]
  [@[k:<-[1..]] -> [lim sup (min{diff_PRIMES_S1[n+i] | [i:<-[0..=k]]}/ln(PRIMES_S1[n]) * lnlnln(PRIMES_S1[n])**2/lnln(PRIMES_S1[n])/lnlnlnln(PRIMES_S1[n])) > 0]]

  [素数间距猜想冫素数平方根差分渐近于零:limit{(sqrt(PRIMES_S1[n+1]) -sqrt(PRIMES_S1[n])) | [n->+oo]} == 0]
  [素数间距猜想冫平方之间含素数:sqrt(PRIMES_S1[n+1]) -sqrt(PRIMES_S1[n]) < 1]
  [[PRIMES_S1[n] < 10**6] -> [sqrt(PRIMES_S1[n+1]) -sqrt(PRIMES_S1[n]) < 1]]

  #page248
  [conjecture_Opperman_1882:[n>1] -> [num_primes_le(n**2+n) > num_primes_le(n**2) > num_primes_le(n**2-n)]]
  #page248
  [conjecture_Brocard_1904:[n>=2] -> [num_primes_le(PRIMES_S1[n+1]**2) -num_primes_le(PRIMES_S1[n]**2) >= 4]]













  @page214[239/567]
  [[x0 :: real][f,h :: real{>x0} -> real{>0}]]:
    [[f(x) /~/ h(x)] =[def]= is_asymptotically_equal_as_input_tends_to_infinity_(f,h) =[def]= [lim{f(x)/h(x) | x-->+oo} == 1]]
      # 对称性:
    [[f(x) /~/ h(x)] == [h(x) /~/ f(x)]]

    [have_the_same_order_of_magnitude_(f,h) =[def]= [?[C4inferior,C4superior :: real{>0}] -> ?[x1 :: real{>x0}] -> @[x :: real{>x1}] -> [C4inferior <= f(x)/h(x) <= C4superior]]]
      # 注意:C4inferior大于0
      # 对称性:
    [have_the_same_order_of_magnitude_(f,h) == have_the_same_order_of_magnitude_(h,f)]

    [[f(x) /~/ h(x)] -> [have_the_same_order_of_magnitude_(f,h)]]

  [[x0 :: real][f,g :: real -> real][h :: real{>x0} -> real{>0}]]:
    # big_O_notation:
    [[f(x) == g(x) +O(h(x))] =[def]= [?[C4superior :: real{>0}] -> ?[x1 :: real{>x0}] -> @[x :: real{>x1}] -> [abs(f(x)-g(x))/h(x) <= C4superior]]]
      # 注意:必须有abs()保证非负
      # 注意:不同于上面have_the_same_order_of_magnitude_，此处C4inferior可能为0，故没有出现
    [[f(x) == g(x) +O(h(x))] <-> [have_the_same_order_of_magnitude_((\x->h(x)+abs(f(x)-g(x))),h)]]
      # 注意:必须有abs()保证非负
      # 注意:必须加上h(x)保证C4inferior大于0

    # ???small_O_notation:
    [[f(x) == g(x) +o(h(x))] =[def]= the_error_is_negligible_in_comparison_to_(h; f,g) =[def]= [lim{(f(x)-g(x))/h(x) | x-->+oo} == 0]]
    [[f(x) == g(x) +o(h(x))] <-> [@[C4superior :: real{>0}] -> ?[x1 :: real{>x0}] -> @[x :: real{>x1}] -> [abs(f(x)-g(x))/h(x) <= C4superior]]]

  [?[x0 :: real] -> @[f,h :: real{>x0} -> real{>0}] -> [[f(x) /~/ h(x)] <-> [lim{f(x)/h(x) | x-->+oo} == 1]]]
  [?[x0 :: real] -> @[f,h :: real{>x0} -> real{>0}] -> [[have_the_same_order_of_magnitude_(f,h)] <-> [?[C4inferior,C4superior :: real{>0}] -> ?[x1 :: real{>x0}] -> @[x :: real{>x1}] -> [C4inferior <= f(x)/h(x) <= C4superior]]]]
  [?[x0 :: real] -> @[f,g :: real -> real] -> @[h :: real{>x0} -> real{>0}] -> [[f(x) == g(x) +O(h(x))] <-> [have_the_same_order_of_magnitude_((\x->h(x)+abs(f(x)-g(x))),h)]]]
    # big_O_notation
  [?[x0 :: real] -> @[f,g :: real -> real] -> @[h :: real{>x0} -> real{>0}] -> [[f(x) == g(x) +o(h(x))] <-> [lim{(f(x)-g(x))/h(x) | x-->+oo} == 0]]]
    # ???small_O_notation

  I. The Growth of PI(x)
  H. Some Properties of PI(x)
  @page247[272/567]
  [x::real]:
    [PI(x) =[def]= num_primes_le(x)]
  Bertrand_postulate_1845:
  [[n>=2] -> [num_primes_le(2*n) -num_primes_le(n) >= 1]]
  <==>:
  [[n>=1] -> [num_primes_le(2*n) -num_primes_le(n) >= 1]]
  <==>:
  [[n>=1] -> [PRIMES_S1(n+1) < 2*PRIMES_S1(n)]]
  <<==:
  [[n>=5] -> [1 < (1/3)*n/ln(n) < (num_primes_le(2*n) -num_primes_le(n)) < (7/5)*n/ln(n)]]

  [@[x,y :: real] -> [x>=6] -> [x>=y>=2] -> [num_primes_le(x*y) > num_primes_le(x)+num_primes_le(y)]]

  [@[x,y :: real] -> [???:[x>=???][y>=???][y>1]...] -> [num_primes_le(x+y) <= num_primes_le(x)+2*y/ln(y)]]
    # [2*y/ln(y) >= 2*e/ln(e) == 2*e == 5.43656365691809]
    #   where [e:=2.718281828459045]
    # [ln(y4)==4] <-> [y4==e**4==54.59815003314423]
    # [ln(y6)==6] <-> [y6==e**6==403.428793492735]
    # [ln(y8)==8] <-> [y8==e**8==2980.957987041727]
    =>:
    [@[x,y :: real] -> [???:[x>=???]...] -> [y>=54.59815003314423] -> [num_primes_le(x+y4) <= num_primes_le(x)+y/2]]
    [@[x,y :: real] -> [???:[x>=???]...] -> [y>=403.428793492735] -> [num_primes_le(x+y4) <= num_primes_le(x)+y/3]]
    [@[x,y :: real] -> [???:[x>=???]...] -> [y>=2980.957987041727] -> [num_primes_le(x+y4) <= num_primes_le(x)+y/4]]
  ==>>:
  [@[x,y :: real] -> [???:[x>=???][y>=2]...] -> [num_primes_le(x+y) <= num_primes_le(x)+2*num_primes_le(y)]]

  [@[x :: real] -> [x>=11] -> [num_primes_le(2*x) < 2*num_primes_le(x)]]

  [[x :: real][x>1]]:
    [main_ratio4num_primesLE =[def]= num_primes_le(x)/(x*ln(x))]
  [@[x :: real] -> [x>1] -> [main_ratio4num_primesLE(x) <= main_ratio4num_primesLE(113) ~=1.25...]]
  [@[x :: real] -> [x>1] -> [0.95695 < main_ratio4num_primesLE(x) < 1.04423]]

  the_prime_number_theorem
  the_fundamental_prime_number_theorem
  [num_primes_le(x) /~/ x/ln(x)]
    =>:
    [num_primes_le(p) /~/ p/ln(p)]
    [n == num_primes_le(PRIMES_S1[n]) /~/ PRIMES_S1[n]/ln(PRIMES_S1[n])]
    [n /~/ PRIMES_S1[n]/ln(PRIMES_S1[n])]
  [num_primes_le(x) /~/ Li(x) /~/ x/ln(x)]
    #Li更佳:
    #??? [(abs(Li(x) -num_primes_le(x))) = o(abs(x/ln(x) -num_primes_le(x)))]
  [[N>=1] -> [num_primes_le(N) == num_primes_le(floor_sqrt(N)) -1+sum[mu(d)*(N//d) | [[d:<-all_divisors_of(II[p | [[p::prime][p**2<=N]]])][d<=N]]]]]
    # !! Eratosthenes sieve
    #mu=the_Mobius_function
    #   含平方因子则为零
    #   不含平方因子且偶数个素因子则为一
    #   不含平方因子且奇数个素因子则为负一

  [k >= 0]:
    [def:Bernoulli_numbers[k] :=> [sum[C(k+1;k+1-j)*Bernoulli_numbers[j] | [j:<-[0..=k]]] == [k==0]]]
      # 1, -1/2, 1/6, 0, ...
    [Bernoulli_numbers[2*k+1] == [k==0]*(-1/2)]
  [k >= 0]:
    [Bernoulli_polynomials[k](x) =[def]= sum[C(k;i)*Bernoulli[k-i]*x**i | [i:<-[0..=k]]]]
  [[k>=1] -> [Bernoulli_numbers[2*k+1] == 0]]
  [x/(e**x-1) == sum[Bernoulli_numbers[k]*x**k/k! | [k:<-[0..]]]]
    #coefficients in the Taylor expansion
  [n! /~/ sqrt(2*pi)*n**(n+1/2)/e**n]
  [Bernoulli_numbers[2*n] /~/ 4*sqrt(pi*n)*(n/pi/e)**(2*n)]
    #Stirling_formula

  [[k>=1] -> [n>=0] -> [sum[j**k | [j:<-[1..=n]]] == (1/(k+1) * sum[(-1)**(k+1-i)*Bernoulli_numbers[k+1-i]*C(k+1;k+1-i)*n**i | [i:<-[1..=1+k]]]) == n**k/2 +(1/(k+1) * sum[Bernoulli_numbers[2*d]*C(k+1;2*d)*n**(k+1-2*d) | [d:<-[0..=k//2]]])]]
    # 公式纟求和纟离散幂方:here
    <==> [[k>=1] -> [n>=0] -> [sum[j**k | [j:<-[1..=n]]] == (1/(k+1) * (-1)**(k+1) * (Bernoulli_polynomials[k+1](-n) -Bernoulli_numbers[k+1]))]]

  [[k>=1] -> [zeta(2*k) == sum[1/n**(2*k) | [n:<-[1..]]] == ((-1)**(k+1)*(2*pi)**(2*k)*Bernoulli_numbers[2*k]/2/(2*k)!)]]
    [zeta(2) == sum[1/n**2 | [n:<-[1..]]] == pi**2/6]
    [zeta(4) == sum[1/n**4 | [n:<-[1..]]] == pi**4/90]

  [@[f :: continuous_function] -> @[k:<-[1..]] -> [is_continuously_differentiable_(k;f)] -> [a,b::int] -> [a<b] -> [sum[f(n) | [n:<-[a+1..=b]]] == (SS{f(t) | [t :<~ a~>b]} +sum[(-1)**r*Bernoulli_numbers[r]/r! * (D(r-1,f;b) -D(r-1,f;a)) | [r:<-[1..=k]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*D(k,f;t) | [t :<~ a~>b]})]]
    #Euler_MacLaurin_summation_formula:here
    # 公式纟求和转积分:here
    #     推导过程应该是依赖 f的泰勒展开式+公式纟求和纟离散幂方
    #######
    #######
    # a far-reaching generalization of Abel's summation formula, namely, the well-known Euler-MacLaurin summation formulas:
    # If f(x) is a continuous function, continuously differentiable as many times as required, if a < b are integers, then
    #######
    #######
  [+sum[(-1)**r*Bernoulli_numbers[r]/r! * (D(r-1,f;b) -D(r-1,f;a)) | [r:<-[1..=k]]]
  !! [[k>=1] -> [Bernoulli_numbers[2*k+1] == 0]]
  == +(-1)**1*Bernoulli_numbers[1]/1! * (D(1-1,f;b) -D(1-1,f;a))
     +sum[(-1)**(2*h)*Bernoulli_numbers[(2*h)]/(2*h)! * (D((2*h)-1,f;b) -D((2*h)-1,f;a)) | [h:<-[1..=k//2]]]
  == -(-1/2) * (f(b) -f(a))
     +sum[Bernoulli_numbers[(2*h)]/(2*h)! * (D((2*h)-1,f;b) -D((2*h)-1,f;a)) | [h:<-[1..=k//2]]]
  == +(f(b) -f(a))/2
     +sum[Bernoulli_numbers[r]/r! * (D(r-1,f;b) -D(r-1,f;a)) | [r:<-[2..=k]]]
  ]
  [@[f :: continuous_function] -> @[k:<-[1..]] -> [is_continuously_differentiable_(k;f)] -> [a,b::int] -> [a<b] -> [sum[f(n) | [n:<-[a+1..=b]]] == (SS{f(t) | [t :<~ a~>b]} +(f(b) -f(a))/2 +sum[Bernoulli_numbers[r]/r! * (D(r-1,f;b) -D(r-1,f;a)) | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*D(k,f;t) | [t :<~ a~>b]})]]
    #Euler_MacLaurin_summation_formula__variant1:here
    # 公式纟求和转积分牜变体一:here


  [[z::complex][z.real>1]]:
    [zeta(z) =[def]= sum[1/n**z | [n:<-[1..]]]]
      #the_zeta_function
      #Euler-real-x
      #Riemann-complex-z
      #zeta==£
  [zeta(1) == sum[1/n | [n:<-[1..]]] == +oo]
  [sum[1/p | [p::prime]] == +oo]
  [@[z::complex] -> [z.real>1] -> [zeta(z) == sum[1/n**z | [n:<-[1..]]] == II[1/(1-1/p**z) | [p::prime]] =!= 0]]
    #Euler_product_formula:here
    #   联系zeta(z)与素数
    [zeta(z)
    == sum[1/n**z | [n:<-[1..]]]
    == II[sum[(1/p**z)**k | [k:<-[1..]]] | [p::prime]]
    == II[1/(1-1/p**z) | [p::prime]]
    # => [abs(zeta(z)) > 1]
    # => [abs(zeta(z)) =!= 0]
    =!= 0
    ]
  ==>>:
  [@[z::complex] -> [z.real>1] -> [zeta(z) =!= 0]]
      # [z.real>1] => [zeta(z) =!= 0]

  [@[z::complex] -> [z.real>1] -> [zeta(z) uniformly convergent]]
  [@[z::complex] -> [z.real>1] -> [zeta(z) continuous and differentiable]]
  [zeta(+oo) == 1]
  [lim{err*zeta(1+err) | err --> 0^+} == 1]

  [[z::complex][z.real>1]]:
    [x::real][x>=1][k:<-[1..]]:
      [SS{t**-z | t :<~ 1~>x} == x**(1-z)/(1-z) -1/(1-z)]
      [SS{t**-z | t :<~ 1~>+oo} == +oo**(1-z)/(1-z) -1/(1-z) == 0-1/(1-z) == -1/(1-z) == 1/(z-1)]
    [SS{t**-z | t :<~ 1~>+oo} == 1/(z-1)]
    [k:<-[1..]]:
      !! Euler_MacLaurin_summation_formula__variant1:公式纟求和转积分牜变体一:goto
      # [@[f :: continuous_function] -> @[k:<-[1..]] -> [is_continuously_differentiable_(k;f)] -> [a,b::int] -> [a<b] -> [sum[f(n) | [n:<-[a+1..=b]]] == (SS{f(t) | [t :<~ a~>b]} +(f(b) -f(a))/2 +sum[Bernoulli_numbers[k]/k! * (D(r-1,f;b) -D(r-1,f;a)) | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*D(k,f;t) | [t :<~ a~>b]})]]
      # [f(t) := t**-z]
      # [a := 1]
      # [b := +oo]
      # [D(k,f;t) == (t**(-z-k)*II[(-z-i) | [i:<-[0..<k]]])]
      #
      #
      [zeta(z) - 1
      == sum[n**-z | [n:<-[2..]]]
      # [f(t) := t**-z]
      :> [a:=1]
      :> [b:=+oo]
      == (SS{t**-z | [t :<~ a~>b]} +(b**-z -a**-z)/2 +sum[Bernoulli_numbers[r]/r! * ((b**(-z-(r-1))*II[(-z-i) | [i:<-[0..<(r-1)]]]) -(a**(-z-(r-1))*II[(-z-i) | [i:<-[0..<(r-1)]]])) | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*(t**(-z-k)*II[(-z-i) | [i:<-[0..<k]]]) | [t :<~ a~>b]})
      !! [a:=1]
      !! [b:=+oo]
      == (SS{t**-z | [t :<~ 1~>+oo]} +(+oo**-z -1**-z)/2 +sum[Bernoulli_numbers[r]/r! * (0 -(1*II[(-z-i) | [i:<-[0..<(r-1)]]])) | [r:<-[2..=k]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*(t**(-z-k)*II[(-z-i) | [i:<-[0..<k]]]) | [t :<~ 1~>+oo]})
    !! [SS{t**-z | t :<~ 1~>+oo} == 1/(z-1)]
      == (1/(z-1) +(0-1)/2 +sum[Bernoulli_numbers[r]/r! * (-1*II[(-z-i) | [i:<-[0..<(r-1)]]]) | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*(t**(-z-k)*II[(-z-i) | [i:<-[0..<k]]]) | [t :<~ 1~>+oo]})
      # (-z-i) --> (-1)*(z+i)
      == (1/(z-1) -1/2 +sum[Bernoulli_numbers[r]/r! * (-1)*(-1)**(r-1)*II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)**(k-1)/k! * SS{Bernoulli_polynomials(k;t-floor(t))*(t**(-z-k)*(-1)**k*II[(z+i) | [i:<-[0..<k]]]) | [t :<~ 1~>+oo]})
      !! [optional:[r%2==0]]
      == (1/(z-1) -1/2 +sum[Bernoulli_numbers[r]/r! * II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)/k! *II[(z+i) | [i:<-[0..<k]]] *SS{Bernoulli_polynomials(k;t-floor(t))*(t**(-z-k)) | [t :<~ 1~>+oo]})
      ]
      [zeta(z) - 1 == (1/(z-1) -1/2 +sum[Bernoulli_numbers[r]/r! * II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)/k! *II[(z+i) | [i:<-[0..<k]]] *SS{Bernoulli_polynomials(k;t-floor(t))*(t**(-z-k)) | [t :<~ 1~>+oo]})]
      ==>>:
      [zeta(z) == (1/(z-1) +1/2 +sum[Bernoulli_numbers[r]/r! * II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)/k! *II[(z+i) | [i:<-[0..<k]]] *SS{Bernoulli_polynomials(k;t-floor(t))*(t**-(z+k)) | [t :<~ 1~>+oo]})]
    [[k:<-[1..]] -> [zeta(z) == (1/(z-1) +1/2 +sum[Bernoulli_numbers[r]/r! * II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)/k! *II[(z+i) | [i:<-[0..<k]]] *SS{Bernoulli_polynomials(k;t-floor(t))*(t**-(z+k)) | [t :<~ 1~>+oo]})]]
      #最后的积分项:在[z.real+k>1]即[z.real>1-k]上收敛；由于[k>=1]，所以此积分项全复平面收敛。
      #zeta(z)只有一个简单极点:即首项(1/(z-1))
      #The integral converges for [Re(z) > 1-k], and since k is an arbitrary positive natural number, this formula provides the analytic continuation of zeta(z) to the whole plane. zeta(z) is everywhere holomorphic, except at z = 1, where it has a simple pole with residue 1, that is, [lim{zeta(z)*(z-1) | z-->1} == 1].
      # @page222[247/567]
  [@[z::complex] -> [z.real>1] -> [k:<-[1..]] -> [zeta(z) == (1/(z-1) +1/2 +sum[Bernoulli_numbers[r]/r! * II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)/k! *II[(z+i) | [i:<-[0..<k]]] *SS{Bernoulli_polynomials(k;t-floor(t))*(t**-(z+k)) | [t :<~ 1~>+oo]})]]
    #公式:证明zeta(z)全复平面唯一极点简单
    #公式:证明(zeta(z)*(z-1))全复平面连续性




  [[z::complex][z.real>0]]:
    #the_gamma_function-ver1-only_right_half_complex_plane
    [gamma(z) =[def]= SS{e**-t * t**(z-1) |t :<~ 0~>+oo}]
      #eulerian integral
  [[z::complex][z !<- {-n | [n:<-[0..]]}]]:
    #the_gamma_function-ver2-almost_whole_complex_plane
    [gamma(z) =[def]= (z**-1 * e**(-y4Euler*z) * II[e**(z/n)/(1+(z/n)) | [n:<-[1..]]])]
    [y4Euler == Euler_constant =[def]= lim{(sum[1/k| [k:<-[1..=n]]] -ln(n)) | n-->+oo} ~= 0.577215665...]
    [e**y4Euler == Mascheroni_constant =[def]= lim{((II[1/(1-1/PRIMES_S1[k])| [k:<-[1..=n]]]) /ln(n)) | n-->+oo} ~= 0.577215665...]
      #у
  [z::complex]:
    #reciprocal_of_the_gamma_function-whole_complex_plane
    [reciprocal_gamma(z) =[def]= (z * e**(y4Euler*z) * II[(1+(z/n))/e**(z/n) | [n:<-[1..]]])]
  [lim{reciprocal_gamma(z)/z | z-->0} == (e**(y4Euler*0) * II[(1+(0/n))/e**(0/n) | [n:<-[1..]]]) == 1]
  [lim{reciprocal_gamma(z)/z | z-->0} == 1]
  [lim{1/gamma(z)/z | z-->0} == 1]

  # @page223[248/567]
  #gamma(z) is never equal to 0; it is holomorphic everywhere except at the points 0, -1, -2, -3, ..., where it has simple poles.  For every positive integer n, gamma(n) = (n - 1)!, so the gamma function is an extension of the factorial function. The gamma function satisfies many interesting relations, among which are the functional equations:
  [gamma(z)*gamma(1-z) == pi/sin(pi*z)]
  [gamma(z)*gamma(z+1/2) == sqrt(pi)/2**(2*z-1) *gamma(2*z)]
  [gamma(z+1) == z*gamma(z)]

  [gamma(z) =!= 0]
  [[n::uint] -> [gamma(n+1) == n!]]
  [@[z::complex] -> [[1/gamma(z) == 0] <-> [z <- {-n | [n:<-[0..]]}]]]
    #极点
  [lim{1/gamma(z)/z | z-->0} == 1]

  !! [gamma(z)*gamma(z+1/2) == sqrt(pi)/2**(2*z-1) *gamma(2*z)]
  [gamma(z+1/2) == sqrt(pi)/2**(2*z-1) *gamma(2*z) /gamma(z)]
  [gamma(1/2)
  == sqrt(pi)/2**(2*0-1) *lim{gamma(2*z) /gamma(z) | z-->0}
  == sqrt(pi)/2**(2*0-1) *1/2 *lim{(gamma(2*z)*2*z) /(gamma(z)*z) | z-->0}
  !! [lim{1/gamma(z)/z | z-->0} == 1]
  == sqrt(pi)/2**(2*0-1) *1/2 *1/1
  == sqrt(pi)
  ]
  [gamma(1/2) == sqrt(pi)]










  [gamma_zeta(z) =[def]= pi**-(z/2) *gamma(z/2) *zeta(z)]

  [gamma_zeta(z) == gamma_zeta(1-z)]
    # the_functional_equation_for_the_Riemann_zeta_function
    #对称性:对称轴:[z.real==1/2]
  <==>:
  [pi**-(z/2) *gamma(z/2) *zeta(z) == pi**-((1-z)/2) *gamma((1-z)/2) *zeta((1-z))]
  <==>:
  [zeta(z) == pi**(z-1/2) *gamma((1-z)/2) /gamma(z/2) *zeta((1-z))]
  <==>:
  !! [gamma(z)*gamma(1-z) == pi/sin(pi*z)]
  => [gamma((1-z)/2)*gamma(1-(1-z)/2) == pi/sin(pi*(1-z)/2)]
  => [gamma((1-z)/2) == pi/sin(pi*(1-z)/2) /gamma((1+z)/2)]
  [zeta(z) == pi**(z-1/2) *pi/sin(pi*(1-z)/2) /gamma((1+z)/2) /gamma(z/2) *zeta((1-z))]
  <==>:
  !! [gamma(z)*gamma(z+1/2) == sqrt(pi)/2**(2*z-1) *gamma(2*z)]
  => [gamma((z/2))*gamma((z/2)+1/2) == sqrt(pi)/2**(2*(z/2)-1) *gamma(2*(z/2))]
  => [gamma(z/2)*gamma((1+z)/2) == sqrt(pi)/2**(z-1) *gamma(z)]
  [zeta(z) == pi**(z-1/2) *pi/sin(pi*(1-z)/2) /sqrt(pi) *2**(z-1) /gamma(z) *zeta((1-z))]
  <==>:
  [zeta(z) == (2**(z-1) *pi**z /sin(pi/2*(1-z)) /gamma(z) *zeta(1-z))]

  !! [zeta(z) == (2**(z-1) *pi**z /sin(pi/2*(1-z)) /gamma(z) *zeta(1-z))]
  !! [@[z::complex] -> [z.real>1] -> [zeta(z) =!= 0]]
  [@[z::complex] -> [z.real<0] -> [[zeta(z) == 0] -> [1/gamma(z) == 0]]]
  !! [@[z::complex] -> [[1/gamma(z) == 0] <-> [z <- {-n | [n:<-[0..]]}]]]
  [@[z::complex] -> [z.real<0] -> [[zeta(z) == 0] -> [z <- {-n | [n:<-[0..]]}]]]
    但是因为1/sin(pi/2*(1-z))抵消部分1/gamma(z)零点，所以只是『->』而非『<->』

  上面打开方式不对，从头再来:
  !! [zeta(z) == pi**(z-1/2) *gamma((1-z)/2) /gamma(z/2) *zeta((1-z))]
  !! [@[z::complex] -> [z.real>1] -> [zeta(z) =!= 0]]
  !! [gamma(z) =!= 0]
  [@[z::complex] -> [z.real<0] -> [[zeta(z) == 0] <-> [1/gamma(z/2) == 0]]]
  !! [@[z::complex] -> [[1/gamma(z) == 0] <-> [z <- {-n | [n:<-[0..]]}]]]
  [@[z::complex] -> [z.real<0] -> [[zeta(z) == 0] <-> [1/gamma(z/2) == 0] <-> [(z/2) <- {-n | [n:<-[0..]]}] <-> [z <- {-2*n | [n:<-[0..]]}] <-> [z <- {-2*n | [n:<-[1..]]}]]]
    # 注意:前提 => [z=!=0]
  [@[z::complex] -> [z.real<0] -> [[zeta(z) == 0] <-> [z <- {-2*n | [n:<-[1..]]}]]]
    #zeta(z)平凡零点

  !! [zeta(z) == pi**(z-1/2) *gamma((1-z)/2) /gamma(z/2) *zeta((1-z))]
  [zeta(0)
  == pi**(0-1/2) *gamma((1-0)/2) *lim{1/gamma(z/2) *zeta((1-z)) | z-->0}
  == pi**(-1/2) *gamma(1/2) *(-1/2)*lim{1/(gamma(z/2)*z/2) *zeta(1-z)*(-z) | z-->0}
  !! [lim{1/gamma(z)/z | z-->0} == 1]
  !! [lim{err*zeta(1+err) | err --> 0^+} == 1]
  == pi**(-1/2) *gamma(1/2) *(-1/2) *1
  !! [gamma(1/2) == sqrt(pi)]
  == pi**(-1/2) *sqrt(pi) * (-1/2)
  == (-1/2)
  ]
  [zeta(0) == (-1/2)]

  [Riemann_hypothesis:[@[z::complex] -> [0<=z.real<=1] -> [zeta(z) == 0] -> [z.real==1/2]]]
    #黎曼猜想:zeta(z)所有非平凡零点在对称轴[Re(z) = 1/2]上
    # vs:平凡零点:[@[z::complex] -> [z.real<0] -> [[zeta(z) == 0] <-> [z <- {-2*n | [n:<-[1..]]}]]]
  ==>>:
  [[
  Here is the functional equation for the Riemann zeta function:
      [pi**-(z/2) *gamma(z/2) *zeta(z) == pi**-((1-z)/2) *gamma((1-z)/2) *zeta((1-z))]
  For example, it follows from the functional equation that [zeta(0) == -1/2].
  The zeros of the zeta function are:
    (a) Simple zeros at the points -2, -4, -6, ..., which are called the trivial zeros.
    (b) Zeros in the critical strip, consisting of the nonreal complex numbers z with [0 < Re(z) < 1].
  Indeed, if Re(z) > 1, then by the Euler product, [zeta(z) =!= 0]. If Re(z) < 0, then Re(1-z) > 1, the right-hand side in the functional equation is not zero, so the zeros must be exactly at z = -2, -4, -6,..., which are the poles of gamma(z/2).
  The knowledge of the zeros in the critical strip has a profound influence on the understanding of the distribution of primes. A first thing to note is that the zeros in the critical strip are not real and they are symmetric about the real axis and the vertical line [Re(z) = 1/2].
  Riemann conjectured that all nontrivial zeros z0 of zeta(z) are on the critical line [Re(z) = 1/2], that is, [z0 == 1/2 + 1j*y0]. This is the famous Riemann's hypothesis, which has never been proved. It is undoubtedly a very difficult and important problem, and I shall return to it soon and narrate some modern developments.

  ]]


  #Li(x) --> Li(z)
  [x::real]:
    [sgn_(x) =[def]= ([x>0]*(+1) +[x<0]*(-1) +[x==0]*(0))]
  [x::real]:
    # Li(x):the function logarithmic integral of x # ver1
    [Li(x) =[def]= SS{1/ln(t) | [t :<~ 2 ~> x]}]
  [z::complex][(u,v) :=> [e**(u+1j*v)==z]]:
    # Li(z):the function logarithmic integral of z # ver2
    [Li(z) =[def]= SS{e**t/t | [t :<~ -oo+ ~> u+1j*v]} +1j*pi*sgn_(v)]

  #Rm(x) --> Rm(z)
  [x::real{>0}]:
    #the_Riemann_function-ver1-单用(非精确估算num_primes_le)
    [Rm(x) =[def]= sum[mu(m)/m * Li(x**/m) | [m:<-[1..]]]]
  [z::complex]:
    #the_Riemann_function-ver2-复用(精确估算num_primes_le)
    # 需要拓展Li的定义
    [Rm(z) =[def]= sum[mu(m)/m * Li(z**/m) | [m:<-[1..]]]]


  [num_primes_le(x) == (Rm(x) - sum[Rm(x**z0) | [z0:<-[zeros of zeta(z) with its own multiplicity]]])]
    #复用(精确估算num_primes_le)
  [num_primes_le(x) ~= Rm(x)]
    #单用(非精确估算num_primes_le)
  [num_primes_le(x) == (Rm(x) - sum[Rm(x**z0) | [z0:<-[zeros of zeta(z) with its own multiplicity]]]) /~/ Rm(x) /~/ Li(x) /~/ (x/ln(x))]
    #Rm最佳估计, Li次佳估计, (x/ln(x))一般估计
    #但是:{Rm,Li}的误差有正有负，而(x/ln(x))尾部总是小于num_primes_le(x)
  [[x>=11] -> [num_primes_le(x) >= (x/ln(x))]]
  [lim{[Li(x) > num_primes_le(x)] | x-->+oo} == diverge]
    #the difference (Li(x) -PI(x)) changes sign infinitely often
  [?[n0:<-[6.62e370..=6.69e370-1e180]] -> @[n:<-[n0..<n0+1e180]] -> [num_primes_le(n) >= Li(n)]]
    # [between 6.62*10**370 and 6.69*10**370 there are more than 10**180 successive integers x for which PI(x) > Li(x)]



  [Rm(x) == 1+sum[(ln(x)**n /n! /n /zeta(n+1))| [n:<-[1..]]]]
    #求值冫黎曼函数
    # 快速收敛序列
    zeta(n+1) 独立计算缓存
    注意:偶数:[[k>=1] -> [zeta(2*k) == sum[1/n**(2*k) | [n:<-[1..]]] == ((-1)**(k+1)*(2*pi)**(2*k)*Bernoulli_numbers[2*k]/2/(2*k)!)]]
    奇数怎么办？难道用:
      [@[z::complex] -> [z.real>1] -> [k:<-[1..]] -> [zeta(z) == (1/(z-1) +1/2 +sum[Bernoulli_numbers[r]/r! * II[(z+i) | [i:<-[0..<(r-1)]]] | [r:<-[2..=k]][optional:[r%2==0]]] +(-1)/k! *II[(z+i) | [i:<-[0..<k]]] *SS{Bernoulli_polynomials(k;t-floor(t))*(t**-(z+k)) | [t :<~ 1~>+oo]})]]






  [?[c>0] -> ?[t0>e**(2*c)] -> @[u,v::real] -> [(1-c/ln(max(t0,abs(v)))) <= u <= 1] -> [z:=u+1j*v] -> [zeta(z) =!= 0]]
    #zero-free regions for the zeta function
    #zeta(z)无零点区域
  ==>>:
  [[v::real] -> [zeta(1+1j*v) =!= 0]]

  ??? ==>>:
  [?[C>0] -> [num_primes_le(x) == Li(x) + O(x*e**(-C*sqrt(ln(x))))]]
    #num_primes_le估算误差 <<== zeta(z)无零点区域





  [n:<-[1..]]:
    [eq1_(n) =[def]= [n==1]]
    [constant1_(n) =[def]= 1]

  [is_arithmetical_function_(f) =[def]= [f :: int{>=1} -> numberT]]
  [z::complex][f :: int{>=1} -> numberT]:
    [gzeta(f;z) =[def]= sum[f(n)/n**z | [n:<-[1..=]]]]
  [[z::complex{.real>1}] -> [gzeta(constant1_;z) == zeta(z)]]
  [[z::complex{.real>1}] -> [gzeta(mu;z) == 1/zeta(z)]]
    #proof via (<*>) see below
  ??? [[gzeta(mu;1) == 0] <-> [num_primes_le(x) /~/ x/ln(x)]]

  [n:<-[1..]][f,g :: int{>=1} -> numberT]:
    [Dirichlet_convolution(f,g;n) =[def]= sum[f(d)*g(n///d) | [d:<-[1..=n]][n%d==0]]]
    [(f <+> g) =[def]= (\n->f(n)+g(n))]
    [(f <*> g) =[def]= (\n->Dirichlet_convolution(f,g;n))]
      #(<+>),(<*>) ==>> the set of arithmetical functions becomes an algebra,
    [[gzeta(f;z),gzeta(f;z) both converges] => [gzeta((f<*>g);z) == gzeta(f;z)*gzeta(g;z)]]

    [D_(f) =[def]= (\n->f(n)*ln(n))]
      #a derivation of the algebra of arithmetic functions
      #微分算子
  [[f,g :: arithmetical_function] -> [gzeta(f;z),gzeta(f;z) both converges] => [gzeta((f<*>g);z) == gzeta(f;z)*gzeta(g;z)]]
  [f,g,h :: int{>=1} -> numberT]:
    #代数特性:
    [((f <*> g) <*> h) == (f <*> (g <*> h))]
      # 结合律
    [(f <*> eq1_) == f == (eq1_ <*> f)]
      # 左右幺元存在
    #不太行:[[[(f <*> g) == f]or[(g <*> f) == f]] -> [g == eq1_]]
      # bug:左右幺元相同唯一
    [[f(0)=!=0] -> [[(f <*> g) == f]or[(g <*> f) == f]] -> [g == eq1_]]
      # 可逆元的左右幺元相同唯一
    [[(f <*> g) == eq1_] <-> [(g <*> f) == eq1_]]
      # 左右逆元要么相同要么同时不存在
    [[(f <*> g) == eq1_] -> [(f <*> h) == eq1_] -> [g == h]]
      # 逆元若存在则唯一

    [D_(f <+> g) == D_(f) <+> D_(g)]
    [D_(f <*> g) == (D_(f)<*>g) <+> (f<*>D_(g))]

  [n:<-[1..]][f,g :: int{>=1} -> numberT]:
    [is_the_Dirichlet_convolution_inverse_of(f;g) =[def]= [Dirichlet_convolution(f,g;n) == eq1_(n)]]
    [is_the_Dirichlet_convolution_inverse_of(f;g) == [(f <*> g) == eq1_]]

  [@[f :: int{>=1} -> numberT] -> [f(1) =!= 0] -> ?1[g :: int{>=1} -> numberT] -> [is_the_Dirichlet_convolution_inverse_of(f;g)]]
  [is_the_Dirichlet_convolution_inverse_of(constant1_;mu)]
  <==>:
  [(mu <*> constant1_) == eq1_]
  ==>>:
  [[f:=(constant1_ <*> g)] -> [g ==(mu <*> f)]]
  <==>:
  [[f(n):=Dirichlet_convolution(constant1_,g;n)] -> [g(n)==Dirichlet_convolution(mu,f;n)]]
  <==>:
  [[f(n):=sum[g(d) | [d:<-[1..=n]][n%d==0]]] -> [g(n)==sum[mu(d)*f(n///d) | [d:<-[1..=n]][n%d==0]]]]
    #the_Mobius_inversion_formula


  [gzeta(eq1_;z) == 1]
  !!  [(mu <*> constant1_) == eq1_]
  [gzeta((mu <*> constant1_);z) == 1]
  !! [[f,g :: arithmetical_function] -> [gzeta(f;z),gzeta(f;z) both converges] => [gzeta((f<*>g);z) == gzeta(f;z)*gzeta(g;z)]]
  [gzeta((mu <*> constant1_);z) =?= gzeta(mu;z)*gzeta(constant1_;z)]
  [gzeta(mu;z) =?= gzeta((mu <*> constant1_);z)/gzeta(constant1_;z)]
  !! [gzeta((mu <*> constant1_);z) == 1]
  [gzeta(mu;z) =?= 1/gzeta(constant1_;z)]
  !! [[z::complex{.real>1}] -> [gzeta(constant1_;z) == zeta(z)]]
  [[z::complex{.real>1}] -> [gzeta(mu;z) == 1/zeta(z)]]

  [gzeta(constant1_;1) == +oo]
  [gzeta(mu;1) =?= 1/gzeta(constant1_;z) == 1/+oo == 0]
  [gzeta(mu;1) == 0]
  ??? <==>:
  [num_primes_le(x) /~/ x/ln(x)]
    #the_prime_number_theorem




  [x::real]:
    #the summatory function of the_Mobius_function
    # the_Mertens_function
    [sum_mu_le(x) =[def]= sum[mu(n) | [n:<-[1..]][n<=x]]]
    #注意:mu(n)可能为-1 => sum_mu_le(x)可能为负数
  [@[x::real] -> [x < 1] -> [sum_mu_le(x) == 0]]
  [@[x::real] -> [sum_mu_le(x) == sum_mu_le(floor(x))]]
    #sum_mu_le阶梯状突变型函数
    #sum_mu_le于相邻两个整数之间是常量
  [@[n::int{>=1}] -> [mu(n) == sum_mu_le(n) - sum_mu_le(n-1)]]

  [z::complex{.real>1}]:
    #关联sum_mu_le+Riemann_hypothesis
    [1/zeta(z)
    !! [[z::complex{.real>1}] -> [gzeta(mu;z) == 1/zeta(z)]]
    == sum[mu(n)/n**z | [n:<-[1..]]]
    !! [@[n::int{>=1}] -> [mu(n) == sum_mu_le(n) - sum_mu_le(n-1)]]
    == sum[(sum_mu_le(n) - sum_mu_le(n-1))/n**z | [n:<-[1..]]]
    == sum[sum_mu_le(n)/n**z | [n:<-[1..]]]
      -sum[sum_mu_le(n-1)/n**z | [n:<-[1..]]]
    == sum[sum_mu_le(n)/n**z | [n:<-[1..]]]
      -sum[sum_mu_le(n)/(n+1)**z | [n:<-[0..]]]
    !! [sum_mu_le(0) == 0]
    == sum[sum_mu_le(n)/n**z | [n:<-[1..]]]
      -sum[sum_mu_le(n)/(n+1)**z | [n:<-[1..]]]
    == sum[sum_mu_le(n)*(1/n**z -/(n+1)**z) | [n:<-[1..]]]
    !! [D<t>(t**-z) == -z*t**-(z+1)]
    => [SS{-z*t**-(z+1) | t :<~ n~>(n+1)} == (n+1)**-z -n**-z]
    => [(1/n**z -/(n+1)**z) == -((n+1)**-z -n**-z) == SS{z*t**-(z+1) | t :<~ n~>(n+1)}]
    == sum[sum_mu_le(n)*SS{z*t**-(z+1) | t :<~ n~>(n+1)} | [n:<-[1..]]]
    !! [@[x::real] -> [sum_mu_le(x) == sum_mu_le(floor(x))]]
    == sum[SS{sum_mu_le(t)*z*t**-(z+1) | t :<~ n~>(n+1)} | [n:<-[1..]]]
    == SS{sum_mu_le(t)*z*t**-(z+1) | t :<~ 1~>+oo}
    == z*SS{sum_mu_le(t)*t**-(z+1) | t :<~ 1~>+oo}
    ]
    [1/zeta(z) == z*SS{sum_mu_le(t)*t**-(z+1) | t :<~ 1~>+oo}]
  [[z::complex{.real>1}] -> [1/zeta(z) == z*SS{sum_mu_le(t)*t**-(z+1) | t :<~ 1~>+oo}]]
  ==>>:
  [?[C>0] -> @[x>0] -> [abs(sum_mu_le(x)) < C*sqrt(x)] -> [Riemann_hypothesis:[@[z::complex] -> [0<=z.real<=1] -> [zeta(z) == 0] -> [z.real==1/2]]]]
    #sqrt(x)即(x**(1/2)) 对应于 [1/2<z.real<=1]
    #   !! zeta(z)对称性(the_functional_equation_for_the_Riemann_zeta_function)
    #   => [-1<=z.real<-1/2]
    #   排除两侧的非平凡零点
    [[证明:
    [z.real>1/2]:
      [abs(SS{sum_mu_le(t)*t**-(z+1) | t :<~ 1~>+oo})
      <= SS{abs(sum_mu_le(t)*t**-(z+1)) | t :<~ 1~>+oo}
      !! [abs(sum_mu_le(x)) < C*sqrt(x)]
      < SS{C*sqrt(t)*t**-(z+1) | t :<~ 1~>+oo}
      == C*SS{t**-(z+1/2) | t :<~ 1~>+oo}
      !! [z.real>1/2]
      => [(z+1/2).real>1]
      #== C*((t**-(z-1/2))/-(z-1/2) : diff at t:=1,+oo)
      == C*((+oo**-(z-1/2)) -(1**-(z-1/2)))/-(z-1/2)
      !! [z.real>1/2]
      == C*(0 -1)/-(z-1/2)
      == C/(z-1/2)
      < +oo
      ]
      [abs(SS{sum_mu_le(t)*t**-(z+1) | t :<~ 1~>+oo}) < +oo]
        #=> 收敛
        #=> 是关于z的解析连续函数
      !! [[z::complex{.real>1}] -> [1/zeta(z) == z*SS{sum_mu_le(t)*t**-(z+1) | t :<~ 1~>+oo}]]
      the last integral defines an analytic function on the domain where [z.real>1/2].
      So, (1/zeta(z)) can be analytically continued to this domain.
      This shows that zeta(z) has no zeros z with [z.real>1/2] -- which is the statement of Riemann's hypothesis.
    ]]
  but above prop may be useless <<==:
    [[@[err>0] -> [abs(sum_mu_le(x)) < x**(1/2+err)]] <-> [Riemann_hypothesis:[@[z::complex] -> [0<=z.real<=1] -> [zeta(z) == 0] -> [z.real==1/2]]]]
    [conjectured:[lim sup {(sum_mu_le(x)/sqrt(x)) | x-->+oo} == +oo]]
    [conjectured:[lim inf {(sum_mu_le(x)/sqrt(x)) | x-->+oo} == -oo]]
    <<==:
  [lim sup {(sum_mu_le(x)/sqrt(x)) | x-->+oo} > 1.06]
  [lim inf {(sum_mu_le(x)/sqrt(x)) | x-->+oo} < -1.009]


  [[@[err>0] -> [abs(sum_mu_le(x)) == O(x**(1/2+err))]] <-> [Riemann_hypothesis:[@[z::complex] -> [0<=z.real<=1] -> [zeta(z) == 0] -> [z.real==1/2]]]]
  [@[x>1] -> [abs(sum_mu_le(x)) < 0.55*x/ln(x)**(2/3)]]








C. Tables of Primes
  tables of prime numbers
  tables of factors of numbers (not divisible by 2, 3, or 5)
  (primes up to 10_0000)
  (table of least factor of numbers up to 10_0000)
  Kulik's factor table of numbers to 1_0033_0200 (except for multiples of 2, 3, 5)
    #1_0033_0200    #1亿
    #将近(2.68e7)项 #三千万
    Kulik spent about 20 years preparing this table, and at his death in 1863, the eight manuscript volumes, with a total of 4212 pages, were deposited at the Academy of Sciences in Vienna (in February 1867).
    The presentation was such that each page covered about 23000 numbers, so one million did require about 43 pages.
      [23000*43 == 98_9000] #百万
        一页两万数字？多大面积每页？
      [floor_sqrt(23000) == 151]
      [floor_sqrt(23000*7) == 401]
        假设平均每项占用7字符，400行*400列...
    One unfortunate circumstance about Kulik's table is that Volume II, running from 1264_2600 to 2285_2800, has been missing for quite some time.
      [2285_2800-1264_2600==1021_0200]
        千万项每卷
  It should be noted that tables of primes on cards or tape are obsolete, because it is possible to generate all the primes up to any given bound, or in a prescribed interval, with the sieve of Eratosthenes, quicker than one can read it from card or tape.
    Thus, for example, in his search in 1980 for large gaps between primes, Brent computer-generated all the primes up to 4.444*10**12.
      4.44e12
      [log2(4.44e12) ~= 42.01369681522373]
      42bit强
      假设每数占用64bit==8字节
      共占用2**45字节==2**5TB==32TB
      这啥计算机？！


D. The Exact Value of PI(x) and Comparison with x/(log x), Li(x), and Rm(x)
  page235[260/567]
  [m::int{>=0}]:
    [IIp_(m) =[def]= II[PRIMES_S1[k] | [k:<-[1..=m]]]]
    [phi_IIp_(m) =[def]= num_coprimes4IIp_le(IIp_(m);m)]
    [phi_IIp_(m) == phi(IIp_(m)) == II[(PRIMES_S1[k]-1) | [k:<-[1..=m]]]]
  [x::real][m::int{>=0}]:
    [num_coprimes4IIp_le(x;m) =[def]= len{n | [n:<-[1..]][n<=x][gcd(n,IIp_(m))==1]}]
    [num_coprimes4IIp_le(x;m) == len{n | [n:<-[1..]][n<=x][@[k:<-[1..=m]] -> [n%PRIMES_S1[k] =!= 0]]}]

  [@[x::real{>=0}] -> [m:=num_primes_le(x**/3)] -> [m2:=num_primes_le(x**/2)] -> [s:=m2-m] -> [num_primes_le(x) == num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -[x>=1] -sum[num_primes_le(x/PRIMES_S1[j]) | [j:<-[m+1..=m2]]]]]
  <<==:
  [@[x::real{>=1}] -> [m:=num_primes_le(x**/3)] -> [m2:=num_primes_le(x**/2)] -> [s:=m2-m] -> [num_primes_le(x) == num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -1 -sum[num_primes_le(x/PRIMES_S1[j]) | [j:<-[m+1..=m2]]]]]
    # the_Meissel_formula_1871
    #前提:数据预备:primes_le(x**/2) #用于 (x/PRIMES_S1[j])#简单
    #前提:数据预备:num_primes_le(y) where some y < x**(2/3) #用于 m,m2,num_primes_le(x/PRIMES_S1[j])
      #麻烦，很多，还各自递归，不知多少... #有没有线性递归版？即递归之后使用的都是相同数据或高密度复用？
      #其实不用预备，更好num_primes_le()求值只展开两层<<==因为(1)有小于等于(x**/2)的所有素数，二分搜索bisect可得y<=x**/2的num_primes_le(y)；(2) [(x**(2/3))**(2/3) == x**(4/9) < x**/2]，故而 第二次应用此公式展开num_primes_le(x/PRIMES_S1[j]) 之后 就直接用bisect
    #耗时递归计算:num_coprimes4IIp_le(x;m)
    #   不断递归展开主项之后其实就是:
    #       [[x::real] -> [m::int{>=0}] -> [num_coprimes4IIp_le(x,m) == num_coprimes4IIp_le(x,0) +sum[(-1)**(m-(j-1)) *num_coprimes4IIp_le(x/(IIp_(m)/IIp_(j-1)),j-1) | [j:<-[1..=m]]]]]
    #   不断递归展开所有项之后其实就是:
    #       vs:[[N>=1] -> [num_primes_le(N) == num_primes_le(floor_sqrt(N)) -1+sum[mu(d)*(N//d) | [[d:<-all_divisors_of(II[p | [[p::prime][p**2<=N]]])][d<=N]]]]]
    #
    #Even though the calculation of num_coprimes4IIp_le(x;m) is long, when m is large, it offers no major difficulty.

  [num_primes_le(10**18) == 24739954287740860]
  [num_primes_le(4*10**16) == 1075292778793150 or 1075292778753150]
    #出现两处:结果不同:...93150 vs ...53150
  #如何递归计算:num_coprimes4IIp_le(x;m)
  [@[x::real] -> @[m::int{>=1}] -> [num_coprimes4IIp_le(x;m) == num_coprimes4IIp_le(x;m-1) -num_coprimes4IIp_le(floor(x/PRIMES_S1[m]);m-1)]]
    #recurrence_relation
  [@[n::int{>=0}] -> @[m::int{>=0}] -> [(q,r):=n/%IIp_(m)] -> [num_coprimes4IIp_le(n;m) == q*phi_IIp_(m) +num_coprimes4IIp_le(r;m)]]
    #division_property
  [@[m::int{>=1}] -> @[r::int{>=0}] -> [IIp_(m)///2 < r < IIp_(m)] -> [num_coprimes4IIp_le(r;m) == phi_IIp_(m) -num_coprimes4IIp_le(IIp_(m)-r-1;m)]]
    #symmetry_property
  我:
    [@[x::real] -> @[m::int{>=0}] -> [x < PRIMES_S1[m+1]**2] -> [num_coprimes4IIp_le(x;m) == [x>=1]+max(0,(num_primes_le(x) -m))]]

    [@[x::real] -> [num_coprimes4IIp_le(x;0) == max(0,floor(x))]]
    [@[x::real{>=1}] -> [m2:=num_primes_le(x**(1/2))] -> [num_primes_le(x) == -1+m2+num_coprimes4IIp_le(x;m2)]]
      # !! Eratosthenes sieve
      vs:
      这里是the_Meissel_formula_1871的起点<<==见下面证明
      the_Meissel_formula_1871相当于做了一点包装，但也允许使用更语义的缓存数据(即更小规模的num_primes_le)
  vs:
    [[N>=1] -> [num_primes_le(N) == num_primes_le(floor_sqrt(N)) -1+sum[mu(d)*(N//d) | [[d:<-all_divisors_of(II[p | [[p::prime][p**2<=N]]])][d<=N]]]]]
      # !! Eratosthenes sieve
      vs:
      * 这里mu版:筛选用素数基的各素数独立增删
        #小规模时2**e；越界后将近C(?n?;?k?)
      * 而the_Meissel_formula_1871改进了一下，素数逐个加入素数基，即 新增单素数 与 已过滤旧素数基 之间的 交合(一叉多<<==因为 多叉多 即 两个互斥素数基的糅合 很麻烦，没有显而易见的简单快速方法实现)。

  Meissel determined, in 1885, the number PI(10**9) (however he found a value which is low by 56).
    A simple proof of Meissel's formula was given by Brauer in 1946.
    In 1959, Lehmer simplified and extended Meissel's method.
    In 1985, Lagarias, Miller, and Odlyzko have further refined the method by incorporating new sieving techniques.

  [[
  证明:the_Meissel_formula_1871
  * [x < 1]:
    [m == 0]
    [m2 == 0]
    [s == 0]
    [num_primes_le(x) == 0]
    [num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -1 -sum[num_primes_le(x/PRIMES_S1[j]) | [j:<-[m+1..=m2]]]
    == 0 +0 +0 -1 -0
    == -1
    ]
    [num_primes_le(x) =!= num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -1 -sum[num_primes_le(x/PRIMES_S1[j]) | [j:<-[m+1..=m2]]]]
    只能成立于[x>=1]
  * [x >= 1][m+1>m2]:
    !! [m:=num_primes_le(x**/3)]
    !! [m2:=num_primes_le(x**/2)]
    [m2 >= m >= 0]
    !! [m+1>m2]
    [m >= m2]
    [m == m2]
    !! [s:=m2-m]
    [s == 0]

    [num_primes_le(x)
    !! [@[x::real{>=1}] -> [m2:=num_primes_le(x**(1/2))] -> [num_primes_le(x) == -1+m2+num_coprimes4IIp_le(x;m2)]]
    == -1+m2+num_coprimes4IIp_le(x;m2)
    !! [m == m2]
    == -1+m+num_coprimes4IIp_le(x;m2)
    ]
    [num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -1 -sum[num_primes_le(x/PRIMES_S1[j]) | [j:<-[m+1..=m2]]]
    !! [m+1>m2]
    == num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -1
    !! [s==0]
    == num_coprimes4IIp_le(x;m) +m -1
    == -1+m+num_coprimes4IIp_le(x;m2)

    == num_primes_le(x)
    ]
  * [x >= 1][m+1<=m2]:
    [num_primes_le(x)
    !! [@[x::real{>=1}] -> [m2:=num_primes_le(x**(1/2))] -> [num_primes_le(x) == -1+m2+num_coprimes4IIp_le(x;m2)]]
    == -1+m2+num_coprimes4IIp_le(x;m2)
    !! [@[x::real] -> @[m::int{>=1}] -> [num_coprimes4IIp_le(x;m) == num_coprimes4IIp_le(x;m-1) -num_coprimes4IIp_le(floor(x/PRIMES_S1[m]);m-1)]]
    #应用s次:
    !! [0<=m<=m2]
    !! [s==m2-m]
    => [m2-s>=0][s>=0]
    == -1+m2+num_coprimes4IIp_le(x;m2-s) -sum[num_coprimes4IIp_le(floor(x/PRIMES_S1[j]);j-1) | [j:<-[m2-s+1..=m2]]]
    !! [s==m2-m]
    == -1+m2+num_coprimes4IIp_le(x;m) -sum[num_coprimes4IIp_le((x/PRIMES_S1[j]);j-1) | [j:<-[m+1..=m2]]]
    !! [m:=num_primes_le(x**/3)]
    => [x**/3 < PRIMES_S1[m+1]]
    !! [m2:=num_primes_le(x**/2)]
    !! [m+1 <= j <= m2]
    => [x**/3 < PRIMES_S1[m+1] <= PRIMES_S1[j] <= PRIMES_S1[m2] < x**/2]
    => [x**/3 < PRIMES_S1[j] < x**/2]
    => [PRIMES_S1[m2] < x**/2 < x/PRIMES_S1[j] < x**(2/3) < PRIMES_S1[m+1]**2]
    => [PRIMES_S1[j] <= PRIMES_S1[m2] < x/PRIMES_S1[j] < PRIMES_S1[m+1]**2 <= PRIMES_S1[(j-1)+1]**2]
    !! [@[x::real] -> @[m::int{>=0}] -> [x < PRIMES_S1[m+1]**2] -> [num_coprimes4IIp_le(x;m) == [x>=1]+max(0,(num_primes_le(x) -m))]]
    # [m' := (j-1)]
    # [x' := (x/PRIMES_S1[j])]
    == -1+m2+num_coprimes4IIp_le(x;m)
       -sum[[(x/PRIMES_S1[j])>=1]+max(0,(num_primes_le((x/PRIMES_S1[j])) -(j-1))) | [j:<-[m+1..=m2]]]
    !! [x>=1]
    !! [m>=1]
    !! [m+1<=m2]
    => [m2 >= 1]
    => [1 < 2 <= PRIMES_S1[m2] < x**/2 < x/PRIMES_S1[j]]
    => [x/PRIMES_S1[j] >= 1]
    !! [PRIMES_S1[j] <= PRIMES_S1[m2] < x/PRIMES_S1[j]]
    => [num_primes_le((x/PRIMES_S1[j])) >= m2 >= j > (j-1)]
    => [num_primes_le((x/PRIMES_S1[j])) -(j-1) > 0]
    == -1+m2+num_coprimes4IIp_le(x;m)
       -sum[1+(num_primes_le((x/PRIMES_S1[j])) -(j-1)) | [j:<-[m+1..=m2]]]
    == -1+m2+num_coprimes4IIp_le(x;m)
       -sum[num_primes_le((x/PRIMES_S1[j])) | [j:<-[m+1..=m2]]]
       -sum[1 -(j-1) | [j:<-[m+1..=m2]]]
    == -1+m2+num_coprimes4IIp_le(x;m)
       -sum[num_primes_le((x/PRIMES_S1[j])) | [j:<-[m+1..=m2]]]
       -2*s
       +sum[j | [j:<-[m+1..=m2]]]
    == -1+m2+num_coprimes4IIp_le(x;m)
       -sum[num_primes_le((x/PRIMES_S1[j])) | [j:<-[m+1..=m2]]]
       -2*s
       +s*(m2+m+1)///2
    !! [m2==m+s]
    == -1+(m+s)+num_coprimes4IIp_le(x;m)
       -sum[num_primes_le((x/PRIMES_S1[j])) | [j:<-[m+1..=m2]]]
       -2*s
       +s*((m+s)+m+1)///2

    == -1+num_coprimes4IIp_le(x;m)
       -sum[num_primes_le((x/PRIMES_S1[j])) | [j:<-[m+1..=m2]]]
       +m*(s+1) +s*(s-1)///2

    == num_coprimes4IIp_le(x;m) +m*(s+1) +s*(s-1)///2 -1 -sum[num_primes_le(x/PRIMES_S1[j]) | [j:<-[m+1..=m2]]]
    ]
  !DONE
  ]]


  !! [@[x::real] -> [e**(-1j*x) == 1j*cos(-x) == 1j*cos(x) == e**(+1j*x)]]
  => [@[x::real] -> @[z::complex] -> [x**z.conjugate == x**z]]
  [zeta(z.conjugate) == zeta(z)]
    # zeta(z)非平凡零点 只需考虑上半复平面
  [T :: real]:
    [NT4zeta(T) =[def]= num_zeta_zeros_in_the_upper_half_of_the_critical_strip__height_le(T) =[def]= num_nontrivial_zeros_of_zeta_function__imag_part_ge0_le(T) =[def]= len{z | [z::complex][0<=z.real<=1][0<z.imag<=T]}]
    [SNT4zeta(T) =[def]= len{z | [z::complex][z.real==1/2][0<z.imag<=T]}]
  [@[t :: real] -> [len{z | [z::complex][0<=z.real<=1][z.imag==t]} < +oo]]
    #zeta(z)于任一水平线上的零点有限

  [NT4zeta(T) == (T/2/pi) *(ln(T/2/pi) -1) +O(ln(T))]
    #zeta(z)零点无限

  [[sufficiently large T] -> [NT4zeta(T+1) -NT4zeta(T) <= 2*ln(T)]]



  [?[C >= 0.3658] -> [sufficiently large T] -> [SNT4zeta(T) >= C*(T/2/pi) *ln(T/2/pi)]]

  [All the known nontrivial zeros of zeta(z) are simple and lie on the critical line.]
    # Van de Lune, te Riele, and Winter have determined (in 1986) that the first 1,500,000,001 nontrivial zeros of £(s) are all simple, lie on the critical line, and have imaginary part with 0 < t < 545,439,823.215. This work has involved over 1000 hours on a supercomputer.






Riemann gave the following exact formula for num_primes_le(x), in terms of the Riemann function:
  [num_primes_le(x) == Rm(x) - sum[Rm(x**z0) | [z0:<-[zeros of zeta(z) with its own multiplicity]]]]
    # [the sum being extended over all the nontrivial zeros of zeta(z), each counted with its own multiplicity].
The Riemann function R(x) provides a very good approximation for PI(x) [#i.e. num_primes_le(x)#], as will be seen in Tables 26 and 27. The size of the error is expressed in terms of R(x**z0), for all the roots of zeta(z) in the critical strip.
The Riemann function is computable by this quickly converging power series, given by Gram in 1893:
  [Rm(x) == 1+sum[(ln(x)**n /n! /n /zeta(n+1))| [n:<-[1..]]]]
The work of Riemann on the distribution of primes is thoroughly studied in Edwards's book A974), which I recommend without reservations.


The determination of a large zero-free region for zeta(z) was an important feature in the proof of the prime number theorem.
I shall soon tell how the error term was subsequently reduced by determining larger zero-free regions for the zeta function.



consecutive vs successive
  successive composite integers
  consecutive primes
  consecutive:不跳过同类型数据的连续性#比如:素数序列连续性
  successive:不跳过背景类型数据的连续性#比如:整数序列连续性
immense skill
interlude
sufficiently large
distinct differences
the right-hand side is asymptotically equal to
extensive numerical calculations of gaps between primes.
strenuous calculations
arduous calculations
obtained sharp estimates and announced that with more arduous calculations
valence价数
valence function 即 像的出现次数/像的原像的数量
to estimate the rate of growth of the difference
independently of any unproved assumption
There have been many improvements of this result, both by sharpening the estimates, and by introducing new methods.
In a much lighter vein, a quick proof that
This inequality has been confirmed by numerical calculation for p[n] < 10**6.
an ingenious method devised in 1871 by
One unfortunate circumstance
In this connection, the most amazing feat
empirical observations
made no appeal to
on experimental evidence,
The complex valued functions f defined over the natural numbers (called arithmetical functions)
situation
various topics pertaining to
a neat proof
prime number theorem
plausible
the zeta function
culminating
have the same order of magnitude
Now I elaborate on these topics.
Let f(x), h(x) be positive real valued functions, defined for x > x0 > 0.
The notation [f(x) /~/ h(x)] means that [lim{f(x)/h(x) | x-->+oo} == 1] ;
f(x) and h(x) are then said to be asymptotically equal as x tends to infinity. Note that their difference may actually tend to infinity.
inferior limit:下限
superior limit:上限
f(x) = g(x) + o(h(x)) means that [lim{(f(x)-g(x))/h(x) | x-->+oo} == 0], so, intuitively, the error is negligible in comparison to h(x).
If, under the above hypothesis,
called the prime counting function.
stressed
As I have already stressed, the various proofs of existence of infinitely many primes are not constructive and do not give an indication of how to determine the nth prime number.
Bertrand's postulate
continuous and nonincreasing
pivotal fact
investigated
corollary of the prime number theorem.
  the_prime_number_theorem
The prime number theorem was raised to the status "a most wanted theorem," and it was folklore to consider that he who would prove it would become immortal.
a far-reaching generalization of Abel's summation formula, namely, the well-known Euler-MacLaurin summation formulas:
  If f(x) is a continuous function, continuously differentiable as many times as required, if a < b are integers, then


===
]]]
[[[
/sdcard/0my_files/book/math/factorint/snd/The new book of prime number records(3ed)(1996)(Ribenboim).djvu
===
I. The Growth of PI(x)
page237 [262/567] Table26
page238 [263/567] Table27

Table26:
x
10**8
10**9
10**10
10**11
10**12
10**13
1O**14
num_primes_le(x)
5761455
50847534
455052511
4118054813
37607912018
346065536839
3204941750802
floor(x/ln(x))-num_primes_le(x)
-332774
-2592592
-20758030
-169923160
-1416706193
-11992858452
-102838308636
floor(Li(x))-num_primes_le(x)
754
1701
3104
11588
38263
108971
314890
floor(Rm(x))-num_primes_le(x)
  #Rm(x):the_Riemann_function
97
-79
-1828
-2318
-1476
-5773
-19200
end-Table26
Table27
x
1 * 10**15
2 * 10**15
3 * 10**15
4 * 10**15
5 * 10**15
6 * 10**15
7 * 10**15
8 * 10**15
9 * 10**15
1 * 10**16
2 * 10**16
3 * 10**16
4 * 10**16
5 * 10**16
6 * 10**16
7 * 10**16
8 * 10**16
9 * 10**16
1 * 10**17
2 * 10**17
3 * 10**17
4 * 10**17
5 * 10**17
6 * 10**17
7 * 10**17
8 * 10**17
9 * 10**17
1 * 10**18
num_primes_le(x)
29844570422669
58478215681891
86688602810119
114630988904000
142377417196364
169969662554551
197434994078331
224792606318600
252056733453928
279238341033925
547863431950008
812760276789503
1075292778753150#or:1075292778793150
1336094767763971
1595534099589274
1853851099626620
2111215026220444
2367751438410550
2623557157654233
5153329362645908
7650011911275069
10125681208311322
12585956566571620
15034102021263820
17472251499627256
19901908567967065
22324189231374849
24739954287740860
floor(Li(x))-num_primes_le(x)
1052619
1317791
1872580
1364039
2277608
1886041
2297328
2727671
1956031
3214632
3776488
4651601
5538861
6977890
5572837
8225687
6208817
9034988
7956589
10857072
14538005
19808695
19070319
20585416
18395468
16763001
26287786
21949555
floor(Rm(x))-num_primes_le(x)
73218
-37631
+233047
-512689
+193397
-384694
-144134
+127929
-791857
327052
-225875
-193899
-10980
811655
-1147719
997606
-1489898
895676
-598255
-1016134
152863
3323994
747495
609065
-3095204
-6132224
2077405
-3501366
end-Table27



===
]]]
[[[
/sdcard/0my_files/book/math/factorint/202308/Prime numbers-A Computational Perspective(2ed)(2005)(Pomerance)/Prime numbers-A Computational Perspective(2ed)(2005)(Pomerance).pdf
page12[26/604]
Table 1.1 Values of the prime-counting function π(x).  In recent times, distributed computation on networks has been brought to bear on the π(x) counting problem.
===
x:π(x)
10**2:25
10**3:168
10**4:1229
10**6:78498
10**8:5761455
10**12:37607912018
10**16:279238341033925
10**17:2623557157654233
10**18:24739954287740860
10**19:234057667276344607
10**20:2220819602560918840
10**21:21127269486018731928
?bug?:10**22:201467286689315906290
?bug?:4*10**22:783964159847056303858
===
The most recent values in Table 1.1, namely π(10**22), π(4*10**22), are due to X.Gourdon and P.Sebah [Gourdon and Sebah 2004].  These researchers, while attempting to establish the value of π(10**23), recently discovered an inconsistency in their program, a numerical discrepancy in regard to local sieving.  Until this problem has been rectified or there has been a confirming independent calculation, their values for π(10**22) and π(4*10**22) should perhaps be considered tentative.
===
]]]

