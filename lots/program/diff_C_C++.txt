
C:用户保证数据的有效性
C++:类保证数据的有效性

协议
C:struct + function
C++:function [+struct]




结构：
C:
    POD――成员类型、成员名
    结构注释――成员名所代表的含义、它们之间的关联一致性
    上面两部分构成了一份协议。
    一望便知，便于使用者自定义读写。
    只要加入必要的注释，设计者便不必再费神。
    1）但这份协议，需要使用者学习，并在使用时保证数据的有效性。
       必须相当稳定，否则牵一发而动全身。
       可以定义相当数量的处理函数，以方便使用者。
       （如果‘has’处理自己的函数指针，也可当作动态算法）
       但这些函数作为协议的一部分也需被学习。
    2）可以定义一套完整的处理函数，以便使用者可以针对接口编程，
       而无需了解结构成员。
       但读写效率低，而且用户必须学习并且约束自己只使用这些函数，
       对于设计者而言，怎么设计一套简洁、常用、高效、不体现具体结构的接口，
       会是一个问题。
    3）为了免除2）中‘使用者的自我约束’这一条件，
        3-1）可以提供一个只有大小以及对齐方式与原结构相同的新结构定义给使用者。
            无须提供成员名、成员类型、成员注释等，一般会有构、析函数。
            使用者与结构解耦。
            但是，当结构的大小或对齐方式改变时，需要重新编译使用者的代码。
        3-2）可以只提供结构的指针类型，从而屏蔽使用者对结构的直接读写。
            结构实现与用户代码解耦，接口即协议。
            须提供构造函数类似nothrow_new()或get_sizeof()+placement_new()
            由于不能在栈上或其它结构体中使用placement_new（除非能保证对齐），
            所以只能在堆中分配，并且其它结构体只能以指针形式包含它，
            为了保证效率，一般只用于实例少、数据重要的结构。
        3-3）可以只提供handle_t类型（如struct{int;}）
            连同实例的地址一同屏蔽。
        如果结构含函数指针，则也可关联相关的未知类型的数据。
        
    
    惯用1）-效率、3-2）-数据安全

C++:
    1）类似于C.1、C.2，POD，全成员公开。
       通过继承‘is a’，可以减少一些数据成员的定义。
    2）类似于C.3，全函数成员公开、全数据成员私有。
       通过屏蔽私有数据，保证数据的有效性。
       数据的有效性从初始化开始，因此构、析函数是必须的。
       如果构造失败，本类实例是‘不曾存在’的，后面的操作也将被取消。
       这时抛出异常……需要支持异常及各种@#!@$#X
    3）通过语言上的支持，简化以下实现及保证操作安全：
        3-1）包含一个指针，指向本类虚函数表，用于动态算法 - 虚类。
            3-1-1）只包含这个指针，类似C3.2 - 纯虚类
            通常在上层往底层函数传入派生类实例指针或派生类工厂。
        3-2）包含一个指针，指向本实例抽象基类的数据，用于重定位数据 - 抽象类的派生类。
    
    惯用2）-数据有效性、3-1-1）-接口编程
    


函数：
C:
    函数参数类型只有结构指针或其它内建类型。
    参数的有效性（一致性）由使用者保证，不作多余检查，高效稍险。
    要求使用者相当谨慎，因为大部份会是运行时的错误，很难debug。
    1）无状态函数或全局状态函数。
    2）当要实现一个框架时，只能：
        2-1）使用宏。
            2-1-1）就地展开。
                代码膨胀，不能当函数指针，使用有风险，维护麻烦。
                最好可以要求所有参数都是有名变量并给出类型名，无返回值。
                只用于实现简单框架。
            2-1-2）针对不同类型，展开不同实例及不同函数名。
                每次应用于新类型时，都要‘注册’。
            语言外的功能，总是乱。
        2-2）去类型。
            使用void*替换结构指针类型，回调函数的参数类型也一样处理。
            类型安全的缺失，虽然也没什么大问题。
    
C++:
    参数可以是引用、结构。但结构的复制开销可能较大。
    如果可能，大概可以用类包装所有关联数据，以确保一致性。
    检查可能只需在构造时发生，就可保证数据的有效性。
    但是这样，使用者的自由度极低。
    1）类似C.1，包括类静态成员函数。
    2）带局部状态的函数，即类成员函数。数据成员及虚函数是局部状态。
    3）实现框架时：
        3-1）使用纯虚类作参数。
            但只能用于派生类。内存开销、执行效率是问题，
            特别是对实例数据少数量大的类及频繁运行的小框架。
        3-2）使用模板。
            3-2-1）完整的函数模板。
                对原数据类型要求不大，效率较高。但代码膨胀。
            3-2-2）只进行类型检查的内联函数模板。
                内部实现直接使用C.2-2。比C.2-2多了类型安全。
                效率相对C++.3-2-1低，但无代码膨胀。
        效率由高至低是：
        C.2-1-1, C++.3-2-1(C.2-1-2), C++.3-2-2(C.2-2)
                
命名：
C:
    由于extern函数名是全局的，一般都会加上库前缀或结构前缀来避免命名冲突。
    比较长，而且难看。但要搜索一个函数时，很方便。
C++:
    由于有命名空间、允许重载、有成员函数、允许覆写，基本不用担心命名冲突。
    函数名比较好看，但由于名字高度重叠、模板的运用以及lookup顺序，
    要找到眼前函数的定义也不容易。



