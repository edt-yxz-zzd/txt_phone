禁止重复――比如连续调用同一函数，出现重复的调用序列，初始化数据重复
只能使用无前缀函数约定名（非实体名！）或基于自己的相对路径名――比如调用自己时只能用self，不同空间中的约定名不得通过完全路径名区分。推导出真名，可以像C++一样从相关输入中推导出信息或从全局数据库中筛选出答案（比如先选出所有整数类、再选出定长的、再选出存在两倍己长整数类的整数、最后选出最快的，同时也确定出最快的两倍长整数）。One other obvious way to conserve programmer time is to teach machines how to do more of the low-level work of programming. This leads to...Rule of Generation
标记出一次计算或函数本身的pure属性――比如循环判断中的返回相同结果的函数调用（避免显式的临时变量）
高层优化约定――即声明等价变换，比如将同参数的/%调用简化为某一类ldiv的底层接口（用户无法直接调用，因为不必因此干扰正常接口），同参数< == 调用时整合为类似strcmp的调用，to_base(16,big_int)根据常量查找是否有优化版本而不是to_base<int>(big_int)，否则加上to_base(int,big_int)会有两种调用风格。
多变量属性绑定――用以检查pre- post-condition。特例是C++的构造函数，因为初始化+数据私有+封装=数据有效，避免在‘检查用户输入’或‘用户对输入负责’中二选一。通过属性构造函数可以确立必要的post-condition或分支条件或异常，数据有效性=post-con蕴含pre-con。
清净简洁的代码――只表达最原始的算法，禁止保留扩展接口以免污染原代码。扩展算法可通过语言内定方式从原始代码扩展，方法待定。
多层次声明――输出信息越少越抽象，但也操作也越少。最详尽的声明是定义。mechanism-not-policy自由但不简单，层次化机制可以使用户自己确定自由度与简单性的折中方案。
支持框架函数（变量作用域扩张（如传递至紧邻作用域）、嵌套扁平化）、多分支函数――以便用户自定义init{}for..in..{}else{}finally{}
一为美德、多为灾难――1 is standard, standard for communication.支持多种形式，但区分统治领域。边界交互待定。
关系显化否则逻辑无关――后向配置――与头文件不同。可以对不同函数中使用的类型组合在一起（set or group），显式声明它们是相同的或依赖性（比如转换及方向）（有向图），不同组之间的类型在实现上可以完全无关，可以对指定范围使用默认实现，默认范围为全局。后向配置与include/import的最大不同在于明确地隔离实现细节的逻辑关系，而import风格在不了解对类型的使用情况下无法理清与外部的关系。。外部定义用于交流，在交流小组中共享同一标准；内部定义独立，隔离不必要相关性（比如基于set的随机组合生成器，set可自由实现）。

